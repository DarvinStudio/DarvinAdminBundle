/*!
 * Bootstrap v3.3.7 (http://getbootstrap.com)
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under the MIT license
 */

if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery')
}

+function ($) {
  'use strict';
  var version = $.fn.jquery.split(' ')[0].split('.')
  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 3)) {
    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4')
  }
}(jQuery);

/* ========================================================================
 * Bootstrap: transition.js v3.3.7
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: alert.js v3.3.7
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.VERSION = '3.3.7'

  Alert.TRANSITION_DURATION = 150

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector === '#' ? [] : selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one('bsTransitionEnd', removeElement)
        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.alert

  $.fn.alert             = Plugin
  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

/* ========================================================================
 * Bootstrap: button.js v3.3.7
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element  = $(element)
    this.options   = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }

  Button.VERSION  = '3.3.7'

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()

    state += 'Text'

    if (data.resetText == null) $el.data('resetText', $el[val]())

    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      $el[val](data[state] == null ? this.options[state] : data[state])

      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d).prop(d, true)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d).prop(d, false)
      }
    }, this), 0)
  }

  Button.prototype.toggle = function () {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')

    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked')) changed = false
        $parent.find('.active').removeClass('active')
        this.$element.addClass('active')
      } else if ($input.prop('type') == 'checkbox') {
        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false
        this.$element.toggleClass('active')
      }
      $input.prop('checked', this.$element.hasClass('active'))
      if (changed) $input.trigger('change')
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
      this.$element.toggleClass('active')
    }
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.button', (data = new Button(this, options)))

      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  var old = $.fn.button

  $.fn.button             = Plugin
  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


  // BUTTON DATA-API
  // ===============

  $(document)
    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      var $btn = $(e.target).closest('.btn')
      Plugin.call($btn, 'toggle')
      if (!($(e.target).is('input[type="radio"], input[type="checkbox"]'))) {
        // Prevent double click on radios, and the double selections (so cancellation) on checkboxes
        e.preventDefault()
        // The target component still receive the focus
        if ($btn.is('input,button')) $btn.trigger('focus')
        else $btn.find('input:visible,button:visible').first().trigger('focus')
      }
    })
    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
    })

}(jQuery);

/* ========================================================================
 * Bootstrap: carousel.js v3.3.7
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      = null
    this.sliding     = null
    this.interval    = null
    this.$active     = null
    this.$items      = null

    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }

  Carousel.VERSION  = '3.3.7'

  Carousel.TRANSITION_DURATION = 600

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }

  Carousel.prototype.keydown = function (e) {
    if (/input|textarea/i.test(e.target.tagName)) return
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }

    e.preventDefault()
  }

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var activeIndex = this.getItemIndex(active)
    var willWrap = (direction == 'prev' && activeIndex === 0)
                || (direction == 'next' && activeIndex == (this.$items.length - 1))
    if (willWrap && !this.options.wrap) return active
    var delta = direction == 'prev' ? -1 : 1
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var that      = this

    if ($next.hasClass('active')) return (this.sliding = false)

    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return

    this.sliding = true

    isCycling && this.pause()

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }

    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  var old = $.fn.carousel

  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  var clickHandler = function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    Plugin.call($target, options)

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  }

  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: collapse.js v3.3.7
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

/* jshint latedef: false */

+function ($) {
  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
                           '[data-toggle="collapse"][data-target="#' + element.id + '"]')
    this.transitioning = null

    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }

    if (this.options.toggle) this.toggle()
  }

  Collapse.VERSION  = '3.3.7'

  Collapse.TRANSITION_DURATION = 350

  Collapse.DEFAULTS = {
    toggle: true
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var activesData
    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')

    if (actives && actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData && activesData.transitioning) return
    }

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    if (actives && actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)

    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)

    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }

  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function (i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in')

    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this   = $(this)

    if (!$this.attr('data-target')) e.preventDefault()

    var $target = getTargetFromTrigger($this)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $this.data()

    Plugin.call($target, option)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.3.7
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.3.7'

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return

      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
    })
  }

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $(document.createElement('div'))
          .addClass('dropdown-backdrop')
          .insertAfter($(this))
          .on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')

      $parent
        .toggleClass('open')
        .trigger($.Event('shown.bs.dropdown', relatedTarget))
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if (!isActive && e.which != 27 || isActive && e.which == 27) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.disabled):visible a'
    var $items = $parent.find('.dropdown-menu' + desc)

    if (!$items.length) return

    var index = $items.index(e.target)

    if (e.which == 38 && index > 0)                 index--         // up
    if (e.which == 40 && index < $items.length - 1) index++         // down
    if (!~index)                                    index = 0

    $items.eq(index).trigger('focus')
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.3.7
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options             = options
    this.$body               = $(document.body)
    this.$element            = $(element)
    this.$dialog             = this.$element.find('.modal-dialog')
    this.$backdrop           = null
    this.isShown             = null
    this.originalBodyPad     = null
    this.scrollbarWidth      = 0
    this.ignoreBackdropClick = false

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.3.7'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.setScrollbar()
    this.$body.addClass('modal-open')

    this.escape()
    this.resize()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
      })
    })

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      that.adjustDialog()

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element.addClass('in')

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$dialog // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()
    this.resize()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .off('click.dismiss.bs.modal')
      .off('mouseup.dismiss.bs.modal')

    this.$dialog.off('mousedown.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (document !== e.target &&
            this.$element[0] !== e.target &&
            !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }

  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
    } else {
      $(window).off('resize.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetAdjustments()
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $(document.createElement('div'))
        .addClass('modal-backdrop ' + animate)
        .appendTo(this.$body)

      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false
          return
        }
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static'
          ? this.$element[0].focus()
          : this.hide()
      }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  // these following methods are used to handle overflowing modals

  Modal.prototype.handleUpdate = function () {
    this.adjustDialog()
  }

  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

    this.$element.css({
      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    })
  }

  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    })
  }

  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth
    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect()
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
    }
    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
    this.scrollbarWidth = this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    this.originalBodyPad = document.body.style.paddingRight || ''
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad)
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tooltip.js v3.3.7
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       = null
    this.options    = null
    this.enabled    = null
    this.timeout    = null
    this.hoverState = null
    this.$element   = null
    this.inState    = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.3.7'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
    this.inState   = { click: false, hover: false, focus: false }

    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
    }

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
    }

    if (self.tip().hasClass('in') || self.hoverState == 'in') {
      self.hoverState = 'in'
      return
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.isInStateTrue = function () {
    for (var key in this.inState) {
      if (this.inState[key]) return true
    }

    return false
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
    }

    if (self.isInStateTrue()) return

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type)

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)

      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
      this.$element.trigger('inserted.bs.' + this.type)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var viewportDim = this.getPosition(this.$viewport)

        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :
                    placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :
                    placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :
                    placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null

        if (prevHoverState == 'out') that.leave(that)
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  += marginTop
    offset.left += marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
    this.arrow()
      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isVertical ? 'top' : 'left', '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = $(this.$tip)
    var e    = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      if (that.$element) { // TODO: Check whether guarding this code with this `if` is really necessary.
        that.$element
          .removeAttr('aria-describedby')
          .trigger('hidden.bs.' + that.type)
      }
      callback && callback()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && $tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element

    var el     = $element[0]
    var isBody = el.tagName == 'BODY'

    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var isSvg = window.SVGElement && el instanceof window.SVGElement
    // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.
    // See https://github.com/twbs/bootstrap/issues/20280
    var elOffset  = isBody ? { top: 0, left: 0 } : (isSvg ? null : $element.offset())
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    if (!this.$tip) {
      this.$tip = $(this.options.template)
      if (this.$tip.length != 1) {
        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
      }
    }
    return this.$tip
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    if (e) {
      self.inState.click = !self.inState.click
      if (self.isInStateTrue()) self.enter(self)
      else self.leave(self)
    } else {
      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
    }
  }

  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
      if (that.$tip) {
        that.$tip.detach()
      }
      that.$tip = null
      that.$arrow = null
      that.$viewport = null
      that.$element = null
    })
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.tooltip')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.3.7
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.3.7'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.popover')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.7
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    this.$body          = $(document.body)
    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target || '') + ' .nav li > a'
    this.offsets        = []
    this.targets        = []
    this.activeTarget   = null
    this.scrollHeight   = 0

    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
    this.refresh()
    this.process()
  }

  ScrollSpy.VERSION  = '3.3.7'

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }

  ScrollSpy.prototype.refresh = function () {
    var that          = this
    var offsetMethod  = 'offset'
    var offsetBase    = 0

    this.offsets      = []
    this.targets      = []
    this.scrollHeight = this.getScrollHeight()

    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase   = this.$scrollElement.scrollTop()
    }

    this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) && $(href)

        return ($href
          && $href.length
          && $href.is(':visible')
          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        that.offsets.push(this[0])
        that.targets.push(this[1])
      })
  }

  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i

    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
    }

    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null
      return this.clear()
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        && scrollTop >= offsets[i]
        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])
        && this.activate(targets[i])
    }
  }

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target

    this.clear()

    var selector = this.selector +
      '[data-target="' + target + '"],' +
      this.selector + '[href="' + target + '"]'

    var active = $(selector)
      .parents('li')
      .addClass('active')

    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }

    active.trigger('activate.bs.scrollspy')
  }

  ScrollSpy.prototype.clear = function () {
    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.scrollspy

  $.fn.scrollspy             = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tab.js v3.3.7
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    // jscs:disable requireDollarBeforejQueryAssignment
    this.element = $(element)
    // jscs:enable requireDollarBeforejQueryAssignment
  }

  Tab.VERSION = '3.3.7'

  Tab.TRANSITION_DURATION = 150

  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return

    var $previous = $ul.find('.active:last a')
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    })
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    })

    $previous.trigger(hideEvent)
    $this.trigger(showEvent)

    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

    var $target = $(selector)

    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      })
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      })
    })
  }

  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      && $.support.transition
      && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
          .removeClass('active')
        .end()
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', false)

      element
        .addClass('active')
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', true)

      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }

      if (element.parent('.dropdown-menu').length) {
        element
          .closest('li.dropdown')
            .addClass('active')
          .end()
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', true)
      }

      callback && callback()
    }

    $active.length && transition ?
      $active
        .one('bsTransitionEnd', next)
        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
      next()

    $active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tab

  $.fn.tab             = Plugin
  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


  // TAB DATA-API
  // ============

  var clickHandler = function (e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  }

  $(document)
    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

}(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.3.7
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      = null
    this.unpin        = null
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.3.7'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()

    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }

    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height

    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

    return false
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = Math.max($(document).height(), $(document.body).height())

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')

      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);

(function() {
  var $, AbstractChosen, Chosen, SelectParser, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  SelectParser = (function() {
    function SelectParser() {
      this.options_index = 0;
      this.parsed = [];
    }

    SelectParser.prototype.add_node = function(child) {
      if (child.nodeName.toUpperCase() === "OPTGROUP") {
        return this.add_group(child);
      } else {
        return this.add_option(child);
      }
    };

    SelectParser.prototype.add_group = function(group) {
      var group_position, option, _i, _len, _ref, _results;
      group_position = this.parsed.length;
      this.parsed.push({
        array_index: group_position,
        group: true,
        label: this.escapeExpression(group.label),
        title: group.title ? group.title : void 0,
        children: 0,
        disabled: group.disabled,
        classes: group.className
      });
      _ref = group.childNodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        _results.push(this.add_option(option, group_position, group.disabled));
      }
      return _results;
    };

    SelectParser.prototype.add_option = function(option, group_position, group_disabled) {
      if (option.nodeName.toUpperCase() === "OPTION") {
        if (option.text !== "") {
          if (group_position != null) {
            this.parsed[group_position].children += 1;
          }
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            value: option.value,
            text: option.text,
            html: option.innerHTML,
            title: option.title ? option.title : void 0,
            selected: option.selected,
            disabled: group_disabled === true ? group_disabled : option.disabled,
            group_array_index: group_position,
            group_label: group_position != null ? this.parsed[group_position].label : null,
            classes: option.className,
            style: option.style.cssText
          });
        } else {
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            empty: true
          });
        }
        return this.options_index += 1;
      }
    };

    SelectParser.prototype.escapeExpression = function(text) {
      var map, unsafe_chars;
      if ((text == null) || text === false) {
        return "";
      }
      if (!/[\&\<\>\"\'\`]/.test(text)) {
        return text;
      }
      map = {
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
      };
      unsafe_chars = /&(?!\w+;)|[\<\>\"\'\`]/g;
      return text.replace(unsafe_chars, function(chr) {
        return map[chr] || "&amp;";
      });
    };

    return SelectParser;

  })();

  SelectParser.select_to_array = function(select) {
    var child, parser, _i, _len, _ref;
    parser = new SelectParser();
    _ref = select.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      parser.add_node(child);
    }
    return parser.parsed;
  };

  AbstractChosen = (function() {
    function AbstractChosen(form_field, options) {
      this.form_field = form_field;
      this.options = options != null ? options : {};
      this.label_click_handler = __bind(this.label_click_handler, this);
      if (!AbstractChosen.browser_is_supported()) {
        return;
      }
      this.is_multiple = this.form_field.multiple;
      this.set_default_text();
      this.set_default_values();
      this.setup();
      this.set_up_html();
      this.register_observers();
      this.on_ready();
    }

    AbstractChosen.prototype.set_default_values = function() {
      var _this = this;
      this.click_test_action = function(evt) {
        return _this.test_active_click(evt);
      };
      this.activate_action = function(evt) {
        return _this.activate_field(evt);
      };
      this.active_field = false;
      this.mouse_on_container = false;
      this.results_showing = false;
      this.result_highlighted = null;
      this.is_rtl = this.options.rtl || /\bchosen-rtl\b/.test(this.form_field.className);
      this.allow_single_deselect = (this.options.allow_single_deselect != null) && (this.form_field.options[0] != null) && this.form_field.options[0].text === "" ? this.options.allow_single_deselect : false;
      this.disable_search_threshold = this.options.disable_search_threshold || 0;
      this.disable_search = this.options.disable_search || false;
      this.enable_split_word_search = this.options.enable_split_word_search != null ? this.options.enable_split_word_search : true;
      this.group_search = this.options.group_search != null ? this.options.group_search : true;
      this.search_contains = this.options.search_contains || false;
      this.single_backstroke_delete = this.options.single_backstroke_delete != null ? this.options.single_backstroke_delete : true;
      this.max_selected_options = this.options.max_selected_options || Infinity;
      this.inherit_select_classes = this.options.inherit_select_classes || false;
      this.display_selected_options = this.options.display_selected_options != null ? this.options.display_selected_options : true;
      this.display_disabled_options = this.options.display_disabled_options != null ? this.options.display_disabled_options : true;
      this.include_group_label_in_selected = this.options.include_group_label_in_selected || false;
      this.max_shown_results = this.options.max_shown_results || Number.POSITIVE_INFINITY;
      this.case_sensitive_search = this.options.case_sensitive_search || false;
      return this.hide_results_on_select = this.options.hide_results_on_select != null ? this.options.hide_results_on_select : true;
    };

    AbstractChosen.prototype.set_default_text = function() {
      if (this.form_field.getAttribute("data-placeholder")) {
        this.default_text = this.form_field.getAttribute("data-placeholder");
      } else if (this.is_multiple) {
        this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || AbstractChosen.default_multiple_text;
      } else {
        this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || AbstractChosen.default_single_text;
      }
      this.default_text = this.escape_html(this.default_text);
      return this.results_none_found = this.form_field.getAttribute("data-no_results_text") || this.options.no_results_text || AbstractChosen.default_no_result_text;
    };

    AbstractChosen.prototype.choice_label = function(item) {
      if (this.include_group_label_in_selected && (item.group_label != null)) {
        return "<b class='group-name'>" + item.group_label + "</b>" + item.html;
      } else {
        return item.html;
      }
    };

    AbstractChosen.prototype.mouse_enter = function() {
      return this.mouse_on_container = true;
    };

    AbstractChosen.prototype.mouse_leave = function() {
      return this.mouse_on_container = false;
    };

    AbstractChosen.prototype.input_focus = function(evt) {
      var _this = this;
      if (this.is_multiple) {
        if (!this.active_field) {
          return setTimeout((function() {
            return _this.container_mousedown();
          }), 50);
        }
      } else {
        if (!this.active_field) {
          return this.activate_field();
        }
      }
    };

    AbstractChosen.prototype.input_blur = function(evt) {
      var _this = this;
      if (!this.mouse_on_container) {
        this.active_field = false;
        return setTimeout((function() {
          return _this.blur_test();
        }), 100);
      }
    };

    AbstractChosen.prototype.label_click_handler = function(evt) {
      if (this.is_multiple) {
        return this.container_mousedown(evt);
      } else {
        return this.activate_field();
      }
    };

    AbstractChosen.prototype.results_option_build = function(options) {
      var content, data, data_content, shown_results, _i, _len, _ref;
      content = '';
      shown_results = 0;
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        data = _ref[_i];
        data_content = '';
        if (data.group) {
          data_content = this.result_add_group(data);
        } else {
          data_content = this.result_add_option(data);
        }
        if (data_content !== '') {
          shown_results++;
          content += data_content;
        }
        if (options != null ? options.first : void 0) {
          if (data.selected && this.is_multiple) {
            this.choice_build(data);
          } else if (data.selected && !this.is_multiple) {
            this.single_set_selected_text(this.choice_label(data));
          }
        }
        if (shown_results >= this.max_shown_results) {
          break;
        }
      }
      return content;
    };

    AbstractChosen.prototype.result_add_option = function(option) {
      var classes, option_el;
      if (!option.search_match) {
        return '';
      }
      if (!this.include_option_in_results(option)) {
        return '';
      }
      classes = [];
      if (!option.disabled && !(option.selected && this.is_multiple)) {
        classes.push("active-result");
      }
      if (option.disabled && !(option.selected && this.is_multiple)) {
        classes.push("disabled-result");
      }
      if (option.selected) {
        classes.push("result-selected");
      }
      if (option.group_array_index != null) {
        classes.push("group-option");
      }
      if (option.classes !== "") {
        classes.push(option.classes);
      }
      option_el = document.createElement("li");
      option_el.className = classes.join(" ");
      option_el.style.cssText = option.style;
      option_el.setAttribute("data-option-array-index", option.array_index);
      option_el.innerHTML = option.search_text;
      if (option.title) {
        option_el.title = option.title;
      }
      return this.outerHTML(option_el);
    };

    AbstractChosen.prototype.result_add_group = function(group) {
      var classes, group_el;
      if (!(group.search_match || group.group_match)) {
        return '';
      }
      if (!(group.active_options > 0)) {
        return '';
      }
      classes = [];
      classes.push("group-result");
      if (group.classes) {
        classes.push(group.classes);
      }
      group_el = document.createElement("li");
      group_el.className = classes.join(" ");
      group_el.innerHTML = group.search_text;
      if (group.title) {
        group_el.title = group.title;
      }
      return this.outerHTML(group_el);
    };

    AbstractChosen.prototype.results_update_field = function() {
      this.set_default_text();
      if (!this.is_multiple) {
        this.results_reset_cleanup();
      }
      this.result_clear_highlight();
      this.results_build();
      if (this.results_showing) {
        return this.winnow_results();
      }
    };

    AbstractChosen.prototype.reset_single_select_options = function() {
      var result, _i, _len, _ref, _results;
      _ref = this.results_data;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        result = _ref[_i];
        if (result.selected) {
          _results.push(result.selected = false);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    AbstractChosen.prototype.results_toggle = function() {
      if (this.results_showing) {
        return this.results_hide();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.results_search = function(evt) {
      if (this.results_showing) {
        return this.winnow_results();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.winnow_results = function() {
      var escapedSearchText, highlightRegex, option, regex, results, results_group, searchText, startpos, text, _i, _len, _ref;
      this.no_results_clear();
      results = 0;
      searchText = this.get_search_text();
      escapedSearchText = searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      regex = this.get_search_regex(escapedSearchText);
      highlightRegex = this.get_highlight_regex(escapedSearchText);
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        option.search_match = false;
        results_group = null;
        if (this.include_option_in_results(option)) {
          if (option.group) {
            option.group_match = false;
            option.active_options = 0;
          }
          if ((option.group_array_index != null) && this.results_data[option.group_array_index]) {
            results_group = this.results_data[option.group_array_index];
            if (results_group.active_options === 0 && results_group.search_match) {
              results += 1;
            }
            results_group.active_options += 1;
          }
          option.search_text = option.group ? option.label : option.html;
          if (!(option.group && !this.group_search)) {
            option.search_match = this.search_string_match(option.search_text, regex);
            if (option.search_match && !option.group) {
              results += 1;
            }
            if (option.search_match) {
              if (searchText.length) {
                startpos = option.search_text.search(highlightRegex);
                text = option.search_text.substr(0, startpos + searchText.length) + '</em>' + option.search_text.substr(startpos + searchText.length);
                option.search_text = text.substr(0, startpos) + '<em>' + text.substr(startpos);
              }
              if (results_group != null) {
                results_group.group_match = true;
              }
            } else if ((option.group_array_index != null) && this.results_data[option.group_array_index].search_match) {
              option.search_match = true;
            }
          }
        }
      }
      this.result_clear_highlight();
      if (results < 1 && searchText.length) {
        this.update_results_content("");
        return this.no_results(searchText);
      } else {
        this.update_results_content(this.results_option_build());
        return this.winnow_results_set_highlight();
      }
    };

    AbstractChosen.prototype.get_search_regex = function(escaped_search_string) {
      var regex_anchor, regex_flag;
      regex_anchor = this.search_contains ? "" : "^";
      regex_flag = this.case_sensitive_search ? "" : "i";
      return new RegExp(regex_anchor + escaped_search_string, regex_flag);
    };

    AbstractChosen.prototype.get_highlight_regex = function(escaped_search_string) {
      var regex_anchor, regex_flag;
      regex_anchor = this.search_contains ? "" : "\\b";
      regex_flag = this.case_sensitive_search ? "" : "i";
      return new RegExp(regex_anchor + escaped_search_string, regex_flag);
    };

    AbstractChosen.prototype.search_string_match = function(search_string, regex) {
      var part, parts, _i, _len;
      if (regex.test(search_string)) {
        return true;
      } else if (this.enable_split_word_search && (search_string.indexOf(" ") >= 0 || search_string.indexOf("[") === 0)) {
        parts = search_string.replace(/\[|\]/g, "").split(" ");
        if (parts.length) {
          for (_i = 0, _len = parts.length; _i < _len; _i++) {
            part = parts[_i];
            if (regex.test(part)) {
              return true;
            }
          }
        }
      }
    };

    AbstractChosen.prototype.choices_count = function() {
      var option, _i, _len, _ref;
      if (this.selected_option_count != null) {
        return this.selected_option_count;
      }
      this.selected_option_count = 0;
      _ref = this.form_field.options;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        if (option.selected) {
          this.selected_option_count += 1;
        }
      }
      return this.selected_option_count;
    };

    AbstractChosen.prototype.choices_click = function(evt) {
      evt.preventDefault();
      this.activate_field();
      if (!(this.results_showing || this.is_disabled)) {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.keydown_checker = function(evt) {
      var stroke, _ref;
      stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
      this.search_field_scale();
      if (stroke !== 8 && this.pending_backstroke) {
        this.clear_backstroke();
      }
      switch (stroke) {
        case 8:
          this.backstroke_length = this.get_search_field_value().length;
          break;
        case 9:
          if (this.results_showing && !this.is_multiple) {
            this.result_select(evt);
          }
          this.mouse_on_container = false;
          break;
        case 13:
          if (this.results_showing) {
            evt.preventDefault();
          }
          break;
        case 27:
          if (this.results_showing) {
            evt.preventDefault();
          }
          break;
        case 32:
          if (this.disable_search) {
            evt.preventDefault();
          }
          break;
        case 38:
          evt.preventDefault();
          this.keyup_arrow();
          break;
        case 40:
          evt.preventDefault();
          this.keydown_arrow();
          break;
      }
    };

    AbstractChosen.prototype.keyup_checker = function(evt) {
      var stroke, _ref;
      stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
      this.search_field_scale();
      switch (stroke) {
        case 8:
          if (this.is_multiple && this.backstroke_length < 1 && this.choices_count() > 0) {
            this.keydown_backstroke();
          } else if (!this.pending_backstroke) {
            this.result_clear_highlight();
            this.results_search();
          }
          break;
        case 13:
          evt.preventDefault();
          if (this.results_showing) {
            this.result_select(evt);
          }
          break;
        case 27:
          if (this.results_showing) {
            this.results_hide();
          }
          break;
        case 9:
        case 16:
        case 17:
        case 18:
        case 38:
        case 40:
        case 91:
          break;
        default:
          this.results_search();
          break;
      }
    };

    AbstractChosen.prototype.clipboard_event_checker = function(evt) {
      var _this = this;
      if (this.is_disabled) {
        return;
      }
      return setTimeout((function() {
        return _this.results_search();
      }), 50);
    };

    AbstractChosen.prototype.container_width = function() {
      if (this.options.width != null) {
        return this.options.width;
      } else {
        return "" + this.form_field.offsetWidth + "px";
      }
    };

    AbstractChosen.prototype.include_option_in_results = function(option) {
      if (this.is_multiple && (!this.display_selected_options && option.selected)) {
        return false;
      }
      if (!this.display_disabled_options && option.disabled) {
        return false;
      }
      if (option.empty) {
        return false;
      }
      return true;
    };

    AbstractChosen.prototype.search_results_touchstart = function(evt) {
      this.touch_started = true;
      return this.search_results_mouseover(evt);
    };

    AbstractChosen.prototype.search_results_touchmove = function(evt) {
      this.touch_started = false;
      return this.search_results_mouseout(evt);
    };

    AbstractChosen.prototype.search_results_touchend = function(evt) {
      if (this.touch_started) {
        return this.search_results_mouseup(evt);
      }
    };

    AbstractChosen.prototype.outerHTML = function(element) {
      var tmp;
      if (element.outerHTML) {
        return element.outerHTML;
      }
      tmp = document.createElement("div");
      tmp.appendChild(element);
      return tmp.innerHTML;
    };

    AbstractChosen.prototype.get_single_html = function() {
      return "<a class=\"chosen-single chosen-default\">\n  <span>" + this.default_text + "</span>\n  <div><b></b></div>\n</a>\n<div class=\"chosen-drop\">\n  <div class=\"chosen-search\">\n    <input class=\"chosen-search-input\" type=\"text\" autocomplete=\"off\" />\n  </div>\n  <ul class=\"chosen-results\"></ul>\n</div>";
    };

    AbstractChosen.prototype.get_multi_html = function() {
      return "<ul class=\"chosen-choices\">\n  <li class=\"search-field\">\n    <input class=\"chosen-search-input\" type=\"text\" autocomplete=\"off\" value=\"" + this.default_text + "\" />\n  </li>\n</ul>\n<div class=\"chosen-drop\">\n  <ul class=\"chosen-results\"></ul>\n</div>";
    };

    AbstractChosen.prototype.get_no_results_html = function(terms) {
      return "<li class=\"no-results\">\n  " + this.results_none_found + " <span>" + terms + "</span>\n</li>";
    };

    AbstractChosen.browser_is_supported = function() {
      if ("Microsoft Internet Explorer" === window.navigator.appName) {
        return document.documentMode >= 8;
      }
      if (/iP(od|hone)/i.test(window.navigator.userAgent) || /IEMobile/i.test(window.navigator.userAgent) || /Windows Phone/i.test(window.navigator.userAgent) || /BlackBerry/i.test(window.navigator.userAgent) || /BB10/i.test(window.navigator.userAgent) || /Android.*Mobile/i.test(window.navigator.userAgent)) {
        return false;
      }
      return true;
    };

    AbstractChosen.default_multiple_text = "Select Some Options";

    AbstractChosen.default_single_text = "Select an Option";

    AbstractChosen.default_no_result_text = "No results match";

    return AbstractChosen;

  })();

  $ = jQuery;

  $.fn.extend({
    chosen: function(options) {
      if (!AbstractChosen.browser_is_supported()) {
        return this;
      }
      return this.each(function(input_field) {
        var $this, chosen;
        $this = $(this);
        chosen = $this.data('chosen');
        if (options === 'destroy') {
          if (chosen instanceof Chosen) {
            chosen.destroy();
          }
          return;
        }
        if (!(chosen instanceof Chosen)) {
          $this.data('chosen', new Chosen(this, options));
        }
      });
    }
  });

  Chosen = (function(_super) {
    __extends(Chosen, _super);

    function Chosen() {
      _ref = Chosen.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Chosen.prototype.setup = function() {
      this.form_field_jq = $(this.form_field);
      return this.current_selectedIndex = this.form_field.selectedIndex;
    };

    Chosen.prototype.set_up_html = function() {
      var container_classes, container_props;
      container_classes = ["chosen-container"];
      container_classes.push("chosen-container-" + (this.is_multiple ? "multi" : "single"));
      if (this.inherit_select_classes && this.form_field.className) {
        container_classes.push(this.form_field.className);
      }
      if (this.is_rtl) {
        container_classes.push("chosen-rtl");
      }
      container_props = {
        'class': container_classes.join(' '),
        'title': this.form_field.title
      };
      if (this.form_field.id.length) {
        container_props.id = this.form_field.id.replace(/[^\w]/g, '_') + "_chosen";
      }
      this.container = $("<div />", container_props);
      this.container.width(this.container_width());
      if (this.is_multiple) {
        this.container.html(this.get_multi_html());
      } else {
        this.container.html(this.get_single_html());
      }
      this.form_field_jq.hide().after(this.container);
      this.dropdown = this.container.find('div.chosen-drop').first();
      this.search_field = this.container.find('input').first();
      this.search_results = this.container.find('ul.chosen-results').first();
      this.search_field_scale();
      this.search_no_results = this.container.find('li.no-results').first();
      if (this.is_multiple) {
        this.search_choices = this.container.find('ul.chosen-choices').first();
        this.search_container = this.container.find('li.search-field').first();
      } else {
        this.search_container = this.container.find('div.chosen-search').first();
        this.selected_item = this.container.find('.chosen-single').first();
      }
      this.results_build();
      this.set_tab_index();
      return this.set_label_behavior();
    };

    Chosen.prototype.on_ready = function() {
      return this.form_field_jq.trigger("chosen:ready", {
        chosen: this
      });
    };

    Chosen.prototype.register_observers = function() {
      var _this = this;
      this.container.bind('touchstart.chosen', function(evt) {
        _this.container_mousedown(evt);
      });
      this.container.bind('touchend.chosen', function(evt) {
        _this.container_mouseup(evt);
      });
      this.container.bind('mousedown.chosen', function(evt) {
        _this.container_mousedown(evt);
      });
      this.container.bind('mouseup.chosen', function(evt) {
        _this.container_mouseup(evt);
      });
      this.container.bind('mouseenter.chosen', function(evt) {
        _this.mouse_enter(evt);
      });
      this.container.bind('mouseleave.chosen', function(evt) {
        _this.mouse_leave(evt);
      });
      this.search_results.bind('mouseup.chosen', function(evt) {
        _this.search_results_mouseup(evt);
      });
      this.search_results.bind('mouseover.chosen', function(evt) {
        _this.search_results_mouseover(evt);
      });
      this.search_results.bind('mouseout.chosen', function(evt) {
        _this.search_results_mouseout(evt);
      });
      this.search_results.bind('mousewheel.chosen DOMMouseScroll.chosen', function(evt) {
        _this.search_results_mousewheel(evt);
      });
      this.search_results.bind('touchstart.chosen', function(evt) {
        _this.search_results_touchstart(evt);
      });
      this.search_results.bind('touchmove.chosen', function(evt) {
        _this.search_results_touchmove(evt);
      });
      this.search_results.bind('touchend.chosen', function(evt) {
        _this.search_results_touchend(evt);
      });
      this.form_field_jq.bind("chosen:updated.chosen", function(evt) {
        _this.results_update_field(evt);
      });
      this.form_field_jq.bind("chosen:activate.chosen", function(evt) {
        _this.activate_field(evt);
      });
      this.form_field_jq.bind("chosen:open.chosen", function(evt) {
        _this.container_mousedown(evt);
      });
      this.form_field_jq.bind("chosen:close.chosen", function(evt) {
        _this.close_field(evt);
      });
      this.search_field.bind('blur.chosen', function(evt) {
        _this.input_blur(evt);
      });
      this.search_field.bind('keyup.chosen', function(evt) {
        _this.keyup_checker(evt);
      });
      this.search_field.bind('keydown.chosen', function(evt) {
        _this.keydown_checker(evt);
      });
      this.search_field.bind('focus.chosen', function(evt) {
        _this.input_focus(evt);
      });
      this.search_field.bind('cut.chosen', function(evt) {
        _this.clipboard_event_checker(evt);
      });
      this.search_field.bind('paste.chosen', function(evt) {
        _this.clipboard_event_checker(evt);
      });
      if (this.is_multiple) {
        return this.search_choices.bind('click.chosen', function(evt) {
          _this.choices_click(evt);
        });
      } else {
        return this.container.bind('click.chosen', function(evt) {
          evt.preventDefault();
        });
      }
    };

    Chosen.prototype.destroy = function() {
      $(this.container[0].ownerDocument).unbind('click.chosen', this.click_test_action);
      if (this.form_field_label.length > 0) {
        this.form_field_label.unbind('click.chosen');
      }
      if (this.search_field[0].tabIndex) {
        this.form_field_jq[0].tabIndex = this.search_field[0].tabIndex;
      }
      this.container.remove();
      this.form_field_jq.removeData('chosen');
      return this.form_field_jq.show();
    };

    Chosen.prototype.search_field_disabled = function() {
      this.is_disabled = this.form_field.disabled || this.form_field_jq.parents('fieldset').is(':disabled');
      this.container.toggleClass('chosen-disabled', this.is_disabled);
      this.search_field[0].disabled = this.is_disabled;
      if (!this.is_multiple) {
        this.selected_item.unbind('focus.chosen', this.activate_field);
      }
      if (this.is_disabled) {
        return this.close_field();
      } else if (!this.is_multiple) {
        return this.selected_item.bind('focus.chosen', this.activate_field);
      }
    };

    Chosen.prototype.container_mousedown = function(evt) {
      var _ref1;
      if (this.is_disabled) {
        return;
      }
      if (evt && ((_ref1 = evt.type) === 'mousedown' || _ref1 === 'touchstart') && !this.results_showing) {
        evt.preventDefault();
      }
      if (!((evt != null) && ($(evt.target)).hasClass("search-choice-close"))) {
        if (!this.active_field) {
          if (this.is_multiple) {
            this.search_field.val("");
          }
          $(this.container[0].ownerDocument).bind('click.chosen', this.click_test_action);
          this.results_show();
        } else if (!this.is_multiple && evt && (($(evt.target)[0] === this.selected_item[0]) || $(evt.target).parents("a.chosen-single").length)) {
          evt.preventDefault();
          this.results_toggle();
        }
        return this.activate_field();
      }
    };

    Chosen.prototype.container_mouseup = function(evt) {
      if (evt.target.nodeName === "ABBR" && !this.is_disabled) {
        return this.results_reset(evt);
      }
    };

    Chosen.prototype.search_results_mousewheel = function(evt) {
      var delta;
      if (evt.originalEvent) {
        delta = evt.originalEvent.deltaY || -evt.originalEvent.wheelDelta || evt.originalEvent.detail;
      }
      if (delta != null) {
        evt.preventDefault();
        if (evt.type === 'DOMMouseScroll') {
          delta = delta * 40;
        }
        return this.search_results.scrollTop(delta + this.search_results.scrollTop());
      }
    };

    Chosen.prototype.blur_test = function(evt) {
      if (!this.active_field && this.container.hasClass("chosen-container-active")) {
        return this.close_field();
      }
    };

    Chosen.prototype.close_field = function() {
      $(this.container[0].ownerDocument).unbind("click.chosen", this.click_test_action);
      this.active_field = false;
      this.results_hide();
      this.container.removeClass("chosen-container-active");
      this.clear_backstroke();
      this.show_search_field_default();
      this.search_field_scale();
      return this.search_field.blur();
    };

    Chosen.prototype.activate_field = function() {
      if (this.is_disabled) {
        return;
      }
      this.container.addClass("chosen-container-active");
      this.active_field = true;
      this.search_field.val(this.search_field.val());
      return this.search_field.focus();
    };

    Chosen.prototype.test_active_click = function(evt) {
      var active_container;
      active_container = $(evt.target).closest('.chosen-container');
      if (active_container.length && this.container[0] === active_container[0]) {
        return this.active_field = true;
      } else {
        return this.close_field();
      }
    };

    Chosen.prototype.results_build = function() {
      this.parsing = true;
      this.selected_option_count = null;
      this.results_data = SelectParser.select_to_array(this.form_field);
      if (this.is_multiple) {
        this.search_choices.find("li.search-choice").remove();
      } else if (!this.is_multiple) {
        this.single_set_selected_text();
        if (this.disable_search || this.form_field.options.length <= this.disable_search_threshold) {
          this.search_field[0].readOnly = true;
          this.container.addClass("chosen-container-single-nosearch");
        } else {
          this.search_field[0].readOnly = false;
          this.container.removeClass("chosen-container-single-nosearch");
        }
      }
      this.update_results_content(this.results_option_build({
        first: true
      }));
      this.search_field_disabled();
      this.show_search_field_default();
      this.search_field_scale();
      return this.parsing = false;
    };

    Chosen.prototype.result_do_highlight = function(el) {
      var high_bottom, high_top, maxHeight, visible_bottom, visible_top;
      if (el.length) {
        this.result_clear_highlight();
        this.result_highlight = el;
        this.result_highlight.addClass("highlighted");
        maxHeight = parseInt(this.search_results.css("maxHeight"), 10);
        visible_top = this.search_results.scrollTop();
        visible_bottom = maxHeight + visible_top;
        high_top = this.result_highlight.position().top + this.search_results.scrollTop();
        high_bottom = high_top + this.result_highlight.outerHeight();
        if (high_bottom >= visible_bottom) {
          return this.search_results.scrollTop((high_bottom - maxHeight) > 0 ? high_bottom - maxHeight : 0);
        } else if (high_top < visible_top) {
          return this.search_results.scrollTop(high_top);
        }
      }
    };

    Chosen.prototype.result_clear_highlight = function() {
      if (this.result_highlight) {
        this.result_highlight.removeClass("highlighted");
      }
      return this.result_highlight = null;
    };

    Chosen.prototype.results_show = function() {
      if (this.is_multiple && this.max_selected_options <= this.choices_count()) {
        this.form_field_jq.trigger("chosen:maxselected", {
          chosen: this
        });
        return false;
      }
      this.container.addClass("chosen-with-drop");
      this.results_showing = true;
      this.search_field.focus();
      this.search_field.val(this.get_search_field_value());
      this.winnow_results();
      return this.form_field_jq.trigger("chosen:showing_dropdown", {
        chosen: this
      });
    };

    Chosen.prototype.update_results_content = function(content) {
      return this.search_results.html(content);
    };

    Chosen.prototype.results_hide = function() {
      if (this.results_showing) {
        this.result_clear_highlight();
        this.container.removeClass("chosen-with-drop");
        this.form_field_jq.trigger("chosen:hiding_dropdown", {
          chosen: this
        });
      }
      return this.results_showing = false;
    };

    Chosen.prototype.set_tab_index = function(el) {
      var ti;
      if (this.form_field.tabIndex) {
        ti = this.form_field.tabIndex;
        this.form_field.tabIndex = -1;
        return this.search_field[0].tabIndex = ti;
      }
    };

    Chosen.prototype.set_label_behavior = function() {
      this.form_field_label = this.form_field_jq.parents("label");
      if (!this.form_field_label.length && this.form_field.id.length) {
        this.form_field_label = $("label[for='" + this.form_field.id + "']");
      }
      if (this.form_field_label.length > 0) {
        return this.form_field_label.bind('click.chosen', this.label_click_handler);
      }
    };

    Chosen.prototype.show_search_field_default = function() {
      if (this.is_multiple && this.choices_count() < 1 && !this.active_field) {
        this.search_field.val(this.default_text);
        return this.search_field.addClass("default");
      } else {
        this.search_field.val("");
        return this.search_field.removeClass("default");
      }
    };

    Chosen.prototype.search_results_mouseup = function(evt) {
      var target;
      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target.length) {
        this.result_highlight = target;
        this.result_select(evt);
        return this.search_field.focus();
      }
    };

    Chosen.prototype.search_results_mouseover = function(evt) {
      var target;
      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target) {
        return this.result_do_highlight(target);
      }
    };

    Chosen.prototype.search_results_mouseout = function(evt) {
      if ($(evt.target).hasClass("active-result" || $(evt.target).parents('.active-result').first())) {
        return this.result_clear_highlight();
      }
    };

    Chosen.prototype.choice_build = function(item) {
      var choice, close_link,
        _this = this;
      choice = $('<li />', {
        "class": "search-choice"
      }).html("<span>" + (this.choice_label(item)) + "</span>");
      if (item.disabled) {
        choice.addClass('search-choice-disabled');
      } else {
        close_link = $('<a />', {
          "class": 'search-choice-close',
          'data-option-array-index': item.array_index
        });
        close_link.bind('click.chosen', function(evt) {
          return _this.choice_destroy_link_click(evt);
        });
        choice.append(close_link);
      }
      return this.search_container.before(choice);
    };

    Chosen.prototype.choice_destroy_link_click = function(evt) {
      evt.preventDefault();
      evt.stopPropagation();
      if (!this.is_disabled) {
        return this.choice_destroy($(evt.target));
      }
    };

    Chosen.prototype.choice_destroy = function(link) {
      if (this.result_deselect(link[0].getAttribute("data-option-array-index"))) {
        if (this.active_field) {
          this.search_field.focus();
        } else {
          this.show_search_field_default();
        }
        if (this.is_multiple && this.choices_count() > 0 && this.get_search_field_value().length < 1) {
          this.results_hide();
        }
        link.parents('li').first().remove();
        return this.search_field_scale();
      }
    };

    Chosen.prototype.results_reset = function() {
      this.reset_single_select_options();
      this.form_field.options[0].selected = true;
      this.single_set_selected_text();
      this.show_search_field_default();
      this.results_reset_cleanup();
      this.trigger_form_field_change();
      if (this.active_field) {
        return this.results_hide();
      }
    };

    Chosen.prototype.results_reset_cleanup = function() {
      this.current_selectedIndex = this.form_field.selectedIndex;
      return this.selected_item.find("abbr").remove();
    };

    Chosen.prototype.result_select = function(evt) {
      var high, item;
      if (this.result_highlight) {
        high = this.result_highlight;
        this.result_clear_highlight();
        if (this.is_multiple && this.max_selected_options <= this.choices_count()) {
          this.form_field_jq.trigger("chosen:maxselected", {
            chosen: this
          });
          return false;
        }
        if (this.is_multiple) {
          high.removeClass("active-result");
        } else {
          this.reset_single_select_options();
        }
        high.addClass("result-selected");
        item = this.results_data[high[0].getAttribute("data-option-array-index")];
        item.selected = true;
        this.form_field.options[item.options_index].selected = true;
        this.selected_option_count = null;
        if (this.is_multiple) {
          this.choice_build(item);
        } else {
          this.single_set_selected_text(this.choice_label(item));
        }
        if (!(this.is_multiple && (!this.hide_results_on_select || (evt.metaKey || evt.ctrlKey)))) {
          this.results_hide();
          this.show_search_field_default();
        }
        if (this.is_multiple || this.form_field.selectedIndex !== this.current_selectedIndex) {
          this.trigger_form_field_change({
            selected: this.form_field.options[item.options_index].value
          });
        }
        this.current_selectedIndex = this.form_field.selectedIndex;
        evt.preventDefault();
        return this.search_field_scale();
      }
    };

    Chosen.prototype.single_set_selected_text = function(text) {
      if (text == null) {
        text = this.default_text;
      }
      if (text === this.default_text) {
        this.selected_item.addClass("chosen-default");
      } else {
        this.single_deselect_control_build();
        this.selected_item.removeClass("chosen-default");
      }
      return this.selected_item.find("span").html(text);
    };

    Chosen.prototype.result_deselect = function(pos) {
      var result_data;
      result_data = this.results_data[pos];
      if (!this.form_field.options[result_data.options_index].disabled) {
        result_data.selected = false;
        this.form_field.options[result_data.options_index].selected = false;
        this.selected_option_count = null;
        this.result_clear_highlight();
        if (this.results_showing) {
          this.winnow_results();
        }
        this.trigger_form_field_change({
          deselected: this.form_field.options[result_data.options_index].value
        });
        this.search_field_scale();
        return true;
      } else {
        return false;
      }
    };

    Chosen.prototype.single_deselect_control_build = function() {
      if (!this.allow_single_deselect) {
        return;
      }
      if (!this.selected_item.find("abbr").length) {
        this.selected_item.find("span").first().after("<abbr class=\"search-choice-close\"></abbr>");
      }
      return this.selected_item.addClass("chosen-single-with-deselect");
    };

    Chosen.prototype.get_search_field_value = function() {
      return this.search_field.val();
    };

    Chosen.prototype.get_search_text = function() {
      return this.escape_html($.trim(this.get_search_field_value()));
    };

    Chosen.prototype.escape_html = function(text) {
      return $('<div/>').text(text).html();
    };

    Chosen.prototype.winnow_results_set_highlight = function() {
      var do_high, selected_results;
      selected_results = !this.is_multiple ? this.search_results.find(".result-selected.active-result") : [];
      do_high = selected_results.length ? selected_results.first() : this.search_results.find(".active-result").first();
      if (do_high != null) {
        return this.result_do_highlight(do_high);
      }
    };

    Chosen.prototype.no_results = function(terms) {
      var no_results_html;
      no_results_html = this.get_no_results_html(terms);
      this.search_results.append(no_results_html);
      return this.form_field_jq.trigger("chosen:no_results", {
        chosen: this
      });
    };

    Chosen.prototype.no_results_clear = function() {
      return this.search_results.find(".no-results").remove();
    };

    Chosen.prototype.keydown_arrow = function() {
      var next_sib;
      if (this.results_showing && this.result_highlight) {
        next_sib = this.result_highlight.nextAll("li.active-result").first();
        if (next_sib) {
          return this.result_do_highlight(next_sib);
        }
      } else {
        return this.results_show();
      }
    };

    Chosen.prototype.keyup_arrow = function() {
      var prev_sibs;
      if (!this.results_showing && !this.is_multiple) {
        return this.results_show();
      } else if (this.result_highlight) {
        prev_sibs = this.result_highlight.prevAll("li.active-result");
        if (prev_sibs.length) {
          return this.result_do_highlight(prev_sibs.first());
        } else {
          if (this.choices_count() > 0) {
            this.results_hide();
          }
          return this.result_clear_highlight();
        }
      }
    };

    Chosen.prototype.keydown_backstroke = function() {
      var next_available_destroy;
      if (this.pending_backstroke) {
        this.choice_destroy(this.pending_backstroke.find("a").first());
        return this.clear_backstroke();
      } else {
        next_available_destroy = this.search_container.siblings("li.search-choice").last();
        if (next_available_destroy.length && !next_available_destroy.hasClass("search-choice-disabled")) {
          this.pending_backstroke = next_available_destroy;
          if (this.single_backstroke_delete) {
            return this.keydown_backstroke();
          } else {
            return this.pending_backstroke.addClass("search-choice-focus");
          }
        }
      }
    };

    Chosen.prototype.clear_backstroke = function() {
      if (this.pending_backstroke) {
        this.pending_backstroke.removeClass("search-choice-focus");
      }
      return this.pending_backstroke = null;
    };

    Chosen.prototype.search_field_scale = function() {
      var container_width, div, style, style_block, styles, width, _i, _len;
      if (!this.is_multiple) {
        return;
      }
      style_block = {
        position: 'absolute',
        left: '-1000px',
        top: '-1000px',
        display: 'none',
        whiteSpace: 'pre'
      };
      styles = ['fontSize', 'fontStyle', 'fontWeight', 'fontFamily', 'lineHeight', 'textTransform', 'letterSpacing'];
      for (_i = 0, _len = styles.length; _i < _len; _i++) {
        style = styles[_i];
        style_block[style] = this.search_field.css(style);
      }
      div = $('<div />').css(style_block);
      div.text(this.get_search_field_value());
      $('body').append(div);
      width = div.width() + 25;
      div.remove();
      container_width = this.container.outerWidth();
      width = Math.min(container_width - 10, width);
      return this.search_field.width(width);
    };

    Chosen.prototype.trigger_form_field_change = function(extra) {
      this.form_field_jq.trigger("input", extra);
      return this.form_field_jq.trigger("change", extra);
    };

    return Chosen;

  })(AbstractChosen);

}).call(this);

"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 *
 * More info at [www.dropzonejs.com](http://www.dropzonejs.com)
 *
 * Copyright (c) 2012, Matias Meno
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */

// The Emitter class provides the ability to call `.on()` on Dropzone to listen
// to events.
// It is strongly based on component's emitter class, and I removed the
// functionality because of the dependency hell with different frameworks.
var Emitter = function () {
  function Emitter() {
    _classCallCheck(this, Emitter);
  }

  _createClass(Emitter, [{
    key: "on",

    // Add an event listener for given event
    value: function on(event, fn) {
      this._callbacks = this._callbacks || {};
      // Create namespace for this event
      if (!this._callbacks[event]) {
        this._callbacks[event] = [];
      }
      this._callbacks[event].push(fn);
      return this;
    }
  }, {
    key: "emit",
    value: function emit(event) {
      this._callbacks = this._callbacks || {};
      var callbacks = this._callbacks[event];

      if (callbacks) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        for (var _iterator = callbacks, _isArray = true, _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var callback = _ref;

          callback.apply(this, args);
        }
      }

      return this;
    }

    // Remove event listener for given event. If fn is not provided, all event
    // listeners for that event will be removed. If neither is provided, all
    // event listeners will be removed.

  }, {
    key: "off",
    value: function off(event, fn) {
      if (!this._callbacks || arguments.length === 0) {
        this._callbacks = {};
        return this;
      }

      // specific event
      var callbacks = this._callbacks[event];
      if (!callbacks) {
        return this;
      }

      // remove all handlers
      if (arguments.length === 1) {
        delete this._callbacks[event];
        return this;
      }

      // remove specific handler
      for (var i = 0; i < callbacks.length; i++) {
        var callback = callbacks[i];
        if (callback === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }

      return this;
    }
  }]);

  return Emitter;
}();

var Dropzone = function (_Emitter) {
  _inherits(Dropzone, _Emitter);

  _createClass(Dropzone, null, [{
    key: "initClass",
    value: function initClass() {

      // Exposing the emitter class, mainly for tests
      this.prototype.Emitter = Emitter;

      /*
       This is a list of all available events you can register on a dropzone object.
        You can register an event handler like this:
        dropzone.on("dragEnter", function() { });
        */
      this.prototype.events = ["drop", "dragstart", "dragend", "dragenter", "dragover", "dragleave", "addedfile", "addedfiles", "removedfile", "thumbnail", "error", "errormultiple", "processing", "processingmultiple", "uploadprogress", "totaluploadprogress", "sending", "sendingmultiple", "success", "successmultiple", "canceled", "canceledmultiple", "complete", "completemultiple", "reset", "maxfilesexceeded", "maxfilesreached", "queuecomplete"];

      this.prototype.defaultOptions = {
        /**
         * Has to be specified on elements other than form (or when the form
         * doesn't have an `action` attribute). You can also
         * provide a function that will be called with `files` and
         * must return the url (since `v3.12.0`)
         */
        url: null,

        /**
         * Can be changed to `"put"` if necessary. You can also provide a function
         * that will be called with `files` and must return the method (since `v3.12.0`).
         */
        method: "post",

        /**
         * Will be set on the XHRequest.
         */
        withCredentials: false,

        /**
         * The timeout for the XHR requests in milliseconds (since `v4.4.0`).
         */
        timeout: 30000,

        /**
         * How many file uploads to process in parallel (See the
         * Enqueuing file uploads* documentation section for more info)
         */
        parallelUploads: 2,

        /**
         * Whether to send multiple files in one request. If
         * this it set to true, then the fallback file input element will
         * have the `multiple` attribute as well. This option will
         * also trigger additional events (like `processingmultiple`). See the events
         * documentation section for more information.
         */
        uploadMultiple: false,

        /**
         * Whether you want files to be uploaded in chunks to your server. This can't be
         * used in combination with `uploadMultiple`.
         *
         * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload.
         */
        chunking: false,

        /**
         * If `chunking` is enabled, this defines whether **every** file should be chunked,
         * even if the file size is below chunkSize. This means, that the additional chunk
         * form data will be submitted and the `chunksUploaded` callback will be invoked.
         */
        forceChunking: false,

        /**
         * If `chunking` is `true`, then this defines the chunk size in bytes.
         */
        chunkSize: 2000000,

        /**
         * If `true`, the individual chunks of a file are being uploaded simultaneously.
         */
        parallelChunkUploads: false,

        /**
         * Whether a chunk should be retried if it fails.
         */
        retryChunks: false,

        /**
         * If `retryChunks` is true, how many times should it be retried.
         */
        retryChunksLimit: 3,

        /**
         * If not `null` defines how many files this Dropzone handles. If it exceeds,
         * the event `maxfilesexceeded` will be called. The dropzone element gets the
         * class `dz-max-files-reached` accordingly so you can provide visual feedback.
         */
        maxFilesize: 256,

        /**
         * The name of the file param that gets transferred.
         * **NOTE**: If you have the option  `uploadMultiple` set to `true`, then
         * Dropzone will append `[]` to the name.
         */
        paramName: "file",

        /**
         * Whether thumbnails for images should be generated
         */
        createImageThumbnails: true,

        /**
         * In MB. When the filename exceeds this limit, the thumbnail will not be generated.
         */
        maxThumbnailFilesize: 10,

        /**
         * If `null`, the ratio of the image will be used to calculate it.
         */
        thumbnailWidth: 120,

        /**
         * The same as `thumbnailWidth`. If both are null, images will not be resized.
         */
        thumbnailHeight: 120,

        /**
         * How the images should be scaled down in case both, `thumbnailWidth` and `thumbnailHeight` are provided.
         * Can be either `contain` or `crop`.
         */
        thumbnailMethod: 'crop',

        /**
         * If set, images will be resized to these dimensions before being **uploaded**.
         * If only one, `resizeWidth` **or** `resizeHeight` is provided, the original aspect
         * ratio of the file will be preserved.
         *
         * The `options.transformFile` function uses these options, so if the `transformFile` function
         * is overridden, these options don't do anything.
         */
        resizeWidth: null,

        /**
         * See `resizeWidth`.
         */
        resizeHeight: null,

        /**
         * The mime type of the resized image (before it gets uploaded to the server).
         * If `null` the original mime type will be used. To force jpeg, for example, use `image/jpeg`.
         * See `resizeWidth` for more information.
         */
        resizeMimeType: null,

        /**
         * The quality of the resized images. See `resizeWidth`.
         */
        resizeQuality: 0.8,

        /**
         * How the images should be scaled down in case both, `resizeWidth` and `resizeHeight` are provided.
         * Can be either `contain` or `crop`.
         */
        resizeMethod: 'contain',

        /**
         * The base that is used to calculate the filesize. You can change this to
         * 1024 if you would rather display kibibytes, mebibytes, etc...
         * 1024 is technically incorrect, because `1024 bytes` are `1 kibibyte` not `1 kilobyte`.
         * You can change this to `1024` if you don't care about validity.
         */
        filesizeBase: 1000,

        /**
         * Can be used to limit the maximum number of files that will be handled by this Dropzone
         */
        maxFiles: null,

        /**
         * An optional object to send additional headers to the server. Eg:
         * `{ "My-Awesome-Header": "header value" }`
         */
        headers: null,

        /**
         * If `true`, the dropzone element itself will be clickable, if `false`
         * nothing will be clickable.
         *
         * You can also pass an HTML element, a CSS selector (for multiple elements)
         * or an array of those. In that case, all of those elements will trigger an
         * upload when clicked.
         */
        clickable: true,

        /**
         * Whether hidden files in directories should be ignored.
         */
        ignoreHiddenFiles: true,

        /**
         * The default implementation of `accept` checks the file's mime type or
         * extension against this list. This is a comma separated list of mime
         * types or file extensions.
         *
         * Eg.: `image/*,application/pdf,.psd`
         *
         * If the Dropzone is `clickable` this option will also be used as
         * [`accept`](https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept)
         * parameter on the hidden file input as well.
         */
        acceptedFiles: null,

        /**
         * **Deprecated!**
         * Use acceptedFiles instead.
         */
        acceptedMimeTypes: null,

        /**
         * If false, files will be added to the queue but the queue will not be
         * processed automatically.
         * This can be useful if you need some additional user input before sending
         * files (or if you want want all files sent at once).
         * If you're ready to send the file simply call `myDropzone.processQueue()`.
         *
         * See the [enqueuing file uploads](#enqueuing-file-uploads) documentation
         * section for more information.
         */
        autoProcessQueue: true,

        /**
         * If false, files added to the dropzone will not be queued by default.
         * You'll have to call `enqueueFile(file)` manually.
         */
        autoQueue: true,

        /**
         * If `true`, this will add a link to every file preview to remove or cancel (if
         * already uploading) the file. The `dictCancelUpload`, `dictCancelUploadConfirmation`
         * and `dictRemoveFile` options are used for the wording.
         */
        addRemoveLinks: false,

        /**
         * Defines where to display the file previews – if `null` the
         * Dropzone element itself is used. Can be a plain `HTMLElement` or a CSS
         * selector. The element should have the `dropzone-previews` class so
         * the previews are displayed properly.
         */
        previewsContainer: null,

        /**
         * This is the element the hidden input field (which is used when clicking on the
         * dropzone to trigger file selection) will be appended to. This might
         * be important in case you use frameworks to switch the content of your page.
         */
        hiddenInputContainer: "body",

        /**
         * If null, no capture type will be specified
         * If camera, mobile devices will skip the file selection and choose camera
         * If microphone, mobile devices will skip the file selection and choose the microphone
         * If camcorder, mobile devices will skip the file selection and choose the camera in video mode
         * On apple devices multiple must be set to false.  AcceptedFiles may need to
         * be set to an appropriate mime type (e.g. "image/*", "audio/*", or "video/*").
         */
        capture: null,

        /**
         * **Deprecated**. Use `renameFile` instead.
         */
        renameFilename: null,

        /**
         * A function that is invoked before the file is uploaded to the server and renames the file.
         * This function gets the `File` as argument and can use the `file.name`. The actual name of the
         * file that gets used during the upload can be accessed through `file.upload.filename`.
         */
        renameFile: null,

        /**
         * If `true` the fallback will be forced. This is very useful to test your server
         * implementations first and make sure that everything works as
         * expected without dropzone if you experience problems, and to test
         * how your fallbacks will look.
         */
        forceFallback: false,

        /**
         * The text used before any files are dropped.
         */
        dictDefaultMessage: "Drop files here to upload",

        /**
         * The text that replaces the default message text it the browser is not supported.
         */
        dictFallbackMessage: "Your browser does not support drag'n'drop file uploads.",

        /**
         * The text that will be added before the fallback form.
         * If you provide a  fallback element yourself, or if this option is `null` this will
         * be ignored.
         */
        dictFallbackText: "Please use the fallback form below to upload your files like in the olden days.",

        /**
         * If the filesize is too big.
         * `{{filesize}}` and `{{maxFilesize}}` will be replaced with the respective configuration values.
         */
        dictFileTooBig: "File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",

        /**
         * If the file doesn't match the file type.
         */
        dictInvalidFileType: "You can't upload files of this type.",

        /**
         * If the server response was invalid.
         * `{{statusCode}}` will be replaced with the servers status code.
         */
        dictResponseError: "Server responded with {{statusCode}} code.",

        /**
         * If `addRemoveLinks` is true, the text to be used for the cancel upload link.
         */
        dictCancelUpload: "Cancel upload",

        /**
         * The text that is displayed if an upload was manually canceled
         */
        dictUploadCanceled: "Upload canceled.",

        /**
         * If `addRemoveLinks` is true, the text to be used for confirmation when cancelling upload.
         */
        dictCancelUploadConfirmation: "Are you sure you want to cancel this upload?",

        /**
         * If `addRemoveLinks` is true, the text to be used to remove a file.
         */
        dictRemoveFile: "Remove file",

        /**
         * If this is not null, then the user will be prompted before removing a file.
         */
        dictRemoveFileConfirmation: null,

        /**
         * Displayed if `maxFiles` is st and exceeded.
         * The string `{{maxFiles}}` will be replaced by the configuration value.
         */
        dictMaxFilesExceeded: "You can not upload any more files.",

        /**
         * Allows you to translate the different units. Starting with `tb` for terabytes and going down to
         * `b` for bytes.
         */
        dictFileSizeUnits: { tb: "TB", gb: "GB", mb: "MB", kb: "KB", b: "b" },
        /**
         * Called when dropzone initialized
         * You can add event listeners here
         */
        init: function init() {},


        /**
         * Can be an **object** of additional parameters to transfer to the server, **or** a `Function`
         * that gets invoked with the `files`, `xhr` and, if it's a chunked upload, `chunk` arguments. In case
         * of a function, this needs to return a map.
         *
         * The default implementation does nothing for normal uploads, but adds relevant information for
         * chunked uploads.
         *
         * This is the same as adding hidden input fields in the form element.
         */
        params: function params(files, xhr, chunk) {
          if (chunk) {
            return {
              dzuuid: chunk.file.upload.uuid,
              dzchunkindex: chunk.index,
              dztotalfilesize: chunk.file.size,
              dzchunksize: this.options.chunkSize,
              dztotalchunkcount: chunk.file.upload.totalChunkCount,
              dzchunkbyteoffset: chunk.index * this.options.chunkSize
            };
          }
        },


        /**
         * A function that gets a [file](https://developer.mozilla.org/en-US/docs/DOM/File)
         * and a `done` function as parameters.
         *
         * If the done function is invoked without arguments, the file is "accepted" and will
         * be processed. If you pass an error message, the file is rejected, and the error
         * message will be displayed.
         * This function will not be called if the file is too big or doesn't match the mime types.
         */
        accept: function accept(file, done) {
          return done();
        },


        /**
         * The callback that will be invoked when all chunks have been uploaded for a file.
         * It gets the file for which the chunks have been uploaded as the first parameter,
         * and the `done` function as second. `done()` needs to be invoked when everything
         * needed to finish the upload process is done.
         */
        chunksUploaded: function chunksUploaded(file, done) {
          done();
        },

        /**
         * Gets called when the browser is not supported.
         * The default implementation shows the fallback input field and adds
         * a text.
         */
        fallback: function fallback() {
          // This code should pass in IE7... :(
          var messageElement = void 0;
          this.element.className = this.element.className + " dz-browser-not-supported";

          for (var _iterator2 = this.element.getElementsByTagName("div"), _isArray2 = true, _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray2) {
              if (_i2 >= _iterator2.length) break;
              _ref2 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done) break;
              _ref2 = _i2.value;
            }

            var child = _ref2;

            if (/(^| )dz-message($| )/.test(child.className)) {
              messageElement = child;
              child.className = "dz-message"; // Removes the 'dz-default' class
              break;
            }
          }
          if (!messageElement) {
            messageElement = Dropzone.createElement("<div class=\"dz-message\"><span></span></div>");
            this.element.appendChild(messageElement);
          }

          var span = messageElement.getElementsByTagName("span")[0];
          if (span) {
            if (span.textContent != null) {
              span.textContent = this.options.dictFallbackMessage;
            } else if (span.innerText != null) {
              span.innerText = this.options.dictFallbackMessage;
            }
          }

          return this.element.appendChild(this.getFallbackForm());
        },


        /**
         * Gets called to calculate the thumbnail dimensions.
         *
         * It gets `file`, `width` and `height` (both may be `null`) as parameters and must return an object containing:
         *
         *  - `srcWidth` & `srcHeight` (required)
         *  - `trgWidth` & `trgHeight` (required)
         *  - `srcX` & `srcY` (optional, default `0`)
         *  - `trgX` & `trgY` (optional, default `0`)
         *
         * Those values are going to be used by `ctx.drawImage()`.
         */
        resize: function resize(file, width, height, resizeMethod) {
          var info = {
            srcX: 0,
            srcY: 0,
            srcWidth: file.width,
            srcHeight: file.height
          };

          var srcRatio = file.width / file.height;

          // Automatically calculate dimensions if not specified
          if (width == null && height == null) {
            width = info.srcWidth;
            height = info.srcHeight;
          } else if (width == null) {
            width = height * srcRatio;
          } else if (height == null) {
            height = width / srcRatio;
          }

          // Make sure images aren't upscaled
          width = Math.min(width, info.srcWidth);
          height = Math.min(height, info.srcHeight);

          var trgRatio = width / height;

          if (info.srcWidth > width || info.srcHeight > height) {
            // Image is bigger and needs rescaling
            if (resizeMethod === 'crop') {
              if (srcRatio > trgRatio) {
                info.srcHeight = file.height;
                info.srcWidth = info.srcHeight * trgRatio;
              } else {
                info.srcWidth = file.width;
                info.srcHeight = info.srcWidth / trgRatio;
              }
            } else if (resizeMethod === 'contain') {
              // Method 'contain'
              if (srcRatio > trgRatio) {
                height = width / srcRatio;
              } else {
                width = height * srcRatio;
              }
            } else {
              throw new Error("Unknown resizeMethod '" + resizeMethod + "'");
            }
          }

          info.srcX = (file.width - info.srcWidth) / 2;
          info.srcY = (file.height - info.srcHeight) / 2;

          info.trgWidth = width;
          info.trgHeight = height;

          return info;
        },


        /**
         * Can be used to transform the file (for example, resize an image if necessary).
         *
         * The default implementation uses `resizeWidth` and `resizeHeight` (if provided) and resizes
         * images according to those dimensions.
         *
         * Gets the `file` as the first parameter, and a `done()` function as the second, that needs
         * to be invoked with the file when the transformation is done.
         */
        transformFile: function transformFile(file, done) {
          if ((this.options.resizeWidth || this.options.resizeHeight) && file.type.match(/image.*/)) {
            return this.resizeImage(file, this.options.resizeWidth, this.options.resizeHeight, this.options.resizeMethod, done);
          } else {
            return done(file);
          }
        },


        /**
         * A string that contains the template used for each dropped
         * file. Change it to fulfill your needs but make sure to properly
         * provide all elements.
         *
         * If you want to use an actual HTML element instead of providing a String
         * as a config option, you could create a div with the id `tpl`,
         * put the template inside it and provide the element like this:
         *
         *     document
         *       .querySelector('#tpl')
         *       .innerHTML
         *
         */
        previewTemplate: "<div class=\"dz-preview dz-file-preview\">\n  <div class=\"dz-image\"><img data-dz-thumbnail /></div>\n  <div class=\"dz-details\">\n    <div class=\"dz-size\"><span data-dz-size></span></div>\n    <div class=\"dz-filename\"><span data-dz-name></span></div>\n  </div>\n  <div class=\"dz-progress\"><span class=\"dz-upload\" data-dz-uploadprogress></span></div>\n  <div class=\"dz-error-message\"><span data-dz-errormessage></span></div>\n  <div class=\"dz-success-mark\">\n    <svg width=\"54px\" height=\"54px\" viewBox=\"0 0 54 54\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:sketch=\"http://www.bohemiancoding.com/sketch/ns\">\n      <title>Check</title>\n      <defs></defs>\n      <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" sketch:type=\"MSPage\">\n        <path d=\"M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\" id=\"Oval-2\" stroke-opacity=\"0.198794158\" stroke=\"#747474\" fill-opacity=\"0.816519475\" fill=\"#FFFFFF\" sketch:type=\"MSShapeGroup\"></path>\n      </g>\n    </svg>\n  </div>\n  <div class=\"dz-error-mark\">\n    <svg width=\"54px\" height=\"54px\" viewBox=\"0 0 54 54\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:sketch=\"http://www.bohemiancoding.com/sketch/ns\">\n      <title>Error</title>\n      <defs></defs>\n      <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" sketch:type=\"MSPage\">\n        <g id=\"Check-+-Oval-2\" sketch:type=\"MSLayerGroup\" stroke=\"#747474\" stroke-opacity=\"0.198794158\" fill=\"#FFFFFF\" fill-opacity=\"0.816519475\">\n          <path d=\"M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\" id=\"Oval-2\" sketch:type=\"MSShapeGroup\"></path>\n        </g>\n      </g>\n    </svg>\n  </div>\n</div>",

        // END OPTIONS
        // (Required by the dropzone documentation parser)


        /*
         Those functions register themselves to the events on init and handle all
         the user interface specific stuff. Overwriting them won't break the upload
         but can break the way it's displayed.
         You can overwrite them if you don't like the default behavior. If you just
         want to add an additional event handler, register it on the dropzone object
         and don't overwrite those options.
         */

        // Those are self explanatory and simply concern the DragnDrop.
        drop: function drop(e) {
          return this.element.classList.remove("dz-drag-hover");
        },
        dragstart: function dragstart(e) {},
        dragend: function dragend(e) {
          return this.element.classList.remove("dz-drag-hover");
        },
        dragenter: function dragenter(e) {
          return this.element.classList.add("dz-drag-hover");
        },
        dragover: function dragover(e) {
          return this.element.classList.add("dz-drag-hover");
        },
        dragleave: function dragleave(e) {
          return this.element.classList.remove("dz-drag-hover");
        },
        paste: function paste(e) {},


        // Called whenever there are no files left in the dropzone anymore, and the
        // dropzone should be displayed as if in the initial state.
        reset: function reset() {
          return this.element.classList.remove("dz-started");
        },


        // Called when a file is added to the queue
        // Receives `file`
        addedfile: function addedfile(file) {
          var _this2 = this;

          if (this.element === this.previewsContainer) {
            this.element.classList.add("dz-started");
          }

          if (this.previewsContainer) {
            file.previewElement = Dropzone.createElement(this.options.previewTemplate.trim());
            file.previewTemplate = file.previewElement; // Backwards compatibility

            this.previewsContainer.appendChild(file.previewElement);
            for (var _iterator3 = file.previewElement.querySelectorAll("[data-dz-name]"), _isArray3 = true, _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
              var _ref3;

              if (_isArray3) {
                if (_i3 >= _iterator3.length) break;
                _ref3 = _iterator3[_i3++];
              } else {
                _i3 = _iterator3.next();
                if (_i3.done) break;
                _ref3 = _i3.value;
              }

              var node = _ref3;

              node.textContent = file.name;
            }
            for (var _iterator4 = file.previewElement.querySelectorAll("[data-dz-size]"), _isArray4 = true, _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
              if (_isArray4) {
                if (_i4 >= _iterator4.length) break;
                node = _iterator4[_i4++];
              } else {
                _i4 = _iterator4.next();
                if (_i4.done) break;
                node = _i4.value;
              }

              node.innerHTML = this.filesize(file.size);
            }

            if (this.options.addRemoveLinks) {
              file._removeLink = Dropzone.createElement("<a class=\"dz-remove\" href=\"javascript:undefined;\" data-dz-remove>" + this.options.dictRemoveFile + "</a>");
              file.previewElement.appendChild(file._removeLink);
            }

            var removeFileEvent = function removeFileEvent(e) {
              e.preventDefault();
              e.stopPropagation();
              if (file.status === Dropzone.UPLOADING) {
                return Dropzone.confirm(_this2.options.dictCancelUploadConfirmation, function () {
                  return _this2.removeFile(file);
                });
              } else {
                if (_this2.options.dictRemoveFileConfirmation) {
                  return Dropzone.confirm(_this2.options.dictRemoveFileConfirmation, function () {
                    return _this2.removeFile(file);
                  });
                } else {
                  return _this2.removeFile(file);
                }
              }
            };

            for (var _iterator5 = file.previewElement.querySelectorAll("[data-dz-remove]"), _isArray5 = true, _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
              var _ref4;

              if (_isArray5) {
                if (_i5 >= _iterator5.length) break;
                _ref4 = _iterator5[_i5++];
              } else {
                _i5 = _iterator5.next();
                if (_i5.done) break;
                _ref4 = _i5.value;
              }

              var removeLink = _ref4;

              removeLink.addEventListener("click", removeFileEvent);
            }
          }
        },


        // Called whenever a file is removed.
        removedfile: function removedfile(file) {
          if (file.previewElement != null && file.previewElement.parentNode != null) {
            file.previewElement.parentNode.removeChild(file.previewElement);
          }
          return this._updateMaxFilesReachedClass();
        },


        // Called when a thumbnail has been generated
        // Receives `file` and `dataUrl`
        thumbnail: function thumbnail(file, dataUrl) {
          if (file.previewElement) {
            file.previewElement.classList.remove("dz-file-preview");
            for (var _iterator6 = file.previewElement.querySelectorAll("[data-dz-thumbnail]"), _isArray6 = true, _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
              var _ref5;

              if (_isArray6) {
                if (_i6 >= _iterator6.length) break;
                _ref5 = _iterator6[_i6++];
              } else {
                _i6 = _iterator6.next();
                if (_i6.done) break;
                _ref5 = _i6.value;
              }

              var thumbnailElement = _ref5;

              thumbnailElement.alt = file.name;
              thumbnailElement.src = dataUrl;
            }

            return setTimeout(function () {
              return file.previewElement.classList.add("dz-image-preview");
            }, 1);
          }
        },


        // Called whenever an error occurs
        // Receives `file` and `message`
        error: function error(file, message) {
          if (file.previewElement) {
            file.previewElement.classList.add("dz-error");
            if (typeof message !== "String" && message.error) {
              message = message.error;
            }
            for (var _iterator7 = file.previewElement.querySelectorAll("[data-dz-errormessage]"), _isArray7 = true, _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
              var _ref6;

              if (_isArray7) {
                if (_i7 >= _iterator7.length) break;
                _ref6 = _iterator7[_i7++];
              } else {
                _i7 = _iterator7.next();
                if (_i7.done) break;
                _ref6 = _i7.value;
              }

              var node = _ref6;

              node.textContent = message;
            }
          }
        },
        errormultiple: function errormultiple() {},


        // Called when a file gets processed. Since there is a cue, not all added
        // files are processed immediately.
        // Receives `file`
        processing: function processing(file) {
          if (file.previewElement) {
            file.previewElement.classList.add("dz-processing");
            if (file._removeLink) {
              return file._removeLink.textContent = this.options.dictCancelUpload;
            }
          }
        },
        processingmultiple: function processingmultiple() {},


        // Called whenever the upload progress gets updated.
        // Receives `file`, `progress` (percentage 0-100) and `bytesSent`.
        // To get the total number of bytes of the file, use `file.size`
        uploadprogress: function uploadprogress(file, progress, bytesSent) {
          if (file.previewElement) {
            for (var _iterator8 = file.previewElement.querySelectorAll("[data-dz-uploadprogress]"), _isArray8 = true, _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
              var _ref7;

              if (_isArray8) {
                if (_i8 >= _iterator8.length) break;
                _ref7 = _iterator8[_i8++];
              } else {
                _i8 = _iterator8.next();
                if (_i8.done) break;
                _ref7 = _i8.value;
              }

              var node = _ref7;

              node.nodeName === 'PROGRESS' ? node.value = progress : node.style.width = progress + "%";
            }
          }
        },


        // Called whenever the total upload progress gets updated.
        // Called with totalUploadProgress (0-100), totalBytes and totalBytesSent
        totaluploadprogress: function totaluploadprogress() {},


        // Called just before the file is sent. Gets the `xhr` object as second
        // parameter, so you can modify it (for example to add a CSRF token) and a
        // `formData` object to add additional information.
        sending: function sending() {},
        sendingmultiple: function sendingmultiple() {},


        // When the complete upload is finished and successful
        // Receives `file`
        success: function success(file) {
          if (file.previewElement) {
            return file.previewElement.classList.add("dz-success");
          }
        },
        successmultiple: function successmultiple() {},


        // When the upload is canceled.
        canceled: function canceled(file) {
          return this.emit("error", file, this.options.dictUploadCanceled);
        },
        canceledmultiple: function canceledmultiple() {},


        // When the upload is finished, either with success or an error.
        // Receives `file`
        complete: function complete(file) {
          if (file._removeLink) {
            file._removeLink.textContent = this.options.dictRemoveFile;
          }
          if (file.previewElement) {
            return file.previewElement.classList.add("dz-complete");
          }
        },
        completemultiple: function completemultiple() {},
        maxfilesexceeded: function maxfilesexceeded() {},
        maxfilesreached: function maxfilesreached() {},
        queuecomplete: function queuecomplete() {},
        addedfiles: function addedfiles() {}
      };

      this.prototype._thumbnailQueue = [];
      this.prototype._processingThumbnail = false;
    }

    // global utility

  }, {
    key: "extend",
    value: function extend(target) {
      for (var _len2 = arguments.length, objects = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        objects[_key2 - 1] = arguments[_key2];
      }

      for (var _iterator9 = objects, _isArray9 = true, _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {
        var _ref8;

        if (_isArray9) {
          if (_i9 >= _iterator9.length) break;
          _ref8 = _iterator9[_i9++];
        } else {
          _i9 = _iterator9.next();
          if (_i9.done) break;
          _ref8 = _i9.value;
        }

        var object = _ref8;

        for (var key in object) {
          var val = object[key];
          target[key] = val;
        }
      }
      return target;
    }
  }]);

  function Dropzone(el, options) {
    _classCallCheck(this, Dropzone);

    var _this = _possibleConstructorReturn(this, (Dropzone.__proto__ || Object.getPrototypeOf(Dropzone)).call(this));

    var fallback = void 0,
        left = void 0;
    _this.element = el;
    // For backwards compatibility since the version was in the prototype previously
    _this.version = Dropzone.version;

    _this.defaultOptions.previewTemplate = _this.defaultOptions.previewTemplate.replace(/\n*/g, "");

    _this.clickableElements = [];
    _this.listeners = [];
    _this.files = []; // All files

    if (typeof _this.element === "string") {
      _this.element = document.querySelector(_this.element);
    }

    // Not checking if instance of HTMLElement or Element since IE9 is extremely weird.
    if (!_this.element || _this.element.nodeType == null) {
      throw new Error("Invalid dropzone element.");
    }

    if (_this.element.dropzone) {
      throw new Error("Dropzone already attached.");
    }

    // Now add this dropzone to the instances.
    Dropzone.instances.push(_this);

    // Put the dropzone inside the element itself.
    _this.element.dropzone = _this;

    var elementOptions = (left = Dropzone.optionsForElement(_this.element)) != null ? left : {};

    _this.options = Dropzone.extend({}, _this.defaultOptions, elementOptions, options != null ? options : {});

    // If the browser failed, just call the fallback and leave
    if (_this.options.forceFallback || !Dropzone.isBrowserSupported()) {
      var _ret;

      return _ret = _this.options.fallback.call(_this), _possibleConstructorReturn(_this, _ret);
    }

    // @options.url = @element.getAttribute "action" unless @options.url?
    if (_this.options.url == null) {
      _this.options.url = _this.element.getAttribute("action");
    }

    if (!_this.options.url) {
      throw new Error("No URL provided.");
    }

    if (_this.options.acceptedFiles && _this.options.acceptedMimeTypes) {
      throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.");
    }

    if (_this.options.uploadMultiple && _this.options.chunking) {
      throw new Error('You cannot set both: uploadMultiple and chunking.');
    }

    // Backwards compatibility
    if (_this.options.acceptedMimeTypes) {
      _this.options.acceptedFiles = _this.options.acceptedMimeTypes;
      delete _this.options.acceptedMimeTypes;
    }

    // Backwards compatibility
    if (_this.options.renameFilename != null) {
      _this.options.renameFile = function (file) {
        return _this.options.renameFilename.call(_this, file.name, file);
      };
    }

    _this.options.method = _this.options.method.toUpperCase();

    if ((fallback = _this.getExistingFallback()) && fallback.parentNode) {
      // Remove the fallback
      fallback.parentNode.removeChild(fallback);
    }

    // Display previews in the previewsContainer element or the Dropzone element unless explicitly set to false
    if (_this.options.previewsContainer !== false) {
      if (_this.options.previewsContainer) {
        _this.previewsContainer = Dropzone.getElement(_this.options.previewsContainer, "previewsContainer");
      } else {
        _this.previewsContainer = _this.element;
      }
    }

    if (_this.options.clickable) {
      if (_this.options.clickable === true) {
        _this.clickableElements = [_this.element];
      } else {
        _this.clickableElements = Dropzone.getElements(_this.options.clickable, "clickable");
      }
    }

    _this.init();
    return _this;
  }

  // Returns all files that have been accepted


  _createClass(Dropzone, [{
    key: "getAcceptedFiles",
    value: function getAcceptedFiles() {
      return this.files.filter(function (file) {
        return file.accepted;
      }).map(function (file) {
        return file;
      });
    }

    // Returns all files that have been rejected
    // Not sure when that's going to be useful, but added for completeness.

  }, {
    key: "getRejectedFiles",
    value: function getRejectedFiles() {
      return this.files.filter(function (file) {
        return !file.accepted;
      }).map(function (file) {
        return file;
      });
    }
  }, {
    key: "getFilesWithStatus",
    value: function getFilesWithStatus(status) {
      return this.files.filter(function (file) {
        return file.status === status;
      }).map(function (file) {
        return file;
      });
    }

    // Returns all files that are in the queue

  }, {
    key: "getQueuedFiles",
    value: function getQueuedFiles() {
      return this.getFilesWithStatus(Dropzone.QUEUED);
    }
  }, {
    key: "getUploadingFiles",
    value: function getUploadingFiles() {
      return this.getFilesWithStatus(Dropzone.UPLOADING);
    }
  }, {
    key: "getAddedFiles",
    value: function getAddedFiles() {
      return this.getFilesWithStatus(Dropzone.ADDED);
    }

    // Files that are either queued or uploading

  }, {
    key: "getActiveFiles",
    value: function getActiveFiles() {
      return this.files.filter(function (file) {
        return file.status === Dropzone.UPLOADING || file.status === Dropzone.QUEUED;
      }).map(function (file) {
        return file;
      });
    }

    // The function that gets called when Dropzone is initialized. You
    // can (and should) setup event listeners inside this function.

  }, {
    key: "init",
    value: function init() {
      var _this3 = this;

      // In case it isn't set already
      if (this.element.tagName === "form") {
        this.element.setAttribute("enctype", "multipart/form-data");
      }

      if (this.element.classList.contains("dropzone") && !this.element.querySelector(".dz-message")) {
        this.element.appendChild(Dropzone.createElement("<div class=\"dz-default dz-message\"><span>" + this.options.dictDefaultMessage + "</span></div>"));
      }

      if (this.clickableElements.length) {
        var setupHiddenFileInput = function setupHiddenFileInput() {
          if (_this3.hiddenFileInput) {
            _this3.hiddenFileInput.parentNode.removeChild(_this3.hiddenFileInput);
          }
          _this3.hiddenFileInput = document.createElement("input");
          _this3.hiddenFileInput.setAttribute("type", "file");
          if (_this3.options.maxFiles === null || _this3.options.maxFiles > 1) {
            _this3.hiddenFileInput.setAttribute("multiple", "multiple");
          }
          _this3.hiddenFileInput.className = "dz-hidden-input";

          if (_this3.options.acceptedFiles !== null) {
            _this3.hiddenFileInput.setAttribute("accept", _this3.options.acceptedFiles);
          }
          if (_this3.options.capture !== null) {
            _this3.hiddenFileInput.setAttribute("capture", _this3.options.capture);
          }

          // Not setting `display="none"` because some browsers don't accept clicks
          // on elements that aren't displayed.
          _this3.hiddenFileInput.style.visibility = "hidden";
          _this3.hiddenFileInput.style.position = "absolute";
          _this3.hiddenFileInput.style.top = "0";
          _this3.hiddenFileInput.style.left = "0";
          _this3.hiddenFileInput.style.height = "0";
          _this3.hiddenFileInput.style.width = "0";
          document.querySelector(_this3.options.hiddenInputContainer).appendChild(_this3.hiddenFileInput);
          return _this3.hiddenFileInput.addEventListener("change", function () {
            var files = _this3.hiddenFileInput.files;

            if (files.length) {
              for (var _iterator10 = files, _isArray10 = true, _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator]();;) {
                var _ref9;

                if (_isArray10) {
                  if (_i10 >= _iterator10.length) break;
                  _ref9 = _iterator10[_i10++];
                } else {
                  _i10 = _iterator10.next();
                  if (_i10.done) break;
                  _ref9 = _i10.value;
                }

                var file = _ref9;

                _this3.addFile(file);
              }
            }
            _this3.emit("addedfiles", files);
            return setupHiddenFileInput();
          });
        };
        setupHiddenFileInput();
      }

      this.URL = window.URL !== null ? window.URL : window.webkitURL;

      // Setup all event listeners on the Dropzone object itself.
      // They're not in @setupEventListeners() because they shouldn't be removed
      // again when the dropzone gets disabled.
      for (var _iterator11 = this.events, _isArray11 = true, _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator]();;) {
        var _ref10;

        if (_isArray11) {
          if (_i11 >= _iterator11.length) break;
          _ref10 = _iterator11[_i11++];
        } else {
          _i11 = _iterator11.next();
          if (_i11.done) break;
          _ref10 = _i11.value;
        }

        var eventName = _ref10;

        this.on(eventName, this.options[eventName]);
      }

      this.on("uploadprogress", function () {
        return _this3.updateTotalUploadProgress();
      });

      this.on("removedfile", function () {
        return _this3.updateTotalUploadProgress();
      });

      this.on("canceled", function (file) {
        return _this3.emit("complete", file);
      });

      // Emit a `queuecomplete` event if all files finished uploading.
      this.on("complete", function (file) {
        if (_this3.getAddedFiles().length === 0 && _this3.getUploadingFiles().length === 0 && _this3.getQueuedFiles().length === 0) {
          // This needs to be deferred so that `queuecomplete` really triggers after `complete`
          return setTimeout(function () {
            return _this3.emit("queuecomplete");
          }, 0);
        }
      });

      var noPropagation = function noPropagation(e) {
        e.stopPropagation();
        if (e.preventDefault) {
          return e.preventDefault();
        } else {
          return e.returnValue = false;
        }
      };

      // Create the listeners
      this.listeners = [{
        element: this.element,
        events: {
          "dragstart": function dragstart(e) {
            return _this3.emit("dragstart", e);
          },
          "dragenter": function dragenter(e) {
            noPropagation(e);
            return _this3.emit("dragenter", e);
          },
          "dragover": function dragover(e) {
            // Makes it possible to drag files from chrome's download bar
            // http://stackoverflow.com/questions/19526430/drag-and-drop-file-uploads-from-chrome-downloads-bar
            // Try is required to prevent bug in Internet Explorer 11 (SCRIPT65535 exception)
            var efct = void 0;
            try {
              efct = e.dataTransfer.effectAllowed;
            } catch (error) {}
            e.dataTransfer.dropEffect = 'move' === efct || 'linkMove' === efct ? 'move' : 'copy';

            noPropagation(e);
            return _this3.emit("dragover", e);
          },
          "dragleave": function dragleave(e) {
            return _this3.emit("dragleave", e);
          },
          "drop": function drop(e) {
            noPropagation(e);
            return _this3.drop(e);
          },
          "dragend": function dragend(e) {
            return _this3.emit("dragend", e);
          }

          // This is disabled right now, because the browsers don't implement it properly.
          // "paste": (e) =>
          //   noPropagation e
          //   @paste e
        } }];

      this.clickableElements.forEach(function (clickableElement) {
        return _this3.listeners.push({
          element: clickableElement,
          events: {
            "click": function click(evt) {
              // Only the actual dropzone or the message element should trigger file selection
              if (clickableElement !== _this3.element || evt.target === _this3.element || Dropzone.elementInside(evt.target, _this3.element.querySelector(".dz-message"))) {
                _this3.hiddenFileInput.click(); // Forward the click
              }
              return true;
            }
          }
        });
      });

      this.enable();

      return this.options.init.call(this);
    }

    // Not fully tested yet

  }, {
    key: "destroy",
    value: function destroy() {
      this.disable();
      this.removeAllFiles(true);
      if (this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : undefined) {
        this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
        this.hiddenFileInput = null;
      }
      delete this.element.dropzone;
      return Dropzone.instances.splice(Dropzone.instances.indexOf(this), 1);
    }
  }, {
    key: "updateTotalUploadProgress",
    value: function updateTotalUploadProgress() {
      var totalUploadProgress = void 0;
      var totalBytesSent = 0;
      var totalBytes = 0;

      var activeFiles = this.getActiveFiles();

      if (activeFiles.length) {
        for (var _iterator12 = this.getActiveFiles(), _isArray12 = true, _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator]();;) {
          var _ref11;

          if (_isArray12) {
            if (_i12 >= _iterator12.length) break;
            _ref11 = _iterator12[_i12++];
          } else {
            _i12 = _iterator12.next();
            if (_i12.done) break;
            _ref11 = _i12.value;
          }

          var file = _ref11;

          totalBytesSent += file.upload.bytesSent;
          totalBytes += file.upload.total;
        }
        totalUploadProgress = 100 * totalBytesSent / totalBytes;
      } else {
        totalUploadProgress = 100;
      }

      return this.emit("totaluploadprogress", totalUploadProgress, totalBytes, totalBytesSent);
    }

    // @options.paramName can be a function taking one parameter rather than a string.
    // A parameter name for a file is obtained simply by calling this with an index number.

  }, {
    key: "_getParamName",
    value: function _getParamName(n) {
      if (typeof this.options.paramName === "function") {
        return this.options.paramName(n);
      } else {
        return "" + this.options.paramName + (this.options.uploadMultiple ? "[" + n + "]" : "");
      }
    }

    // If @options.renameFile is a function,
    // the function will be used to rename the file.name before appending it to the formData

  }, {
    key: "_renameFile",
    value: function _renameFile(file) {
      if (typeof this.options.renameFile !== "function") {
        return file.name;
      }
      return this.options.renameFile(file);
    }

    // Returns a form that can be used as fallback if the browser does not support DragnDrop
    //
    // If the dropzone is already a form, only the input field and button are returned. Otherwise a complete form element is provided.
    // This code has to pass in IE7 :(

  }, {
    key: "getFallbackForm",
    value: function getFallbackForm() {
      var existingFallback = void 0,
          form = void 0;
      if (existingFallback = this.getExistingFallback()) {
        return existingFallback;
      }

      var fieldsString = "<div class=\"dz-fallback\">";
      if (this.options.dictFallbackText) {
        fieldsString += "<p>" + this.options.dictFallbackText + "</p>";
      }
      fieldsString += "<input type=\"file\" name=\"" + this._getParamName(0) + "\" " + (this.options.uploadMultiple ? 'multiple="multiple"' : undefined) + " /><input type=\"submit\" value=\"Upload!\"></div>";

      var fields = Dropzone.createElement(fieldsString);
      if (this.element.tagName !== "FORM") {
        form = Dropzone.createElement("<form action=\"" + this.options.url + "\" enctype=\"multipart/form-data\" method=\"" + this.options.method + "\"></form>");
        form.appendChild(fields);
      } else {
        // Make sure that the enctype and method attributes are set properly
        this.element.setAttribute("enctype", "multipart/form-data");
        this.element.setAttribute("method", this.options.method);
      }
      return form != null ? form : fields;
    }

    // Returns the fallback elements if they exist already
    //
    // This code has to pass in IE7 :(

  }, {
    key: "getExistingFallback",
    value: function getExistingFallback() {
      var getFallback = function getFallback(elements) {
        for (var _iterator13 = elements, _isArray13 = true, _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator]();;) {
          var _ref12;

          if (_isArray13) {
            if (_i13 >= _iterator13.length) break;
            _ref12 = _iterator13[_i13++];
          } else {
            _i13 = _iterator13.next();
            if (_i13.done) break;
            _ref12 = _i13.value;
          }

          var el = _ref12;

          if (/(^| )fallback($| )/.test(el.className)) {
            return el;
          }
        }
      };

      var _arr = ["div", "form"];
      for (var _i14 = 0; _i14 < _arr.length; _i14++) {
        var tagName = _arr[_i14];
        var fallback;
        if (fallback = getFallback(this.element.getElementsByTagName(tagName))) {
          return fallback;
        }
      }
    }

    // Activates all listeners stored in @listeners

  }, {
    key: "setupEventListeners",
    value: function setupEventListeners() {
      return this.listeners.map(function (elementListeners) {
        return function () {
          var result = [];
          for (var event in elementListeners.events) {
            var listener = elementListeners.events[event];
            result.push(elementListeners.element.addEventListener(event, listener, false));
          }
          return result;
        }();
      });
    }

    // Deactivates all listeners stored in @listeners

  }, {
    key: "removeEventListeners",
    value: function removeEventListeners() {
      return this.listeners.map(function (elementListeners) {
        return function () {
          var result = [];
          for (var event in elementListeners.events) {
            var listener = elementListeners.events[event];
            result.push(elementListeners.element.removeEventListener(event, listener, false));
          }
          return result;
        }();
      });
    }

    // Removes all event listeners and cancels all files in the queue or being processed.

  }, {
    key: "disable",
    value: function disable() {
      var _this4 = this;

      this.clickableElements.forEach(function (element) {
        return element.classList.remove("dz-clickable");
      });
      this.removeEventListeners();
      this.disabled = true;

      return this.files.map(function (file) {
        return _this4.cancelUpload(file);
      });
    }
  }, {
    key: "enable",
    value: function enable() {
      delete this.disabled;
      this.clickableElements.forEach(function (element) {
        return element.classList.add("dz-clickable");
      });
      return this.setupEventListeners();
    }

    // Returns a nicely formatted filesize

  }, {
    key: "filesize",
    value: function filesize(size) {
      var selectedSize = 0;
      var selectedUnit = "b";

      if (size > 0) {
        var units = ['tb', 'gb', 'mb', 'kb', 'b'];

        for (var i = 0; i < units.length; i++) {
          var unit = units[i];
          var cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;

          if (size >= cutoff) {
            selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);
            selectedUnit = unit;
            break;
          }
        }

        selectedSize = Math.round(10 * selectedSize) / 10; // Cutting of digits
      }

      return "<strong>" + selectedSize + "</strong> " + this.options.dictFileSizeUnits[selectedUnit];
    }

    // Adds or removes the `dz-max-files-reached` class from the form.

  }, {
    key: "_updateMaxFilesReachedClass",
    value: function _updateMaxFilesReachedClass() {
      if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
        if (this.getAcceptedFiles().length === this.options.maxFiles) {
          this.emit('maxfilesreached', this.files);
        }
        return this.element.classList.add("dz-max-files-reached");
      } else {
        return this.element.classList.remove("dz-max-files-reached");
      }
    }
  }, {
    key: "drop",
    value: function drop(e) {
      if (!e.dataTransfer) {
        return;
      }
      this.emit("drop", e);

      // Convert the FileList to an Array
      // This is necessary for IE11
      var files = [];
      for (var i = 0; i < e.dataTransfer.files.length; i++) {
        files[i] = e.dataTransfer.files[i];
      }

      this.emit("addedfiles", files);

      // Even if it's a folder, files.length will contain the folders.
      if (files.length) {
        var items = e.dataTransfer.items;

        if (items && items.length && items[0].webkitGetAsEntry != null) {
          // The browser supports dropping of folders, so handle items instead of files
          this._addFilesFromItems(items);
        } else {
          this.handleFiles(files);
        }
      }
    }
  }, {
    key: "paste",
    value: function paste(e) {
      if (__guard__(e != null ? e.clipboardData : undefined, function (x) {
        return x.items;
      }) == null) {
        return;
      }

      this.emit("paste", e);
      var items = e.clipboardData.items;


      if (items.length) {
        return this._addFilesFromItems(items);
      }
    }
  }, {
    key: "handleFiles",
    value: function handleFiles(files) {
      for (var _iterator14 = files, _isArray14 = true, _i15 = 0, _iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator]();;) {
        var _ref13;

        if (_isArray14) {
          if (_i15 >= _iterator14.length) break;
          _ref13 = _iterator14[_i15++];
        } else {
          _i15 = _iterator14.next();
          if (_i15.done) break;
          _ref13 = _i15.value;
        }

        var file = _ref13;

        this.addFile(file);
      }
    }

    // When a folder is dropped (or files are pasted), items must be handled
    // instead of files.

  }, {
    key: "_addFilesFromItems",
    value: function _addFilesFromItems(items) {
      var _this5 = this;

      return function () {
        var result = [];
        for (var _iterator15 = items, _isArray15 = true, _i16 = 0, _iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator]();;) {
          var _ref14;

          if (_isArray15) {
            if (_i16 >= _iterator15.length) break;
            _ref14 = _iterator15[_i16++];
          } else {
            _i16 = _iterator15.next();
            if (_i16.done) break;
            _ref14 = _i16.value;
          }

          var item = _ref14;

          var entry;
          if (item.webkitGetAsEntry != null && (entry = item.webkitGetAsEntry())) {
            if (entry.isFile) {
              result.push(_this5.addFile(item.getAsFile()));
            } else if (entry.isDirectory) {
              // Append all files from that directory to files
              result.push(_this5._addFilesFromDirectory(entry, entry.name));
            } else {
              result.push(undefined);
            }
          } else if (item.getAsFile != null) {
            if (item.kind == null || item.kind === "file") {
              result.push(_this5.addFile(item.getAsFile()));
            } else {
              result.push(undefined);
            }
          } else {
            result.push(undefined);
          }
        }
        return result;
      }();
    }

    // Goes through the directory, and adds each file it finds recursively

  }, {
    key: "_addFilesFromDirectory",
    value: function _addFilesFromDirectory(directory, path) {
      var _this6 = this;

      var dirReader = directory.createReader();

      var errorHandler = function errorHandler(error) {
        return __guardMethod__(console, 'log', function (o) {
          return o.log(error);
        });
      };

      var readEntries = function readEntries() {
        return dirReader.readEntries(function (entries) {
          if (entries.length > 0) {
            for (var _iterator16 = entries, _isArray16 = true, _i17 = 0, _iterator16 = _isArray16 ? _iterator16 : _iterator16[Symbol.iterator]();;) {
              var _ref15;

              if (_isArray16) {
                if (_i17 >= _iterator16.length) break;
                _ref15 = _iterator16[_i17++];
              } else {
                _i17 = _iterator16.next();
                if (_i17.done) break;
                _ref15 = _i17.value;
              }

              var entry = _ref15;

              if (entry.isFile) {
                entry.file(function (file) {
                  if (_this6.options.ignoreHiddenFiles && file.name.substring(0, 1) === '.') {
                    return;
                  }
                  file.fullPath = path + "/" + file.name;
                  return _this6.addFile(file);
                });
              } else if (entry.isDirectory) {
                _this6._addFilesFromDirectory(entry, path + "/" + entry.name);
              }
            }

            // Recursively call readEntries() again, since browser only handle
            // the first 100 entries.
            // See: https://developer.mozilla.org/en-US/docs/Web/API/DirectoryReader#readEntries
            readEntries();
          }
          return null;
        }, errorHandler);
      };

      return readEntries();
    }

    // If `done()` is called without argument the file is accepted
    // If you call it with an error message, the file is rejected
    // (This allows for asynchronous validation)
    //
    // This function checks the filesize, and if the file.type passes the
    // `acceptedFiles` check.

  }, {
    key: "accept",
    value: function accept(file, done) {
      if (file.size > this.options.maxFilesize * 1024 * 1024) {
        return done(this.options.dictFileTooBig.replace("{{filesize}}", Math.round(file.size / 1024 / 10.24) / 100).replace("{{maxFilesize}}", this.options.maxFilesize));
      } else if (!Dropzone.isValidFile(file, this.options.acceptedFiles)) {
        return done(this.options.dictInvalidFileType);
      } else if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
        done(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}", this.options.maxFiles));
        return this.emit("maxfilesexceeded", file);
      } else {
        return this.options.accept.call(this, file, done);
      }
    }
  }, {
    key: "addFile",
    value: function addFile(file) {
      var _this7 = this;

      file.upload = {
        uuid: Dropzone.uuidv4(),
        progress: 0,
        // Setting the total upload size to file.size for the beginning
        // It's actual different than the size to be transmitted.
        total: file.size,
        bytesSent: 0,
        filename: this._renameFile(file),
        chunked: this.options.chunking && (this.options.forceChunking || file.size > this.options.chunkSize),
        totalChunkCount: Math.ceil(file.size / this.options.chunkSize)
      };
      this.files.push(file);

      file.status = Dropzone.ADDED;

      this.emit("addedfile", file);

      this._enqueueThumbnail(file);

      return this.accept(file, function (error) {
        if (error) {
          file.accepted = false;
          _this7._errorProcessing([file], error); // Will set the file.status
        } else {
          file.accepted = true;
          if (_this7.options.autoQueue) {
            _this7.enqueueFile(file);
          } // Will set .accepted = true
        }
        return _this7._updateMaxFilesReachedClass();
      });
    }

    // Wrapper for enqueueFile

  }, {
    key: "enqueueFiles",
    value: function enqueueFiles(files) {
      for (var _iterator17 = files, _isArray17 = true, _i18 = 0, _iterator17 = _isArray17 ? _iterator17 : _iterator17[Symbol.iterator]();;) {
        var _ref16;

        if (_isArray17) {
          if (_i18 >= _iterator17.length) break;
          _ref16 = _iterator17[_i18++];
        } else {
          _i18 = _iterator17.next();
          if (_i18.done) break;
          _ref16 = _i18.value;
        }

        var file = _ref16;

        this.enqueueFile(file);
      }
      return null;
    }
  }, {
    key: "enqueueFile",
    value: function enqueueFile(file) {
      var _this8 = this;

      if (file.status === Dropzone.ADDED && file.accepted === true) {
        file.status = Dropzone.QUEUED;
        if (this.options.autoProcessQueue) {
          return setTimeout(function () {
            return _this8.processQueue();
          }, 0); // Deferring the call
        }
      } else {
        throw new Error("This file can't be queued because it has already been processed or was rejected.");
      }
    }
  }, {
    key: "_enqueueThumbnail",
    value: function _enqueueThumbnail(file) {
      var _this9 = this;

      if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1024 * 1024) {
        this._thumbnailQueue.push(file);
        return setTimeout(function () {
          return _this9._processThumbnailQueue();
        }, 0); // Deferring the call
      }
    }
  }, {
    key: "_processThumbnailQueue",
    value: function _processThumbnailQueue() {
      var _this10 = this;

      if (this._processingThumbnail || this._thumbnailQueue.length === 0) {
        return;
      }

      this._processingThumbnail = true;
      var file = this._thumbnailQueue.shift();
      return this.createThumbnail(file, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, true, function (dataUrl) {
        _this10.emit("thumbnail", file, dataUrl);
        _this10._processingThumbnail = false;
        return _this10._processThumbnailQueue();
      });
    }

    // Can be called by the user to remove a file

  }, {
    key: "removeFile",
    value: function removeFile(file) {
      if (file.status === Dropzone.UPLOADING) {
        this.cancelUpload(file);
      }
      this.files = without(this.files, file);

      this.emit("removedfile", file);
      if (this.files.length === 0) {
        return this.emit("reset");
      }
    }

    // Removes all files that aren't currently processed from the list

  }, {
    key: "removeAllFiles",
    value: function removeAllFiles(cancelIfNecessary) {
      // Create a copy of files since removeFile() changes the @files array.
      if (cancelIfNecessary == null) {
        cancelIfNecessary = false;
      }
      for (var _iterator18 = this.files.slice(), _isArray18 = true, _i19 = 0, _iterator18 = _isArray18 ? _iterator18 : _iterator18[Symbol.iterator]();;) {
        var _ref17;

        if (_isArray18) {
          if (_i19 >= _iterator18.length) break;
          _ref17 = _iterator18[_i19++];
        } else {
          _i19 = _iterator18.next();
          if (_i19.done) break;
          _ref17 = _i19.value;
        }

        var file = _ref17;

        if (file.status !== Dropzone.UPLOADING || cancelIfNecessary) {
          this.removeFile(file);
        }
      }
      return null;
    }

    // Resizes an image before it gets sent to the server. This function is the default behavior of
    // `options.transformFile` if `resizeWidth` or `resizeHeight` are set. The callback is invoked with
    // the resized blob.

  }, {
    key: "resizeImage",
    value: function resizeImage(file, width, height, resizeMethod, callback) {
      var _this11 = this;

      return this.createThumbnail(file, width, height, resizeMethod, false, function (dataUrl, canvas) {
        if (canvas == null) {
          // The image has not been resized
          return callback(file);
        } else {
          var resizeMimeType = _this11.options.resizeMimeType;

          if (resizeMimeType == null) {
            resizeMimeType = file.type;
          }
          var resizedDataURL = canvas.toDataURL(resizeMimeType, _this11.options.resizeQuality);
          if (resizeMimeType === 'image/jpeg' || resizeMimeType === 'image/jpg') {
            // Now add the original EXIF information
            resizedDataURL = ExifRestore.restore(file.dataURL, resizedDataURL);
          }
          return callback(Dropzone.dataURItoBlob(resizedDataURL));
        }
      });
    }
  }, {
    key: "createThumbnail",
    value: function createThumbnail(file, width, height, resizeMethod, fixOrientation, callback) {
      var _this12 = this;

      var fileReader = new FileReader();

      fileReader.onload = function () {

        file.dataURL = fileReader.result;

        // Don't bother creating a thumbnail for SVG images since they're vector
        if (file.type === "image/svg+xml") {
          if (callback != null) {
            callback(fileReader.result);
          }
          return;
        }

        return _this12.createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback);
      };

      return fileReader.readAsDataURL(file);
    }
  }, {
    key: "createThumbnailFromUrl",
    value: function createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback, crossOrigin) {
      var _this13 = this;

      // Not using `new Image` here because of a bug in latest Chrome versions.
      // See https://github.com/enyo/dropzone/pull/226
      var img = document.createElement("img");

      if (crossOrigin) {
        img.crossOrigin = crossOrigin;
      }

      img.onload = function () {
        var loadExif = function loadExif(callback) {
          return callback(1);
        };
        if (typeof EXIF !== 'undefined' && EXIF !== null && fixOrientation) {
          loadExif = function loadExif(callback) {
            return EXIF.getData(img, function () {
              return callback(EXIF.getTag(this, 'Orientation'));
            });
          };
        }

        return loadExif(function (orientation) {
          file.width = img.width;
          file.height = img.height;

          var resizeInfo = _this13.options.resize.call(_this13, file, width, height, resizeMethod);

          var canvas = document.createElement("canvas");
          var ctx = canvas.getContext("2d");

          canvas.width = resizeInfo.trgWidth;
          canvas.height = resizeInfo.trgHeight;

          if (orientation > 4) {
            canvas.width = resizeInfo.trgHeight;
            canvas.height = resizeInfo.trgWidth;
          }

          switch (orientation) {
            case 2:
              // horizontal flip
              ctx.translate(canvas.width, 0);
              ctx.scale(-1, 1);
              break;
            case 3:
              // 180° rotate left
              ctx.translate(canvas.width, canvas.height);
              ctx.rotate(Math.PI);
              break;
            case 4:
              // vertical flip
              ctx.translate(0, canvas.height);
              ctx.scale(1, -1);
              break;
            case 5:
              // vertical flip + 90 rotate right
              ctx.rotate(0.5 * Math.PI);
              ctx.scale(1, -1);
              break;
            case 6:
              // 90° rotate right
              ctx.rotate(0.5 * Math.PI);
              ctx.translate(0, -canvas.height);
              break;
            case 7:
              // horizontal flip + 90 rotate right
              ctx.rotate(0.5 * Math.PI);
              ctx.translate(canvas.width, -canvas.height);
              ctx.scale(-1, 1);
              break;
            case 8:
              // 90° rotate left
              ctx.rotate(-0.5 * Math.PI);
              ctx.translate(-canvas.width, 0);
              break;
          }

          // This is a bugfix for iOS' scaling bug.
          drawImageIOSFix(ctx, img, resizeInfo.srcX != null ? resizeInfo.srcX : 0, resizeInfo.srcY != null ? resizeInfo.srcY : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, resizeInfo.trgX != null ? resizeInfo.trgX : 0, resizeInfo.trgY != null ? resizeInfo.trgY : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);

          var thumbnail = canvas.toDataURL("image/png");

          if (callback != null) {
            return callback(thumbnail, canvas);
          }
        });
      };

      if (callback != null) {
        img.onerror = callback;
      }

      return img.src = file.dataURL;
    }

    // Goes through the queue and processes files if there aren't too many already.

  }, {
    key: "processQueue",
    value: function processQueue() {
      var parallelUploads = this.options.parallelUploads;

      var processingLength = this.getUploadingFiles().length;
      var i = processingLength;

      // There are already at least as many files uploading than should be
      if (processingLength >= parallelUploads) {
        return;
      }

      var queuedFiles = this.getQueuedFiles();

      if (!(queuedFiles.length > 0)) {
        return;
      }

      if (this.options.uploadMultiple) {
        // The files should be uploaded in one request
        return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));
      } else {
        while (i < parallelUploads) {
          if (!queuedFiles.length) {
            return;
          } // Nothing left to process
          this.processFile(queuedFiles.shift());
          i++;
        }
      }
    }

    // Wrapper for `processFiles`

  }, {
    key: "processFile",
    value: function processFile(file) {
      return this.processFiles([file]);
    }

    // Loads the file, then calls finishedLoading()

  }, {
    key: "processFiles",
    value: function processFiles(files) {
      for (var _iterator19 = files, _isArray19 = true, _i20 = 0, _iterator19 = _isArray19 ? _iterator19 : _iterator19[Symbol.iterator]();;) {
        var _ref18;

        if (_isArray19) {
          if (_i20 >= _iterator19.length) break;
          _ref18 = _iterator19[_i20++];
        } else {
          _i20 = _iterator19.next();
          if (_i20.done) break;
          _ref18 = _i20.value;
        }

        var file = _ref18;

        file.processing = true; // Backwards compatibility
        file.status = Dropzone.UPLOADING;

        this.emit("processing", file);
      }

      if (this.options.uploadMultiple) {
        this.emit("processingmultiple", files);
      }

      return this.uploadFiles(files);
    }
  }, {
    key: "_getFilesWithXhr",
    value: function _getFilesWithXhr(xhr) {
      var files = void 0;
      return files = this.files.filter(function (file) {
        return file.xhr === xhr;
      }).map(function (file) {
        return file;
      });
    }

    // Cancels the file upload and sets the status to CANCELED
    // **if** the file is actually being uploaded.
    // If it's still in the queue, the file is being removed from it and the status
    // set to CANCELED.

  }, {
    key: "cancelUpload",
    value: function cancelUpload(file) {
      if (file.status === Dropzone.UPLOADING) {
        var groupedFiles = this._getFilesWithXhr(file.xhr);
        for (var _iterator20 = groupedFiles, _isArray20 = true, _i21 = 0, _iterator20 = _isArray20 ? _iterator20 : _iterator20[Symbol.iterator]();;) {
          var _ref19;

          if (_isArray20) {
            if (_i21 >= _iterator20.length) break;
            _ref19 = _iterator20[_i21++];
          } else {
            _i21 = _iterator20.next();
            if (_i21.done) break;
            _ref19 = _i21.value;
          }

          var groupedFile = _ref19;

          groupedFile.status = Dropzone.CANCELED;
        }
        if (typeof file.xhr !== 'undefined') {
          file.xhr.abort();
        }
        for (var _iterator21 = groupedFiles, _isArray21 = true, _i22 = 0, _iterator21 = _isArray21 ? _iterator21 : _iterator21[Symbol.iterator]();;) {
          var _ref20;

          if (_isArray21) {
            if (_i22 >= _iterator21.length) break;
            _ref20 = _iterator21[_i22++];
          } else {
            _i22 = _iterator21.next();
            if (_i22.done) break;
            _ref20 = _i22.value;
          }

          var _groupedFile = _ref20;

          this.emit("canceled", _groupedFile);
        }
        if (this.options.uploadMultiple) {
          this.emit("canceledmultiple", groupedFiles);
        }
      } else if (file.status === Dropzone.ADDED || file.status === Dropzone.QUEUED) {
        file.status = Dropzone.CANCELED;
        this.emit("canceled", file);
        if (this.options.uploadMultiple) {
          this.emit("canceledmultiple", [file]);
        }
      }

      if (this.options.autoProcessQueue) {
        return this.processQueue();
      }
    }
  }, {
    key: "resolveOption",
    value: function resolveOption(option) {
      if (typeof option === 'function') {
        for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }

        return option.apply(this, args);
      }
      return option;
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(file) {
      return this.uploadFiles([file]);
    }
  }, {
    key: "uploadFiles",
    value: function uploadFiles(files) {
      var _this14 = this;

      this._transformFiles(files, function (transformedFiles) {
        if (files[0].upload.chunked) {
          // This file should be sent in chunks!

          // If the chunking option is set, we **know** that there can only be **one** file, since
          // uploadMultiple is not allowed with this option.
          var file = files[0];
          var transformedFile = transformedFiles[0];
          var startedChunkCount = 0;

          file.upload.chunks = [];

          var handleNextChunk = function handleNextChunk() {
            var chunkIndex = 0;

            // Find the next item in file.upload.chunks that is not defined yet.
            while (file.upload.chunks[chunkIndex] !== undefined) {
              chunkIndex++;
            }

            // This means, that all chunks have already been started.
            if (chunkIndex >= file.upload.totalChunkCount) return;

            startedChunkCount++;

            var start = chunkIndex * _this14.options.chunkSize;
            var end = Math.min(start + _this14.options.chunkSize, file.size);

            var dataBlock = {
              name: _this14._getParamName(0),
              data: transformedFile.webkitSlice ? transformedFile.webkitSlice(start, end) : transformedFile.slice(start, end),
              filename: file.upload.filename,
              chunkIndex: chunkIndex
            };

            file.upload.chunks[chunkIndex] = {
              file: file,
              index: chunkIndex,
              dataBlock: dataBlock, // In case we want to retry.
              status: Dropzone.UPLOADING,
              progress: 0,
              retries: 0 // The number of times this block has been retried.
            };

            _this14._uploadData(files, [dataBlock]);
          };

          file.upload.finishedChunkUpload = function (chunk) {
            var allFinished = true;
            chunk.status = Dropzone.SUCCESS;

            // Clear the data from the chunk
            chunk.dataBlock = null;

            for (var i = 0; i < file.upload.totalChunkCount; i++) {
              if (file.upload.chunks[i] === undefined) {
                return handleNextChunk();
              }
              if (file.upload.chunks[i].status !== Dropzone.SUCCESS) {
                allFinished = false;
              }
            }

            if (allFinished) {
              _this14.options.chunksUploaded(file, function () {
                _this14._finished(files, '', null);
              });
            }
          };

          if (_this14.options.parallelChunkUploads) {
            for (var i = 0; i < file.upload.totalChunkCount; i++) {
              handleNextChunk();
            }
          } else {
            handleNextChunk();
          }
        } else {
          var dataBlocks = [];
          for (var _i23 = 0; _i23 < files.length; _i23++) {
            dataBlocks[_i23] = {
              name: _this14._getParamName(_i23),
              data: transformedFiles[_i23],
              filename: files[_i23].upload.filename
            };
          }
          _this14._uploadData(files, dataBlocks);
        }
      });
    }

    /// Returns the right chunk for given file and xhr

  }, {
    key: "_getChunk",
    value: function _getChunk(file, xhr) {
      for (var i = 0; i < file.upload.totalChunkCount; i++) {
        if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].xhr === xhr) {
          return file.upload.chunks[i];
        }
      }
    }

    // This function actually uploads the file(s) to the server.
    // If dataBlocks contains the actual data to upload (meaning, that this could either be transformed
    // files, or individual chunks for chunked upload).

  }, {
    key: "_uploadData",
    value: function _uploadData(files, dataBlocks) {
      var _this15 = this;

      var xhr = new XMLHttpRequest();

      // Put the xhr object in the file objects to be able to reference it later.
      for (var _iterator22 = files, _isArray22 = true, _i24 = 0, _iterator22 = _isArray22 ? _iterator22 : _iterator22[Symbol.iterator]();;) {
        var _ref21;

        if (_isArray22) {
          if (_i24 >= _iterator22.length) break;
          _ref21 = _iterator22[_i24++];
        } else {
          _i24 = _iterator22.next();
          if (_i24.done) break;
          _ref21 = _i24.value;
        }

        var file = _ref21;

        file.xhr = xhr;
      }
      if (files[0].upload.chunked) {
        // Put the xhr object in the right chunk object, so it can be associated later, and found with _getChunk
        files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr = xhr;
      }

      var method = this.resolveOption(this.options.method, files);
      var url = this.resolveOption(this.options.url, files);
      xhr.open(method, url, true);

      // Setting the timeout after open because of IE11 issue: https://gitlab.com/meno/dropzone/issues/8
      xhr.timeout = this.resolveOption(this.options.timeout, files);

      // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179
      xhr.withCredentials = !!this.options.withCredentials;

      xhr.onload = function (e) {
        _this15._finishedUploading(files, xhr, e);
      };

      xhr.onerror = function () {
        _this15._handleUploadError(files, xhr);
      };

      // Some browsers do not have the .upload property
      var progressObj = xhr.upload != null ? xhr.upload : xhr;
      progressObj.onprogress = function (e) {
        return _this15._updateFilesUploadProgress(files, xhr, e);
      };

      var headers = {
        "Accept": "application/json",
        "Cache-Control": "no-cache",
        "X-Requested-With": "XMLHttpRequest"
      };

      if (this.options.headers) {
        Dropzone.extend(headers, this.options.headers);
      }

      for (var headerName in headers) {
        var headerValue = headers[headerName];
        if (headerValue) {
          xhr.setRequestHeader(headerName, headerValue);
        }
      }

      var formData = new FormData();

      // Adding all @options parameters
      if (this.options.params) {
        var additionalParams = this.options.params;
        if (typeof additionalParams === 'function') {
          additionalParams = additionalParams.call(this, files, xhr, files[0].upload.chunked ? this._getChunk(files[0], xhr) : null);
        }

        for (var key in additionalParams) {
          var value = additionalParams[key];
          formData.append(key, value);
        }
      }

      // Let the user add additional data if necessary
      for (var _iterator23 = files, _isArray23 = true, _i25 = 0, _iterator23 = _isArray23 ? _iterator23 : _iterator23[Symbol.iterator]();;) {
        var _ref22;

        if (_isArray23) {
          if (_i25 >= _iterator23.length) break;
          _ref22 = _iterator23[_i25++];
        } else {
          _i25 = _iterator23.next();
          if (_i25.done) break;
          _ref22 = _i25.value;
        }

        var _file = _ref22;

        this.emit("sending", _file, xhr, formData);
      }
      if (this.options.uploadMultiple) {
        this.emit("sendingmultiple", files, xhr, formData);
      }

      this._addFormElementData(formData);

      // Finally add the files
      // Has to be last because some servers (eg: S3) expect the file to be the last parameter
      for (var i = 0; i < dataBlocks.length; i++) {
        var dataBlock = dataBlocks[i];
        formData.append(dataBlock.name, dataBlock.data, dataBlock.filename);
      }

      this.submitRequest(xhr, formData, files);
    }

    // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.

  }, {
    key: "_transformFiles",
    value: function _transformFiles(files, done) {
      var _this16 = this;

      var transformedFiles = [];
      // Clumsy way of handling asynchronous calls, until I get to add a proper Future library.
      var doneCounter = 0;

      var _loop = function _loop(i) {
        _this16.options.transformFile.call(_this16, files[i], function (transformedFile) {
          transformedFiles[i] = transformedFile;
          if (++doneCounter === files.length) {
            done(transformedFiles);
          }
        });
      };

      for (var i = 0; i < files.length; i++) {
        _loop(i);
      }
    }

    // Takes care of adding other input elements of the form to the AJAX request

  }, {
    key: "_addFormElementData",
    value: function _addFormElementData(formData) {
      // Take care of other input elements
      if (this.element.tagName === "FORM") {
        for (var _iterator24 = this.element.querySelectorAll("input, textarea, select, button"), _isArray24 = true, _i26 = 0, _iterator24 = _isArray24 ? _iterator24 : _iterator24[Symbol.iterator]();;) {
          var _ref23;

          if (_isArray24) {
            if (_i26 >= _iterator24.length) break;
            _ref23 = _iterator24[_i26++];
          } else {
            _i26 = _iterator24.next();
            if (_i26.done) break;
            _ref23 = _i26.value;
          }

          var input = _ref23;

          var inputName = input.getAttribute("name");
          var inputType = input.getAttribute("type");
          if (inputType) inputType = inputType.toLowerCase();

          // If the input doesn't have a name, we can't use it.
          if (typeof inputName === 'undefined' || inputName === null) continue;

          if (input.tagName === "SELECT" && input.hasAttribute("multiple")) {
            // Possibly multiple values
            for (var _iterator25 = input.options, _isArray25 = true, _i27 = 0, _iterator25 = _isArray25 ? _iterator25 : _iterator25[Symbol.iterator]();;) {
              var _ref24;

              if (_isArray25) {
                if (_i27 >= _iterator25.length) break;
                _ref24 = _iterator25[_i27++];
              } else {
                _i27 = _iterator25.next();
                if (_i27.done) break;
                _ref24 = _i27.value;
              }

              var option = _ref24;

              if (option.selected) {
                formData.append(inputName, option.value);
              }
            }
          } else if (!inputType || inputType !== "checkbox" && inputType !== "radio" || input.checked) {
            formData.append(inputName, input.value);
          }
        }
      }
    }

    // Invoked when there is new progress information about given files.
    // If e is not provided, it is assumed that the upload is finished.

  }, {
    key: "_updateFilesUploadProgress",
    value: function _updateFilesUploadProgress(files, xhr, e) {
      var progress = void 0;
      if (typeof e !== 'undefined') {
        progress = 100 * e.loaded / e.total;

        if (files[0].upload.chunked) {
          var file = files[0];
          // Since this is a chunked upload, we need to update the appropriate chunk progress.
          var chunk = this._getChunk(file, xhr);
          chunk.progress = progress;
          chunk.total = e.total;
          chunk.bytesSent = e.loaded;
          var fileProgress = 0,
              fileTotal = void 0,
              fileBytesSent = void 0;
          file.upload.progress = 0;
          file.upload.total = 0;
          file.upload.bytesSent = 0;
          for (var i = 0; i < file.upload.totalChunkCount; i++) {
            if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].progress !== undefined) {
              file.upload.progress += file.upload.chunks[i].progress;
              file.upload.total += file.upload.chunks[i].total;
              file.upload.bytesSent += file.upload.chunks[i].bytesSent;
            }
          }
          file.upload.progress = file.upload.progress / file.upload.totalChunkCount;
        } else {
          for (var _iterator26 = files, _isArray26 = true, _i28 = 0, _iterator26 = _isArray26 ? _iterator26 : _iterator26[Symbol.iterator]();;) {
            var _ref25;

            if (_isArray26) {
              if (_i28 >= _iterator26.length) break;
              _ref25 = _iterator26[_i28++];
            } else {
              _i28 = _iterator26.next();
              if (_i28.done) break;
              _ref25 = _i28.value;
            }

            var _file2 = _ref25;

            _file2.upload.progress = progress;
            _file2.upload.total = e.total;
            _file2.upload.bytesSent = e.loaded;
          }
        }
        for (var _iterator27 = files, _isArray27 = true, _i29 = 0, _iterator27 = _isArray27 ? _iterator27 : _iterator27[Symbol.iterator]();;) {
          var _ref26;

          if (_isArray27) {
            if (_i29 >= _iterator27.length) break;
            _ref26 = _iterator27[_i29++];
          } else {
            _i29 = _iterator27.next();
            if (_i29.done) break;
            _ref26 = _i29.value;
          }

          var _file3 = _ref26;

          this.emit("uploadprogress", _file3, _file3.upload.progress, _file3.upload.bytesSent);
        }
      } else {
        // Called when the file finished uploading

        var allFilesFinished = true;

        progress = 100;

        for (var _iterator28 = files, _isArray28 = true, _i30 = 0, _iterator28 = _isArray28 ? _iterator28 : _iterator28[Symbol.iterator]();;) {
          var _ref27;

          if (_isArray28) {
            if (_i30 >= _iterator28.length) break;
            _ref27 = _iterator28[_i30++];
          } else {
            _i30 = _iterator28.next();
            if (_i30.done) break;
            _ref27 = _i30.value;
          }

          var _file4 = _ref27;

          if (_file4.upload.progress !== 100 || _file4.upload.bytesSent !== _file4.upload.total) {
            allFilesFinished = false;
          }
          _file4.upload.progress = progress;
          _file4.upload.bytesSent = _file4.upload.total;
        }

        // Nothing to do, all files already at 100%
        if (allFilesFinished) {
          return;
        }

        for (var _iterator29 = files, _isArray29 = true, _i31 = 0, _iterator29 = _isArray29 ? _iterator29 : _iterator29[Symbol.iterator]();;) {
          var _ref28;

          if (_isArray29) {
            if (_i31 >= _iterator29.length) break;
            _ref28 = _iterator29[_i31++];
          } else {
            _i31 = _iterator29.next();
            if (_i31.done) break;
            _ref28 = _i31.value;
          }

          var _file5 = _ref28;

          this.emit("uploadprogress", _file5, progress, _file5.upload.bytesSent);
        }
      }
    }
  }, {
    key: "_finishedUploading",
    value: function _finishedUploading(files, xhr, e) {
      var response = void 0;

      if (files[0].status === Dropzone.CANCELED) {
        return;
      }

      if (xhr.readyState !== 4) {
        return;
      }

      if (xhr.responseType !== 'arraybuffer' && xhr.responseType !== 'blob') {
        response = xhr.responseText;

        if (xhr.getResponseHeader("content-type") && ~xhr.getResponseHeader("content-type").indexOf("application/json")) {
          try {
            response = JSON.parse(response);
          } catch (error) {
            e = error;
            response = "Invalid JSON response from server.";
          }
        }
      }

      this._updateFilesUploadProgress(files);

      if (!(200 <= xhr.status && xhr.status < 300)) {
        this._handleUploadError(files, xhr, response);
      } else {
        if (files[0].upload.chunked) {
          files[0].upload.finishedChunkUpload(this._getChunk(files[0], xhr));
        } else {
          this._finished(files, response, e);
        }
      }
    }
  }, {
    key: "_handleUploadError",
    value: function _handleUploadError(files, xhr, response) {
      if (files[0].status === Dropzone.CANCELED) {
        return;
      }

      if (files[0].upload.chunked && this.options.retryChunks) {
        var chunk = this._getChunk(files[0], xhr);
        if (chunk.retries++ < this.options.retryChunksLimit) {
          this._uploadData(files, [chunk.dataBlock]);
          return;
        } else {
          console.warn('Retried this chunk too often. Giving up.');
        }
      }

      for (var _iterator30 = files, _isArray30 = true, _i32 = 0, _iterator30 = _isArray30 ? _iterator30 : _iterator30[Symbol.iterator]();;) {
        var _ref29;

        if (_isArray30) {
          if (_i32 >= _iterator30.length) break;
          _ref29 = _iterator30[_i32++];
        } else {
          _i32 = _iterator30.next();
          if (_i32.done) break;
          _ref29 = _i32.value;
        }

        var file = _ref29;

        this._errorProcessing(files, response || this.options.dictResponseError.replace("{{statusCode}}", xhr.status), xhr);
      }
    }
  }, {
    key: "submitRequest",
    value: function submitRequest(xhr, formData, files) {
      xhr.send(formData);
    }

    // Called internally when processing is finished.
    // Individual callbacks have to be called in the appropriate sections.

  }, {
    key: "_finished",
    value: function _finished(files, responseText, e) {
      for (var _iterator31 = files, _isArray31 = true, _i33 = 0, _iterator31 = _isArray31 ? _iterator31 : _iterator31[Symbol.iterator]();;) {
        var _ref30;

        if (_isArray31) {
          if (_i33 >= _iterator31.length) break;
          _ref30 = _iterator31[_i33++];
        } else {
          _i33 = _iterator31.next();
          if (_i33.done) break;
          _ref30 = _i33.value;
        }

        var file = _ref30;

        file.status = Dropzone.SUCCESS;
        this.emit("success", file, responseText, e);
        this.emit("complete", file);
      }
      if (this.options.uploadMultiple) {
        this.emit("successmultiple", files, responseText, e);
        this.emit("completemultiple", files);
      }

      if (this.options.autoProcessQueue) {
        return this.processQueue();
      }
    }

    // Called internally when processing is finished.
    // Individual callbacks have to be called in the appropriate sections.

  }, {
    key: "_errorProcessing",
    value: function _errorProcessing(files, message, xhr) {
      for (var _iterator32 = files, _isArray32 = true, _i34 = 0, _iterator32 = _isArray32 ? _iterator32 : _iterator32[Symbol.iterator]();;) {
        var _ref31;

        if (_isArray32) {
          if (_i34 >= _iterator32.length) break;
          _ref31 = _iterator32[_i34++];
        } else {
          _i34 = _iterator32.next();
          if (_i34.done) break;
          _ref31 = _i34.value;
        }

        var file = _ref31;

        file.status = Dropzone.ERROR;
        this.emit("error", file, message, xhr);
        this.emit("complete", file);
      }
      if (this.options.uploadMultiple) {
        this.emit("errormultiple", files, message, xhr);
        this.emit("completemultiple", files);
      }

      if (this.options.autoProcessQueue) {
        return this.processQueue();
      }
    }
  }], [{
    key: "uuidv4",
    value: function uuidv4() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0,
            v = c === 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
      });
    }
  }]);

  return Dropzone;
}(Emitter);

Dropzone.initClass();

Dropzone.version = "5.4.0";

// This is a map of options for your different dropzones. Add configurations
// to this object for your different dropzone elemens.
//
// Example:
//
//     Dropzone.options.myDropzoneElementId = { maxFilesize: 1 };
//
// To disable autoDiscover for a specific element, you can set `false` as an option:
//
//     Dropzone.options.myDisabledElementId = false;
//
// And in html:
//
//     <form action="/upload" id="my-dropzone-element-id" class="dropzone"></form>
Dropzone.options = {};

// Returns the options for an element or undefined if none available.
Dropzone.optionsForElement = function (element) {
  // Get the `Dropzone.options.elementId` for this element if it exists
  if (element.getAttribute("id")) {
    return Dropzone.options[camelize(element.getAttribute("id"))];
  } else {
    return undefined;
  }
};

// Holds a list of all dropzone instances
Dropzone.instances = [];

// Returns the dropzone for given element if any
Dropzone.forElement = function (element) {
  if (typeof element === "string") {
    element = document.querySelector(element);
  }
  if ((element != null ? element.dropzone : undefined) == null) {
    throw new Error("No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");
  }
  return element.dropzone;
};

// Set to false if you don't want Dropzone to automatically find and attach to .dropzone elements.
Dropzone.autoDiscover = true;

// Looks for all .dropzone elements and creates a dropzone for them
Dropzone.discover = function () {
  var dropzones = void 0;
  if (document.querySelectorAll) {
    dropzones = document.querySelectorAll(".dropzone");
  } else {
    dropzones = [];
    // IE :(
    var checkElements = function checkElements(elements) {
      return function () {
        var result = [];
        for (var _iterator33 = elements, _isArray33 = true, _i35 = 0, _iterator33 = _isArray33 ? _iterator33 : _iterator33[Symbol.iterator]();;) {
          var _ref32;

          if (_isArray33) {
            if (_i35 >= _iterator33.length) break;
            _ref32 = _iterator33[_i35++];
          } else {
            _i35 = _iterator33.next();
            if (_i35.done) break;
            _ref32 = _i35.value;
          }

          var el = _ref32;

          if (/(^| )dropzone($| )/.test(el.className)) {
            result.push(dropzones.push(el));
          } else {
            result.push(undefined);
          }
        }
        return result;
      }();
    };
    checkElements(document.getElementsByTagName("div"));
    checkElements(document.getElementsByTagName("form"));
  }

  return function () {
    var result = [];
    for (var _iterator34 = dropzones, _isArray34 = true, _i36 = 0, _iterator34 = _isArray34 ? _iterator34 : _iterator34[Symbol.iterator]();;) {
      var _ref33;

      if (_isArray34) {
        if (_i36 >= _iterator34.length) break;
        _ref33 = _iterator34[_i36++];
      } else {
        _i36 = _iterator34.next();
        if (_i36.done) break;
        _ref33 = _i36.value;
      }

      var dropzone = _ref33;

      // Create a dropzone unless auto discover has been disabled for specific element
      if (Dropzone.optionsForElement(dropzone) !== false) {
        result.push(new Dropzone(dropzone));
      } else {
        result.push(undefined);
      }
    }
    return result;
  }();
};

// Since the whole Drag'n'Drop API is pretty new, some browsers implement it,
// but not correctly.
// So I created a blacklist of userAgents. Yes, yes. Browser sniffing, I know.
// But what to do when browsers *theoretically* support an API, but crash
// when using it.
//
// This is a list of regular expressions tested against navigator.userAgent
//
// ** It should only be used on browser that *do* support the API, but
// incorrectly **
//
Dropzone.blacklistedBrowsers = [
// The mac os and windows phone version of opera 12 seems to have a problem with the File drag'n'drop API.
/opera.*(Macintosh|Windows Phone).*version\/12/i];

// Checks if the browser is supported
Dropzone.isBrowserSupported = function () {
  var capableBrowser = true;

  if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {
    if (!("classList" in document.createElement("a"))) {
      capableBrowser = false;
    } else {
      // The browser supports the API, but may be blacklisted.
      for (var _iterator35 = Dropzone.blacklistedBrowsers, _isArray35 = true, _i37 = 0, _iterator35 = _isArray35 ? _iterator35 : _iterator35[Symbol.iterator]();;) {
        var _ref34;

        if (_isArray35) {
          if (_i37 >= _iterator35.length) break;
          _ref34 = _iterator35[_i37++];
        } else {
          _i37 = _iterator35.next();
          if (_i37.done) break;
          _ref34 = _i37.value;
        }

        var regex = _ref34;

        if (regex.test(navigator.userAgent)) {
          capableBrowser = false;
          continue;
        }
      }
    }
  } else {
    capableBrowser = false;
  }

  return capableBrowser;
};

Dropzone.dataURItoBlob = function (dataURI) {
  // convert base64 to raw binary data held in a string
  // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
  var byteString = atob(dataURI.split(',')[1]);

  // separate out the mime component
  var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

  // write the bytes of the string to an ArrayBuffer
  var ab = new ArrayBuffer(byteString.length);
  var ia = new Uint8Array(ab);
  for (var i = 0, end = byteString.length, asc = 0 <= end; asc ? i <= end : i >= end; asc ? i++ : i--) {
    ia[i] = byteString.charCodeAt(i);
  }

  // write the ArrayBuffer to a blob
  return new Blob([ab], { type: mimeString });
};

// Returns an array without the rejected item
var without = function without(list, rejectedItem) {
  return list.filter(function (item) {
    return item !== rejectedItem;
  }).map(function (item) {
    return item;
  });
};

// abc-def_ghi -> abcDefGhi
var camelize = function camelize(str) {
  return str.replace(/[\-_](\w)/g, function (match) {
    return match.charAt(1).toUpperCase();
  });
};

// Creates an element from string
Dropzone.createElement = function (string) {
  var div = document.createElement("div");
  div.innerHTML = string;
  return div.childNodes[0];
};

// Tests if given element is inside (or simply is) the container
Dropzone.elementInside = function (element, container) {
  if (element === container) {
    return true;
  } // Coffeescript doesn't support do/while loops
  while (element = element.parentNode) {
    if (element === container) {
      return true;
    }
  }
  return false;
};

Dropzone.getElement = function (el, name) {
  var element = void 0;
  if (typeof el === "string") {
    element = document.querySelector(el);
  } else if (el.nodeType != null) {
    element = el;
  }
  if (element == null) {
    throw new Error("Invalid `" + name + "` option provided. Please provide a CSS selector or a plain HTML element.");
  }
  return element;
};

Dropzone.getElements = function (els, name) {
  var el = void 0,
      elements = void 0;
  if (els instanceof Array) {
    elements = [];
    try {
      for (var _iterator36 = els, _isArray36 = true, _i38 = 0, _iterator36 = _isArray36 ? _iterator36 : _iterator36[Symbol.iterator]();;) {
        if (_isArray36) {
          if (_i38 >= _iterator36.length) break;
          el = _iterator36[_i38++];
        } else {
          _i38 = _iterator36.next();
          if (_i38.done) break;
          el = _i38.value;
        }

        elements.push(this.getElement(el, name));
      }
    } catch (e) {
      elements = null;
    }
  } else if (typeof els === "string") {
    elements = [];
    for (var _iterator37 = document.querySelectorAll(els), _isArray37 = true, _i39 = 0, _iterator37 = _isArray37 ? _iterator37 : _iterator37[Symbol.iterator]();;) {
      if (_isArray37) {
        if (_i39 >= _iterator37.length) break;
        el = _iterator37[_i39++];
      } else {
        _i39 = _iterator37.next();
        if (_i39.done) break;
        el = _i39.value;
      }

      elements.push(el);
    }
  } else if (els.nodeType != null) {
    elements = [els];
  }

  if (elements == null || !elements.length) {
    throw new Error("Invalid `" + name + "` option provided. Please provide a CSS selector, a plain HTML element or a list of those.");
  }

  return elements;
};

// Asks the user the question and calls accepted or rejected accordingly
//
// The default implementation just uses `window.confirm` and then calls the
// appropriate callback.
Dropzone.confirm = function (question, accepted, rejected) {
  if (window.confirm(question)) {
    return accepted();
  } else if (rejected != null) {
    return rejected();
  }
};

// Validates the mime type like this:
//
// https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept
Dropzone.isValidFile = function (file, acceptedFiles) {
  if (!acceptedFiles) {
    return true;
  } // If there are no accepted mime types, it's OK
  acceptedFiles = acceptedFiles.split(",");

  var mimeType = file.type;
  var baseMimeType = mimeType.replace(/\/.*$/, "");

  for (var _iterator38 = acceptedFiles, _isArray38 = true, _i40 = 0, _iterator38 = _isArray38 ? _iterator38 : _iterator38[Symbol.iterator]();;) {
    var _ref35;

    if (_isArray38) {
      if (_i40 >= _iterator38.length) break;
      _ref35 = _iterator38[_i40++];
    } else {
      _i40 = _iterator38.next();
      if (_i40.done) break;
      _ref35 = _i40.value;
    }

    var validType = _ref35;

    validType = validType.trim();
    if (validType.charAt(0) === ".") {
      if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) {
        return true;
      }
    } else if (/\/\*$/.test(validType)) {
      // This is something like a image/* mime type
      if (baseMimeType === validType.replace(/\/.*$/, "")) {
        return true;
      }
    } else {
      if (mimeType === validType) {
        return true;
      }
    }
  }

  return false;
};

// Augment jQuery
if (typeof jQuery !== 'undefined' && jQuery !== null) {
  jQuery.fn.dropzone = function (options) {
    return this.each(function () {
      return new Dropzone(this, options);
    });
  };
}

if (typeof module !== 'undefined' && module !== null) {
  module.exports = Dropzone;
} else {
  window.Dropzone = Dropzone;
}

// Dropzone file status codes
Dropzone.ADDED = "added";

Dropzone.QUEUED = "queued";
// For backwards compatibility. Now, if a file is accepted, it's either queued
// or uploading.
Dropzone.ACCEPTED = Dropzone.QUEUED;

Dropzone.UPLOADING = "uploading";
Dropzone.PROCESSING = Dropzone.UPLOADING; // alias

Dropzone.CANCELED = "canceled";
Dropzone.ERROR = "error";
Dropzone.SUCCESS = "success";

/*

 Bugfix for iOS 6 and 7
 Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios
 based on the work of https://github.com/stomita/ios-imagefile-megapixel

 */

// Detecting vertical squash in loaded image.
// Fixes a bug which squash image vertically while drawing into canvas for some images.
// This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel
var detectVerticalSquash = function detectVerticalSquash(img) {
  var iw = img.naturalWidth;
  var ih = img.naturalHeight;
  var canvas = document.createElement("canvas");
  canvas.width = 1;
  canvas.height = ih;
  var ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  var _ctx$getImageData = ctx.getImageData(1, 0, 1, ih),
      data = _ctx$getImageData.data;

  // search image edge pixel position in case it is squashed vertically.


  var sy = 0;
  var ey = ih;
  var py = ih;
  while (py > sy) {
    var alpha = data[(py - 1) * 4 + 3];

    if (alpha === 0) {
      ey = py;
    } else {
      sy = py;
    }

    py = ey + sy >> 1;
  }
  var ratio = py / ih;

  if (ratio === 0) {
    return 1;
  } else {
    return ratio;
  }
};

// A replacement for context.drawImage
// (args are for source and destination).
var drawImageIOSFix = function drawImageIOSFix(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
  var vertSquashRatio = detectVerticalSquash(img);
  return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);
};

// Based on MinifyJpeg
// Source: http://www.perry.cz/files/ExifRestorer.js
// http://elicon.blog57.fc2.com/blog-entry-206.html

var ExifRestore = function () {
  function ExifRestore() {
    _classCallCheck(this, ExifRestore);
  }

  _createClass(ExifRestore, null, [{
    key: "initClass",
    value: function initClass() {
      this.KEY_STR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    }
  }, {
    key: "encode64",
    value: function encode64(input) {
      var output = '';
      var chr1 = undefined;
      var chr2 = undefined;
      var chr3 = '';
      var enc1 = undefined;
      var enc2 = undefined;
      var enc3 = undefined;
      var enc4 = '';
      var i = 0;
      while (true) {
        chr1 = input[i++];
        chr2 = input[i++];
        chr3 = input[i++];
        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = (chr2 & 15) << 2 | chr3 >> 6;
        enc4 = chr3 & 63;
        if (isNaN(chr2)) {
          enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
          enc4 = 64;
        }
        output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);
        chr1 = chr2 = chr3 = '';
        enc1 = enc2 = enc3 = enc4 = '';
        if (!(i < input.length)) {
          break;
        }
      }
      return output;
    }
  }, {
    key: "restore",
    value: function restore(origFileBase64, resizedFileBase64) {
      if (!origFileBase64.match('data:image/jpeg;base64,')) {
        return resizedFileBase64;
      }
      var rawImage = this.decode64(origFileBase64.replace('data:image/jpeg;base64,', ''));
      var segments = this.slice2Segments(rawImage);
      var image = this.exifManipulation(resizedFileBase64, segments);
      return "data:image/jpeg;base64," + this.encode64(image);
    }
  }, {
    key: "exifManipulation",
    value: function exifManipulation(resizedFileBase64, segments) {
      var exifArray = this.getExifArray(segments);
      var newImageArray = this.insertExif(resizedFileBase64, exifArray);
      var aBuffer = new Uint8Array(newImageArray);
      return aBuffer;
    }
  }, {
    key: "getExifArray",
    value: function getExifArray(segments) {
      var seg = undefined;
      var x = 0;
      while (x < segments.length) {
        seg = segments[x];
        if (seg[0] === 255 & seg[1] === 225) {
          return seg;
        }
        x++;
      }
      return [];
    }
  }, {
    key: "insertExif",
    value: function insertExif(resizedFileBase64, exifArray) {
      var imageData = resizedFileBase64.replace('data:image/jpeg;base64,', '');
      var buf = this.decode64(imageData);
      var separatePoint = buf.indexOf(255, 3);
      var mae = buf.slice(0, separatePoint);
      var ato = buf.slice(separatePoint);
      var array = mae;
      array = array.concat(exifArray);
      array = array.concat(ato);
      return array;
    }
  }, {
    key: "slice2Segments",
    value: function slice2Segments(rawImageArray) {
      var head = 0;
      var segments = [];
      while (true) {
        var length;
        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) {
          break;
        }
        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) {
          head += 2;
        } else {
          length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];
          var endPoint = head + length + 2;
          var seg = rawImageArray.slice(head, endPoint);
          segments.push(seg);
          head = endPoint;
        }
        if (head > rawImageArray.length) {
          break;
        }
      }
      return segments;
    }
  }, {
    key: "decode64",
    value: function decode64(input) {
      var output = '';
      var chr1 = undefined;
      var chr2 = undefined;
      var chr3 = '';
      var enc1 = undefined;
      var enc2 = undefined;
      var enc3 = undefined;
      var enc4 = '';
      var i = 0;
      var buf = [];
      // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
      var base64test = /[^A-Za-z0-9\+\/\=]/g;
      if (base64test.exec(input)) {
        console.warn('There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, \'+\', \'/\',and \'=\'\nExpect errors in decoding.');
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
      while (true) {
        enc1 = this.KEY_STR.indexOf(input.charAt(i++));
        enc2 = this.KEY_STR.indexOf(input.charAt(i++));
        enc3 = this.KEY_STR.indexOf(input.charAt(i++));
        enc4 = this.KEY_STR.indexOf(input.charAt(i++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        buf.push(chr1);
        if (enc3 !== 64) {
          buf.push(chr2);
        }
        if (enc4 !== 64) {
          buf.push(chr3);
        }
        chr1 = chr2 = chr3 = '';
        enc1 = enc2 = enc3 = enc4 = '';
        if (!(i < input.length)) {
          break;
        }
      }
      return buf;
    }
  }]);

  return ExifRestore;
}();

ExifRestore.initClass();

/*
 * contentloaded.js
 *
 * Author: Diego Perini (diego.perini at gmail.com)
 * Summary: cross-browser wrapper for DOMContentLoaded
 * Updated: 20101020
 * License: MIT
 * Version: 1.2
 *
 * URL:
 * http://javascript.nwbox.com/ContentLoaded/
 * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
 */

// @win window reference
// @fn function reference
var contentLoaded = function contentLoaded(win, fn) {
  var done = false;
  var top = true;
  var doc = win.document;
  var root = doc.documentElement;
  var add = doc.addEventListener ? "addEventListener" : "attachEvent";
  var rem = doc.addEventListener ? "removeEventListener" : "detachEvent";
  var pre = doc.addEventListener ? "" : "on";
  var init = function init(e) {
    if (e.type === "readystatechange" && doc.readyState !== "complete") {
      return;
    }
    (e.type === "load" ? win : doc)[rem](pre + e.type, init, false);
    if (!done && (done = true)) {
      return fn.call(win, e.type || e);
    }
  };

  var poll = function poll() {
    try {
      root.doScroll("left");
    } catch (e) {
      setTimeout(poll, 50);
      return;
    }
    return init("poll");
  };

  if (doc.readyState !== "complete") {
    if (doc.createEventObject && root.doScroll) {
      try {
        top = !win.frameElement;
      } catch (error) {}
      if (top) {
        poll();
      }
    }
    doc[add](pre + "DOMContentLoaded", init, false);
    doc[add](pre + "readystatechange", init, false);
    return win[add](pre + "load", init, false);
  }
};

// As a single function to be able to write tests.
Dropzone._autoDiscoverFunction = function () {
  if (Dropzone.autoDiscover) {
    return Dropzone.discover();
  }
};
contentLoaded(window, Dropzone._autoDiscoverFunction);

function __guard__(value, transform) {
  return typeof value !== 'undefined' && value !== null ? transform(value) : undefined;
}
function __guardMethod__(obj, methodName, transform) {
  if (typeof obj !== 'undefined' && obj !== null && typeof obj[methodName] === 'function') {
    return transform(obj, methodName);
  } else {
    return undefined;
  }
}

/*!
	Colorbox 1.6.4
	license: MIT
	http://www.jacklmoore.com/colorbox
*/
(function ($, document, window) {
	var
	// Default settings object.
	// See http://jacklmoore.com/colorbox for details.
	defaults = {
		// data sources
		html: false,
		photo: false,
		iframe: false,
		inline: false,

		// behavior and appearance
		transition: "elastic",
		speed: 300,
		fadeOut: 300,
		width: false,
		initialWidth: "600",
		innerWidth: false,
		maxWidth: false,
		height: false,
		initialHeight: "450",
		innerHeight: false,
		maxHeight: false,
		scalePhotos: true,
		scrolling: true,
		opacity: 0.9,
		preloading: true,
		className: false,
		overlayClose: true,
		escKey: true,
		arrowKey: true,
		top: false,
		bottom: false,
		left: false,
		right: false,
		fixed: false,
		data: undefined,
		closeButton: true,
		fastIframe: true,
		open: false,
		reposition: true,
		loop: true,
		slideshow: false,
		slideshowAuto: true,
		slideshowSpeed: 2500,
		slideshowStart: "start slideshow",
		slideshowStop: "stop slideshow",
		photoRegex: /\.(gif|png|jp(e|g|eg)|bmp|ico|webp|jxr|svg)((#|\?).*)?$/i,

		// alternate image paths for high-res displays
		retinaImage: false,
		retinaUrl: false,
		retinaSuffix: '@2x.$1',

		// internationalization
		current: "image {current} of {total}",
		previous: "previous",
		next: "next",
		close: "close",
		xhrError: "This content failed to load.",
		imgError: "This image failed to load.",

		// accessbility
		returnFocus: true,
		trapFocus: true,

		// callbacks
		onOpen: false,
		onLoad: false,
		onComplete: false,
		onCleanup: false,
		onClosed: false,

		rel: function() {
			return this.rel;
		},
		href: function() {
			// using this.href would give the absolute url, when the href may have been inteded as a selector (e.g. '#container')
			return $(this).attr('href');
		},
		title: function() {
			return this.title;
		},
		createImg: function() {
			var img = new Image();
			var attrs = $(this).data('cbox-img-attrs');

			if (typeof attrs === 'object') {
				$.each(attrs, function(key, val){
					img[key] = val;
				});
			}

			return img;
		},
		createIframe: function() {
			var iframe = document.createElement('iframe');
			var attrs = $(this).data('cbox-iframe-attrs');

			if (typeof attrs === 'object') {
				$.each(attrs, function(key, val){
					iframe[key] = val;
				});
			}

			if ('frameBorder' in iframe) {
				iframe.frameBorder = 0;
			}
			if ('allowTransparency' in iframe) {
				iframe.allowTransparency = "true";
			}
			iframe.name = (new Date()).getTime(); // give the iframe a unique name to prevent caching
			iframe.allowFullscreen = true;

			return iframe;
		}
	},

	// Abstracting the HTML and event identifiers for easy rebranding
	colorbox = 'colorbox',
	prefix = 'cbox',
	boxElement = prefix + 'Element',

	// Events
	event_open = prefix + '_open',
	event_load = prefix + '_load',
	event_complete = prefix + '_complete',
	event_cleanup = prefix + '_cleanup',
	event_closed = prefix + '_closed',
	event_purge = prefix + '_purge',

	// Cached jQuery Object Variables
	$overlay,
	$box,
	$wrap,
	$content,
	$topBorder,
	$leftBorder,
	$rightBorder,
	$bottomBorder,
	$related,
	$window,
	$loaded,
	$loadingBay,
	$loadingOverlay,
	$title,
	$current,
	$slideshow,
	$next,
	$prev,
	$close,
	$groupControls,
	$events = $('<a/>'), // $({}) would be prefered, but there is an issue with jQuery 1.4.2

	// Variables for cached values or use across multiple functions
	settings,
	interfaceHeight,
	interfaceWidth,
	loadedHeight,
	loadedWidth,
	index,
	photo,
	open,
	active,
	closing,
	loadingTimer,
	publicMethod,
	div = "div",
	requests = 0,
	previousCSS = {},
	init;

	// ****************
	// HELPER FUNCTIONS
	// ****************

	// Convenience function for creating new jQuery objects
	function $tag(tag, id, css) {
		var element = document.createElement(tag);

		if (id) {
			element.id = prefix + id;
		}

		if (css) {
			element.style.cssText = css;
		}

		return $(element);
	}

	// Get the window height using innerHeight when available to avoid an issue with iOS
	// http://bugs.jquery.com/ticket/6724
	function winheight() {
		return window.innerHeight ? window.innerHeight : $(window).height();
	}

	function Settings(element, options) {
		if (options !== Object(options)) {
			options = {};
		}

		this.cache = {};
		this.el = element;

		this.value = function(key) {
			var dataAttr;

			if (this.cache[key] === undefined) {
				dataAttr = $(this.el).attr('data-cbox-'+key);

				if (dataAttr !== undefined) {
					this.cache[key] = dataAttr;
				} else if (options[key] !== undefined) {
					this.cache[key] = options[key];
				} else if (defaults[key] !== undefined) {
					this.cache[key] = defaults[key];
				}
			}

			return this.cache[key];
		};

		this.get = function(key) {
			var value = this.value(key);
			return $.isFunction(value) ? value.call(this.el, this) : value;
		};
	}

	// Determine the next and previous members in a group.
	function getIndex(increment) {
		var
		max = $related.length,
		newIndex = (index + increment) % max;

		return (newIndex < 0) ? max + newIndex : newIndex;
	}

	// Convert '%' and 'px' values to integers
	function setSize(size, dimension) {
		return Math.round((/%/.test(size) ? ((dimension === 'x' ? $window.width() : winheight()) / 100) : 1) * parseInt(size, 10));
	}

	// Checks an href to see if it is a photo.
	// There is a force photo option (photo: true) for hrefs that cannot be matched by the regex.
	function isImage(settings, url) {
		return settings.get('photo') || settings.get('photoRegex').test(url);
	}

	function retinaUrl(settings, url) {
		return settings.get('retinaUrl') && window.devicePixelRatio > 1 ? url.replace(settings.get('photoRegex'), settings.get('retinaSuffix')) : url;
	}

	function trapFocus(e) {
		if ('contains' in $box[0] && !$box[0].contains(e.target) && e.target !== $overlay[0]) {
			e.stopPropagation();
			$box.focus();
		}
	}

	function setClass(str) {
		if (setClass.str !== str) {
			$box.add($overlay).removeClass(setClass.str).addClass(str);
			setClass.str = str;
		}
	}

	function getRelated(rel) {
		index = 0;

		if (rel && rel !== false && rel !== 'nofollow') {
			$related = $('.' + boxElement).filter(function () {
				var options = $.data(this, colorbox);
				var settings = new Settings(this, options);
				return (settings.get('rel') === rel);
			});
			index = $related.index(settings.el);

			// Check direct calls to Colorbox.
			if (index === -1) {
				$related = $related.add(settings.el);
				index = $related.length - 1;
			}
		} else {
			$related = $(settings.el);
		}
	}

	function trigger(event) {
		// for external use
		$(document).trigger(event);
		// for internal use
		$events.triggerHandler(event);
	}

	var slideshow = (function(){
		var active,
			className = prefix + "Slideshow_",
			click = "click." + prefix,
			timeOut;

		function clear () {
			clearTimeout(timeOut);
		}

		function set() {
			if (settings.get('loop') || $related[index + 1]) {
				clear();
				timeOut = setTimeout(publicMethod.next, settings.get('slideshowSpeed'));
			}
		}

		function start() {
			$slideshow
				.html(settings.get('slideshowStop'))
				.unbind(click)
				.one(click, stop);

			$events
				.bind(event_complete, set)
				.bind(event_load, clear);

			$box.removeClass(className + "off").addClass(className + "on");
		}

		function stop() {
			clear();

			$events
				.unbind(event_complete, set)
				.unbind(event_load, clear);

			$slideshow
				.html(settings.get('slideshowStart'))
				.unbind(click)
				.one(click, function () {
					publicMethod.next();
					start();
				});

			$box.removeClass(className + "on").addClass(className + "off");
		}

		function reset() {
			active = false;
			$slideshow.hide();
			clear();
			$events
				.unbind(event_complete, set)
				.unbind(event_load, clear);
			$box.removeClass(className + "off " + className + "on");
		}

		return function(){
			if (active) {
				if (!settings.get('slideshow')) {
					$events.unbind(event_cleanup, reset);
					reset();
				}
			} else {
				if (settings.get('slideshow') && $related[1]) {
					active = true;
					$events.one(event_cleanup, reset);
					if (settings.get('slideshowAuto')) {
						start();
					} else {
						stop();
					}
					$slideshow.show();
				}
			}
		};

	}());


	function launch(element) {
		var options;

		if (!closing) {

			options = $(element).data(colorbox);

			settings = new Settings(element, options);

			getRelated(settings.get('rel'));

			if (!open) {
				open = active = true; // Prevents the page-change action from queuing up if the visitor holds down the left or right keys.

				setClass(settings.get('className'));

				// Show colorbox so the sizes can be calculated in older versions of jQuery
				$box.css({visibility:'hidden', display:'block', opacity:''});

				$loaded = $tag(div, 'LoadedContent', 'width:0; height:0; overflow:hidden; visibility:hidden');
				$content.css({width:'', height:''}).append($loaded);

				// Cache values needed for size calculations
				interfaceHeight = $topBorder.height() + $bottomBorder.height() + $content.outerHeight(true) - $content.height();
				interfaceWidth = $leftBorder.width() + $rightBorder.width() + $content.outerWidth(true) - $content.width();
				loadedHeight = $loaded.outerHeight(true);
				loadedWidth = $loaded.outerWidth(true);

				// Opens inital empty Colorbox prior to content being loaded.
				var initialWidth = setSize(settings.get('initialWidth'), 'x');
				var initialHeight = setSize(settings.get('initialHeight'), 'y');
				var maxWidth = settings.get('maxWidth');
				var maxHeight = settings.get('maxHeight');

				settings.w = Math.max((maxWidth !== false ? Math.min(initialWidth, setSize(maxWidth, 'x')) : initialWidth) - loadedWidth - interfaceWidth, 0);
				settings.h = Math.max((maxHeight !== false ? Math.min(initialHeight, setSize(maxHeight, 'y')) : initialHeight) - loadedHeight - interfaceHeight, 0);

				$loaded.css({width:'', height:settings.h});
				publicMethod.position();

				trigger(event_open);
				settings.get('onOpen');

				$groupControls.add($title).hide();

				$box.focus();

				if (settings.get('trapFocus')) {
					// Confine focus to the modal
					// Uses event capturing that is not supported in IE8-
					if (document.addEventListener) {

						document.addEventListener('focus', trapFocus, true);

						$events.one(event_closed, function () {
							document.removeEventListener('focus', trapFocus, true);
						});
					}
				}

				// Return focus on closing
				if (settings.get('returnFocus')) {
					$events.one(event_closed, function () {
						$(settings.el).focus();
					});
				}
			}

			var opacity = parseFloat(settings.get('opacity'));
			$overlay.css({
				opacity: opacity === opacity ? opacity : '',
				cursor: settings.get('overlayClose') ? 'pointer' : '',
				visibility: 'visible'
			}).show();

			if (settings.get('closeButton')) {
				$close.html(settings.get('close')).appendTo($content);
			} else {
				$close.appendTo('<div/>'); // replace with .detach() when dropping jQuery < 1.4
			}

			load();
		}
	}

	// Colorbox's markup needs to be added to the DOM prior to being called
	// so that the browser will go ahead and load the CSS background images.
	function appendHTML() {
		if (!$box) {
			init = false;
			$window = $(window);
			$box = $tag(div).attr({
				id: colorbox,
				'class': $.support.opacity === false ? prefix + 'IE' : '', // class for optional IE8 & lower targeted CSS.
				role: 'dialog',
				tabindex: '-1'
			}).hide();
			$overlay = $tag(div, "Overlay").hide();
			$loadingOverlay = $([$tag(div, "LoadingOverlay")[0],$tag(div, "LoadingGraphic")[0]]);
			$wrap = $tag(div, "Wrapper");
			$content = $tag(div, "Content").append(
				$title = $tag(div, "Title"),
				$current = $tag(div, "Current"),
				$prev = $('<button type="button"/>').attr({id:prefix+'Previous'}),
				$next = $('<button type="button"/>').attr({id:prefix+'Next'}),
				$slideshow = $('<button type="button"/>').attr({id:prefix+'Slideshow'}),
				$loadingOverlay
			);

			$close = $('<button type="button"/>').attr({id:prefix+'Close'});

			$wrap.append( // The 3x3 Grid that makes up Colorbox
				$tag(div).append(
					$tag(div, "TopLeft"),
					$topBorder = $tag(div, "TopCenter"),
					$tag(div, "TopRight")
				),
				$tag(div, false, 'clear:left').append(
					$leftBorder = $tag(div, "MiddleLeft"),
					$content,
					$rightBorder = $tag(div, "MiddleRight")
				),
				$tag(div, false, 'clear:left').append(
					$tag(div, "BottomLeft"),
					$bottomBorder = $tag(div, "BottomCenter"),
					$tag(div, "BottomRight")
				)
			).find('div div').css({'float': 'left'});

			$loadingBay = $tag(div, false, 'position:absolute; width:9999px; visibility:hidden; display:none; max-width:none;');

			$groupControls = $next.add($prev).add($current).add($slideshow);
		}
		if (document.body && !$box.parent().length) {
			$(document.body).append($overlay, $box.append($wrap, $loadingBay));
		}
	}

	// Add Colorbox's event bindings
	function addBindings() {
		function clickHandler(e) {
			// ignore non-left-mouse-clicks and clicks modified with ctrl / command, shift, or alt.
			// See: http://jacklmoore.com/notes/click-events/
			if (!(e.which > 1 || e.shiftKey || e.altKey || e.metaKey || e.ctrlKey)) {
				e.preventDefault();
				launch(this);
			}
		}

		if ($box) {
			if (!init) {
				init = true;

				// Anonymous functions here keep the public method from being cached, thereby allowing them to be redefined on the fly.
				$next.click(function () {
					publicMethod.next();
				});
				$prev.click(function () {
					publicMethod.prev();
				});
				$close.click(function () {
					publicMethod.close();
				});
				$overlay.click(function () {
					if (settings.get('overlayClose')) {
						publicMethod.close();
					}
				});

				// Key Bindings
				$(document).bind('keydown.' + prefix, function (e) {
					var key = e.keyCode;
					if (open && settings.get('escKey') && key === 27) {
						e.preventDefault();
						publicMethod.close();
					}
					if (open && settings.get('arrowKey') && $related[1] && !e.altKey) {
						if (key === 37) {
							e.preventDefault();
							$prev.click();
						} else if (key === 39) {
							e.preventDefault();
							$next.click();
						}
					}
				});

				if ($.isFunction($.fn.on)) {
					// For jQuery 1.7+
					$(document).on('click.'+prefix, '.'+boxElement, clickHandler);
				} else {
					// For jQuery 1.3.x -> 1.6.x
					// This code is never reached in jQuery 1.9, so do not contact me about 'live' being removed.
					// This is not here for jQuery 1.9, it's here for legacy users.
					$('.'+boxElement).live('click.'+prefix, clickHandler);
				}
			}
			return true;
		}
		return false;
	}

	// Don't do anything if Colorbox already exists.
	if ($[colorbox]) {
		return;
	}

	// Append the HTML when the DOM loads
	$(appendHTML);


	// ****************
	// PUBLIC FUNCTIONS
	// Usage format: $.colorbox.close();
	// Usage from within an iframe: parent.jQuery.colorbox.close();
	// ****************

	publicMethod = $.fn[colorbox] = $[colorbox] = function (options, callback) {
		var settings;
		var $obj = this;

		options = options || {};

		if ($.isFunction($obj)) { // assume a call to $.colorbox
			$obj = $('<a/>');
			options.open = true;
		}

		if (!$obj[0]) { // colorbox being applied to empty collection
			return $obj;
		}

		appendHTML();

		if (addBindings()) {

			if (callback) {
				options.onComplete = callback;
			}

			$obj.each(function () {
				var old = $.data(this, colorbox) || {};
				$.data(this, colorbox, $.extend(old, options));
			}).addClass(boxElement);

			settings = new Settings($obj[0], options);

			if (settings.get('open')) {
				launch($obj[0]);
			}
		}

		return $obj;
	};

	publicMethod.position = function (speed, loadedCallback) {
		var
		css,
		top = 0,
		left = 0,
		offset = $box.offset(),
		scrollTop,
		scrollLeft;

		$window.unbind('resize.' + prefix);

		// remove the modal so that it doesn't influence the document width/height
		$box.css({top: -9e4, left: -9e4});

		scrollTop = $window.scrollTop();
		scrollLeft = $window.scrollLeft();

		if (settings.get('fixed')) {
			offset.top -= scrollTop;
			offset.left -= scrollLeft;
			$box.css({position: 'fixed'});
		} else {
			top = scrollTop;
			left = scrollLeft;
			$box.css({position: 'absolute'});
		}

		// keeps the top and left positions within the browser's viewport.
		if (settings.get('right') !== false) {
			left += Math.max($window.width() - settings.w - loadedWidth - interfaceWidth - setSize(settings.get('right'), 'x'), 0);
		} else if (settings.get('left') !== false) {
			left += setSize(settings.get('left'), 'x');
		} else {
			left += Math.round(Math.max($window.width() - settings.w - loadedWidth - interfaceWidth, 0) / 2);
		}

		if (settings.get('bottom') !== false) {
			top += Math.max(winheight() - settings.h - loadedHeight - interfaceHeight - setSize(settings.get('bottom'), 'y'), 0);
		} else if (settings.get('top') !== false) {
			top += setSize(settings.get('top'), 'y');
		} else {
			top += Math.round(Math.max(winheight() - settings.h - loadedHeight - interfaceHeight, 0) / 2);
		}

		$box.css({top: offset.top, left: offset.left, visibility:'visible'});

		// this gives the wrapper plenty of breathing room so it's floated contents can move around smoothly,
		// but it has to be shrank down around the size of div#colorbox when it's done.  If not,
		// it can invoke an obscure IE bug when using iframes.
		$wrap[0].style.width = $wrap[0].style.height = "9999px";

		function modalDimensions() {
			$topBorder[0].style.width = $bottomBorder[0].style.width = $content[0].style.width = (parseInt($box[0].style.width,10) - interfaceWidth)+'px';
			$content[0].style.height = $leftBorder[0].style.height = $rightBorder[0].style.height = (parseInt($box[0].style.height,10) - interfaceHeight)+'px';
		}

		css = {width: settings.w + loadedWidth + interfaceWidth, height: settings.h + loadedHeight + interfaceHeight, top: top, left: left};

		// setting the speed to 0 if the content hasn't changed size or position
		if (speed) {
			var tempSpeed = 0;
			$.each(css, function(i){
				if (css[i] !== previousCSS[i]) {
					tempSpeed = speed;
					return;
				}
			});
			speed = tempSpeed;
		}

		previousCSS = css;

		if (!speed) {
			$box.css(css);
		}

		$box.dequeue().animate(css, {
			duration: speed || 0,
			complete: function () {
				modalDimensions();

				active = false;

				// shrink the wrapper down to exactly the size of colorbox to avoid a bug in IE's iframe implementation.
				$wrap[0].style.width = (settings.w + loadedWidth + interfaceWidth) + "px";
				$wrap[0].style.height = (settings.h + loadedHeight + interfaceHeight) + "px";

				if (settings.get('reposition')) {
					setTimeout(function () {  // small delay before binding onresize due to an IE8 bug.
						$window.bind('resize.' + prefix, publicMethod.position);
					}, 1);
				}

				if ($.isFunction(loadedCallback)) {
					loadedCallback();
				}
			},
			step: modalDimensions
		});
	};

	publicMethod.resize = function (options) {
		var scrolltop;

		if (open) {
			options = options || {};

			if (options.width) {
				settings.w = setSize(options.width, 'x') - loadedWidth - interfaceWidth;
			}

			if (options.innerWidth) {
				settings.w = setSize(options.innerWidth, 'x');
			}

			$loaded.css({width: settings.w});

			if (options.height) {
				settings.h = setSize(options.height, 'y') - loadedHeight - interfaceHeight;
			}

			if (options.innerHeight) {
				settings.h = setSize(options.innerHeight, 'y');
			}

			if (!options.innerHeight && !options.height) {
				scrolltop = $loaded.scrollTop();
				$loaded.css({height: "auto"});
				settings.h = $loaded.height();
			}

			$loaded.css({height: settings.h});

			if(scrolltop) {
				$loaded.scrollTop(scrolltop);
			}

			publicMethod.position(settings.get('transition') === "none" ? 0 : settings.get('speed'));
		}
	};

	publicMethod.prep = function (object) {
		if (!open) {
			return;
		}

		var callback, speed = settings.get('transition') === "none" ? 0 : settings.get('speed');

		$loaded.remove();

		$loaded = $tag(div, 'LoadedContent').append(object);

		function getWidth() {
			settings.w = settings.w || $loaded.width();
			settings.w = settings.mw && settings.mw < settings.w ? settings.mw : settings.w;
			return settings.w;
		}
		function getHeight() {
			settings.h = settings.h || $loaded.height();
			settings.h = settings.mh && settings.mh < settings.h ? settings.mh : settings.h;
			return settings.h;
		}

		$loaded.hide()
		.appendTo($loadingBay.show())// content has to be appended to the DOM for accurate size calculations.
		.css({width: getWidth(), overflow: settings.get('scrolling') ? 'auto' : 'hidden'})
		.css({height: getHeight()})// sets the height independently from the width in case the new width influences the value of height.
		.prependTo($content);

		$loadingBay.hide();

		// floating the IMG removes the bottom line-height and fixed a problem where IE miscalculates the width of the parent element as 100% of the document width.

		$(photo).css({'float': 'none'});

		setClass(settings.get('className'));

		callback = function () {
			var total = $related.length,
				iframe,
				complete;

			if (!open) {
				return;
			}

			function removeFilter() { // Needed for IE8 in versions of jQuery prior to 1.7.2
				if ($.support.opacity === false) {
					$box[0].style.removeAttribute('filter');
				}
			}

			complete = function () {
				clearTimeout(loadingTimer);
				$loadingOverlay.hide();
				trigger(event_complete);
				settings.get('onComplete');
			};


			$title.html(settings.get('title')).show();
			$loaded.show();

			if (total > 1) { // handle grouping
				if (typeof settings.get('current') === "string") {
					$current.html(settings.get('current').replace('{current}', index + 1).replace('{total}', total)).show();
				}

				$next[(settings.get('loop') || index < total - 1) ? "show" : "hide"]().html(settings.get('next'));
				$prev[(settings.get('loop') || index) ? "show" : "hide"]().html(settings.get('previous'));

				slideshow();

				// Preloads images within a rel group
				if (settings.get('preloading')) {
					$.each([getIndex(-1), getIndex(1)], function(){
						var img,
							i = $related[this],
							settings = new Settings(i, $.data(i, colorbox)),
							src = settings.get('href');

						if (src && isImage(settings, src)) {
							src = retinaUrl(settings, src);
							img = document.createElement('img');
							img.src = src;
						}
					});
				}
			} else {
				$groupControls.hide();
			}

			if (settings.get('iframe')) {

				iframe = settings.get('createIframe');

				if (!settings.get('scrolling')) {
					iframe.scrolling = "no";
				}

				$(iframe)
					.attr({
						src: settings.get('href'),
						'class': prefix + 'Iframe'
					})
					.one('load', complete)
					.appendTo($loaded);

				$events.one(event_purge, function () {
					iframe.src = "//about:blank";
				});

				if (settings.get('fastIframe')) {
					$(iframe).trigger('load');
				}
			} else {
				complete();
			}

			if (settings.get('transition') === 'fade') {
				$box.fadeTo(speed, 1, removeFilter);
			} else {
				removeFilter();
			}
		};

		if (settings.get('transition') === 'fade') {
			$box.fadeTo(speed, 0, function () {
				publicMethod.position(0, callback);
			});
		} else {
			publicMethod.position(speed, callback);
		}
	};

	function load () {
		var href, setResize, prep = publicMethod.prep, $inline, request = ++requests;

		active = true;

		photo = false;

		trigger(event_purge);
		trigger(event_load);
		settings.get('onLoad');

		settings.h = settings.get('height') ?
				setSize(settings.get('height'), 'y') - loadedHeight - interfaceHeight :
				settings.get('innerHeight') && setSize(settings.get('innerHeight'), 'y');

		settings.w = settings.get('width') ?
				setSize(settings.get('width'), 'x') - loadedWidth - interfaceWidth :
				settings.get('innerWidth') && setSize(settings.get('innerWidth'), 'x');

		// Sets the minimum dimensions for use in image scaling
		settings.mw = settings.w;
		settings.mh = settings.h;

		// Re-evaluate the minimum width and height based on maxWidth and maxHeight values.
		// If the width or height exceed the maxWidth or maxHeight, use the maximum values instead.
		if (settings.get('maxWidth')) {
			settings.mw = setSize(settings.get('maxWidth'), 'x') - loadedWidth - interfaceWidth;
			settings.mw = settings.w && settings.w < settings.mw ? settings.w : settings.mw;
		}
		if (settings.get('maxHeight')) {
			settings.mh = setSize(settings.get('maxHeight'), 'y') - loadedHeight - interfaceHeight;
			settings.mh = settings.h && settings.h < settings.mh ? settings.h : settings.mh;
		}

		href = settings.get('href');

		loadingTimer = setTimeout(function () {
			$loadingOverlay.show();
		}, 100);

		if (settings.get('inline')) {
			var $target = $(href).eq(0);
			// Inserts an empty placeholder where inline content is being pulled from.
			// An event is bound to put inline content back when Colorbox closes or loads new content.
			$inline = $('<div>').hide().insertBefore($target);

			$events.one(event_purge, function () {
				$inline.replaceWith($target);
			});

			prep($target);
		} else if (settings.get('iframe')) {
			// IFrame element won't be added to the DOM until it is ready to be displayed,
			// to avoid problems with DOM-ready JS that might be trying to run in that iframe.
			prep(" ");
		} else if (settings.get('html')) {
			prep(settings.get('html'));
		} else if (isImage(settings, href)) {

			href = retinaUrl(settings, href);

			photo = settings.get('createImg');

			$(photo)
			.addClass(prefix + 'Photo')
			.bind('error.'+prefix,function () {
				prep($tag(div, 'Error').html(settings.get('imgError')));
			})
			.one('load', function () {
				if (request !== requests) {
					return;
				}

				// A small pause because some browsers will occassionaly report a
				// img.width and img.height of zero immediately after the img.onload fires
				setTimeout(function(){
					var percent;

					if (settings.get('retinaImage') && window.devicePixelRatio > 1) {
						photo.height = photo.height / window.devicePixelRatio;
						photo.width = photo.width / window.devicePixelRatio;
					}

					if (settings.get('scalePhotos')) {
						setResize = function () {
							photo.height -= photo.height * percent;
							photo.width -= photo.width * percent;
						};
						if (settings.mw && photo.width > settings.mw) {
							percent = (photo.width - settings.mw) / photo.width;
							setResize();
						}
						if (settings.mh && photo.height > settings.mh) {
							percent = (photo.height - settings.mh) / photo.height;
							setResize();
						}
					}

					if (settings.h) {
						photo.style.marginTop = Math.max(settings.mh - photo.height, 0) / 2 + 'px';
					}

					if ($related[1] && (settings.get('loop') || $related[index + 1])) {
						photo.style.cursor = 'pointer';

						$(photo).bind('click.'+prefix, function () {
							publicMethod.next();
						});
					}

					photo.style.width = photo.width + 'px';
					photo.style.height = photo.height + 'px';
					prep(photo);
				}, 1);
			});

			photo.src = href;

		} else if (href) {
			$loadingBay.load(href, settings.get('data'), function (data, status) {
				if (request === requests) {
					prep(status === 'error' ? $tag(div, 'Error').html(settings.get('xhrError')) : $(this).contents());
				}
			});
		}
	}

	// Navigates to the next page/image in a set.
	publicMethod.next = function () {
		if (!active && $related[1] && (settings.get('loop') || $related[index + 1])) {
			index = getIndex(1);
			launch($related[index]);
		}
	};

	publicMethod.prev = function () {
		if (!active && $related[1] && (settings.get('loop') || index)) {
			index = getIndex(-1);
			launch($related[index]);
		}
	};

	// Note: to use this within an iframe use the following format: parent.jQuery.colorbox.close();
	publicMethod.close = function () {
		if (open && !closing) {

			closing = true;
			open = false;
			trigger(event_cleanup);
			settings.get('onCleanup');
			$window.unbind('.' + prefix);
			$overlay.fadeTo(settings.get('fadeOut') || 0, 0);

			$box.stop().fadeTo(settings.get('fadeOut') || 0, 0, function () {
				$box.hide();
				$overlay.hide();
				trigger(event_purge);
				$loaded.remove();

				setTimeout(function () {
					closing = false;
					trigger(event_closed);
					settings.get('onClosed');
				}, 1);
			});
		}
	};

	// Removes changes Colorbox made to the document, but does not remove the plugin.
	publicMethod.remove = function () {
		if (!$box) { return; }

		$box.stop();
		$[colorbox].close();
		$box.stop(false, true).remove();
		$overlay.remove();
		closing = false;
		$box = null;
		$('.' + boxElement)
			.removeData(colorbox)
			.removeClass(boxElement);

		$(document).unbind('click.'+prefix).unbind('keydown.'+prefix);
	};

	// A method for fetching the current element Colorbox is referencing.
	// returns a jQuery object.
	publicMethod.element = function () {
		return $(settings.el);
	};

	publicMethod.settings = defaults;

}(jQuery, document, window));

/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            offsetX    = 0,
            offsetY    = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

/*!
* jQuery Text Counter Plugin v0.8.0
* https://github.com/ractoon/jQuery-Text-Counter
*
* Copyright 2014 ractoon
* Released under the MIT license
*/
;(function($) {
    $.textcounter = function(el, options) {
        // To avoid scope issues, use 'base' instead of 'this'
        // to reference this class from internal events and functions.
        var base = this;

        // Access to jQuery and DOM versions of element
        base.$el = $(el);
        base.el = el;

        // Add a reverse reference to the DOM object
        base.$el.data('textcounter', base);

        base.init = function() {
            base.options = $.extend({}, $.textcounter.defaultOptions, options);

            // append the count element
            var counterText = base.options.countDown ? base.options.countDownText : base.options.counterText,
                counterNum = base.options.countDown ? base.options.max : 0,
                $formatted_counter_text = $('<div/>').addClass(base.options.textCountMessageClass)
                .html(counterText.replace('%d', '<span class="' + base.options.textCountClass + '">' + counterNum + '</span>')),
                $count_overflow_text = $('<div/>').addClass(base.options.countOverflowContainerClass);

            base.hideMessage($count_overflow_text);

            base.$container = $('<' + base.options.countContainerElement + '/>')
                .addClass(base.options.countContainerClass)
                .append($formatted_counter_text)
                .append($count_overflow_text);

            base.$text_counter = base.$container.find('span');
            base.$el.after(base.$container);

            // bind input events
            base.$el.bind('keyup.textcounter click.textcounter blur.textcounter focus.textcounter change.textcounter paste.textcounter', base.checkLimits).trigger('click.textcounter');

            // TextCounter: init(el) Callback
            base.options.init(base.el);
        };

        base.checkLimits = function(e) {
            var $this = base.$el,
            $countEl = base.$container,
            $text = $this.val(),
            textCount = 0,
            textTotalCount = 0,
            eventTriggered =  e.originalEvent === undefined ? false : true;

            if (!$.isEmptyObject($text)) {
                textCount = base.textCount($text);
            }

            // if max is auto retrieve value
            if (base.options.max == 'auto') {
                var max = base.$el.attr('maxlength');

                if (typeof max !== 'undefined' && max !== false) {
                    base.options.max = max;
                }
                else {
                    base.$container.text('error: [maxlength] attribute not set');
                }
            }

            // if this is a countdown counter deduct from the max characters/words
            textTotalCount = base.options.countDown ? base.options.max - textCount : textCount;

            // set the current text count
            base.setCount(textTotalCount);

            if (base.options.min > 0 && eventTriggered) {   // if a minimum value has been set
                if (textCount < base.options.min) {
                    base.setErrors('min');

                    // TextCounter: minunder(el) Callback
                    base.options.minunder(base.el);
                }
                else if (textCount >= base.options.min) {
                    // TextCounter: mincount(el) Callback
                    base.options.mincount(base.el);

                    base.clearErrors('min');
                }
            }

            if (base.options.max !== -1) {  // if a maximum value has been set
                if (textCount === base.options.max && base.options.max !== 0) {
                    // TextCounter: maxcount(el) Callback
                    base.options.maxcount(base.el);
                    base.clearErrors('max');

                } else if (textCount > base.options.max && base.options.max !== 0) {
                    if (base.options.stopInputAtMaximum) {  // if the string should be trimmed at the maximum length
                        var trimmedString = '';

                        if (base.options.type == "word") {  // word type
                            var wordArray = $text.split(/[^\S\n]/g);
                            var i = 0;

                            // iterate over individual words
                            while (i < wordArray.length) {
                                // if over the maximum words allowed break;
                                if (i >= base.options.max) break;

                                if (wordArray[i] !== undefined) {
                                    trimmedString += wordArray[i] + ' ';
                                    i++;
                                }
                            }
                        }
                        else {  // character type
                            var maxLimit = (base.options.twoCharCarriageReturn) ?
                                base.options.max - base.twoCharCarriageReturnCount($text)
                                : base.options.max;

                            if (base.options.countSpaces) {     // if spaces should be counted
                                trimmedString = $text.substring(0, maxLimit);
                            }
                            else {
                                var charArray = $text.split(''),
                                totalCharacters = charArray.length,
                                charCount = 0,
                                i = 0;

                                while (charCount < maxLimit && i < totalCharacters) {
                                    if (charArray[i] !== ' ') charCount++;
                                    trimmedString += charArray[i++];
                                }
                            }
                        }

                        $this.val(trimmedString.trim());

                        textCount = base.textCount($this.val());
                        textTotalCount = base.options.countDown ? base.options.max - textCount : textCount;
                        base.setCount(textTotalCount);
                    } else {
                        base.setErrors('max');
                    }
                }
                else {
                    // TextCounter: maxunder(el) Callback
                    base.options.maxunder(base.el);
                    base.clearErrors('max');
                }
            }
			
			// hide the counter if it doesn't meet either the minimum or maximum display cutoff
			if  (base.options.minDisplayCutoff == -1 && base.options.maxDisplayCutoff == -1) {
				base.$container.show();				
			} else if (textCount <= base.options.min + base.options.minDisplayCutoff) { 
				base.$container.show();
			} else if (base.options.max !== -1 && textCount >= base.options.max - base.options.maxDisplayCutoff) {
				base.$container.show();
			} else {
				base.$container.hide();
			}
        };

        base.textCount = function(text) {
            var textCount = 0;

            if (base.options.type == "word") {  // word count
                textCount = base.wordCount(text);
            }
            else {  // character count
                textCount = base.characterCount(text);
            }

            return textCount;
        };

        base.wordCount = function(text) {
            return text.trim().replace(/\s+/gi, ' ').split(' ').length;
        };

        base.characterCount = function(text) {
            var textCount = 0,
                carriageReturnsCount = 0;

            // count carriage returns/newlines as 2 characters
            if (base.options.twoCharCarriageReturn) {
                carriageReturnsCount = base.twoCharCarriageReturnCount(text);
            }

            if (base.options.countSpaces) { // if need to count spaces
                textCount = text.replace(/[^\S\n|\r|\r\n]/g, ' ').length;
            }
            else {
                textCount = text.replace(/\s/g, '').length;
            }

            // count extended characters (e.g. Chinese)
            if (base.options.countExtendedCharacters) {
                var extended = text.match(/[^\x00-\xff]/gi);

                if (extended == null) {
                    textCount = text.length;
                } else {
                    textCount = text.length + extended.length;
                }
            }

            if (base.options.twoCharCarriageReturn) {
                textCount += carriageReturnsCount;
            }

            return textCount;
        };

        base.twoCharCarriageReturnCount = function(text) {
            var carriageReturns = text.match(/(\r\n|\n|\r)/g),
                carriageReturnsCount = 0;

            if (carriageReturns !== null) {
                carriageReturnsCount = carriageReturns.length;
            }

            return carriageReturnsCount;
        };

        base.setCount = function(count) {
            base.$text_counter.text(count);
        };

        base.setErrors = function(type) {
            var $this = base.$el,
            $countEl = base.$container,
            errorText = '';

            $this.addClass(base.options.inputErrorClass);
            $countEl.addClass(base.options.counterErrorClass);

            switch(type) {
                case 'min':
                    errorText = base.options.minimumErrorText;
                    break;
                case 'max':
                    errorText = base.options.maximumErrorText;

                    if (base.options.countOverflow) {
                        base.setOverflowMessage();
                    }

                    break;
            }

            if (base.options.displayErrorText) {
                if (!$countEl.children('.error-text-' + type).length) {
                    $countEl.append('<' + base.options.errorTextElement + ' class="error-text error-text-' + type + '">' + errorText + '</' + base.options.errorTextElement + '>');
                }
            }
        };

        base.setOverflowMessage = function () {
            base.hideMessage(base.$container.find('.' + base.options.textCountMessageClass));

            base.removeOverflowMessage();

            var overflowText = base.options.countOverflowText
                .replace('%d', base.textCount(base.$el.val()) - base.options.max)
                .replace('%type', base.options.type + 's');

            var overflowDiv = base.$container.find('.' + base.options.countOverflowContainerClass).append(overflowText);
            base.showMessage(overflowDiv);
        },

        base.removeOverflowMessage = function () {
            base.$container.find('.' + base.options.countOverflowContainerClass).empty();
        },

        base.showMessage = function ($selector) {
            $selector.css('display', 'inline');
        },

        base.hideMessage = function ($selector) {
            $selector.css('display', 'none');
        },

        base.clearErrors = function(type) {
            var $this = base.$el,
            $countEl = base.$container;

            $countEl.children('.error-text-' + type).remove();

            if ($countEl.children('.error-text').length == 0) {
                base.removeOverflowMessage();
                base.showMessage(base.$container.find('.' + base.options.textCountMessageClass));
                $this.removeClass(base.options.inputErrorClass);
                $countEl.removeClass(base.options.counterErrorClass);
            }
        };

        // kick it off
        base.init();
    };

    $.textcounter.defaultOptions = {
        'type'                        : "character",                     // "character" or "word"
        'min'                         : 0,                               // minimum number of characters/words
        'max'                         : 200,                             // maximum number of characters/words, -1 for unlimited, 'auto' to use maxlength attribute
        'countContainerElement'       : "div",                           // HTML element to wrap the text count in
        'countContainerClass'         : "text-count-wrapper",            // class applied to the countContainerElement
        'textCountMessageClass'       : "text-count-message",            // class applied to the counter message
        'textCountClass'              : "text-count",                    // class applied to the counter length (the count number)
        'inputErrorClass'             : "error",                         // error class appended to the input element if error occurs
        'counterErrorClass'           : "error",                         // error class appended to the countContainerElement if error occurs
        'counterText'                 : "Total Count: %d",               // counter text
        'errorTextElement'            : "div",                           // error text element
        'minimumErrorText'            : "Minimum not met",               // error message for minimum not met,
        'maximumErrorText'            : "Maximum exceeded",              // error message for maximum range exceeded,
        'displayErrorText'            : true,                            // display error text messages for minimum/maximum values
        'stopInputAtMaximum'          : true,                            // stop further text input if maximum reached
        'countSpaces'                 : false,                           // count spaces as character (only for "character" type)
        'countDown'                   : false,                           // if the counter should deduct from maximum characters/words rather than counting up
        'countDownText'               : "Remaining: %d",                 // count down text
        'countExtendedCharacters'     : false,                           // count extended UTF-8 characters as 2 bytes (such as Chinese characters)
        'twoCharCarriageReturn'       : false,                           // count carriage returns/newlines as 2 characters
        'countOverflow'               : false,                           // display text overflow element
        'countOverflowText'           : "Maximum %type exceeded by %d",  // count overflow text
        'countOverflowContainerClass' : "text-count-overflow-wrapper",   // class applied to the count overflow wrapper
        'minDisplayCutoff'            : -1,                              // maximum number of characters/words above the minimum to display a count
        'maxDisplayCutoff'            : -1,                              // maximum number of characters/words below the maximum to display a count

        // Callback API
        'maxunder'                    : function(el){},                  // Callback: function(element) - Fires when counter under max limit
        'minunder'                    : function(el){},                  // Callback: function(element) - Fires when counter under min limit
        'maxcount'                    : function(el){},                  // Callback: function(element) - Fires when the counter hits the maximum word/character count
        'mincount'                    : function(el){},                  // Callback: function(element) - Fires when the counter hits the minimum word/character count
        'init'                        : function(el){}                   // Callback: function(element) - Fires after the counter is initially setup
    };

    $.fn.textcounter = function(options) {
        return this.each(function() {
            new $.textcounter(this, options);
        });
    };

})(jQuery);

/*! jQuery UI - v1.12.1 - 2016-09-14
* http://jqueryui.com
* Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-1-7.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

$.ui = $.ui || {};

var version = $.ui.version = "1.12.1";


/*!
 * jQuery UI Widget 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/



var widgetUuid = 0;
var widgetSlice = Array.prototype.slice;

$.cleanData = ( function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// Http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
} )( $.cleanData );

$.widget = function( name, base, prototype ) {
	var existingConstructor, constructor, basePrototype;

	// ProxiedPrototype allows the provided prototype to remain unmodified
	// so that it can be used as a mixin for multiple widgets (#8876)
	var proxiedPrototype = {};

	var namespace = name.split( "." )[ 0 ];
	name = name.split( "." )[ 1 ];
	var fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	if ( $.isArray( prototype ) ) {
		prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
	}

	// Create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {

		// Allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// Allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	// Extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,

		// Copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),

		// Track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	} );

	basePrototype = new base();

	// We need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = ( function() {
			function _super() {
				return base.prototype[ prop ].apply( this, arguments );
			}

			function _superApply( args ) {
				return base.prototype[ prop ].apply( this, args );
			}

			return function() {
				var __super = this._super;
				var __superApply = this._superApply;
				var returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		} )();
	} );
	constructor.prototype = $.widget.extend( basePrototype, {

		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	} );

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// Redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
				child._proto );
		} );

		// Remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widgetSlice.call( arguments, 1 );
	var inputIndex = 0;
	var inputLength = input.length;
	var key;
	var value;

	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {

				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :

						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );

				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string";
		var args = widgetSlice.call( arguments, 1 );
		var returnValue = this;

		if ( isMethodCall ) {

			// If this is an empty collection, we need to have the instance method
			// return undefined instead of the jQuery instance
			if ( !this.length && options === "instance" ) {
				returnValue = undefined;
			} else {
				this.each( function() {
					var methodValue;
					var instance = $.data( this, fullName );

					if ( options === "instance" ) {
						returnValue = instance;
						return false;
					}

					if ( !instance ) {
						return $.error( "cannot call methods on " + name +
							" prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}

					if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name +
							" widget instance" );
					}

					methodValue = instance[ options ].apply( instance, args );

					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				} );
			}
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat( args ) );
			}

			this.each( function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			} );
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",

	options: {
		classes: {},
		disabled: false,

		// Callbacks
		create: null
	},

	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widgetUuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();
		this.classesElementLookup = {};

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			} );
			this.document = $( element.style ?

				// Element within the document
				element.ownerDocument :

				// Element is window or document
				element.document || element );
			this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();

		if ( this.options.disabled ) {
			this._setOptionDisabled( this.options.disabled );
		}

		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},

	_getCreateOptions: function() {
		return {};
	},

	_getCreateEventData: $.noop,

	_create: $.noop,

	_init: $.noop,

	destroy: function() {
		var that = this;

		this._destroy();
		$.each( this.classesElementLookup, function( key, value ) {
			that._removeClass( value, key );
		} );

		// We can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.off( this.eventNamespace )
			.removeData( this.widgetFullName );
		this.widget()
			.off( this.eventNamespace )
			.removeAttr( "aria-disabled" );

		// Clean up events and states
		this.bindings.off( this.eventNamespace );
	},

	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;
		var parts;
		var curOption;
		var i;

		if ( arguments.length === 0 ) {

			// Don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {

			// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},

	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "classes" ) {
			this._setOptionClasses( value );
		}

		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this._setOptionDisabled( value );
		}

		return this;
	},

	_setOptionClasses: function( value ) {
		var classKey, elements, currentElements;

		for ( classKey in value ) {
			currentElements = this.classesElementLookup[ classKey ];
			if ( value[ classKey ] === this.options.classes[ classKey ] ||
					!currentElements ||
					!currentElements.length ) {
				continue;
			}

			// We are doing this to create a new jQuery object because the _removeClass() call
			// on the next line is going to destroy the reference to the current elements being
			// tracked. We need to save a copy of this collection so that we can add the new classes
			// below.
			elements = $( currentElements.get() );
			this._removeClass( currentElements, classKey );

			// We don't use _addClass() here, because that uses this.options.classes
			// for generating the string of classes. We want to use the value passed in from
			// _setOption(), this is the new value of the classes option which was passed to
			// _setOption(). We pass this value directly to _classes().
			elements.addClass( this._classes( {
				element: elements,
				keys: classKey,
				classes: value,
				add: true
			} ) );
		}
	},

	_setOptionDisabled: function( value ) {
		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

		// If the widget is becoming disabled, then nothing is interactive
		if ( value ) {
			this._removeClass( this.hoverable, null, "ui-state-hover" );
			this._removeClass( this.focusable, null, "ui-state-focus" );
		}
	},

	enable: function() {
		return this._setOptions( { disabled: false } );
	},

	disable: function() {
		return this._setOptions( { disabled: true } );
	},

	_classes: function( options ) {
		var full = [];
		var that = this;

		options = $.extend( {
			element: this.element,
			classes: this.options.classes || {}
		}, options );

		function processClassString( classes, checkOption ) {
			var current, i;
			for ( i = 0; i < classes.length; i++ ) {
				current = that.classesElementLookup[ classes[ i ] ] || $();
				if ( options.add ) {
					current = $( $.unique( current.get().concat( options.element.get() ) ) );
				} else {
					current = $( current.not( options.element ).get() );
				}
				that.classesElementLookup[ classes[ i ] ] = current;
				full.push( classes[ i ] );
				if ( checkOption && options.classes[ classes[ i ] ] ) {
					full.push( options.classes[ classes[ i ] ] );
				}
			}
		}

		this._on( options.element, {
			"remove": "_untrackClassesElement"
		} );

		if ( options.keys ) {
			processClassString( options.keys.match( /\S+/g ) || [], true );
		}
		if ( options.extra ) {
			processClassString( options.extra.match( /\S+/g ) || [] );
		}

		return full.join( " " );
	},

	_untrackClassesElement: function( event ) {
		var that = this;
		$.each( that.classesElementLookup, function( key, value ) {
			if ( $.inArray( event.target, value ) !== -1 ) {
				that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
			}
		} );
	},

	_removeClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, false );
	},

	_addClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, true );
	},

	_toggleClass: function( element, keys, extra, add ) {
		add = ( typeof add === "boolean" ) ? add : extra;
		var shift = ( typeof element === "string" || element === null ),
			options = {
				extra: shift ? keys : extra,
				keys: shift ? element : keys,
				element: shift ? this.element : element,
				add: add
			};
		options.element.toggleClass( this._classes( options ), add );
		return this;
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement;
		var instance = this;

		// No suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// No element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {

				// Allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
						$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// Copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ );
			var eventName = match[ 1 ] + instance.eventNamespace;
			var selector = match[ 2 ];

			if ( selector ) {
				delegateElement.on( eventName, selector, handlerProxy );
			} else {
				element.on( eventName, handlerProxy );
			}
		} );
	},

	_off: function( element, eventName ) {
		eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.off( eventName ).off( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
			},
			mouseleave: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
			}
		} );
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
			},
			focusout: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
			}
		} );
	},

	_trigger: function( type, event, data ) {
		var prop, orig;
		var callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();

		// The original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// Copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}

		var hasOptions;
		var effectName = !options ?
			method :
			options === true || typeof options === "number" ?
				defaultEffect :
				options.effect || defaultEffect;

		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}

		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;

		if ( options.delay ) {
			element.delay( options.delay );
		}

		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue( function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			} );
		}
	};
} );

var widget = $.widget;


/*!
 * jQuery UI Position 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */

//>>label: Position
//>>group: Core
//>>description: Positions elements relative to other elements.
//>>docs: http://api.jqueryui.com/position/
//>>demos: http://jqueryui.com/position/


( function() {
var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[ 0 ];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div " +
				"style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>" +
				"<div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[ 0 ];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[ 0 ].clientWidth;
		}

		div.remove();

		return ( cachedScrollbarWidth = w1 - w2 );
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[ 0 ] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,
			hasOffset = !isWindow && !isDocument;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: withinElement.outerWidth(),
			height: withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// Make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[ 0 ].preventDefault ) {

		// Force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;

	// Clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// Force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1 ) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// Calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// Reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	} );

	// Normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each( function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) +
				scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) +
				scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem: elem
				} );
			}
		} );

		if ( options.using ) {

			// Adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	} );
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// Element is wider than within
			if ( data.collisionWidth > outerWidth ) {

				// Element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
						withinOffset;
					position.left += overLeft - newOverRight;

				// Element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;

				// Element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}

			// Too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;

			// Too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;

			// Adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// Element is taller than within
			if ( data.collisionHeight > outerHeight ) {

				// Element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
						withinOffset;
					position.top += overTop - newOverBottom;

				// Element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;

				// Element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}

			// Too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;

			// Too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;

			// Adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
					outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			} else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
					atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
					outerHeight - withinOffset;
				if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
					position.top += myOffset + atOffset + offset;
				}
			} else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
					offset - offsetTop;
				if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

} )();

var position = $.ui.position;


/*!
 * jQuery UI :data 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :data Selector
//>>group: Core
//>>description: Selects elements which have data stored under the specified key.
//>>docs: http://api.jqueryui.com/data-selector/


var data = $.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo( function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		} ) :

		// Support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		}
} );

/*!
 * jQuery UI Disable Selection 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: disableSelection
//>>group: Core
//>>description: Disable selection of text content within the set of matched elements.
//>>docs: http://api.jqueryui.com/disableSelection/

// This file is deprecated


var disableSelection = $.fn.extend( {
	disableSelection: ( function() {
		var eventType = "onselectstart" in document.createElement( "div" ) ?
			"selectstart" :
			"mousedown";

		return function() {
			return this.on( eventType + ".ui-disableSelection", function( event ) {
				event.preventDefault();
			} );
		};
	} )(),

	enableSelection: function() {
		return this.off( ".ui-disableSelection" );
	}
} );


/*!
 * jQuery UI Effects 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Effects Core
//>>group: Effects
// jscs:disable maximumLineLength
//>>description: Extends the internal jQuery effects. Includes morphing and easing. Required by all other effects.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/category/effects-core/
//>>demos: http://jqueryui.com/effect/



var dataSpace = "ui-effects-",
	dataSpaceStyle = "ui-effects-style",
	dataSpaceAnimated = "ui-effects-animated",

	// Create a local jQuery because jQuery Color relies on it and the
	// global may not exist with AMD and a custom build (#10199)
	jQuery = $;

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
( function( jQuery, undefined ) {

	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor " +
		"borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

	// Plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,

	// A set of RE's that can match strings and generate color tuples.
	stringParsers = [ {
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {

			// This regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {

			// This regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			space: "hsla",
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		} ],

	// JQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: "byte"
				},
				green: {
					idx: 1,
					type: "byte"
				},
				blue: {
					idx: 2,
					type: "byte"
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: "degrees"
				},
				saturation: {
					idx: 1,
					type: "percent"
				},
				lightness: {
					idx: 2,
					type: "percent"
				}
			}
		}
	},
	propTypes = {
		"byte": {
			floor: true,
			max: 255
		},
		"percent": {
			max: 1
		},
		"degrees": {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// Element for support tests
	supportElem = jQuery( "<p>" )[ 0 ],

	// Colors = jQuery.Color.names
	colors,

	// Local aliases of functions called often
	each = jQuery.each;

// Determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// Define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = "_" + spaceName;
	space.props.alpha = {
		idx: 3,
		type: "percent",
		def: 1
	};
} );

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return ( allowEmpty || !prop.def ) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {

		// We add mod before modding to make sure that negatives values
		// get converted properly: -10 -> 350
		return ( value + type.mod ) % type.mod;
	}

	// For now all property types without mod have min and max
	return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match && parser.parse( match ),
			spaceName = parser.space || "rgba";

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// If this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// Exit each( stringParsers ) here because we matched
			return false;
		}
	} );

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// If this came from a parsed string, force "transparent" when alpha is 0
		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
		if ( rgba.join() === "0,0,0,0" ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// Named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		// More than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = "array";
		}

		if ( type === "string" ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === "array" ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			} );
			return this;
		}

		if ( type === "object" ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				} );
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// If the cache doesn't exist, and we know how to convert
						if ( !inst[ cache ] && space.to ) {

							// If the value was null, we don't need to copy it
							// if the key was alpha, we don't need to copy it either
							if ( key === "alpha" || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// This is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					} );

					// Everything defined but alpha?
					if ( inst[ cache ] &&
							jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {

						// Use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				} );
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if ( isCache ) {
				localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				} );
			}
			return same;
		} );
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		} );
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( "transparent" ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// If null, don't override start value
			if ( endValue === null ) {
				return;
			}

			// If null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue > type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue > type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		} );
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {

		// If we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		} ) );
	},
	toRgbaString: function() {
		var prefix = "rgba(",
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i > 2 ? 1 : 0 ) : v;
			} );

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = "rgb(";
		}

		return prefix + rgba.join() + ")";
	},
	toHslaString: function() {
		var prefix = "hsla(",
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i > 2 ? 1 : 0;
				}

				// Catch 1 and 2
				if ( i && i < 3 ) {
					v = Math.round( v * 100 ) + "%";
				}
				return v;
			} );

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = "hsl(";
		}
		return prefix + hsla.join() + ")";
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return "#" + jQuery.map( rgba, function( v ) {

			// Default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? "0" + v : v;
		} ).join( "" );
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
	}
} );
color.fn.parse.prototype = color.fn;

// Hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 < 1 ) {
		return p + ( q - p ) * h * 6;
	}
	if ( h * 2 < 1 ) {
		return q;
	}
	if ( h * 3 < 2 ) {
		return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;
	}
	return p;
}

spaces.hsla.to = function( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	// Chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
	// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
	if ( diff === 0 ) {
		s = 0;
	} else if ( l <= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round( h ) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};

each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// Makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// Generate a cache for this space if it doesn't exist
		if ( to && !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === "array" || type === "object" ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === "object" ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		} );

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// Makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {

		// Alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === "undefined" ) {
				return cur;
			}

			if ( vtype === "function" ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null && prop.empty ) {
				return this;
			}
			if ( vtype === "string" ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	} );
} );

// Add cssHook and .fx.step function for each named hook.
// accept a space separated string of properties
color.hook = function( hook ) {
	var hooks = hook.split( " " );
	each( hooks, function( i, hook ) {
		jQuery.cssHooks[ hook ] = {
			set: function( elem, value ) {
				var parsed, curElem,
					backgroundColor = "";

				if ( value !== "transparent" && ( jQuery.type( value ) !== "string" ||
						( parsed = stringParse( value ) ) ) ) {
					value = color( parsed || value );
					if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
						curElem = hook === "backgroundColor" ? elem.parentNode : elem;
						while (
							( backgroundColor === "" || backgroundColor === "transparent" ) &&
							curElem && curElem.style
						) {
							try {
								backgroundColor = jQuery.css( curElem, "backgroundColor" );
								curElem = curElem.parentNode;
							} catch ( e ) {
							}
						}

						value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
							backgroundColor :
							"_default" );
					}

					value = value.toRgbaString();
				}
				try {
					elem.style[ hook ] = value;
				} catch ( e ) {

					// Wrapped to prevent IE from throwing errors on "invalid" values like
					// 'auto' or 'inherit'
				}
			}
		};
		jQuery.fx.step[ hook ] = function( fx ) {
			if ( !fx.colorInit ) {
				fx.start = color( fx.elem, hook );
				fx.end = color( fx.end );
				fx.colorInit = true;
			}
			jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
		};
	} );

};

color.hook( stepHooks );

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
			expanded[ "border" + part + "Color" ] = value;
		} );
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {

	// 4.1. Basic color keywords
	aqua: "#00ffff",
	black: "#000000",
	blue: "#0000ff",
	fuchsia: "#ff00ff",
	gray: "#808080",
	green: "#008000",
	lime: "#00ff00",
	maroon: "#800000",
	navy: "#000080",
	olive: "#808000",
	purple: "#800080",
	red: "#ff0000",
	silver: "#c0c0c0",
	teal: "#008080",
	white: "#ffffff",
	yellow: "#ffff00",

	// 4.2.3. "transparent" color keyword
	transparent: [ null, null, null, 0 ],

	_default: "#ffffff"
};

} )( jQuery );

/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
( function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each(
	[ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ],
	function( _, prop ) {
		$.fx.step[ prop ] = function( fx ) {
			if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
				jQuery.style( fx.elem, prop, fx.end );
				fx.setAttr = true;
			}
		};
	}
);

function getElementStyles( elem ) {
	var key, len,
		style = elem.ownerDocument.defaultView ?
			elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
			elem.currentStyle,
		styles = {};

	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === "string" ) {
				styles[ $.camelCase( key ) ] = style[ key ];
			}
		}

	// Support: Opera, IE <9
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === "string" ) {
				styles[ key ] = style[ key ];
			}
		}
	}

	return styles;
}

function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

// Support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( "class" ) || "",
			applyClassChange,
			allAnimations = o.children ? animated.find( "*" ).addBack() : animated;

		// Map the animated objects to store the original styles.
		allAnimations = allAnimations.map( function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles( this )
			};
		} );

		// Apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function( i, action ) {
				if ( value[ action ] ) {
					animated[ action + "Class" ]( value[ action ] );
				}
			} );
		};
		applyClassChange();

		// Map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map( function() {
			this.end = getElementStyles( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		} );

		// Apply original class
		animated.attr( "class", baseClass );

		// Map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map( function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = $.extend( {}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				} );

			this.el.animate( this.diff, opts );
			return dfd.promise();
		} );

		// Once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done( function() {

			// Set the final class
			applyClassChange();

			// For each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function( key ) {
					el.css( key, "" );
				} );
			} );

			// This is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		} );
	} );
};

$.fn.extend( {
	addClass: ( function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return speed ?
				$.effects.animateClass.call( this,
					{ add: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	} )( $.fn.addClass ),

	removeClass: ( function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return arguments.length > 1 ?
				$.effects.animateClass.call( this,
					{ remove: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	} )( $.fn.removeClass ),

	toggleClass: ( function( orig ) {
		return function( classNames, force, speed, easing, callback ) {
			if ( typeof force === "boolean" || force === undefined ) {
				if ( !speed ) {

					// Without speed parameter
					return orig.apply( this, arguments );
				} else {
					return $.effects.animateClass.call( this,
						( force ? { add: classNames } : { remove: classNames } ),
						speed, easing, callback );
				}
			} else {

				// Without force parameter
				return $.effects.animateClass.call( this,
					{ toggle: classNames }, force, speed, easing );
			}
		};
	} )( $.fn.toggleClass ),

	switchClass: function( remove, add, speed, easing, callback ) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
} );

} )();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

( function() {

if ( $.expr && $.expr.filters && $.expr.filters.animated ) {
	$.expr.filters.animated = ( function( orig ) {
		return function( elem ) {
			return !!$( elem ).data( dataSpaceAnimated ) || orig( elem );
		};
	} )( $.expr.filters.animated );
}

if ( $.uiBackCompat !== false ) {
	$.extend( $.effects, {

		// Saves a set of properties in a data storage
		save: function( element, set ) {
			var i = 0, length = set.length;
			for ( ; i < length; i++ ) {
				if ( set[ i ] !== null ) {
					element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
				}
			}
		},

		// Restores a set of previously saved properties from a data storage
		restore: function( element, set ) {
			var val, i = 0, length = set.length;
			for ( ; i < length; i++ ) {
				if ( set[ i ] !== null ) {
					val = element.data( dataSpace + set[ i ] );
					element.css( set[ i ], val );
				}
			}
		},

		setMode: function( el, mode ) {
			if ( mode === "toggle" ) {
				mode = el.is( ":hidden" ) ? "show" : "hide";
			}
			return mode;
		},

		// Wraps the element around a wrapper that copies position properties
		createWrapper: function( element ) {

			// If the element is already wrapped, return it
			if ( element.parent().is( ".ui-effects-wrapper" ) ) {
				return element.parent();
			}

			// Wrap the element
			var props = {
					width: element.outerWidth( true ),
					height: element.outerHeight( true ),
					"float": element.css( "float" )
				},
				wrapper = $( "<div></div>" )
					.addClass( "ui-effects-wrapper" )
					.css( {
						fontSize: "100%",
						background: "transparent",
						border: "none",
						margin: 0,
						padding: 0
					} ),

				// Store the size in case width/height are defined in % - Fixes #5245
				size = {
					width: element.width(),
					height: element.height()
				},
				active = document.activeElement;

			// Support: Firefox
			// Firefox incorrectly exposes anonymous content
			// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
			try {
				active.id;
			} catch ( e ) {
				active = document.body;
			}

			element.wrap( wrapper );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).trigger( "focus" );
			}

			// Hotfix for jQuery 1.4 since some change in wrap() seems to actually
			// lose the reference to the wrapped element
			wrapper = element.parent();

			// Transfer positioning properties to the wrapper
			if ( element.css( "position" ) === "static" ) {
				wrapper.css( { position: "relative" } );
				element.css( { position: "relative" } );
			} else {
				$.extend( props, {
					position: element.css( "position" ),
					zIndex: element.css( "z-index" )
				} );
				$.each( [ "top", "left", "bottom", "right" ], function( i, pos ) {
					props[ pos ] = element.css( pos );
					if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
						props[ pos ] = "auto";
					}
				} );
				element.css( {
					position: "relative",
					top: 0,
					left: 0,
					right: "auto",
					bottom: "auto"
				} );
			}
			element.css( size );

			return wrapper.css( props ).show();
		},

		removeWrapper: function( element ) {
			var active = document.activeElement;

			if ( element.parent().is( ".ui-effects-wrapper" ) ) {
				element.parent().replaceWith( element );

				// Fixes #7595 - Elements lose focus when wrapped.
				if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
					$( active ).trigger( "focus" );
				}
			}

			return element;
		}
	} );
}

$.extend( $.effects, {
	version: "1.12.1",

	define: function( name, mode, effect ) {
		if ( !effect ) {
			effect = mode;
			mode = "effect";
		}

		$.effects.effect[ name ] = effect;
		$.effects.effect[ name ].mode = mode;

		return effect;
	},

	scaledDimensions: function( element, percent, direction ) {
		if ( percent === 0 ) {
			return {
				height: 0,
				width: 0,
				outerHeight: 0,
				outerWidth: 0
			};
		}

		var x = direction !== "horizontal" ? ( ( percent || 100 ) / 100 ) : 1,
			y = direction !== "vertical" ? ( ( percent || 100 ) / 100 ) : 1;

		return {
			height: element.height() * y,
			width: element.width() * x,
			outerHeight: element.outerHeight() * y,
			outerWidth: element.outerWidth() * x
		};

	},

	clipToBox: function( animation ) {
		return {
			width: animation.clip.right - animation.clip.left,
			height: animation.clip.bottom - animation.clip.top,
			left: animation.clip.left,
			top: animation.clip.top
		};
	},

	// Injects recently queued functions to be first in line (after "inprogress")
	unshift: function( element, queueLength, count ) {
		var queue = element.queue();

		if ( queueLength > 1 ) {
			queue.splice.apply( queue,
				[ 1, 0 ].concat( queue.splice( queueLength, count ) ) );
		}
		element.dequeue();
	},

	saveStyle: function( element ) {
		element.data( dataSpaceStyle, element[ 0 ].style.cssText );
	},

	restoreStyle: function( element ) {
		element[ 0 ].style.cssText = element.data( dataSpaceStyle ) || "";
		element.removeData( dataSpaceStyle );
	},

	mode: function( element, mode ) {
		var hidden = element.is( ":hidden" );

		if ( mode === "toggle" ) {
			mode = hidden ? "show" : "hide";
		}
		if ( hidden ? mode === "hide" : mode === "show" ) {
			mode = "none";
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	getBaseline: function( origin, original ) {
		var y, x;

		switch ( origin[ 0 ] ) {
		case "top":
			y = 0;
			break;
		case "middle":
			y = 0.5;
			break;
		case "bottom":
			y = 1;
			break;
		default:
			y = origin[ 0 ] / original.height;
		}

		switch ( origin[ 1 ] ) {
		case "left":
			x = 0;
			break;
		case "center":
			x = 0.5;
			break;
		case "right":
			x = 1;
			break;
		default:
			x = origin[ 1 ] / original.width;
		}

		return {
			x: x,
			y: y
		};
	},

	// Creates a placeholder element so that the original element can be made absolute
	createPlaceholder: function( element ) {
		var placeholder,
			cssPosition = element.css( "position" ),
			position = element.position();

		// Lock in margins first to account for form elements, which
		// will change margin if you explicitly set height
		// see: http://jsfiddle.net/JZSMt/3/ https://bugs.webkit.org/show_bug.cgi?id=107380
		// Support: Safari
		element.css( {
			marginTop: element.css( "marginTop" ),
			marginBottom: element.css( "marginBottom" ),
			marginLeft: element.css( "marginLeft" ),
			marginRight: element.css( "marginRight" )
		} )
		.outerWidth( element.outerWidth() )
		.outerHeight( element.outerHeight() );

		if ( /^(static|relative)/.test( cssPosition ) ) {
			cssPosition = "absolute";

			placeholder = $( "<" + element[ 0 ].nodeName + ">" ).insertAfter( element ).css( {

				// Convert inline to inline block to account for inline elements
				// that turn to inline block based on content (like img)
				display: /^(inline|ruby)/.test( element.css( "display" ) ) ?
					"inline-block" :
					"block",
				visibility: "hidden",

				// Margins need to be set to account for margin collapse
				marginTop: element.css( "marginTop" ),
				marginBottom: element.css( "marginBottom" ),
				marginLeft: element.css( "marginLeft" ),
				marginRight: element.css( "marginRight" ),
				"float": element.css( "float" )
			} )
			.outerWidth( element.outerWidth() )
			.outerHeight( element.outerHeight() )
			.addClass( "ui-effects-placeholder" );

			element.data( dataSpace + "placeholder", placeholder );
		}

		element.css( {
			position: cssPosition,
			left: position.left,
			top: position.top
		} );

		return placeholder;
	},

	removePlaceholder: function( element ) {
		var dataKey = dataSpace + "placeholder",
				placeholder = element.data( dataKey );

		if ( placeholder ) {
			placeholder.remove();
			element.removeData( dataKey );
		}
	},

	// Removes a placeholder if it exists and restores
	// properties that were modified during placeholder creation
	cleanUp: function( element ) {
		$.effects.restoreStyle( element );
		$.effects.removePlaceholder( element );
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] > 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		} );
		return value;
	}
} );

// Return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// Allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// Convert to an object
	effect = { effect: effect };

	// Catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	// Catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// Catch (effect, speed, ?)
	if ( typeof options === "number" || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// Catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// Add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === "number" ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardAnimationOption( option ) {

	// Valid standard speeds (nothing, number, named speed)
	if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
		return true;
	}

	// Invalid strings - treat as "normal" speed
	if ( typeof option === "string" && !$.effects.effect[ option ] ) {
		return true;
	}

	// Complete callback
	if ( $.isFunction( option ) ) {
		return true;
	}

	// Options hash (but not naming an effect)
	if ( typeof option === "object" && !option.effect ) {
		return true;
	}

	// Didn't match any standard API
	return false;
}

$.fn.extend( {
	effect: function( /* effect, options, speed, callback */ ) {
		var args = _normalizeArguments.apply( this, arguments ),
			effectMethod = $.effects.effect[ args.effect ],
			defaultMode = effectMethod.mode,
			queue = args.queue,
			queueName = queue || "fx",
			complete = args.complete,
			mode = args.mode,
			modes = [],
			prefilter = function( next ) {
				var el = $( this ),
					normalizedMode = $.effects.mode( el, mode ) || defaultMode;

				// Sentinel for duck-punching the :animated psuedo-selector
				el.data( dataSpaceAnimated, true );

				// Save effect mode for later use,
				// we can't just call $.effects.mode again later,
				// as the .show() below destroys the initial state
				modes.push( normalizedMode );

				// See $.uiBackCompat inside of run() for removal of defaultMode in 1.13
				if ( defaultMode && ( normalizedMode === "show" ||
						( normalizedMode === defaultMode && normalizedMode === "hide" ) ) ) {
					el.show();
				}

				if ( !defaultMode || normalizedMode !== "none" ) {
					$.effects.saveStyle( el );
				}

				if ( $.isFunction( next ) ) {
					next();
				}
			};

		if ( $.fx.off || !effectMethod ) {

			// Delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, complete );
			} else {
				return this.each( function() {
					if ( complete ) {
						complete.call( this );
					}
				} );
			}
		}

		function run( next ) {
			var elem = $( this );

			function cleanup() {
				elem.removeData( dataSpaceAnimated );

				$.effects.cleanUp( elem );

				if ( args.mode === "hide" ) {
					elem.hide();
				}

				done();
			}

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[ 0 ] );
				}

				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// Override mode option on a per element basis,
			// as toggle can be either show or hide depending on element state
			args.mode = modes.shift();

			if ( $.uiBackCompat !== false && !defaultMode ) {
				if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {

					// Call the core method to track "olddisplay" properly
					elem[ mode ]();
					done();
				} else {
					effectMethod.call( elem[ 0 ], args, done );
				}
			} else {
				if ( args.mode === "none" ) {

					// Call the core method to track "olddisplay" properly
					elem[ mode ]();
					done();
				} else {
					effectMethod.call( elem[ 0 ], args, cleanup );
				}
			}
		}

		// Run prefilter on all elements first to ensure that
		// any showing or hiding happens before placeholder creation,
		// which ensures that any layout changes are correctly captured.
		return queue === false ?
			this.each( prefilter ).each( run ) :
			this.queue( queueName, prefilter ).queue( queueName, run );
	},

	show: ( function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "show";
				return this.effect.call( this, args );
			}
		};
	} )( $.fn.show ),

	hide: ( function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "hide";
				return this.effect.call( this, args );
			}
		};
	} )( $.fn.hide ),

	toggle: ( function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "toggle";
				return this.effect.call( this, args );
			}
		};
	} )( $.fn.toggle ),

	cssUnit: function( key ) {
		var style = this.css( key ),
			val = [];

		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
			if ( style.indexOf( unit ) > 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		} );
		return val;
	},

	cssClip: function( clipObj ) {
		if ( clipObj ) {
			return this.css( "clip", "rect(" + clipObj.top + "px " + clipObj.right + "px " +
				clipObj.bottom + "px " + clipObj.left + "px)" );
		}
		return parseClip( this.css( "clip" ), this );
	},

	transfer: function( options, done ) {
		var element = $( this ),
			target = $( options.to ),
			targetFixed = target.css( "position" ) === "fixed",
			body = $( "body" ),
			fixTop = targetFixed ? body.scrollTop() : 0,
			fixLeft = targetFixed ? body.scrollLeft() : 0,
			endPosition = target.offset(),
			animation = {
				top: endPosition.top - fixTop,
				left: endPosition.left - fixLeft,
				height: target.innerHeight(),
				width: target.innerWidth()
			},
			startPosition = element.offset(),
			transfer = $( "<div class='ui-effects-transfer'></div>" )
				.appendTo( "body" )
				.addClass( options.className )
				.css( {
					top: startPosition.top - fixTop,
					left: startPosition.left - fixLeft,
					height: element.innerHeight(),
					width: element.innerWidth(),
					position: targetFixed ? "fixed" : "absolute"
				} )
				.animate( animation, options.duration, options.easing, function() {
					transfer.remove();
					if ( $.isFunction( done ) ) {
						done();
					}
				} );
	}
} );

function parseClip( str, element ) {
		var outerWidth = element.outerWidth(),
			outerHeight = element.outerHeight(),
			clipRegex = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,
			values = clipRegex.exec( str ) || [ "", 0, outerWidth, outerHeight, 0 ];

		return {
			top: parseFloat( values[ 1 ] ) || 0,
			right: values[ 2 ] === "auto" ? outerWidth : parseFloat( values[ 2 ] ),
			bottom: values[ 3 ] === "auto" ? outerHeight : parseFloat( values[ 3 ] ),
			left: parseFloat( values[ 4 ] ) || 0
		};
}

$.fx.step.clip = function( fx ) {
	if ( !fx.clipInit ) {
		fx.start = $( fx.elem ).cssClip();
		if ( typeof fx.end === "string" ) {
			fx.end = parseClip( fx.end, fx.elem );
		}
		fx.clipInit = true;
	}

	$( fx.elem ).cssClip( {
		top: fx.pos * ( fx.end.top - fx.start.top ) + fx.start.top,
		right: fx.pos * ( fx.end.right - fx.start.right ) + fx.start.right,
		bottom: fx.pos * ( fx.end.bottom - fx.start.bottom ) + fx.start.bottom,
		left: fx.pos * ( fx.end.left - fx.start.left ) + fx.start.left
	} );
};

} )();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

( function() {

// Based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
} );

$.extend( baseEasings, {
	Sine: function( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * ( p - 1 ) ) * Math.sin( ( ( p - 1 ) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function( p ) {
		var pow2,
			bounce = 4;

		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
} );

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ "easeIn" + name ] = easeIn;
	$.easing[ "easeOut" + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ "easeInOut" + name ] = function( p ) {
		return p < 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
} );

} )();

var effect = $.effects;


/*!
 * jQuery UI Effects Blind 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Blind Effect
//>>group: Effects
//>>description: Blinds the element.
//>>docs: http://api.jqueryui.com/blind-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectBlind = $.effects.define( "blind", "hide", function( options, done ) {
	var map = {
			up: [ "bottom", "top" ],
			vertical: [ "bottom", "top" ],
			down: [ "top", "bottom" ],
			left: [ "right", "left" ],
			horizontal: [ "right", "left" ],
			right: [ "left", "right" ]
		},
		element = $( this ),
		direction = options.direction || "up",
		start = element.cssClip(),
		animate = { clip: $.extend( {}, start ) },
		placeholder = $.effects.createPlaceholder( element );

	animate.clip[ map[ direction ][ 0 ] ] = animate.clip[ map[ direction ][ 1 ] ];

	if ( options.mode === "show" ) {
		element.cssClip( animate.clip );
		if ( placeholder ) {
			placeholder.css( $.effects.clipToBox( animate ) );
		}

		animate.clip = start;
	}

	if ( placeholder ) {
		placeholder.animate( $.effects.clipToBox( animate ), options.duration, options.easing );
	}

	element.animate( animate, {
		queue: false,
		duration: options.duration,
		easing: options.easing,
		complete: done
	} );
} );


/*!
 * jQuery UI Effects Bounce 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Bounce Effect
//>>group: Effects
//>>description: Bounces an element horizontally or vertically n times.
//>>docs: http://api.jqueryui.com/bounce-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectBounce = $.effects.define( "bounce", function( options, done ) {
	var upAnim, downAnim, refValue,
		element = $( this ),

		// Defaults:
		mode = options.mode,
		hide = mode === "hide",
		show = mode === "show",
		direction = options.direction || "up",
		distance = options.distance,
		times = options.times || 5,

		// Number of internal animations
		anims = times * 2 + ( show || hide ? 1 : 0 ),
		speed = options.duration / anims,
		easing = options.easing,

		// Utility:
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ),
		i = 0,

		queuelen = element.queue().length;

	$.effects.createPlaceholder( element );

	refValue = element.css( ref );

	// Default distance for the BIGGEST bounce is the outer Distance / 3
	if ( !distance ) {
		distance = element[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
	}

	if ( show ) {
		downAnim = { opacity: 1 };
		downAnim[ ref ] = refValue;

		// If we are showing, force opacity 0 and set the initial position
		// then do the "first" animation
		element
			.css( "opacity", 0 )
			.css( ref, motion ? -distance * 2 : distance * 2 )
			.animate( downAnim, speed, easing );
	}

	// Start at the smallest distance if we are hiding
	if ( hide ) {
		distance = distance / Math.pow( 2, times - 1 );
	}

	downAnim = {};
	downAnim[ ref ] = refValue;

	// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
	for ( ; i < times; i++ ) {
		upAnim = {};
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		element
			.animate( upAnim, speed, easing )
			.animate( downAnim, speed, easing );

		distance = hide ? distance * 2 : distance / 2;
	}

	// Last Bounce when Hiding
	if ( hide ) {
		upAnim = { opacity: 0 };
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		element.animate( upAnim, speed, easing );
	}

	element.queue( done );

	$.effects.unshift( element, queuelen, anims + 1 );
} );


/*!
 * jQuery UI Effects Clip 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Clip Effect
//>>group: Effects
//>>description: Clips the element on and off like an old TV.
//>>docs: http://api.jqueryui.com/clip-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectClip = $.effects.define( "clip", "hide", function( options, done ) {
	var start,
		animate = {},
		element = $( this ),
		direction = options.direction || "vertical",
		both = direction === "both",
		horizontal = both || direction === "horizontal",
		vertical = both || direction === "vertical";

	start = element.cssClip();
	animate.clip = {
		top: vertical ? ( start.bottom - start.top ) / 2 : start.top,
		right: horizontal ? ( start.right - start.left ) / 2 : start.right,
		bottom: vertical ? ( start.bottom - start.top ) / 2 : start.bottom,
		left: horizontal ? ( start.right - start.left ) / 2 : start.left
	};

	$.effects.createPlaceholder( element );

	if ( options.mode === "show" ) {
		element.cssClip( animate.clip );
		animate.clip = start;
	}

	element.animate( animate, {
		queue: false,
		duration: options.duration,
		easing: options.easing,
		complete: done
	} );

} );


/*!
 * jQuery UI Effects Drop 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Drop Effect
//>>group: Effects
//>>description: Moves an element in one direction and hides it at the same time.
//>>docs: http://api.jqueryui.com/drop-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectDrop = $.effects.define( "drop", "hide", function( options, done ) {

	var distance,
		element = $( this ),
		mode = options.mode,
		show = mode === "show",
		direction = options.direction || "left",
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ) ? "-=" : "+=",
		oppositeMotion = ( motion === "+=" ) ? "-=" : "+=",
		animation = {
			opacity: 0
		};

	$.effects.createPlaceholder( element );

	distance = options.distance ||
		element[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ) / 2;

	animation[ ref ] = motion + distance;

	if ( show ) {
		element.css( animation );

		animation[ ref ] = oppositeMotion + distance;
		animation.opacity = 1;
	}

	// Animate
	element.animate( animation, {
		queue: false,
		duration: options.duration,
		easing: options.easing,
		complete: done
	} );
} );


/*!
 * jQuery UI Effects Explode 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Explode Effect
//>>group: Effects
// jscs:disable maximumLineLength
//>>description: Explodes an element in all directions into n pieces. Implodes an element to its original wholeness.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/explode-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectExplode = $.effects.define( "explode", "hide", function( options, done ) {

	var i, j, left, top, mx, my,
		rows = options.pieces ? Math.round( Math.sqrt( options.pieces ) ) : 3,
		cells = rows,
		element = $( this ),
		mode = options.mode,
		show = mode === "show",

		// Show and then visibility:hidden the element before calculating offset
		offset = element.show().css( "visibility", "hidden" ).offset(),

		// Width and height of a piece
		width = Math.ceil( element.outerWidth() / cells ),
		height = Math.ceil( element.outerHeight() / rows ),
		pieces = [];

	// Children animate complete:
	function childComplete() {
		pieces.push( this );
		if ( pieces.length === rows * cells ) {
			animComplete();
		}
	}

	// Clone the element for each row and cell.
	for ( i = 0; i < rows; i++ ) { // ===>
		top = offset.top + i * height;
		my = i - ( rows - 1 ) / 2;

		for ( j = 0; j < cells; j++ ) { // |||
			left = offset.left + j * width;
			mx = j - ( cells - 1 ) / 2;

			// Create a clone of the now hidden main element that will be absolute positioned
			// within a wrapper div off the -left and -top equal to size of our pieces
			element
				.clone()
				.appendTo( "body" )
				.wrap( "<div></div>" )
				.css( {
					position: "absolute",
					visibility: "visible",
					left: -j * width,
					top: -i * height
				} )

				// Select the wrapper - make it overflow: hidden and absolute positioned based on
				// where the original was located +left and +top equal to the size of pieces
				.parent()
					.addClass( "ui-effects-explode" )
					.css( {
						position: "absolute",
						overflow: "hidden",
						width: width,
						height: height,
						left: left + ( show ? mx * width : 0 ),
						top: top + ( show ? my * height : 0 ),
						opacity: show ? 0 : 1
					} )
					.animate( {
						left: left + ( show ? 0 : mx * width ),
						top: top + ( show ? 0 : my * height ),
						opacity: show ? 1 : 0
					}, options.duration || 500, options.easing, childComplete );
		}
	}

	function animComplete() {
		element.css( {
			visibility: "visible"
		} );
		$( pieces ).remove();
		done();
	}
} );


/*!
 * jQuery UI Effects Fade 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Fade Effect
//>>group: Effects
//>>description: Fades the element.
//>>docs: http://api.jqueryui.com/fade-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectFade = $.effects.define( "fade", "toggle", function( options, done ) {
	var show = options.mode === "show";

	$( this )
		.css( "opacity", show ? 0 : 1 )
		.animate( {
			opacity: show ? 1 : 0
		}, {
			queue: false,
			duration: options.duration,
			easing: options.easing,
			complete: done
		} );
} );


/*!
 * jQuery UI Effects Fold 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Fold Effect
//>>group: Effects
//>>description: Folds an element first horizontally and then vertically.
//>>docs: http://api.jqueryui.com/fold-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectFold = $.effects.define( "fold", "hide", function( options, done ) {

	// Create element
	var element = $( this ),
		mode = options.mode,
		show = mode === "show",
		hide = mode === "hide",
		size = options.size || 15,
		percent = /([0-9]+)%/.exec( size ),
		horizFirst = !!options.horizFirst,
		ref = horizFirst ? [ "right", "bottom" ] : [ "bottom", "right" ],
		duration = options.duration / 2,

		placeholder = $.effects.createPlaceholder( element ),

		start = element.cssClip(),
		animation1 = { clip: $.extend( {}, start ) },
		animation2 = { clip: $.extend( {}, start ) },

		distance = [ start[ ref[ 0 ] ], start[ ref[ 1 ] ] ],

		queuelen = element.queue().length;

	if ( percent ) {
		size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
	}
	animation1.clip[ ref[ 0 ] ] = size;
	animation2.clip[ ref[ 0 ] ] = size;
	animation2.clip[ ref[ 1 ] ] = 0;

	if ( show ) {
		element.cssClip( animation2.clip );
		if ( placeholder ) {
			placeholder.css( $.effects.clipToBox( animation2 ) );
		}

		animation2.clip = start;
	}

	// Animate
	element
		.queue( function( next ) {
			if ( placeholder ) {
				placeholder
					.animate( $.effects.clipToBox( animation1 ), duration, options.easing )
					.animate( $.effects.clipToBox( animation2 ), duration, options.easing );
			}

			next();
		} )
		.animate( animation1, duration, options.easing )
		.animate( animation2, duration, options.easing )
		.queue( done );

	$.effects.unshift( element, queuelen, 4 );
} );


/*!
 * jQuery UI Effects Highlight 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Highlight Effect
//>>group: Effects
//>>description: Highlights the background of an element in a defined color for a custom duration.
//>>docs: http://api.jqueryui.com/highlight-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectHighlight = $.effects.define( "highlight", "show", function( options, done ) {
	var element = $( this ),
		animation = {
			backgroundColor: element.css( "backgroundColor" )
		};

	if ( options.mode === "hide" ) {
		animation.opacity = 0;
	}

	$.effects.saveStyle( element );

	element
		.css( {
			backgroundImage: "none",
			backgroundColor: options.color || "#ffff99"
		} )
		.animate( animation, {
			queue: false,
			duration: options.duration,
			easing: options.easing,
			complete: done
		} );
} );


/*!
 * jQuery UI Effects Size 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Size Effect
//>>group: Effects
//>>description: Resize an element to a specified width and height.
//>>docs: http://api.jqueryui.com/size-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectSize = $.effects.define( "size", function( options, done ) {

	// Create element
	var baseline, factor, temp,
		element = $( this ),

		// Copy for children
		cProps = [ "fontSize" ],
		vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
		hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],

		// Set options
		mode = options.mode,
		restore = mode !== "effect",
		scale = options.scale || "both",
		origin = options.origin || [ "middle", "center" ],
		position = element.css( "position" ),
		pos = element.position(),
		original = $.effects.scaledDimensions( element ),
		from = options.from || original,
		to = options.to || $.effects.scaledDimensions( element, 0 );

	$.effects.createPlaceholder( element );

	if ( mode === "show" ) {
		temp = from;
		from = to;
		to = temp;
	}

	// Set scaling factor
	factor = {
		from: {
			y: from.height / original.height,
			x: from.width / original.width
		},
		to: {
			y: to.height / original.height,
			x: to.width / original.width
		}
	};

	// Scale the css box
	if ( scale === "box" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			from = $.effects.setTransition( element, vProps, factor.from.y, from );
			to = $.effects.setTransition( element, vProps, factor.to.y, to );
		}

		// Horizontal props scaling
		if ( factor.from.x !== factor.to.x ) {
			from = $.effects.setTransition( element, hProps, factor.from.x, from );
			to = $.effects.setTransition( element, hProps, factor.to.x, to );
		}
	}

	// Scale the content
	if ( scale === "content" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			from = $.effects.setTransition( element, cProps, factor.from.y, from );
			to = $.effects.setTransition( element, cProps, factor.to.y, to );
		}
	}

	// Adjust the position properties based on the provided origin points
	if ( origin ) {
		baseline = $.effects.getBaseline( origin, original );
		from.top = ( original.outerHeight - from.outerHeight ) * baseline.y + pos.top;
		from.left = ( original.outerWidth - from.outerWidth ) * baseline.x + pos.left;
		to.top = ( original.outerHeight - to.outerHeight ) * baseline.y + pos.top;
		to.left = ( original.outerWidth - to.outerWidth ) * baseline.x + pos.left;
	}
	element.css( from );

	// Animate the children if desired
	if ( scale === "content" || scale === "both" ) {

		vProps = vProps.concat( [ "marginTop", "marginBottom" ] ).concat( cProps );
		hProps = hProps.concat( [ "marginLeft", "marginRight" ] );

		// Only animate children with width attributes specified
		// TODO: is this right? should we include anything with css width specified as well
		element.find( "*[width]" ).each( function() {
			var child = $( this ),
				childOriginal = $.effects.scaledDimensions( child ),
				childFrom = {
					height: childOriginal.height * factor.from.y,
					width: childOriginal.width * factor.from.x,
					outerHeight: childOriginal.outerHeight * factor.from.y,
					outerWidth: childOriginal.outerWidth * factor.from.x
				},
				childTo = {
					height: childOriginal.height * factor.to.y,
					width: childOriginal.width * factor.to.x,
					outerHeight: childOriginal.height * factor.to.y,
					outerWidth: childOriginal.width * factor.to.x
				};

			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				childFrom = $.effects.setTransition( child, vProps, factor.from.y, childFrom );
				childTo = $.effects.setTransition( child, vProps, factor.to.y, childTo );
			}

			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				childFrom = $.effects.setTransition( child, hProps, factor.from.x, childFrom );
				childTo = $.effects.setTransition( child, hProps, factor.to.x, childTo );
			}

			if ( restore ) {
				$.effects.saveStyle( child );
			}

			// Animate children
			child.css( childFrom );
			child.animate( childTo, options.duration, options.easing, function() {

				// Restore children
				if ( restore ) {
					$.effects.restoreStyle( child );
				}
			} );
		} );
	}

	// Animate
	element.animate( to, {
		queue: false,
		duration: options.duration,
		easing: options.easing,
		complete: function() {

			var offset = element.offset();

			if ( to.opacity === 0 ) {
				element.css( "opacity", from.opacity );
			}

			if ( !restore ) {
				element
					.css( "position", position === "static" ? "relative" : position )
					.offset( offset );

				// Need to save style here so that automatic style restoration
				// doesn't restore to the original styles from before the animation.
				$.effects.saveStyle( element );
			}

			done();
		}
	} );

} );


/*!
 * jQuery UI Effects Scale 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Scale Effect
//>>group: Effects
//>>description: Grows or shrinks an element and its content.
//>>docs: http://api.jqueryui.com/scale-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectScale = $.effects.define( "scale", function( options, done ) {

	// Create element
	var el = $( this ),
		mode = options.mode,
		percent = parseInt( options.percent, 10 ) ||
			( parseInt( options.percent, 10 ) === 0 ? 0 : ( mode !== "effect" ? 0 : 100 ) ),

		newOptions = $.extend( true, {
			from: $.effects.scaledDimensions( el ),
			to: $.effects.scaledDimensions( el, percent, options.direction || "both" ),
			origin: options.origin || [ "middle", "center" ]
		}, options );

	// Fade option to support puff
	if ( options.fade ) {
		newOptions.from.opacity = 1;
		newOptions.to.opacity = 0;
	}

	$.effects.effect.size.call( this, newOptions, done );
} );


/*!
 * jQuery UI Effects Puff 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Puff Effect
//>>group: Effects
//>>description: Creates a puff effect by scaling the element up and hiding it at the same time.
//>>docs: http://api.jqueryui.com/puff-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectPuff = $.effects.define( "puff", "hide", function( options, done ) {
	var newOptions = $.extend( true, {}, options, {
		fade: true,
		percent: parseInt( options.percent, 10 ) || 150
	} );

	$.effects.effect.scale.call( this, newOptions, done );
} );


/*!
 * jQuery UI Effects Pulsate 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Pulsate Effect
//>>group: Effects
//>>description: Pulsates an element n times by changing the opacity to zero and back.
//>>docs: http://api.jqueryui.com/pulsate-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectPulsate = $.effects.define( "pulsate", "show", function( options, done ) {
	var element = $( this ),
		mode = options.mode,
		show = mode === "show",
		hide = mode === "hide",
		showhide = show || hide,

		// Showing or hiding leaves off the "last" animation
		anims = ( ( options.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
		duration = options.duration / anims,
		animateTo = 0,
		i = 1,
		queuelen = element.queue().length;

	if ( show || !element.is( ":visible" ) ) {
		element.css( "opacity", 0 ).show();
		animateTo = 1;
	}

	// Anims - 1 opacity "toggles"
	for ( ; i < anims; i++ ) {
		element.animate( { opacity: animateTo }, duration, options.easing );
		animateTo = 1 - animateTo;
	}

	element.animate( { opacity: animateTo }, duration, options.easing );

	element.queue( done );

	$.effects.unshift( element, queuelen, anims + 1 );
} );


/*!
 * jQuery UI Effects Shake 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Shake Effect
//>>group: Effects
//>>description: Shakes an element horizontally or vertically n times.
//>>docs: http://api.jqueryui.com/shake-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectShake = $.effects.define( "shake", function( options, done ) {

	var i = 1,
		element = $( this ),
		direction = options.direction || "left",
		distance = options.distance || 20,
		times = options.times || 3,
		anims = times * 2 + 1,
		speed = Math.round( options.duration / anims ),
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		positiveMotion = ( direction === "up" || direction === "left" ),
		animation = {},
		animation1 = {},
		animation2 = {},

		queuelen = element.queue().length;

	$.effects.createPlaceholder( element );

	// Animation
	animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
	animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
	animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;

	// Animate
	element.animate( animation, speed, options.easing );

	// Shakes
	for ( ; i < times; i++ ) {
		element
			.animate( animation1, speed, options.easing )
			.animate( animation2, speed, options.easing );
	}

	element
		.animate( animation1, speed, options.easing )
		.animate( animation, speed / 2, options.easing )
		.queue( done );

	$.effects.unshift( element, queuelen, anims + 1 );
} );


/*!
 * jQuery UI Effects Slide 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Slide Effect
//>>group: Effects
//>>description: Slides an element in and out of the viewport.
//>>docs: http://api.jqueryui.com/slide-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectSlide = $.effects.define( "slide", "show", function( options, done ) {
	var startClip, startRef,
		element = $( this ),
		map = {
			up: [ "bottom", "top" ],
			down: [ "top", "bottom" ],
			left: [ "right", "left" ],
			right: [ "left", "right" ]
		},
		mode = options.mode,
		direction = options.direction || "left",
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		positiveMotion = ( direction === "up" || direction === "left" ),
		distance = options.distance ||
			element[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ),
		animation = {};

	$.effects.createPlaceholder( element );

	startClip = element.cssClip();
	startRef = element.position()[ ref ];

	// Define hide animation
	animation[ ref ] = ( positiveMotion ? -1 : 1 ) * distance + startRef;
	animation.clip = element.cssClip();
	animation.clip[ map[ direction ][ 1 ] ] = animation.clip[ map[ direction ][ 0 ] ];

	// Reverse the animation if we're showing
	if ( mode === "show" ) {
		element.cssClip( animation.clip );
		element.css( ref, animation[ ref ] );
		animation.clip = startClip;
		animation[ ref ] = startRef;
	}

	// Actually animate
	element.animate( animation, {
		queue: false,
		duration: options.duration,
		easing: options.easing,
		complete: done
	} );
} );


/*!
 * jQuery UI Effects Transfer 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Transfer Effect
//>>group: Effects
//>>description: Displays a transfer effect from one element to another.
//>>docs: http://api.jqueryui.com/transfer-effect/
//>>demos: http://jqueryui.com/effect/



var effect;
if ( $.uiBackCompat !== false ) {
	effect = $.effects.define( "transfer", function( options, done ) {
		$( this ).transfer( options, done );
	} );
}
var effectsEffectTransfer = effect;


/*!
 * jQuery UI Focusable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :focusable Selector
//>>group: Core
//>>description: Selects elements which can be focused.
//>>docs: http://api.jqueryui.com/focusable-selector/



// Selectors
$.ui.focusable = function( element, hasTabindex ) {
	var map, mapName, img, focusableIfVisible, fieldset,
		nodeName = element.nodeName.toLowerCase();

	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap='#" + mapName + "']" );
		return img.length > 0 && img.is( ":visible" );
	}

	if ( /^(input|select|textarea|button|object)$/.test( nodeName ) ) {
		focusableIfVisible = !element.disabled;

		if ( focusableIfVisible ) {

			// Form controls within a disabled fieldset are disabled.
			// However, controls within the fieldset's legend do not get disabled.
			// Since controls generally aren't placed inside legends, we skip
			// this portion of the check.
			fieldset = $( element ).closest( "fieldset" )[ 0 ];
			if ( fieldset ) {
				focusableIfVisible = !fieldset.disabled;
			}
		}
	} else if ( "a" === nodeName ) {
		focusableIfVisible = element.href || hasTabindex;
	} else {
		focusableIfVisible = hasTabindex;
	}

	return focusableIfVisible && $( element ).is( ":visible" ) && visible( $( element ) );
};

// Support: IE 8 only
// IE 8 doesn't resolve inherit to visible/hidden for computed values
function visible( element ) {
	var visibility = element.css( "visibility" );
	while ( visibility === "inherit" ) {
		element = element.parent();
		visibility = element.css( "visibility" );
	}
	return visibility !== "hidden";
}

$.extend( $.expr[ ":" ], {
	focusable: function( element ) {
		return $.ui.focusable( element, $.attr( element, "tabindex" ) != null );
	}
} );

var focusable = $.ui.focusable;




// Support: IE8 Only
// IE8 does not support the form attribute and when it is supplied. It overwrites the form prop
// with a string, so we need to find the proper form.
var form = $.fn.form = function() {
	return typeof this[ 0 ].form === "string" ? this.closest( "form" ) : $( this[ 0 ].form );
};


/*!
 * jQuery UI Form Reset Mixin 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Form Reset Mixin
//>>group: Core
//>>description: Refresh input widgets when their form is reset
//>>docs: http://api.jqueryui.com/form-reset-mixin/



var formResetMixin = $.ui.formResetMixin = {
	_formResetHandler: function() {
		var form = $( this );

		// Wait for the form reset to actually happen before refreshing
		setTimeout( function() {
			var instances = form.data( "ui-form-reset-instances" );
			$.each( instances, function() {
				this.refresh();
			} );
		} );
	},

	_bindFormResetHandler: function() {
		this.form = this.element.form();
		if ( !this.form.length ) {
			return;
		}

		var instances = this.form.data( "ui-form-reset-instances" ) || [];
		if ( !instances.length ) {

			// We don't use _on() here because we use a single event handler per form
			this.form.on( "reset.ui-form-reset", this._formResetHandler );
		}
		instances.push( this );
		this.form.data( "ui-form-reset-instances", instances );
	},

	_unbindFormResetHandler: function() {
		if ( !this.form.length ) {
			return;
		}

		var instances = this.form.data( "ui-form-reset-instances" );
		instances.splice( $.inArray( this, instances ), 1 );
		if ( instances.length ) {
			this.form.data( "ui-form-reset-instances", instances );
		} else {
			this.form
				.removeData( "ui-form-reset-instances" )
				.off( "reset.ui-form-reset" );
		}
	}
};


/*!
 * jQuery UI Support for jQuery core 1.7.x 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 */

//>>label: jQuery 1.7 Support
//>>group: Core
//>>description: Support version 1.7.x of jQuery core



// Support: jQuery 1.7 only
// Not a great way to check versions, but since we only support 1.7+ and only
// need to detect <1.8, this is a simple check that should suffice. Checking
// for "1.7." would be a bit safer, but the version string is 1.7, not 1.7.0
// and we'll never reach 1.70.0 (if we do, we certainly won't be supporting
// 1.7 anymore). See #11197 for why we're not using feature detection.
if ( $.fn.jquery.substring( 0, 3 ) === "1.7" ) {

	// Setters for .innerWidth(), .innerHeight(), .outerWidth(), .outerHeight()
	// Unlike jQuery Core 1.8+, these only support numeric values to set the
	// dimensions in pixels
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			} );
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each( function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			} );
		};

		$.fn[ "outer" + name ] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each( function() {
				$( this ).css( type, reduce( this, size, true, margin ) + "px" );
			} );
		};
	} );

	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

;
/*!
 * jQuery UI Keycode 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Keycode
//>>group: Core
//>>description: Provide keycodes as keynames
//>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/


var keycode = $.ui.keyCode = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	END: 35,
	ENTER: 13,
	ESCAPE: 27,
	HOME: 36,
	LEFT: 37,
	PAGE_DOWN: 34,
	PAGE_UP: 33,
	PERIOD: 190,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};




// Internal use only
var escapeSelector = $.ui.escapeSelector = ( function() {
	var selectorEscape = /([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g;
	return function( selector ) {
		return selector.replace( selectorEscape, "\\$1" );
	};
} )();


/*!
 * jQuery UI Labels 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: labels
//>>group: Core
//>>description: Find all the labels associated with a given input
//>>docs: http://api.jqueryui.com/labels/



var labels = $.fn.labels = function() {
	var ancestor, selector, id, labels, ancestors;

	// Check control.labels first
	if ( this[ 0 ].labels && this[ 0 ].labels.length ) {
		return this.pushStack( this[ 0 ].labels );
	}

	// Support: IE <= 11, FF <= 37, Android <= 2.3 only
	// Above browsers do not support control.labels. Everything below is to support them
	// as well as document fragments. control.labels does not work on document fragments
	labels = this.eq( 0 ).parents( "label" );

	// Look for the label based on the id
	id = this.attr( "id" );
	if ( id ) {

		// We don't search against the document in case the element
		// is disconnected from the DOM
		ancestor = this.eq( 0 ).parents().last();

		// Get a full set of top level ancestors
		ancestors = ancestor.add( ancestor.length ? ancestor.siblings() : this.siblings() );

		// Create a selector for the label based on the id
		selector = "label[for='" + $.ui.escapeSelector( id ) + "']";

		labels = labels.add( ancestors.find( selector ).addBack( selector ) );

	}

	// Return whatever we have found for labels
	return this.pushStack( labels );
};


/*!
 * jQuery UI Scroll Parent 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: scrollParent
//>>group: Core
//>>description: Get the closest ancestor element that is scrollable.
//>>docs: http://api.jqueryui.com/scrollParent/



var scrollParent = $.fn.scrollParent = function( includeHidden ) {
	var position = this.css( "position" ),
		excludeStaticParent = position === "absolute",
		overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
		scrollParent = this.parents().filter( function() {
			var parent = $( this );
			if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
				return false;
			}
			return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
				parent.css( "overflow-x" ) );
		} ).eq( 0 );

	return position === "fixed" || !scrollParent.length ?
		$( this[ 0 ].ownerDocument || document ) :
		scrollParent;
};


/*!
 * jQuery UI Tabbable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :tabbable Selector
//>>group: Core
//>>description: Selects elements which can be tabbed to.
//>>docs: http://api.jqueryui.com/tabbable-selector/



var tabbable = $.extend( $.expr[ ":" ], {
	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			hasTabindex = tabIndex != null;
		return ( !hasTabindex || tabIndex >= 0 ) && $.ui.focusable( element, hasTabindex );
	}
} );


/*!
 * jQuery UI Unique ID 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: uniqueId
//>>group: Core
//>>description: Functions to generate and remove uniqueId's
//>>docs: http://api.jqueryui.com/uniqueId/



var uniqueId = $.fn.extend( {
	uniqueId: ( function() {
		var uuid = 0;

		return function() {
			return this.each( function() {
				if ( !this.id ) {
					this.id = "ui-id-" + ( ++uuid );
				}
			} );
		};
	} )(),

	removeUniqueId: function() {
		return this.each( function() {
			if ( /^ui-id-\d+$/.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		} );
	}
} );


/*!
 * jQuery UI Accordion 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Accordion
//>>group: Widgets
// jscs:disable maximumLineLength
//>>description: Displays collapsible content panels for presenting information in a limited amount of space.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/accordion/
//>>demos: http://jqueryui.com/accordion/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/accordion.css
//>>css.theme: ../../themes/base/theme.css



var widgetsAccordion = $.widget( "ui.accordion", {
	version: "1.12.1",
	options: {
		active: 0,
		animate: {},
		classes: {
			"ui-accordion-header": "ui-corner-top",
			"ui-accordion-header-collapsed": "ui-corner-all",
			"ui-accordion-content": "ui-corner-bottom"
		},
		collapsible: false,
		event: "click",
		header: "> li > :first-child, > :not(li):even",
		heightStyle: "auto",
		icons: {
			activeHeader: "ui-icon-triangle-1-s",
			header: "ui-icon-triangle-1-e"
		},

		// Callbacks
		activate: null,
		beforeActivate: null
	},

	hideProps: {
		borderTopWidth: "hide",
		borderBottomWidth: "hide",
		paddingTop: "hide",
		paddingBottom: "hide",
		height: "hide"
	},

	showProps: {
		borderTopWidth: "show",
		borderBottomWidth: "show",
		paddingTop: "show",
		paddingBottom: "show",
		height: "show"
	},

	_create: function() {
		var options = this.options;

		this.prevShow = this.prevHide = $();
		this._addClass( "ui-accordion", "ui-widget ui-helper-reset" );
		this.element.attr( "role", "tablist" );

		// Don't allow collapsible: false and active: false / null
		if ( !options.collapsible && ( options.active === false || options.active == null ) ) {
			options.active = 0;
		}

		this._processPanels();

		// handle negative values
		if ( options.active < 0 ) {
			options.active += this.headers.length;
		}
		this._refresh();
	},

	_getCreateEventData: function() {
		return {
			header: this.active,
			panel: !this.active.length ? $() : this.active.next()
		};
	},

	_createIcons: function() {
		var icon, children,
			icons = this.options.icons;

		if ( icons ) {
			icon = $( "<span>" );
			this._addClass( icon, "ui-accordion-header-icon", "ui-icon " + icons.header );
			icon.prependTo( this.headers );
			children = this.active.children( ".ui-accordion-header-icon" );
			this._removeClass( children, icons.header )
				._addClass( children, null, icons.activeHeader )
				._addClass( this.headers, "ui-accordion-icons" );
		}
	},

	_destroyIcons: function() {
		this._removeClass( this.headers, "ui-accordion-icons" );
		this.headers.children( ".ui-accordion-header-icon" ).remove();
	},

	_destroy: function() {
		var contents;

		// Clean up main element
		this.element.removeAttr( "role" );

		// Clean up headers
		this.headers
			.removeAttr( "role aria-expanded aria-selected aria-controls tabIndex" )
			.removeUniqueId();

		this._destroyIcons();

		// Clean up content panels
		contents = this.headers.next()
			.css( "display", "" )
			.removeAttr( "role aria-hidden aria-labelledby" )
			.removeUniqueId();

		if ( this.options.heightStyle !== "content" ) {
			contents.css( "height", "" );
		}
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {

			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "event" ) {
			if ( this.options.event ) {
				this._off( this.headers, this.options.event );
			}
			this._setupEvents( value );
		}

		this._super( key, value );

		// Setting collapsible: false while collapsed; open first panel
		if ( key === "collapsible" && !value && this.options.active === false ) {
			this._activate( 0 );
		}

		if ( key === "icons" ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this.element.attr( "aria-disabled", value );

		// Support: IE8 Only
		// #5332 / #6059 - opacity doesn't cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		this._toggleClass( null, "ui-state-disabled", !!value );
		this._toggleClass( this.headers.add( this.headers.next() ), null, "ui-state-disabled",
			!!value );
	},

	_keydown: function( event ) {
		if ( event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
		case keyCode.RIGHT:
		case keyCode.DOWN:
			toFocus = this.headers[ ( currentIndex + 1 ) % length ];
			break;
		case keyCode.LEFT:
		case keyCode.UP:
			toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
			break;
		case keyCode.SPACE:
		case keyCode.ENTER:
			this._eventHandler( event );
			break;
		case keyCode.HOME:
			toFocus = this.headers[ 0 ];
			break;
		case keyCode.END:
			toFocus = this.headers[ length - 1 ];
			break;
		}

		if ( toFocus ) {
			$( event.target ).attr( "tabIndex", -1 );
			$( toFocus ).attr( "tabIndex", 0 );
			$( toFocus ).trigger( "focus" );
			event.preventDefault();
		}
	},

	_panelKeyDown: function( event ) {
		if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
			$( event.currentTarget ).prev().trigger( "focus" );
		}
	},

	refresh: function() {
		var options = this.options;
		this._processPanels();

		// Was collapsed or no panel
		if ( ( options.active === false && options.collapsible === true ) ||
				!this.headers.length ) {
			options.active = false;
			this.active = $();

		// active false only when collapsible is true
		} else if ( options.active === false ) {
			this._activate( 0 );

		// was active, but active panel is gone
		} else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {

			// all remaining panel are disabled
			if ( this.headers.length === this.headers.find( ".ui-state-disabled" ).length ) {
				options.active = false;
				this.active = $();

			// activate previous panel
			} else {
				this._activate( Math.max( 0, options.active - 1 ) );
			}

		// was active, active panel still exists
		} else {

			// make sure active index is correct
			options.active = this.headers.index( this.active );
		}

		this._destroyIcons();

		this._refresh();
	},

	_processPanels: function() {
		var prevHeaders = this.headers,
			prevPanels = this.panels;

		this.headers = this.element.find( this.options.header );
		this._addClass( this.headers, "ui-accordion-header ui-accordion-header-collapsed",
			"ui-state-default" );

		this.panels = this.headers.next().filter( ":not(.ui-accordion-content-active)" ).hide();
		this._addClass( this.panels, "ui-accordion-content", "ui-helper-reset ui-widget-content" );

		// Avoid memory leaks (#10056)
		if ( prevPanels ) {
			this._off( prevHeaders.not( this.headers ) );
			this._off( prevPanels.not( this.panels ) );
		}
	},

	_refresh: function() {
		var maxHeight,
			options = this.options,
			heightStyle = options.heightStyle,
			parent = this.element.parent();

		this.active = this._findActive( options.active );
		this._addClass( this.active, "ui-accordion-header-active", "ui-state-active" )
			._removeClass( this.active, "ui-accordion-header-collapsed" );
		this._addClass( this.active.next(), "ui-accordion-content-active" );
		this.active.next().show();

		this.headers
			.attr( "role", "tab" )
			.each( function() {
				var header = $( this ),
					headerId = header.uniqueId().attr( "id" ),
					panel = header.next(),
					panelId = panel.uniqueId().attr( "id" );
				header.attr( "aria-controls", panelId );
				panel.attr( "aria-labelledby", headerId );
			} )
			.next()
				.attr( "role", "tabpanel" );

		this.headers
			.not( this.active )
				.attr( {
					"aria-selected": "false",
					"aria-expanded": "false",
					tabIndex: -1
				} )
				.next()
					.attr( {
						"aria-hidden": "true"
					} )
					.hide();

		// Make sure at least one header is in the tab order
		if ( !this.active.length ) {
			this.headers.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active.attr( {
				"aria-selected": "true",
				"aria-expanded": "true",
				tabIndex: 0
			} )
				.next()
					.attr( {
						"aria-hidden": "false"
					} );
		}

		this._createIcons();

		this._setupEvents( options.event );

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			this.element.siblings( ":visible" ).each( function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			} );

			this.headers.each( function() {
				maxHeight -= $( this ).outerHeight( true );
			} );

			this.headers.next()
				.each( function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				} )
				.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.headers.next()
				.each( function() {
					var isVisible = $( this ).is( ":visible" );
					if ( !isVisible ) {
						$( this ).show();
					}
					maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
					if ( !isVisible ) {
						$( this ).hide();
					}
				} )
				.height( maxHeight );
		}
	},

	_activate: function( index ) {
		var active = this._findActive( index )[ 0 ];

		// Trying to activate the already active panel
		if ( active === this.active[ 0 ] ) {
			return;
		}

		// Trying to collapse, simulate a click on the currently active header
		active = active || this.active[ 0 ];

		this._eventHandler( {
			target: active,
			currentTarget: active,
			preventDefault: $.noop
		} );
	},

	_findActive: function( selector ) {
		return typeof selector === "number" ? this.headers.eq( selector ) : $();
	},

	_setupEvents: function( event ) {
		var events = {
			keydown: "_keydown"
		};
		if ( event ) {
			$.each( event.split( " " ), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			} );
		}

		this._off( this.headers.add( this.headers.next() ) );
		this._on( this.headers, events );
		this._on( this.headers.next(), { keydown: "_panelKeyDown" } );
		this._hoverable( this.headers );
		this._focusable( this.headers );
	},

	_eventHandler: function( event ) {
		var activeChildren, clickedChildren,
			options = this.options,
			active = this.active,
			clicked = $( event.currentTarget ),
			clickedIsActive = clicked[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : clicked.next(),
			toHide = active.next(),
			eventData = {
				oldHeader: active,
				oldPanel: toHide,
				newHeader: collapsing ? $() : clicked,
				newPanel: toShow
			};

		event.preventDefault();

		if (

				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||

				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.headers.index( clicked );

		// When the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $() : clicked;
		this._toggle( eventData );

		// Switch classes
		// corner classes on the previously active header stay after the animation
		this._removeClass( active, "ui-accordion-header-active", "ui-state-active" );
		if ( options.icons ) {
			activeChildren = active.children( ".ui-accordion-header-icon" );
			this._removeClass( activeChildren, null, options.icons.activeHeader )
				._addClass( activeChildren, null, options.icons.header );
		}

		if ( !clickedIsActive ) {
			this._removeClass( clicked, "ui-accordion-header-collapsed" )
				._addClass( clicked, "ui-accordion-header-active", "ui-state-active" );
			if ( options.icons ) {
				clickedChildren = clicked.children( ".ui-accordion-header-icon" );
				this._removeClass( clickedChildren, null, options.icons.header )
					._addClass( clickedChildren, null, options.icons.activeHeader );
			}

			this._addClass( clicked.next(), "ui-accordion-content-active" );
		}
	},

	_toggle: function( data ) {
		var toShow = data.newPanel,
			toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

		// Handle activating a panel during the animation for another activation
		this.prevShow.add( this.prevHide ).stop( true, true );
		this.prevShow = toShow;
		this.prevHide = toHide;

		if ( this.options.animate ) {
			this._animate( toShow, toHide, data );
		} else {
			toHide.hide();
			toShow.show();
			this._toggleComplete( data );
		}

		toHide.attr( {
			"aria-hidden": "true"
		} );
		toHide.prev().attr( {
			"aria-selected": "false",
			"aria-expanded": "false"
		} );

		// if we're switching panels, remove the old header from the tab order
		// if we're opening from collapsed state, remove the previous header from the tab order
		// if we're collapsing, then keep the collapsing header in the tab order
		if ( toShow.length && toHide.length ) {
			toHide.prev().attr( {
				"tabIndex": -1,
				"aria-expanded": "false"
			} );
		} else if ( toShow.length ) {
			this.headers.filter( function() {
				return parseInt( $( this ).attr( "tabIndex" ), 10 ) === 0;
			} )
				.attr( "tabIndex", -1 );
		}

		toShow
			.attr( "aria-hidden", "false" )
			.prev()
				.attr( {
					"aria-selected": "true",
					"aria-expanded": "true",
					tabIndex: 0
				} );
	},

	_animate: function( toShow, toHide, data ) {
		var total, easing, duration,
			that = this,
			adjust = 0,
			boxSizing = toShow.css( "box-sizing" ),
			down = toShow.length &&
				( !toHide.length || ( toShow.index() < toHide.index() ) ),
			animate = this.options.animate || {},
			options = down && animate.down || animate,
			complete = function() {
				that._toggleComplete( data );
			};

		if ( typeof options === "number" ) {
			duration = options;
		}
		if ( typeof options === "string" ) {
			easing = options;
		}

		// fall back from options to animation in case of partial down settings
		easing = easing || options.easing || animate.easing;
		duration = duration || options.duration || animate.duration;

		if ( !toHide.length ) {
			return toShow.animate( this.showProps, duration, easing, complete );
		}
		if ( !toShow.length ) {
			return toHide.animate( this.hideProps, duration, easing, complete );
		}

		total = toShow.show().outerHeight();
		toHide.animate( this.hideProps, {
			duration: duration,
			easing: easing,
			step: function( now, fx ) {
				fx.now = Math.round( now );
			}
		} );
		toShow
			.hide()
			.animate( this.showProps, {
				duration: duration,
				easing: easing,
				complete: complete,
				step: function( now, fx ) {
					fx.now = Math.round( now );
					if ( fx.prop !== "height" ) {
						if ( boxSizing === "content-box" ) {
							adjust += fx.now;
						}
					} else if ( that.options.heightStyle !== "content" ) {
						fx.now = Math.round( total - toHide.outerHeight() - adjust );
						adjust = 0;
					}
				}
			} );
	},

	_toggleComplete: function( data ) {
		var toHide = data.oldPanel,
			prev = toHide.prev();

		this._removeClass( toHide, "ui-accordion-content-active" );
		this._removeClass( prev, "ui-accordion-header-active" )
			._addClass( prev, "ui-accordion-header-collapsed" );

		// Work around for rendering bug in IE (#5421)
		if ( toHide.length ) {
			toHide.parent()[ 0 ].className = toHide.parent()[ 0 ].className;
		}
		this._trigger( "activate", null, data );
	}
} );



var safeActiveElement = $.ui.safeActiveElement = function( document ) {
	var activeElement;

	// Support: IE 9 only
	// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
	try {
		activeElement = document.activeElement;
	} catch ( error ) {
		activeElement = document.body;
	}

	// Support: IE 9 - 11 only
	// IE may return null instead of an element
	// Interestingly, this only seems to occur when NOT in an iframe
	if ( !activeElement ) {
		activeElement = document.body;
	}

	// Support: IE 11 only
	// IE11 returns a seemingly empty object in some cases when accessing
	// document.activeElement from an <iframe>
	if ( !activeElement.nodeName ) {
		activeElement = document.body;
	}

	return activeElement;
};


/*!
 * jQuery UI Menu 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Menu
//>>group: Widgets
//>>description: Creates nestable menus.
//>>docs: http://api.jqueryui.com/menu/
//>>demos: http://jqueryui.com/menu/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/menu.css
//>>css.theme: ../../themes/base/theme.css



var widgetsMenu = $.widget( "ui.menu", {
	version: "1.12.1",
	defaultElement: "<ul>",
	delay: 300,
	options: {
		icons: {
			submenu: "ui-icon-caret-1-e"
		},
		items: "> *",
		menus: "ul",
		position: {
			my: "left top",
			at: "right top"
		},
		role: "menu",

		// Callbacks
		blur: null,
		focus: null,
		select: null
	},

	_create: function() {
		this.activeMenu = this.element;

		// Flag used to prevent firing of the click handler
		// as the event bubbles up through nested menus
		this.mouseHandled = false;
		this.element
			.uniqueId()
			.attr( {
				role: this.options.role,
				tabIndex: 0
			} );

		this._addClass( "ui-menu", "ui-widget ui-widget-content" );
		this._on( {

			// Prevent focus from sticking to links inside menu after clicking
			// them (focus should always stay on UL during navigation).
			"mousedown .ui-menu-item": function( event ) {
				event.preventDefault();
			},
			"click .ui-menu-item": function( event ) {
				var target = $( event.target );
				var active = $( $.ui.safeActiveElement( this.document[ 0 ] ) );
				if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
					this.select( event );

					// Only set the mouseHandled flag if the event will bubble, see #9469.
					if ( !event.isPropagationStopped() ) {
						this.mouseHandled = true;
					}

					// Open submenu on click
					if ( target.has( ".ui-menu" ).length ) {
						this.expand( event );
					} else if ( !this.element.is( ":focus" ) &&
							active.closest( ".ui-menu" ).length ) {

						// Redirect focus to the menu
						this.element.trigger( "focus", [ true ] );

						// If the active item is on the top level, let it stay active.
						// Otherwise, blur the active item since it is no longer visible.
						if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
							clearTimeout( this.timer );
						}
					}
				}
			},
			"mouseenter .ui-menu-item": function( event ) {

				// Ignore mouse events while typeahead is active, see #10458.
				// Prevents focusing the wrong item when typeahead causes a scroll while the mouse
				// is over an item in the menu
				if ( this.previousFilter ) {
					return;
				}

				var actualTarget = $( event.target ).closest( ".ui-menu-item" ),
					target = $( event.currentTarget );

				// Ignore bubbled events on parent items, see #11641
				if ( actualTarget[ 0 ] !== target[ 0 ] ) {
					return;
				}

				// Remove ui-state-active class from siblings of the newly focused menu item
				// to avoid a jump caused by adjacent elements both having a class with a border
				this._removeClass( target.siblings().children( ".ui-state-active" ),
					null, "ui-state-active" );
				this.focus( event, target );
			},
			mouseleave: "collapseAll",
			"mouseleave .ui-menu": "collapseAll",
			focus: function( event, keepActiveItem ) {

				// If there's already an active item, keep it active
				// If not, activate the first item
				var item = this.active || this.element.find( this.options.items ).eq( 0 );

				if ( !keepActiveItem ) {
					this.focus( event, item );
				}
			},
			blur: function( event ) {
				this._delay( function() {
					var notContained = !$.contains(
						this.element[ 0 ],
						$.ui.safeActiveElement( this.document[ 0 ] )
					);
					if ( notContained ) {
						this.collapseAll( event );
					}
				} );
			},
			keydown: "_keydown"
		} );

		this.refresh();

		// Clicks outside of a menu collapse any open menus
		this._on( this.document, {
			click: function( event ) {
				if ( this._closeOnDocumentClick( event ) ) {
					this.collapseAll( event );
				}

				// Reset the mouseHandled flag
				this.mouseHandled = false;
			}
		} );
	},

	_destroy: function() {
		var items = this.element.find( ".ui-menu-item" )
				.removeAttr( "role aria-disabled" ),
			submenus = items.children( ".ui-menu-item-wrapper" )
				.removeUniqueId()
				.removeAttr( "tabIndex role aria-haspopup" );

		// Destroy (sub)menus
		this.element
			.removeAttr( "aria-activedescendant" )
			.find( ".ui-menu" ).addBack()
				.removeAttr( "role aria-labelledby aria-expanded aria-hidden aria-disabled " +
					"tabIndex" )
				.removeUniqueId()
				.show();

		submenus.children().each( function() {
			var elem = $( this );
			if ( elem.data( "ui-menu-submenu-caret" ) ) {
				elem.remove();
			}
		} );
	},

	_keydown: function( event ) {
		var match, prev, character, skip,
			preventDefault = true;

		switch ( event.keyCode ) {
		case $.ui.keyCode.PAGE_UP:
			this.previousPage( event );
			break;
		case $.ui.keyCode.PAGE_DOWN:
			this.nextPage( event );
			break;
		case $.ui.keyCode.HOME:
			this._move( "first", "first", event );
			break;
		case $.ui.keyCode.END:
			this._move( "last", "last", event );
			break;
		case $.ui.keyCode.UP:
			this.previous( event );
			break;
		case $.ui.keyCode.DOWN:
			this.next( event );
			break;
		case $.ui.keyCode.LEFT:
			this.collapse( event );
			break;
		case $.ui.keyCode.RIGHT:
			if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
				this.expand( event );
			}
			break;
		case $.ui.keyCode.ENTER:
		case $.ui.keyCode.SPACE:
			this._activate( event );
			break;
		case $.ui.keyCode.ESCAPE:
			this.collapse( event );
			break;
		default:
			preventDefault = false;
			prev = this.previousFilter || "";
			skip = false;

			// Support number pad values
			character = event.keyCode >= 96 && event.keyCode <= 105 ?
				( event.keyCode - 96 ).toString() : String.fromCharCode( event.keyCode );

			clearTimeout( this.filterTimer );

			if ( character === prev ) {
				skip = true;
			} else {
				character = prev + character;
			}

			match = this._filterMenuItems( character );
			match = skip && match.index( this.active.next() ) !== -1 ?
				this.active.nextAll( ".ui-menu-item" ) :
				match;

			// If no matches on the current filter, reset to the last character pressed
			// to move down the menu to the first item that starts with that character
			if ( !match.length ) {
				character = String.fromCharCode( event.keyCode );
				match = this._filterMenuItems( character );
			}

			if ( match.length ) {
				this.focus( event, match );
				this.previousFilter = character;
				this.filterTimer = this._delay( function() {
					delete this.previousFilter;
				}, 1000 );
			} else {
				delete this.previousFilter;
			}
		}

		if ( preventDefault ) {
			event.preventDefault();
		}
	},

	_activate: function( event ) {
		if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
			if ( this.active.children( "[aria-haspopup='true']" ).length ) {
				this.expand( event );
			} else {
				this.select( event );
			}
		}
	},

	refresh: function() {
		var menus, items, newSubmenus, newItems, newWrappers,
			that = this,
			icon = this.options.icons.submenu,
			submenus = this.element.find( this.options.menus );

		this._toggleClass( "ui-menu-icons", null, !!this.element.find( ".ui-icon" ).length );

		// Initialize nested menus
		newSubmenus = submenus.filter( ":not(.ui-menu)" )
			.hide()
			.attr( {
				role: this.options.role,
				"aria-hidden": "true",
				"aria-expanded": "false"
			} )
			.each( function() {
				var menu = $( this ),
					item = menu.prev(),
					submenuCaret = $( "<span>" ).data( "ui-menu-submenu-caret", true );

				that._addClass( submenuCaret, "ui-menu-icon", "ui-icon " + icon );
				item
					.attr( "aria-haspopup", "true" )
					.prepend( submenuCaret );
				menu.attr( "aria-labelledby", item.attr( "id" ) );
			} );

		this._addClass( newSubmenus, "ui-menu", "ui-widget ui-widget-content ui-front" );

		menus = submenus.add( this.element );
		items = menus.find( this.options.items );

		// Initialize menu-items containing spaces and/or dashes only as dividers
		items.not( ".ui-menu-item" ).each( function() {
			var item = $( this );
			if ( that._isDivider( item ) ) {
				that._addClass( item, "ui-menu-divider", "ui-widget-content" );
			}
		} );

		// Don't refresh list items that are already adapted
		newItems = items.not( ".ui-menu-item, .ui-menu-divider" );
		newWrappers = newItems.children()
			.not( ".ui-menu" )
				.uniqueId()
				.attr( {
					tabIndex: -1,
					role: this._itemRole()
				} );
		this._addClass( newItems, "ui-menu-item" )
			._addClass( newWrappers, "ui-menu-item-wrapper" );

		// Add aria-disabled attribute to any disabled menu item
		items.filter( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

		// If the active item has been removed, blur the menu
		if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			this.blur();
		}
	},

	_itemRole: function() {
		return {
			menu: "menuitem",
			listbox: "option"
		}[ this.options.role ];
	},

	_setOption: function( key, value ) {
		if ( key === "icons" ) {
			var icons = this.element.find( ".ui-menu-icon" );
			this._removeClass( icons, null, this.options.icons.submenu )
				._addClass( icons, null, value.submenu );
		}
		this._super( key, value );
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this.element.attr( "aria-disabled", String( value ) );
		this._toggleClass( null, "ui-state-disabled", !!value );
	},

	focus: function( event, item ) {
		var nested, focused, activeParent;
		this.blur( event, event && event.type === "focus" );

		this._scrollIntoView( item );

		this.active = item.first();

		focused = this.active.children( ".ui-menu-item-wrapper" );
		this._addClass( focused, null, "ui-state-active" );

		// Only update aria-activedescendant if there's a role
		// otherwise we assume focus is managed elsewhere
		if ( this.options.role ) {
			this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
		}

		// Highlight active parent menu item, if any
		activeParent = this.active
			.parent()
				.closest( ".ui-menu-item" )
					.children( ".ui-menu-item-wrapper" );
		this._addClass( activeParent, null, "ui-state-active" );

		if ( event && event.type === "keydown" ) {
			this._close();
		} else {
			this.timer = this._delay( function() {
				this._close();
			}, this.delay );
		}

		nested = item.children( ".ui-menu" );
		if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {
			this._startOpening( nested );
		}
		this.activeMenu = item.parent();

		this._trigger( "focus", event, { item: item } );
	},

	_scrollIntoView: function( item ) {
		var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
		if ( this._hasScroll() ) {
			borderTop = parseFloat( $.css( this.activeMenu[ 0 ], "borderTopWidth" ) ) || 0;
			paddingTop = parseFloat( $.css( this.activeMenu[ 0 ], "paddingTop" ) ) || 0;
			offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
			scroll = this.activeMenu.scrollTop();
			elementHeight = this.activeMenu.height();
			itemHeight = item.outerHeight();

			if ( offset < 0 ) {
				this.activeMenu.scrollTop( scroll + offset );
			} else if ( offset + itemHeight > elementHeight ) {
				this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
			}
		}
	},

	blur: function( event, fromFocus ) {
		if ( !fromFocus ) {
			clearTimeout( this.timer );
		}

		if ( !this.active ) {
			return;
		}

		this._removeClass( this.active.children( ".ui-menu-item-wrapper" ),
			null, "ui-state-active" );

		this._trigger( "blur", event, { item: this.active } );
		this.active = null;
	},

	_startOpening: function( submenu ) {
		clearTimeout( this.timer );

		// Don't open if already open fixes a Firefox bug that caused a .5 pixel
		// shift in the submenu position when mousing over the caret icon
		if ( submenu.attr( "aria-hidden" ) !== "true" ) {
			return;
		}

		this.timer = this._delay( function() {
			this._close();
			this._open( submenu );
		}, this.delay );
	},

	_open: function( submenu ) {
		var position = $.extend( {
			of: this.active
		}, this.options.position );

		clearTimeout( this.timer );
		this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
			.hide()
			.attr( "aria-hidden", "true" );

		submenu
			.show()
			.removeAttr( "aria-hidden" )
			.attr( "aria-expanded", "true" )
			.position( position );
	},

	collapseAll: function( event, all ) {
		clearTimeout( this.timer );
		this.timer = this._delay( function() {

			// If we were passed an event, look for the submenu that contains the event
			var currentMenu = all ? this.element :
				$( event && event.target ).closest( this.element.find( ".ui-menu" ) );

			// If we found no valid submenu ancestor, use the main menu to close all
			// sub menus anyway
			if ( !currentMenu.length ) {
				currentMenu = this.element;
			}

			this._close( currentMenu );

			this.blur( event );

			// Work around active item staying active after menu is blurred
			this._removeClass( currentMenu.find( ".ui-state-active" ), null, "ui-state-active" );

			this.activeMenu = currentMenu;
		}, this.delay );
	},

	// With no arguments, closes the currently active menu - if nothing is active
	// it closes all menus.  If passed an argument, it will search for menus BELOW
	_close: function( startMenu ) {
		if ( !startMenu ) {
			startMenu = this.active ? this.active.parent() : this.element;
		}

		startMenu.find( ".ui-menu" )
			.hide()
			.attr( "aria-hidden", "true" )
			.attr( "aria-expanded", "false" );
	},

	_closeOnDocumentClick: function( event ) {
		return !$( event.target ).closest( ".ui-menu" ).length;
	},

	_isDivider: function( item ) {

		// Match hyphen, em dash, en dash
		return !/[^\-\u2014\u2013\s]/.test( item.text() );
	},

	collapse: function( event ) {
		var newItem = this.active &&
			this.active.parent().closest( ".ui-menu-item", this.element );
		if ( newItem && newItem.length ) {
			this._close();
			this.focus( event, newItem );
		}
	},

	expand: function( event ) {
		var newItem = this.active &&
			this.active
				.children( ".ui-menu " )
					.find( this.options.items )
						.first();

		if ( newItem && newItem.length ) {
			this._open( newItem.parent() );

			// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
			this._delay( function() {
				this.focus( event, newItem );
			} );
		}
	},

	next: function( event ) {
		this._move( "next", "first", event );
	},

	previous: function( event ) {
		this._move( "prev", "last", event );
	},

	isFirstItem: function() {
		return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
	},

	isLastItem: function() {
		return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
	},

	_move: function( direction, filter, event ) {
		var next;
		if ( this.active ) {
			if ( direction === "first" || direction === "last" ) {
				next = this.active
					[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
					.eq( -1 );
			} else {
				next = this.active
					[ direction + "All" ]( ".ui-menu-item" )
					.eq( 0 );
			}
		}
		if ( !next || !next.length || !this.active ) {
			next = this.activeMenu.find( this.options.items )[ filter ]();
		}

		this.focus( event, next );
	},

	nextPage: function( event ) {
		var item, base, height;

		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isLastItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.nextAll( ".ui-menu-item" ).each( function() {
				item = $( this );
				return item.offset().top - base - height < 0;
			} );

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.find( this.options.items )
				[ !this.active ? "first" : "last" ]() );
		}
	},

	previousPage: function( event ) {
		var item, base, height;
		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isFirstItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.prevAll( ".ui-menu-item" ).each( function() {
				item = $( this );
				return item.offset().top - base + height > 0;
			} );

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.find( this.options.items ).first() );
		}
	},

	_hasScroll: function() {
		return this.element.outerHeight() < this.element.prop( "scrollHeight" );
	},

	select: function( event ) {

		// TODO: It should never be possible to not have an active item at this
		// point, but the tests don't trigger mouseenter before click.
		this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
		var ui = { item: this.active };
		if ( !this.active.has( ".ui-menu" ).length ) {
			this.collapseAll( event, true );
		}
		this._trigger( "select", event, ui );
	},

	_filterMenuItems: function( character ) {
		var escapedCharacter = character.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" ),
			regex = new RegExp( "^" + escapedCharacter, "i" );

		return this.activeMenu
			.find( this.options.items )

				// Only match on items, not dividers or other content (#10571)
				.filter( ".ui-menu-item" )
					.filter( function() {
						return regex.test(
							$.trim( $( this ).children( ".ui-menu-item-wrapper" ).text() ) );
					} );
	}
} );


/*!
 * jQuery UI Autocomplete 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Autocomplete
//>>group: Widgets
//>>description: Lists suggested words as the user is typing.
//>>docs: http://api.jqueryui.com/autocomplete/
//>>demos: http://jqueryui.com/autocomplete/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/autocomplete.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.autocomplete", {
	version: "1.12.1",
	defaultElement: "<input>",
	options: {
		appendTo: null,
		autoFocus: false,
		delay: 300,
		minLength: 1,
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		source: null,

		// Callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		response: null,
		search: null,
		select: null
	},

	requestIndex: 0,
	pending: 0,

	_create: function() {

		// Some browsers only repeat keydown events, not keypress events,
		// so we use the suppressKeyPress flag to determine if we've already
		// handled the keydown event. #7269
		// Unfortunately the code for & in keypress is the same as the up arrow,
		// so we use the suppressKeyPressRepeat flag to avoid handling keypress
		// events when we know the keydown event was used to modify the
		// search term. #7799
		var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
			nodeName = this.element[ 0 ].nodeName.toLowerCase(),
			isTextarea = nodeName === "textarea",
			isInput = nodeName === "input";

		// Textareas are always multi-line
		// Inputs are always single-line, even if inside a contentEditable element
		// IE also treats inputs as contentEditable
		// All other element types are determined by whether or not they're contentEditable
		this.isMultiLine = isTextarea || !isInput && this._isContentEditable( this.element );

		this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];
		this.isNewMenu = true;

		this._addClass( "ui-autocomplete-input" );
		this.element.attr( "autocomplete", "off" );

		this._on( this.element, {
			keydown: function( event ) {
				if ( this.element.prop( "readOnly" ) ) {
					suppressKeyPress = true;
					suppressInput = true;
					suppressKeyPressRepeat = true;
					return;
				}

				suppressKeyPress = false;
				suppressInput = false;
				suppressKeyPressRepeat = false;
				var keyCode = $.ui.keyCode;
				switch ( event.keyCode ) {
				case keyCode.PAGE_UP:
					suppressKeyPress = true;
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					suppressKeyPress = true;
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					suppressKeyPress = true;
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					suppressKeyPress = true;
					this._keyEvent( "next", event );
					break;
				case keyCode.ENTER:

					// when menu is open and has focus
					if ( this.menu.active ) {

						// #6055 - Opera still allows the keypress to occur
						// which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
						this.menu.select( event );
					}
					break;
				case keyCode.TAB:
					if ( this.menu.active ) {
						this.menu.select( event );
					}
					break;
				case keyCode.ESCAPE:
					if ( this.menu.element.is( ":visible" ) ) {
						if ( !this.isMultiLine ) {
							this._value( this.term );
						}
						this.close( event );

						// Different browsers have different default behavior for escape
						// Single press can mean undo or clear
						// Double press in IE means clear the whole form
						event.preventDefault();
					}
					break;
				default:
					suppressKeyPressRepeat = true;

					// search timeout should be triggered before the input value is changed
					this._searchTimeout( event );
					break;
				}
			},
			keypress: function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
						event.preventDefault();
					}
					return;
				}
				if ( suppressKeyPressRepeat ) {
					return;
				}

				// Replicate some key handlers to allow them to repeat in Firefox and Opera
				var keyCode = $.ui.keyCode;
				switch ( event.keyCode ) {
				case keyCode.PAGE_UP:
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					this._keyEvent( "next", event );
					break;
				}
			},
			input: function( event ) {
				if ( suppressInput ) {
					suppressInput = false;
					event.preventDefault();
					return;
				}
				this._searchTimeout( event );
			},
			focus: function() {
				this.selectedItem = null;
				this.previous = this._value();
			},
			blur: function( event ) {
				if ( this.cancelBlur ) {
					delete this.cancelBlur;
					return;
				}

				clearTimeout( this.searching );
				this.close( event );
				this._change( event );
			}
		} );

		this._initSource();
		this.menu = $( "<ul>" )
			.appendTo( this._appendTo() )
			.menu( {

				// disable ARIA support, the live region takes care of that
				role: null
			} )
			.hide()
			.menu( "instance" );

		this._addClass( this.menu.element, "ui-autocomplete", "ui-front" );
		this._on( this.menu.element, {
			mousedown: function( event ) {

				// prevent moving focus out of the text field
				event.preventDefault();

				// IE doesn't prevent moving focus even with event.preventDefault()
				// so we set a flag to know when we should ignore the blur event
				this.cancelBlur = true;
				this._delay( function() {
					delete this.cancelBlur;

					// Support: IE 8 only
					// Right clicking a menu item or selecting text from the menu items will
					// result in focus moving out of the input. However, we've already received
					// and ignored the blur event because of the cancelBlur flag set above. So
					// we restore focus to ensure that the menu closes properly based on the user's
					// next actions.
					if ( this.element[ 0 ] !== $.ui.safeActiveElement( this.document[ 0 ] ) ) {
						this.element.trigger( "focus" );
					}
				} );
			},
			menufocus: function( event, ui ) {
				var label, item;

				// support: Firefox
				// Prevent accidental activation of menu items in Firefox (#7024 #9118)
				if ( this.isNewMenu ) {
					this.isNewMenu = false;
					if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
						this.menu.blur();

						this.document.one( "mousemove", function() {
							$( event.target ).trigger( event.originalEvent );
						} );

						return;
					}
				}

				item = ui.item.data( "ui-autocomplete-item" );
				if ( false !== this._trigger( "focus", event, { item: item } ) ) {

					// use value to match what will end up in the input, if it was a key event
					if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
						this._value( item.value );
					}
				}

				// Announce the value in the liveRegion
				label = ui.item.attr( "aria-label" ) || item.value;
				if ( label && $.trim( label ).length ) {
					this.liveRegion.children().hide();
					$( "<div>" ).text( label ).appendTo( this.liveRegion );
				}
			},
			menuselect: function( event, ui ) {
				var item = ui.item.data( "ui-autocomplete-item" ),
					previous = this.previous;

				// Only trigger when focus was lost (click on menu)
				if ( this.element[ 0 ] !== $.ui.safeActiveElement( this.document[ 0 ] ) ) {
					this.element.trigger( "focus" );
					this.previous = previous;

					// #6109 - IE triggers two focus events and the second
					// is asynchronous, so we need to reset the previous
					// term synchronously and asynchronously :-(
					this._delay( function() {
						this.previous = previous;
						this.selectedItem = item;
					} );
				}

				if ( false !== this._trigger( "select", event, { item: item } ) ) {
					this._value( item.value );
				}

				// reset the term after the select event
				// this allows custom select handling to work properly
				this.term = this._value();

				this.close( event );
				this.selectedItem = item;
			}
		} );

		this.liveRegion = $( "<div>", {
			role: "status",
			"aria-live": "assertive",
			"aria-relevant": "additions"
		} )
			.appendTo( this.document[ 0 ].body );

		this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" );

		// Turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		} );
	},

	_destroy: function() {
		clearTimeout( this.searching );
		this.element.removeAttr( "autocomplete" );
		this.menu.element.remove();
		this.liveRegion.remove();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "source" ) {
			this._initSource();
		}
		if ( key === "appendTo" ) {
			this.menu.element.appendTo( this._appendTo() );
		}
		if ( key === "disabled" && value && this.xhr ) {
			this.xhr.abort();
		}
	},

	_isEventTargetInWidget: function( event ) {
		var menuElement = this.menu.element[ 0 ];

		return event.target === this.element[ 0 ] ||
			event.target === menuElement ||
			$.contains( menuElement, event.target );
	},

	_closeOnClickOutside: function( event ) {
		if ( !this._isEventTargetInWidget( event ) ) {
			this.close();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;

		if ( element ) {
			element = element.jquery || element.nodeType ?
				$( element ) :
				this.document.find( element ).eq( 0 );
		}

		if ( !element || !element[ 0 ] ) {
			element = this.element.closest( ".ui-front, dialog" );
		}

		if ( !element.length ) {
			element = this.document[ 0 ].body;
		}

		return element;
	},

	_initSource: function() {
		var array, url,
			that = this;
		if ( $.isArray( this.options.source ) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter( array, request.term ) );
			};
		} else if ( typeof this.options.source === "string" ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if ( that.xhr ) {
					that.xhr.abort();
				}
				that.xhr = $.ajax( {
					url: url,
					data: request,
					dataType: "json",
					success: function( data ) {
						response( data );
					},
					error: function() {
						response( [] );
					}
				} );
			};
		} else {
			this.source = this.options.source;
		}
	},

	_searchTimeout: function( event ) {
		clearTimeout( this.searching );
		this.searching = this._delay( function() {

			// Search if the value has changed, or if the user retypes the same value (see #7434)
			var equalValues = this.term === this._value(),
				menuVisible = this.menu.element.is( ":visible" ),
				modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;

			if ( !equalValues || ( equalValues && !menuVisible && !modifierKey ) ) {
				this.selectedItem = null;
				this.search( null, event );
			}
		}, this.options.delay );
	},

	search: function( value, event ) {
		value = value != null ? value : this._value();

		// Always save the actual value, not the one passed as an argument
		this.term = this._value();

		if ( value.length < this.options.minLength ) {
			return this.close( event );
		}

		if ( this._trigger( "search", event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.pending++;
		this._addClass( "ui-autocomplete-loading" );
		this.cancelSearch = false;

		this.source( { term: value }, this._response() );
	},

	_response: function() {
		var index = ++this.requestIndex;

		return $.proxy( function( content ) {
			if ( index === this.requestIndex ) {
				this.__response( content );
			}

			this.pending--;
			if ( !this.pending ) {
				this._removeClass( "ui-autocomplete-loading" );
			}
		}, this );
	},

	__response: function( content ) {
		if ( content ) {
			content = this._normalize( content );
		}
		this._trigger( "response", null, { content: content } );
		if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
			this._suggest( content );
			this._trigger( "open" );
		} else {

			// use ._close() instead of .close() so we don't cancel future searches
			this._close();
		}
	},

	close: function( event ) {
		this.cancelSearch = true;
		this._close( event );
	},

	_close: function( event ) {

		// Remove the handler that closes the menu on outside clicks
		this._off( this.document, "mousedown" );

		if ( this.menu.element.is( ":visible" ) ) {
			this.menu.element.hide();
			this.menu.blur();
			this.isNewMenu = true;
			this._trigger( "close", event );
		}
	},

	_change: function( event ) {
		if ( this.previous !== this._value() ) {
			this._trigger( "change", event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {

		// assume all items have the right format when the first item is complete
		if ( items.length && items[ 0 ].label && items[ 0 ].value ) {
			return items;
		}
		return $.map( items, function( item ) {
			if ( typeof item === "string" ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend( {}, item, {
				label: item.label || item.value,
				value: item.value || item.label
			} );
		} );
	},

	_suggest: function( items ) {
		var ul = this.menu.element.empty();
		this._renderMenu( ul, items );
		this.isNewMenu = true;
		this.menu.refresh();

		// Size and position menu
		ul.show();
		this._resizeMenu();
		ul.position( $.extend( {
			of: this.element
		}, this.options.position ) );

		if ( this.options.autoFocus ) {
			this.menu.next();
		}

		// Listen for interactions outside of the widget (#6642)
		this._on( this.document, {
			mousedown: "_closeOnClickOutside"
		} );
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(

			// Firefox wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping (#7513)
			ul.width( "" ).outerWidth() + 1,
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var that = this;
		$.each( items, function( index, item ) {
			that._renderItemData( ul, item );
		} );
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
	},

	_renderItem: function( ul, item ) {
		return $( "<li>" )
			.append( $( "<div>" ).text( item.label ) )
			.appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is( ":visible" ) ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
				this.menu.isLastItem() && /^next/.test( direction ) ) {

			if ( !this.isMultiLine ) {
				this._value( this.term );
			}

			this.menu.blur();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	},

	_value: function() {
		return this.valueMethod.apply( this.element, arguments );
	},

	_keyEvent: function( keyEvent, event ) {
		if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
			this._move( keyEvent, event );

			// Prevents moving cursor to beginning/end of the text field in some browsers
			event.preventDefault();
		}
	},

	// Support: Chrome <=50
	// We should be able to just use this.element.prop( "isContentEditable" )
	// but hidden elements always report false in Chrome.
	// https://code.google.com/p/chromium/issues/detail?id=313082
	_isContentEditable: function( element ) {
		if ( !element.length ) {
			return false;
		}

		var editable = element.prop( "contentEditable" );

		if ( editable === "inherit" ) {
		  return this._isContentEditable( element.parent() );
		}

		return editable === "true";
	}
} );

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
	},
	filter: function( array, term ) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex( term ), "i" );
		return $.grep( array, function( value ) {
			return matcher.test( value.label || value.value || value );
		} );
	}
} );

// Live region extension, adding a `messages` option
// NOTE: This is an experimental API. We are still investigating
// a full solution for string manipulation and internationalization.
$.widget( "ui.autocomplete", $.ui.autocomplete, {
	options: {
		messages: {
			noResults: "No search results.",
			results: function( amount ) {
				return amount + ( amount > 1 ? " results are" : " result is" ) +
					" available, use up and down arrow keys to navigate.";
			}
		}
	},

	__response: function( content ) {
		var message;
		this._superApply( arguments );
		if ( this.options.disabled || this.cancelSearch ) {
			return;
		}
		if ( content && content.length ) {
			message = this.options.messages.results( content.length );
		} else {
			message = this.options.messages.noResults;
		}
		this.liveRegion.children().hide();
		$( "<div>" ).text( message ).appendTo( this.liveRegion );
	}
} );

var widgetsAutocomplete = $.ui.autocomplete;


/*!
 * jQuery UI Controlgroup 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Controlgroup
//>>group: Widgets
//>>description: Visually groups form control widgets
//>>docs: http://api.jqueryui.com/controlgroup/
//>>demos: http://jqueryui.com/controlgroup/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/controlgroup.css
//>>css.theme: ../../themes/base/theme.css


var controlgroupCornerRegex = /ui-corner-([a-z]){2,6}/g;

var widgetsControlgroup = $.widget( "ui.controlgroup", {
	version: "1.12.1",
	defaultElement: "<div>",
	options: {
		direction: "horizontal",
		disabled: null,
		onlyVisible: true,
		items: {
			"button": "input[type=button], input[type=submit], input[type=reset], button, a",
			"controlgroupLabel": ".ui-controlgroup-label",
			"checkboxradio": "input[type='checkbox'], input[type='radio']",
			"selectmenu": "select",
			"spinner": ".ui-spinner-input"
		}
	},

	_create: function() {
		this._enhance();
	},

	// To support the enhanced option in jQuery Mobile, we isolate DOM manipulation
	_enhance: function() {
		this.element.attr( "role", "toolbar" );
		this.refresh();
	},

	_destroy: function() {
		this._callChildMethod( "destroy" );
		this.childWidgets.removeData( "ui-controlgroup-data" );
		this.element.removeAttr( "role" );
		if ( this.options.items.controlgroupLabel ) {
			this.element
				.find( this.options.items.controlgroupLabel )
				.find( ".ui-controlgroup-label-contents" )
				.contents().unwrap();
		}
	},

	_initWidgets: function() {
		var that = this,
			childWidgets = [];

		// First we iterate over each of the items options
		$.each( this.options.items, function( widget, selector ) {
			var labels;
			var options = {};

			// Make sure the widget has a selector set
			if ( !selector ) {
				return;
			}

			if ( widget === "controlgroupLabel" ) {
				labels = that.element.find( selector );
				labels.each( function() {
					var element = $( this );

					if ( element.children( ".ui-controlgroup-label-contents" ).length ) {
						return;
					}
					element.contents()
						.wrapAll( "<span class='ui-controlgroup-label-contents'></span>" );
				} );
				that._addClass( labels, null, "ui-widget ui-widget-content ui-state-default" );
				childWidgets = childWidgets.concat( labels.get() );
				return;
			}

			// Make sure the widget actually exists
			if ( !$.fn[ widget ] ) {
				return;
			}

			// We assume everything is in the middle to start because we can't determine
			// first / last elements until all enhancments are done.
			if ( that[ "_" + widget + "Options" ] ) {
				options = that[ "_" + widget + "Options" ]( "middle" );
			} else {
				options = { classes: {} };
			}

			// Find instances of this widget inside controlgroup and init them
			that.element
				.find( selector )
				.each( function() {
					var element = $( this );
					var instance = element[ widget ]( "instance" );

					// We need to clone the default options for this type of widget to avoid
					// polluting the variable options which has a wider scope than a single widget.
					var instanceOptions = $.widget.extend( {}, options );

					// If the button is the child of a spinner ignore it
					// TODO: Find a more generic solution
					if ( widget === "button" && element.parent( ".ui-spinner" ).length ) {
						return;
					}

					// Create the widget if it doesn't exist
					if ( !instance ) {
						instance = element[ widget ]()[ widget ]( "instance" );
					}
					if ( instance ) {
						instanceOptions.classes =
							that._resolveClassesValues( instanceOptions.classes, instance );
					}
					element[ widget ]( instanceOptions );

					// Store an instance of the controlgroup to be able to reference
					// from the outermost element for changing options and refresh
					var widgetElement = element[ widget ]( "widget" );
					$.data( widgetElement[ 0 ], "ui-controlgroup-data",
						instance ? instance : element[ widget ]( "instance" ) );

					childWidgets.push( widgetElement[ 0 ] );
				} );
		} );

		this.childWidgets = $( $.unique( childWidgets ) );
		this._addClass( this.childWidgets, "ui-controlgroup-item" );
	},

	_callChildMethod: function( method ) {
		this.childWidgets.each( function() {
			var element = $( this ),
				data = element.data( "ui-controlgroup-data" );
			if ( data && data[ method ] ) {
				data[ method ]();
			}
		} );
	},

	_updateCornerClass: function( element, position ) {
		var remove = "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all";
		var add = this._buildSimpleOptions( position, "label" ).classes.label;

		this._removeClass( element, null, remove );
		this._addClass( element, null, add );
	},

	_buildSimpleOptions: function( position, key ) {
		var direction = this.options.direction === "vertical";
		var result = {
			classes: {}
		};
		result.classes[ key ] = {
			"middle": "",
			"first": "ui-corner-" + ( direction ? "top" : "left" ),
			"last": "ui-corner-" + ( direction ? "bottom" : "right" ),
			"only": "ui-corner-all"
		}[ position ];

		return result;
	},

	_spinnerOptions: function( position ) {
		var options = this._buildSimpleOptions( position, "ui-spinner" );

		options.classes[ "ui-spinner-up" ] = "";
		options.classes[ "ui-spinner-down" ] = "";

		return options;
	},

	_buttonOptions: function( position ) {
		return this._buildSimpleOptions( position, "ui-button" );
	},

	_checkboxradioOptions: function( position ) {
		return this._buildSimpleOptions( position, "ui-checkboxradio-label" );
	},

	_selectmenuOptions: function( position ) {
		var direction = this.options.direction === "vertical";
		return {
			width: direction ? "auto" : false,
			classes: {
				middle: {
					"ui-selectmenu-button-open": "",
					"ui-selectmenu-button-closed": ""
				},
				first: {
					"ui-selectmenu-button-open": "ui-corner-" + ( direction ? "top" : "tl" ),
					"ui-selectmenu-button-closed": "ui-corner-" + ( direction ? "top" : "left" )
				},
				last: {
					"ui-selectmenu-button-open": direction ? "" : "ui-corner-tr",
					"ui-selectmenu-button-closed": "ui-corner-" + ( direction ? "bottom" : "right" )
				},
				only: {
					"ui-selectmenu-button-open": "ui-corner-top",
					"ui-selectmenu-button-closed": "ui-corner-all"
				}

			}[ position ]
		};
	},

	_resolveClassesValues: function( classes, instance ) {
		var result = {};
		$.each( classes, function( key ) {
			var current = instance.options.classes[ key ] || "";
			current = $.trim( current.replace( controlgroupCornerRegex, "" ) );
			result[ key ] = ( current + " " + classes[ key ] ).replace( /\s+/g, " " );
		} );
		return result;
	},

	_setOption: function( key, value ) {
		if ( key === "direction" ) {
			this._removeClass( "ui-controlgroup-" + this.options.direction );
		}

		this._super( key, value );
		if ( key === "disabled" ) {
			this._callChildMethod( value ? "disable" : "enable" );
			return;
		}

		this.refresh();
	},

	refresh: function() {
		var children,
			that = this;

		this._addClass( "ui-controlgroup ui-controlgroup-" + this.options.direction );

		if ( this.options.direction === "horizontal" ) {
			this._addClass( null, "ui-helper-clearfix" );
		}
		this._initWidgets();

		children = this.childWidgets;

		// We filter here because we need to track all childWidgets not just the visible ones
		if ( this.options.onlyVisible ) {
			children = children.filter( ":visible" );
		}

		if ( children.length ) {

			// We do this last because we need to make sure all enhancment is done
			// before determining first and last
			$.each( [ "first", "last" ], function( index, value ) {
				var instance = children[ value ]().data( "ui-controlgroup-data" );

				if ( instance && that[ "_" + instance.widgetName + "Options" ] ) {
					var options = that[ "_" + instance.widgetName + "Options" ](
						children.length === 1 ? "only" : value
					);
					options.classes = that._resolveClassesValues( options.classes, instance );
					instance.element[ instance.widgetName ]( options );
				} else {
					that._updateCornerClass( children[ value ](), value );
				}
			} );

			// Finally call the refresh method on each of the child widgets.
			this._callChildMethod( "refresh" );
		}
	}
} );

/*!
 * jQuery UI Checkboxradio 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Checkboxradio
//>>group: Widgets
//>>description: Enhances a form with multiple themeable checkboxes or radio buttons.
//>>docs: http://api.jqueryui.com/checkboxradio/
//>>demos: http://jqueryui.com/checkboxradio/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/button.css
//>>css.structure: ../../themes/base/checkboxradio.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.checkboxradio", [ $.ui.formResetMixin, {
	version: "1.12.1",
	options: {
		disabled: null,
		label: null,
		icon: true,
		classes: {
			"ui-checkboxradio-label": "ui-corner-all",
			"ui-checkboxradio-icon": "ui-corner-all"
		}
	},

	_getCreateOptions: function() {
		var disabled, labels;
		var that = this;
		var options = this._super() || {};

		// We read the type here, because it makes more sense to throw a element type error first,
		// rather then the error for lack of a label. Often if its the wrong type, it
		// won't have a label (e.g. calling on a div, btn, etc)
		this._readType();

		labels = this.element.labels();

		// If there are multiple labels, use the last one
		this.label = $( labels[ labels.length - 1 ] );
		if ( !this.label.length ) {
			$.error( "No label found for checkboxradio widget" );
		}

		this.originalLabel = "";

		// We need to get the label text but this may also need to make sure it does not contain the
		// input itself.
		this.label.contents().not( this.element[ 0 ] ).each( function() {

			// The label contents could be text, html, or a mix. We concat each element to get a
			// string representation of the label, without the input as part of it.
			that.originalLabel += this.nodeType === 3 ? $( this ).text() : this.outerHTML;
		} );

		// Set the label option if we found label text
		if ( this.originalLabel ) {
			options.label = this.originalLabel;
		}

		disabled = this.element[ 0 ].disabled;
		if ( disabled != null ) {
			options.disabled = disabled;
		}
		return options;
	},

	_create: function() {
		var checked = this.element[ 0 ].checked;

		this._bindFormResetHandler();

		if ( this.options.disabled == null ) {
			this.options.disabled = this.element[ 0 ].disabled;
		}

		this._setOption( "disabled", this.options.disabled );
		this._addClass( "ui-checkboxradio", "ui-helper-hidden-accessible" );
		this._addClass( this.label, "ui-checkboxradio-label", "ui-button ui-widget" );

		if ( this.type === "radio" ) {
			this._addClass( this.label, "ui-checkboxradio-radio-label" );
		}

		if ( this.options.label && this.options.label !== this.originalLabel ) {
			this._updateLabel();
		} else if ( this.originalLabel ) {
			this.options.label = this.originalLabel;
		}

		this._enhance();

		if ( checked ) {
			this._addClass( this.label, "ui-checkboxradio-checked", "ui-state-active" );
			if ( this.icon ) {
				this._addClass( this.icon, null, "ui-state-hover" );
			}
		}

		this._on( {
			change: "_toggleClasses",
			focus: function() {
				this._addClass( this.label, null, "ui-state-focus ui-visual-focus" );
			},
			blur: function() {
				this._removeClass( this.label, null, "ui-state-focus ui-visual-focus" );
			}
		} );
	},

	_readType: function() {
		var nodeName = this.element[ 0 ].nodeName.toLowerCase();
		this.type = this.element[ 0 ].type;
		if ( nodeName !== "input" || !/radio|checkbox/.test( this.type ) ) {
			$.error( "Can't create checkboxradio on element.nodeName=" + nodeName +
				" and element.type=" + this.type );
		}
	},

	// Support jQuery Mobile enhanced option
	_enhance: function() {
		this._updateIcon( this.element[ 0 ].checked );
	},

	widget: function() {
		return this.label;
	},

	_getRadioGroup: function() {
		var group;
		var name = this.element[ 0 ].name;
		var nameSelector = "input[name='" + $.ui.escapeSelector( name ) + "']";

		if ( !name ) {
			return $( [] );
		}

		if ( this.form.length ) {
			group = $( this.form[ 0 ].elements ).filter( nameSelector );
		} else {

			// Not inside a form, check all inputs that also are not inside a form
			group = $( nameSelector ).filter( function() {
				return $( this ).form().length === 0;
			} );
		}

		return group.not( this.element );
	},

	_toggleClasses: function() {
		var checked = this.element[ 0 ].checked;
		this._toggleClass( this.label, "ui-checkboxradio-checked", "ui-state-active", checked );

		if ( this.options.icon && this.type === "checkbox" ) {
			this._toggleClass( this.icon, null, "ui-icon-check ui-state-checked", checked )
				._toggleClass( this.icon, null, "ui-icon-blank", !checked );
		}

		if ( this.type === "radio" ) {
			this._getRadioGroup()
				.each( function() {
					var instance = $( this ).checkboxradio( "instance" );

					if ( instance ) {
						instance._removeClass( instance.label,
							"ui-checkboxradio-checked", "ui-state-active" );
					}
				} );
		}
	},

	_destroy: function() {
		this._unbindFormResetHandler();

		if ( this.icon ) {
			this.icon.remove();
			this.iconSpace.remove();
		}
	},

	_setOption: function( key, value ) {

		// We don't allow the value to be set to nothing
		if ( key === "label" && !value ) {
			return;
		}

		this._super( key, value );

		if ( key === "disabled" ) {
			this._toggleClass( this.label, null, "ui-state-disabled", value );
			this.element[ 0 ].disabled = value;

			// Don't refresh when setting disabled
			return;
		}
		this.refresh();
	},

	_updateIcon: function( checked ) {
		var toAdd = "ui-icon ui-icon-background ";

		if ( this.options.icon ) {
			if ( !this.icon ) {
				this.icon = $( "<span>" );
				this.iconSpace = $( "<span> </span>" );
				this._addClass( this.iconSpace, "ui-checkboxradio-icon-space" );
			}

			if ( this.type === "checkbox" ) {
				toAdd += checked ? "ui-icon-check ui-state-checked" : "ui-icon-blank";
				this._removeClass( this.icon, null, checked ? "ui-icon-blank" : "ui-icon-check" );
			} else {
				toAdd += "ui-icon-blank";
			}
			this._addClass( this.icon, "ui-checkboxradio-icon", toAdd );
			if ( !checked ) {
				this._removeClass( this.icon, null, "ui-icon-check ui-state-checked" );
			}
			this.icon.prependTo( this.label ).after( this.iconSpace );
		} else if ( this.icon !== undefined ) {
			this.icon.remove();
			this.iconSpace.remove();
			delete this.icon;
		}
	},

	_updateLabel: function() {

		// Remove the contents of the label ( minus the icon, icon space, and input )
		var contents = this.label.contents().not( this.element[ 0 ] );
		if ( this.icon ) {
			contents = contents.not( this.icon[ 0 ] );
		}
		if ( this.iconSpace ) {
			contents = contents.not( this.iconSpace[ 0 ] );
		}
		contents.remove();

		this.label.append( this.options.label );
	},

	refresh: function() {
		var checked = this.element[ 0 ].checked,
			isDisabled = this.element[ 0 ].disabled;

		this._updateIcon( checked );
		this._toggleClass( this.label, "ui-checkboxradio-checked", "ui-state-active", checked );
		if ( this.options.label !== null ) {
			this._updateLabel();
		}

		if ( isDisabled !== this.options.disabled ) {
			this._setOptions( { "disabled": isDisabled } );
		}
	}

} ] );

var widgetsCheckboxradio = $.ui.checkboxradio;


/*!
 * jQuery UI Button 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Button
//>>group: Widgets
//>>description: Enhances a form with themeable buttons.
//>>docs: http://api.jqueryui.com/button/
//>>demos: http://jqueryui.com/button/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/button.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.button", {
	version: "1.12.1",
	defaultElement: "<button>",
	options: {
		classes: {
			"ui-button": "ui-corner-all"
		},
		disabled: null,
		icon: null,
		iconPosition: "beginning",
		label: null,
		showLabel: true
	},

	_getCreateOptions: function() {
		var disabled,

			// This is to support cases like in jQuery Mobile where the base widget does have
			// an implementation of _getCreateOptions
			options = this._super() || {};

		this.isInput = this.element.is( "input" );

		disabled = this.element[ 0 ].disabled;
		if ( disabled != null ) {
			options.disabled = disabled;
		}

		this.originalLabel = this.isInput ? this.element.val() : this.element.html();
		if ( this.originalLabel ) {
			options.label = this.originalLabel;
		}

		return options;
	},

	_create: function() {
		if ( !this.option.showLabel & !this.options.icon ) {
			this.options.showLabel = true;
		}

		// We have to check the option again here even though we did in _getCreateOptions,
		// because null may have been passed on init which would override what was set in
		// _getCreateOptions
		if ( this.options.disabled == null ) {
			this.options.disabled = this.element[ 0 ].disabled || false;
		}

		this.hasTitle = !!this.element.attr( "title" );

		// Check to see if the label needs to be set or if its already correct
		if ( this.options.label && this.options.label !== this.originalLabel ) {
			if ( this.isInput ) {
				this.element.val( this.options.label );
			} else {
				this.element.html( this.options.label );
			}
		}
		this._addClass( "ui-button", "ui-widget" );
		this._setOption( "disabled", this.options.disabled );
		this._enhance();

		if ( this.element.is( "a" ) ) {
			this._on( {
				"keyup": function( event ) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						event.preventDefault();

						// Support: PhantomJS <= 1.9, IE 8 Only
						// If a native click is available use it so we actually cause navigation
						// otherwise just trigger a click event
						if ( this.element[ 0 ].click ) {
							this.element[ 0 ].click();
						} else {
							this.element.trigger( "click" );
						}
					}
				}
			} );
		}
	},

	_enhance: function() {
		if ( !this.element.is( "button" ) ) {
			this.element.attr( "role", "button" );
		}

		if ( this.options.icon ) {
			this._updateIcon( "icon", this.options.icon );
			this._updateTooltip();
		}
	},

	_updateTooltip: function() {
		this.title = this.element.attr( "title" );

		if ( !this.options.showLabel && !this.title ) {
			this.element.attr( "title", this.options.label );
		}
	},

	_updateIcon: function( option, value ) {
		var icon = option !== "iconPosition",
			position = icon ? this.options.iconPosition : value,
			displayBlock = position === "top" || position === "bottom";

		// Create icon
		if ( !this.icon ) {
			this.icon = $( "<span>" );

			this._addClass( this.icon, "ui-button-icon", "ui-icon" );

			if ( !this.options.showLabel ) {
				this._addClass( "ui-button-icon-only" );
			}
		} else if ( icon ) {

			// If we are updating the icon remove the old icon class
			this._removeClass( this.icon, null, this.options.icon );
		}

		// If we are updating the icon add the new icon class
		if ( icon ) {
			this._addClass( this.icon, null, value );
		}

		this._attachIcon( position );

		// If the icon is on top or bottom we need to add the ui-widget-icon-block class and remove
		// the iconSpace if there is one.
		if ( displayBlock ) {
			this._addClass( this.icon, null, "ui-widget-icon-block" );
			if ( this.iconSpace ) {
				this.iconSpace.remove();
			}
		} else {

			// Position is beginning or end so remove the ui-widget-icon-block class and add the
			// space if it does not exist
			if ( !this.iconSpace ) {
				this.iconSpace = $( "<span> </span>" );
				this._addClass( this.iconSpace, "ui-button-icon-space" );
			}
			this._removeClass( this.icon, null, "ui-wiget-icon-block" );
			this._attachIconSpace( position );
		}
	},

	_destroy: function() {
		this.element.removeAttr( "role" );

		if ( this.icon ) {
			this.icon.remove();
		}
		if ( this.iconSpace ) {
			this.iconSpace.remove();
		}
		if ( !this.hasTitle ) {
			this.element.removeAttr( "title" );
		}
	},

	_attachIconSpace: function( iconPosition ) {
		this.icon[ /^(?:end|bottom)/.test( iconPosition ) ? "before" : "after" ]( this.iconSpace );
	},

	_attachIcon: function( iconPosition ) {
		this.element[ /^(?:end|bottom)/.test( iconPosition ) ? "append" : "prepend" ]( this.icon );
	},

	_setOptions: function( options ) {
		var newShowLabel = options.showLabel === undefined ?
				this.options.showLabel :
				options.showLabel,
			newIcon = options.icon === undefined ? this.options.icon : options.icon;

		if ( !newShowLabel && !newIcon ) {
			options.showLabel = true;
		}
		this._super( options );
	},

	_setOption: function( key, value ) {
		if ( key === "icon" ) {
			if ( value ) {
				this._updateIcon( key, value );
			} else if ( this.icon ) {
				this.icon.remove();
				if ( this.iconSpace ) {
					this.iconSpace.remove();
				}
			}
		}

		if ( key === "iconPosition" ) {
			this._updateIcon( key, value );
		}

		// Make sure we can't end up with a button that has neither text nor icon
		if ( key === "showLabel" ) {
				this._toggleClass( "ui-button-icon-only", null, !value );
				this._updateTooltip();
		}

		if ( key === "label" ) {
			if ( this.isInput ) {
				this.element.val( value );
			} else {

				// If there is an icon, append it, else nothing then append the value
				// this avoids removal of the icon when setting label text
				this.element.html( value );
				if ( this.icon ) {
					this._attachIcon( this.options.iconPosition );
					this._attachIconSpace( this.options.iconPosition );
				}
			}
		}

		this._super( key, value );

		if ( key === "disabled" ) {
			this._toggleClass( null, "ui-state-disabled", value );
			this.element[ 0 ].disabled = value;
			if ( value ) {
				this.element.blur();
			}
		}
	},

	refresh: function() {

		// Make sure to only check disabled if its an element that supports this otherwise
		// check for the disabled class to determine state
		var isDisabled = this.element.is( "input, button" ) ?
			this.element[ 0 ].disabled : this.element.hasClass( "ui-button-disabled" );

		if ( isDisabled !== this.options.disabled ) {
			this._setOptions( { disabled: isDisabled } );
		}

		this._updateTooltip();
	}
} );

// DEPRECATED
if ( $.uiBackCompat !== false ) {

	// Text and Icons options
	$.widget( "ui.button", $.ui.button, {
		options: {
			text: true,
			icons: {
				primary: null,
				secondary: null
			}
		},

		_create: function() {
			if ( this.options.showLabel && !this.options.text ) {
				this.options.showLabel = this.options.text;
			}
			if ( !this.options.showLabel && this.options.text ) {
				this.options.text = this.options.showLabel;
			}
			if ( !this.options.icon && ( this.options.icons.primary ||
					this.options.icons.secondary ) ) {
				if ( this.options.icons.primary ) {
					this.options.icon = this.options.icons.primary;
				} else {
					this.options.icon = this.options.icons.secondary;
					this.options.iconPosition = "end";
				}
			} else if ( this.options.icon ) {
				this.options.icons.primary = this.options.icon;
			}
			this._super();
		},

		_setOption: function( key, value ) {
			if ( key === "text" ) {
				this._super( "showLabel", value );
				return;
			}
			if ( key === "showLabel" ) {
				this.options.text = value;
			}
			if ( key === "icon" ) {
				this.options.icons.primary = value;
			}
			if ( key === "icons" ) {
				if ( value.primary ) {
					this._super( "icon", value.primary );
					this._super( "iconPosition", "beginning" );
				} else if ( value.secondary ) {
					this._super( "icon", value.secondary );
					this._super( "iconPosition", "end" );
				}
			}
			this._superApply( arguments );
		}
	} );

	$.fn.button = ( function( orig ) {
		return function() {
			if ( !this.length || ( this.length && this[ 0 ].tagName !== "INPUT" ) ||
					( this.length && this[ 0 ].tagName === "INPUT" && (
						this.attr( "type" ) !== "checkbox" && this.attr( "type" ) !== "radio"
					) ) ) {
				return orig.apply( this, arguments );
			}
			if ( !$.ui.checkboxradio ) {
				$.error( "Checkboxradio widget missing" );
			}
			if ( arguments.length === 0 ) {
				return this.checkboxradio( {
					"icon": false
				} );
			}
			return this.checkboxradio.apply( this, arguments );
		};
	} )( $.fn.button );

	$.fn.buttonset = function() {
		if ( !$.ui.controlgroup ) {
			$.error( "Controlgroup widget missing" );
		}
		if ( arguments[ 0 ] === "option" && arguments[ 1 ] === "items" && arguments[ 2 ] ) {
			return this.controlgroup.apply( this,
				[ arguments[ 0 ], "items.button", arguments[ 2 ] ] );
		}
		if ( arguments[ 0 ] === "option" && arguments[ 1 ] === "items" ) {
			return this.controlgroup.apply( this, [ arguments[ 0 ], "items.button" ] );
		}
		if ( typeof arguments[ 0 ] === "object" && arguments[ 0 ].items ) {
			arguments[ 0 ].items = {
				button: arguments[ 0 ].items
			};
		}
		return this.controlgroup.apply( this, arguments );
	};
}

var widgetsButton = $.ui.button;


// jscs:disable maximumLineLength
/* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
/*!
 * jQuery UI Datepicker 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Datepicker
//>>group: Widgets
//>>description: Displays a calendar from an input or inline for selecting dates.
//>>docs: http://api.jqueryui.com/datepicker/
//>>demos: http://jqueryui.com/datepicker/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/datepicker.css
//>>css.theme: ../../themes/base/theme.css



$.extend( $.ui, { datepicker: { version: "1.12.1" } } );

var datepicker_instActive;

function datepicker_getZindex( elem ) {
	var position, value;
	while ( elem.length && elem[ 0 ] !== document ) {

		// Ignore z-index if position is set to a value where z-index is ignored by the browser
		// This makes behavior of this function consistent across browsers
		// WebKit always returns auto if the element is positioned
		position = elem.css( "position" );
		if ( position === "absolute" || position === "relative" || position === "fixed" ) {

			// IE returns 0 when zIndex is not specified
			// other browsers return a string
			// we ignore the case of nested elements with an explicit value of 0
			// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
			value = parseInt( elem.css( "zIndex" ), 10 );
			if ( !isNaN( value ) && value !== 0 ) {
				return value;
			}
		}
		elem = elem.parent();
	}

	return 0;
}
/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[ "" ] = { // Default regional settings
		closeText: "Done", // Display text for close link
		prevText: "Prev", // Display text for previous month link
		nextText: "Next", // Display text for next month link
		currentText: "Today", // Display text for current month link
		monthNames: [ "January","February","March","April","May","June",
			"July","August","September","October","November","December" ], // Names of months for drop-down and formatting
		monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], // For formatting
		dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], // For formatting
		dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], // For formatting
		dayNamesMin: [ "Su","Mo","Tu","We","Th","Fr","Sa" ], // Column headings for days starting at Sunday
		weekHeader: "Wk", // Column header for week of the year
		dateFormat: "mm/dd/yy", // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: "" // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: "focus", // "focus" for popup on focus,
			// "button" for trigger button, or "both" for either
		showAnim: "fadeIn", // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: "", // Display text following the input box, e.g. showing the format
		buttonText: "...", // Text for trigger button
		buttonImage: "", // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: "c-10:c+10", // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: "+10", // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with "+" for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: "fast", // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: "", // Selector for an alternate field to store selected dates into
		altFormat: "", // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend( this._defaults, this.regional[ "" ] );
	this.regional.en = $.extend( true, {}, this.regional[ "" ] );
	this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );
	this.dpDiv = datepicker_bindHover( $( "<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) );
}

$.extend( Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: "hasDatepicker",

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
	setDefaults: function( settings ) {
		datepicker_extendRemove( this._defaults, settings || {} );
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
	_attachDatepicker: function( target, settings ) {
		var nodeName, inline, inst;
		nodeName = target.nodeName.toLowerCase();
		inline = ( nodeName === "div" || nodeName === "span" );
		if ( !target.id ) {
			this.uuid += 1;
			target.id = "dp" + this.uuid;
		}
		inst = this._newInst( $( target ), inline );
		inst.settings = $.extend( {}, settings || {} );
		if ( nodeName === "input" ) {
			this._connectDatepicker( target, inst );
		} else if ( inline ) {
			this._inlineDatepicker( target, inst );
		}
	},

	/* Create a new instance object. */
	_newInst: function( target, inline ) {
		var id = target[ 0 ].id.replace( /([^A-Za-z0-9_\-])/g, "\\\\$1" ); // escape jQuery meta chars
		return { id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: ( !inline ? this.dpDiv : // presentation div
			datepicker_bindHover( $( "<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) ) ) };
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function( target, inst ) {
		var input = $( target );
		inst.append = $( [] );
		inst.trigger = $( [] );
		if ( input.hasClass( this.markerClassName ) ) {
			return;
		}
		this._attachments( input, inst );
		input.addClass( this.markerClassName ).on( "keydown", this._doKeyDown ).
			on( "keypress", this._doKeyPress ).on( "keyup", this._doKeyUp );
		this._autoSize( inst );
		$.data( target, "datepicker", inst );

		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if ( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function( input, inst ) {
		var showOn, buttonText, buttonImage,
			appendText = this._get( inst, "appendText" ),
			isRTL = this._get( inst, "isRTL" );

		if ( inst.append ) {
			inst.append.remove();
		}
		if ( appendText ) {
			inst.append = $( "<span class='" + this._appendClass + "'>" + appendText + "</span>" );
			input[ isRTL ? "before" : "after" ]( inst.append );
		}

		input.off( "focus", this._showDatepicker );

		if ( inst.trigger ) {
			inst.trigger.remove();
		}

		showOn = this._get( inst, "showOn" );
		if ( showOn === "focus" || showOn === "both" ) { // pop-up date picker when in the marked field
			input.on( "focus", this._showDatepicker );
		}
		if ( showOn === "button" || showOn === "both" ) { // pop-up date picker when button clicked
			buttonText = this._get( inst, "buttonText" );
			buttonImage = this._get( inst, "buttonImage" );
			inst.trigger = $( this._get( inst, "buttonImageOnly" ) ?
				$( "<img/>" ).addClass( this._triggerClass ).
					attr( { src: buttonImage, alt: buttonText, title: buttonText } ) :
				$( "<button type='button'></button>" ).addClass( this._triggerClass ).
					html( !buttonImage ? buttonText : $( "<img/>" ).attr(
					{ src:buttonImage, alt:buttonText, title:buttonText } ) ) );
			input[ isRTL ? "before" : "after" ]( inst.trigger );
			inst.trigger.on( "click", function() {
				if ( $.datepicker._datepickerShowing && $.datepicker._lastInput === input[ 0 ] ) {
					$.datepicker._hideDatepicker();
				} else if ( $.datepicker._datepickerShowing && $.datepicker._lastInput !== input[ 0 ] ) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker( input[ 0 ] );
				} else {
					$.datepicker._showDatepicker( input[ 0 ] );
				}
				return false;
			} );
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function( inst ) {
		if ( this._get( inst, "autoSize" ) && !inst.inline ) {
			var findMax, max, maxI, i,
				date = new Date( 2009, 12 - 1, 20 ), // Ensure double digits
				dateFormat = this._get( inst, "dateFormat" );

			if ( dateFormat.match( /[DM]/ ) ) {
				findMax = function( names ) {
					max = 0;
					maxI = 0;
					for ( i = 0; i < names.length; i++ ) {
						if ( names[ i ].length > max ) {
							max = names[ i ].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth( findMax( this._get( inst, ( dateFormat.match( /MM/ ) ?
					"monthNames" : "monthNamesShort" ) ) ) );
				date.setDate( findMax( this._get( inst, ( dateFormat.match( /DD/ ) ?
					"dayNames" : "dayNamesShort" ) ) ) + 20 - date.getDay() );
			}
			inst.input.attr( "size", this._formatDate( inst, date ).length );
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function( target, inst ) {
		var divSpan = $( target );
		if ( divSpan.hasClass( this.markerClassName ) ) {
			return;
		}
		divSpan.addClass( this.markerClassName ).append( inst.dpDiv );
		$.data( target, "datepicker", inst );
		this._setDate( inst, this._getDefaultDate( inst ), true );
		this._updateDatepicker( inst );
		this._updateAlternate( inst );

		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if ( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}

		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
	_dialogDatepicker: function( input, date, onSelect, settings, pos ) {
		var id, browserWidth, browserHeight, scrollX, scrollY,
			inst = this._dialogInst; // internal instance

		if ( !inst ) {
			this.uuid += 1;
			id = "dp" + this.uuid;
			this._dialogInput = $( "<input type='text' id='" + id +
				"' style='position: absolute; top: -100px; width: 0px;'/>" );
			this._dialogInput.on( "keydown", this._doKeyDown );
			$( "body" ).append( this._dialogInput );
			inst = this._dialogInst = this._newInst( this._dialogInput, false );
			inst.settings = {};
			$.data( this._dialogInput[ 0 ], "datepicker", inst );
		}
		datepicker_extendRemove( inst.settings, settings || {} );
		date = ( date && date.constructor === Date ? this._formatDate( inst, date ) : date );
		this._dialogInput.val( date );

		this._pos = ( pos ? ( pos.length ? pos : [ pos.pageX, pos.pageY ] ) : null );
		if ( !this._pos ) {
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[ ( browserWidth / 2 ) - 100 + scrollX, ( browserHeight / 2 ) - 150 + scrollY ];
		}

		// Move input on screen for focus, but hidden behind dialog
		this._dialogInput.css( "left", ( this._pos[ 0 ] + 20 ) + "px" ).css( "top", this._pos[ 1 ] + "px" );
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass( this._dialogClass );
		this._showDatepicker( this._dialogInput[ 0 ] );
		if ( $.blockUI ) {
			$.blockUI( this.dpDiv );
		}
		$.data( this._dialogInput[ 0 ], "datepicker", inst );
		return this;
	},

	/* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
	_destroyDatepicker: function( target ) {
		var nodeName,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		$.removeData( target, "datepicker" );
		if ( nodeName === "input" ) {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass( this.markerClassName ).
				off( "focus", this._showDatepicker ).
				off( "keydown", this._doKeyDown ).
				off( "keypress", this._doKeyPress ).
				off( "keyup", this._doKeyUp );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			$target.removeClass( this.markerClassName ).empty();
		}

		if ( datepicker_instActive === inst ) {
			datepicker_instActive = null;
		}
	},

	/* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_enableDatepicker: function( target ) {
		var nodeName, inline,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if ( nodeName === "input" ) {
			target.disabled = false;
			inst.trigger.filter( "button" ).
				each( function() { this.disabled = false; } ).end().
				filter( "img" ).css( { opacity: "1.0", cursor: "" } );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			inline = $target.children( "." + this._inlineClass );
			inline.children().removeClass( "ui-state-disabled" );
			inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
				prop( "disabled", false );
		}
		this._disabledInputs = $.map( this._disabledInputs,
			function( value ) { return ( value === target ? null : value ); } ); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_disableDatepicker: function( target ) {
		var nodeName, inline,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if ( nodeName === "input" ) {
			target.disabled = true;
			inst.trigger.filter( "button" ).
				each( function() { this.disabled = true; } ).end().
				filter( "img" ).css( { opacity: "0.5", cursor: "default" } );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			inline = $target.children( "." + this._inlineClass );
			inline.children().addClass( "ui-state-disabled" );
			inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
				prop( "disabled", true );
		}
		this._disabledInputs = $.map( this._disabledInputs,
			function( value ) { return ( value === target ? null : value ); } ); // delete entry
		this._disabledInputs[ this._disabledInputs.length ] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
	_isDisabledDatepicker: function( target ) {
		if ( !target ) {
			return false;
		}
		for ( var i = 0; i < this._disabledInputs.length; i++ ) {
			if ( this._disabledInputs[ i ] === target ) {
				return true;
			}
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
	_getInst: function( target ) {
		try {
			return $.data( target, "datepicker" );
		}
		catch ( err ) {
			throw "Missing instance data for this datepicker";
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
	_optionDatepicker: function( target, name, value ) {
		var settings, date, minDate, maxDate,
			inst = this._getInst( target );

		if ( arguments.length === 2 && typeof name === "string" ) {
			return ( name === "defaults" ? $.extend( {}, $.datepicker._defaults ) :
				( inst ? ( name === "all" ? $.extend( {}, inst.settings ) :
				this._get( inst, name ) ) : null ) );
		}

		settings = name || {};
		if ( typeof name === "string" ) {
			settings = {};
			settings[ name ] = value;
		}

		if ( inst ) {
			if ( this._curInst === inst ) {
				this._hideDatepicker();
			}

			date = this._getDateDatepicker( target, true );
			minDate = this._getMinMaxDate( inst, "min" );
			maxDate = this._getMinMaxDate( inst, "max" );
			datepicker_extendRemove( inst.settings, settings );

			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if ( minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined ) {
				inst.settings.minDate = this._formatDate( inst, minDate );
			}
			if ( maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined ) {
				inst.settings.maxDate = this._formatDate( inst, maxDate );
			}
			if ( "disabled" in settings ) {
				if ( settings.disabled ) {
					this._disableDatepicker( target );
				} else {
					this._enableDatepicker( target );
				}
			}
			this._attachments( $( target ), inst );
			this._autoSize( inst );
			this._setDate( inst, date );
			this._updateAlternate( inst );
			this._updateDatepicker( inst );
		}
	},

	// Change method deprecated
	_changeDatepicker: function( target, name, value ) {
		this._optionDatepicker( target, name, value );
	},

	/* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
	_refreshDatepicker: function( target ) {
		var inst = this._getInst( target );
		if ( inst ) {
			this._updateDatepicker( inst );
		}
	},

	/* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
	_setDateDatepicker: function( target, date ) {
		var inst = this._getInst( target );
		if ( inst ) {
			this._setDate( inst, date );
			this._updateDatepicker( inst );
			this._updateAlternate( inst );
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
	_getDateDatepicker: function( target, noDefault ) {
		var inst = this._getInst( target );
		if ( inst && !inst.inline ) {
			this._setDateFromField( inst, noDefault );
		}
		return ( inst ? this._getDate( inst ) : null );
	},

	/* Handle keystrokes. */
	_doKeyDown: function( event ) {
		var onSelect, dateStr, sel,
			inst = $.datepicker._getInst( event.target ),
			handled = true,
			isRTL = inst.dpDiv.is( ".ui-datepicker-rtl" );

		inst._keyEvent = true;
		if ( $.datepicker._datepickerShowing ) {
			switch ( event.keyCode ) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: sel = $( "td." + $.datepicker._dayOverClass + ":not(." +
									$.datepicker._currentClass + ")", inst.dpDiv );
						if ( sel[ 0 ] ) {
							$.datepicker._selectDay( event.target, inst.selectedMonth, inst.selectedYear, sel[ 0 ] );
						}

						onSelect = $.datepicker._get( inst, "onSelect" );
						if ( onSelect ) {
							dateStr = $.datepicker._formatDate( inst );

							// Trigger custom callback
							onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );
						} else {
							$.datepicker._hideDatepicker();
						}

						return false; // don't submit the form
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
							-$.datepicker._get( inst, "stepBigMonths" ) :
							-$.datepicker._get( inst, "stepMonths" ) ), "M" );
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
							+$.datepicker._get( inst, "stepBigMonths" ) :
							+$.datepicker._get( inst, "stepMonths" ) ), "M" );
						break; // next month/year on page down/+ ctrl
				case 35: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._clearDate( event.target );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._gotoToday( event.target );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, ( isRTL ? +1 : -1 ), "D" );
						}
						handled = event.ctrlKey || event.metaKey;

						// -1 day on ctrl or command +left
						if ( event.originalEvent.altKey ) {
							$.datepicker._adjustDate( event.target, ( event.ctrlKey ?
								-$.datepicker._get( inst, "stepBigMonths" ) :
								-$.datepicker._get( inst, "stepMonths" ) ), "M" );
						}

						// next month/year on alt +left on Mac
						break;
				case 38: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, -7, "D" );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, ( isRTL ? -1 : +1 ), "D" );
						}
						handled = event.ctrlKey || event.metaKey;

						// +1 day on ctrl or command +right
						if ( event.originalEvent.altKey ) {
							$.datepicker._adjustDate( event.target, ( event.ctrlKey ?
								+$.datepicker._get( inst, "stepBigMonths" ) :
								+$.datepicker._get( inst, "stepMonths" ) ), "M" );
						}

						// next month/year on alt +right
						break;
				case 40: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, +7, "D" );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		} else if ( event.keyCode === 36 && event.ctrlKey ) { // display the date picker on ctrl+home
			$.datepicker._showDatepicker( this );
		} else {
			handled = false;
		}

		if ( handled ) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function( event ) {
		var chars, chr,
			inst = $.datepicker._getInst( event.target );

		if ( $.datepicker._get( inst, "constrainInput" ) ) {
			chars = $.datepicker._possibleChars( $.datepicker._get( inst, "dateFormat" ) );
			chr = String.fromCharCode( event.charCode == null ? event.keyCode : event.charCode );
			return event.ctrlKey || event.metaKey || ( chr < " " || !chars || chars.indexOf( chr ) > -1 );
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function( event ) {
		var date,
			inst = $.datepicker._getInst( event.target );

		if ( inst.input.val() !== inst.lastVal ) {
			try {
				date = $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
					( inst.input ? inst.input.val() : null ),
					$.datepicker._getFormatConfig( inst ) );

				if ( date ) { // only if valid
					$.datepicker._setDateFromField( inst );
					$.datepicker._updateAlternate( inst );
					$.datepicker._updateDatepicker( inst );
				}
			}
			catch ( err ) {
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
	_showDatepicker: function( input ) {
		input = input.target || input;
		if ( input.nodeName.toLowerCase() !== "input" ) { // find from button/image trigger
			input = $( "input", input.parentNode )[ 0 ];
		}

		if ( $.datepicker._isDisabledDatepicker( input ) || $.datepicker._lastInput === input ) { // already here
			return;
		}

		var inst, beforeShow, beforeShowSettings, isFixed,
			offset, showAnim, duration;

		inst = $.datepicker._getInst( input );
		if ( $.datepicker._curInst && $.datepicker._curInst !== inst ) {
			$.datepicker._curInst.dpDiv.stop( true, true );
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[ 0 ] );
			}
		}

		beforeShow = $.datepicker._get( inst, "beforeShow" );
		beforeShowSettings = beforeShow ? beforeShow.apply( input, [ input, inst ] ) : {};
		if ( beforeShowSettings === false ) {
			return;
		}
		datepicker_extendRemove( inst.settings, beforeShowSettings );

		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField( inst );

		if ( $.datepicker._inDialog ) { // hide cursor
			input.value = "";
		}
		if ( !$.datepicker._pos ) { // position below input
			$.datepicker._pos = $.datepicker._findPos( input );
			$.datepicker._pos[ 1 ] += input.offsetHeight; // add the height
		}

		isFixed = false;
		$( input ).parents().each( function() {
			isFixed |= $( this ).css( "position" ) === "fixed";
			return !isFixed;
		} );

		offset = { left: $.datepicker._pos[ 0 ], top: $.datepicker._pos[ 1 ] };
		$.datepicker._pos = null;

		//to avoid flashes on Firefox
		inst.dpDiv.empty();

		// determine sizing offscreen
		inst.dpDiv.css( { position: "absolute", display: "block", top: "-1000px" } );
		$.datepicker._updateDatepicker( inst );

		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset( inst, offset, isFixed );
		inst.dpDiv.css( { position: ( $.datepicker._inDialog && $.blockUI ?
			"static" : ( isFixed ? "fixed" : "absolute" ) ), display: "none",
			left: offset.left + "px", top: offset.top + "px" } );

		if ( !inst.inline ) {
			showAnim = $.datepicker._get( inst, "showAnim" );
			duration = $.datepicker._get( inst, "duration" );
			inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );
			$.datepicker._datepickerShowing = true;

			if ( $.effects && $.effects.effect[ showAnim ] ) {
				inst.dpDiv.show( showAnim, $.datepicker._get( inst, "showOptions" ), duration );
			} else {
				inst.dpDiv[ showAnim || "show" ]( showAnim ? duration : null );
			}

			if ( $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.trigger( "focus" );
			}

			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function( inst ) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		datepicker_instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append( this._generateHTML( inst ) );
		this._attachHandlers( inst );

		var origyearshtml,
			numMonths = this._getNumberOfMonths( inst ),
			cols = numMonths[ 1 ],
			width = 17,
			activeCell = inst.dpDiv.find( "." + this._dayOverClass + " a" );

		if ( activeCell.length > 0 ) {
			datepicker_handleMouseover.apply( activeCell.get( 0 ) );
		}

		inst.dpDiv.removeClass( "ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4" ).width( "" );
		if ( cols > 1 ) {
			inst.dpDiv.addClass( "ui-datepicker-multi-" + cols ).css( "width", ( width * cols ) + "em" );
		}
		inst.dpDiv[ ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ? "add" : "remove" ) +
			"Class" ]( "ui-datepicker-multi" );
		inst.dpDiv[ ( this._get( inst, "isRTL" ) ? "add" : "remove" ) +
			"Class" ]( "ui-datepicker-rtl" );

		if ( inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
			inst.input.trigger( "focus" );
		}

		// Deffered render of the years select (to avoid flashes on Firefox)
		if ( inst.yearshtml ) {
			origyearshtml = inst.yearshtml;
			setTimeout( function() {

				//assure that inst.yearshtml didn't change.
				if ( origyearshtml === inst.yearshtml && inst.yearshtml ) {
					inst.dpDiv.find( "select.ui-datepicker-year:first" ).replaceWith( inst.yearshtml );
				}
				origyearshtml = inst.yearshtml = null;
			}, 0 );
		}
	},

	// #6694 - don't focus the input if it's already focused
	// this breaks the change event in IE
	// Support: IE and jQuery <1.9
	_shouldFocusInput: function( inst ) {
		return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function( inst, offset, isFixed ) {
		var dpWidth = inst.dpDiv.outerWidth(),
			dpHeight = inst.dpDiv.outerHeight(),
			inputWidth = inst.input ? inst.input.outerWidth() : 0,
			inputHeight = inst.input ? inst.input.outerHeight() : 0,
			viewWidth = document.documentElement.clientWidth + ( isFixed ? 0 : $( document ).scrollLeft() ),
			viewHeight = document.documentElement.clientHeight + ( isFixed ? 0 : $( document ).scrollTop() );

		offset.left -= ( this._get( inst, "isRTL" ) ? ( dpWidth - inputWidth ) : 0 );
		offset.left -= ( isFixed && offset.left === inst.input.offset().left ) ? $( document ).scrollLeft() : 0;
		offset.top -= ( isFixed && offset.top === ( inst.input.offset().top + inputHeight ) ) ? $( document ).scrollTop() : 0;

		// Now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min( offset.left, ( offset.left + dpWidth > viewWidth && viewWidth > dpWidth ) ?
			Math.abs( offset.left + dpWidth - viewWidth ) : 0 );
		offset.top -= Math.min( offset.top, ( offset.top + dpHeight > viewHeight && viewHeight > dpHeight ) ?
			Math.abs( dpHeight + inputHeight ) : 0 );

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function( obj ) {
		var position,
			inst = this._getInst( obj ),
			isRTL = this._get( inst, "isRTL" );

		while ( obj && ( obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden( obj ) ) ) {
			obj = obj[ isRTL ? "previousSibling" : "nextSibling" ];
		}

		position = $( obj ).offset();
		return [ position.left, position.top ];
	},

	/* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
	_hideDatepicker: function( input ) {
		var showAnim, duration, postProcess, onClose,
			inst = this._curInst;

		if ( !inst || ( input && inst !== $.data( input, "datepicker" ) ) ) {
			return;
		}

		if ( this._datepickerShowing ) {
			showAnim = this._get( inst, "showAnim" );
			duration = this._get( inst, "duration" );
			postProcess = function() {
				$.datepicker._tidyDialog( inst );
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
				inst.dpDiv.hide( showAnim, $.datepicker._get( inst, "showOptions" ), duration, postProcess );
			} else {
				inst.dpDiv[ ( showAnim === "slideDown" ? "slideUp" :
					( showAnim === "fadeIn" ? "fadeOut" : "hide" ) ) ]( ( showAnim ? duration : null ), postProcess );
			}

			if ( !showAnim ) {
				postProcess();
			}
			this._datepickerShowing = false;

			onClose = this._get( inst, "onClose" );
			if ( onClose ) {
				onClose.apply( ( inst.input ? inst.input[ 0 ] : null ), [ ( inst.input ? inst.input.val() : "" ), inst ] );
			}

			this._lastInput = null;
			if ( this._inDialog ) {
				this._dialogInput.css( { position: "absolute", left: "0", top: "-100px" } );
				if ( $.blockUI ) {
					$.unblockUI();
					$( "body" ).append( this.dpDiv );
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function( inst ) {
		inst.dpDiv.removeClass( this._dialogClass ).off( ".ui-datepicker-calendar" );
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function( event ) {
		if ( !$.datepicker._curInst ) {
			return;
		}

		var $target = $( event.target ),
			inst = $.datepicker._getInst( $target[ 0 ] );

		if ( ( ( $target[ 0 ].id !== $.datepicker._mainDivId &&
				$target.parents( "#" + $.datepicker._mainDivId ).length === 0 &&
				!$target.hasClass( $.datepicker.markerClassName ) &&
				!$target.closest( "." + $.datepicker._triggerClass ).length &&
				$.datepicker._datepickerShowing && !( $.datepicker._inDialog && $.blockUI ) ) ) ||
			( $target.hasClass( $.datepicker.markerClassName ) && $.datepicker._curInst !== inst ) ) {
				$.datepicker._hideDatepicker();
		}
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function( id, offset, period ) {
		var target = $( id ),
			inst = this._getInst( target[ 0 ] );

		if ( this._isDisabledDatepicker( target[ 0 ] ) ) {
			return;
		}
		this._adjustInstDate( inst, offset +
			( period === "M" ? this._get( inst, "showCurrentAtPos" ) : 0 ), // undo positioning
			period );
		this._updateDatepicker( inst );
	},

	/* Action for current link. */
	_gotoToday: function( id ) {
		var date,
			target = $( id ),
			inst = this._getInst( target[ 0 ] );

		if ( this._get( inst, "gotoCurrent" ) && inst.currentDay ) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		} else {
			date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange( inst );
		this._adjustDate( target );
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function( id, select, period ) {
		var target = $( id ),
			inst = this._getInst( target[ 0 ] );

		inst[ "selected" + ( period === "M" ? "Month" : "Year" ) ] =
		inst[ "draw" + ( period === "M" ? "Month" : "Year" ) ] =
			parseInt( select.options[ select.selectedIndex ].value, 10 );

		this._notifyChange( inst );
		this._adjustDate( target );
	},

	/* Action for selecting a day. */
	_selectDay: function( id, month, year, td ) {
		var inst,
			target = $( id );

		if ( $( td ).hasClass( this._unselectableClass ) || this._isDisabledDatepicker( target[ 0 ] ) ) {
			return;
		}

		inst = this._getInst( target[ 0 ] );
		inst.selectedDay = inst.currentDay = $( "a", td ).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate( id, this._formatDate( inst,
			inst.currentDay, inst.currentMonth, inst.currentYear ) );
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function( id ) {
		var target = $( id );
		this._selectDate( target, "" );
	},

	/* Update the input field with the selected date. */
	_selectDate: function( id, dateStr ) {
		var onSelect,
			target = $( id ),
			inst = this._getInst( target[ 0 ] );

		dateStr = ( dateStr != null ? dateStr : this._formatDate( inst ) );
		if ( inst.input ) {
			inst.input.val( dateStr );
		}
		this._updateAlternate( inst );

		onSelect = this._get( inst, "onSelect" );
		if ( onSelect ) {
			onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );  // trigger custom callback
		} else if ( inst.input ) {
			inst.input.trigger( "change" ); // fire the change event
		}

		if ( inst.inline ) {
			this._updateDatepicker( inst );
		} else {
			this._hideDatepicker();
			this._lastInput = inst.input[ 0 ];
			if ( typeof( inst.input[ 0 ] ) !== "object" ) {
				inst.input.trigger( "focus" ); // restore focus
			}
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function( inst ) {
		var altFormat, date, dateStr,
			altField = this._get( inst, "altField" );

		if ( altField ) { // update alternate field too
			altFormat = this._get( inst, "altFormat" ) || this._get( inst, "dateFormat" );
			date = this._getDate( inst );
			dateStr = this.formatDate( altFormat, date, this._getFormatConfig( inst ) );
			$( altField ).val( dateStr );
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
	noWeekends: function( date ) {
		var day = date.getDay();
		return [ ( day > 0 && day < 6 ), "" ];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
	iso8601Week: function( date ) {
		var time,
			checkDate = new Date( date.getTime() );

		// Find Thursday of this week starting on Monday
		checkDate.setDate( checkDate.getDate() + 4 - ( checkDate.getDay() || 7 ) );

		time = checkDate.getTime();
		checkDate.setMonth( 0 ); // Compare with Jan 1
		checkDate.setDate( 1 );
		return Math.floor( Math.round( ( time - checkDate ) / 86400000 ) / 7 ) + 1;
	},

	/* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
	parseDate: function( format, value, settings ) {
		if ( format == null || value == null ) {
			throw "Invalid arguments";
		}

		value = ( typeof value === "object" ? value.toString() : value + "" );
		if ( value === "" ) {
			return null;
		}

		var iFormat, dim, extra,
			iValue = 0,
			shortYearCutoffTemp = ( settings ? settings.shortYearCutoff : null ) || this._defaults.shortYearCutoff,
			shortYearCutoff = ( typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
				new Date().getFullYear() % 100 + parseInt( shortYearCutoffTemp, 10 ) ),
			dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
			dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
			monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
			monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,
			year = -1,
			month = -1,
			day = -1,
			doy = -1,
			literal = false,
			date,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			},

			// Extract a number from the string value
			getNumber = function( match ) {
				var isDoubled = lookAhead( match ),
					size = ( match === "@" ? 14 : ( match === "!" ? 20 :
					( match === "y" && isDoubled ? 4 : ( match === "o" ? 3 : 2 ) ) ) ),
					minSize = ( match === "y" ? size : 1 ),
					digits = new RegExp( "^\\d{" + minSize + "," + size + "}" ),
					num = value.substring( iValue ).match( digits );
				if ( !num ) {
					throw "Missing number at position " + iValue;
				}
				iValue += num[ 0 ].length;
				return parseInt( num[ 0 ], 10 );
			},

			// Extract a name from the string value and convert to an index
			getName = function( match, shortNames, longNames ) {
				var index = -1,
					names = $.map( lookAhead( match ) ? longNames : shortNames, function( v, k ) {
						return [ [ k, v ] ];
					} ).sort( function( a, b ) {
						return -( a[ 1 ].length - b[ 1 ].length );
					} );

				$.each( names, function( i, pair ) {
					var name = pair[ 1 ];
					if ( value.substr( iValue, name.length ).toLowerCase() === name.toLowerCase() ) {
						index = pair[ 0 ];
						iValue += name.length;
						return false;
					}
				} );
				if ( index !== -1 ) {
					return index + 1;
				} else {
					throw "Unknown name at position " + iValue;
				}
			},

			// Confirm that a literal character matches the string value
			checkLiteral = function() {
				if ( value.charAt( iValue ) !== format.charAt( iFormat ) ) {
					throw "Unexpected literal at position " + iValue;
				}
				iValue++;
			};

		for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
			if ( literal ) {
				if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
					literal = false;
				} else {
					checkLiteral();
				}
			} else {
				switch ( format.charAt( iFormat ) ) {
					case "d":
						day = getNumber( "d" );
						break;
					case "D":
						getName( "D", dayNamesShort, dayNames );
						break;
					case "o":
						doy = getNumber( "o" );
						break;
					case "m":
						month = getNumber( "m" );
						break;
					case "M":
						month = getName( "M", monthNamesShort, monthNames );
						break;
					case "y":
						year = getNumber( "y" );
						break;
					case "@":
						date = new Date( getNumber( "@" ) );
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "!":
						date = new Date( ( getNumber( "!" ) - this._ticksTo1970 ) / 10000 );
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if ( lookAhead( "'" ) ) {
							checkLiteral();
						} else {
							literal = true;
						}
						break;
					default:
						checkLiteral();
				}
			}
		}

		if ( iValue < value.length ) {
			extra = value.substr( iValue );
			if ( !/^\s+/.test( extra ) ) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}

		if ( year === -1 ) {
			year = new Date().getFullYear();
		} else if ( year < 100 ) {
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				( year <= shortYearCutoff ? 0 : -100 );
		}

		if ( doy > -1 ) {
			month = 1;
			day = doy;
			do {
				dim = this._getDaysInMonth( year, month - 1 );
				if ( day <= dim ) {
					break;
				}
				month++;
				day -= dim;
			} while ( true );
		}

		date = this._daylightSavingAdjust( new Date( year, month - 1, day ) );
		if ( date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day ) {
			throw "Invalid date"; // E.g. 31/02/00
		}
		return date;
	},

	/* Standard date formats. */
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
	COOKIE: "D, dd M yy",
	ISO_8601: "yy-mm-dd",
	RFC_822: "D, d M y",
	RFC_850: "DD, dd-M-y",
	RFC_1036: "D, d M y",
	RFC_1123: "D, d M yy",
	RFC_2822: "D, d M yy",
	RSS: "D, d M y", // RFC 822
	TICKS: "!",
	TIMESTAMP: "@",
	W3C: "yy-mm-dd", // ISO 8601

	_ticksTo1970: ( ( ( 1970 - 1 ) * 365 + Math.floor( 1970 / 4 ) - Math.floor( 1970 / 100 ) +
		Math.floor( 1970 / 400 ) ) * 24 * 60 * 60 * 10000000 ),

	/* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
	formatDate: function( format, date, settings ) {
		if ( !date ) {
			return "";
		}

		var iFormat,
			dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
			dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
			monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
			monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			},

			// Format a number, with leading zero if necessary
			formatNumber = function( match, value, len ) {
				var num = "" + value;
				if ( lookAhead( match ) ) {
					while ( num.length < len ) {
						num = "0" + num;
					}
				}
				return num;
			},

			// Format a name, short or long as requested
			formatName = function( match, value, shortNames, longNames ) {
				return ( lookAhead( match ) ? longNames[ value ] : shortNames[ value ] );
			},
			output = "",
			literal = false;

		if ( date ) {
			for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
				if ( literal ) {
					if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
						literal = false;
					} else {
						output += format.charAt( iFormat );
					}
				} else {
					switch ( format.charAt( iFormat ) ) {
						case "d":
							output += formatNumber( "d", date.getDate(), 2 );
							break;
						case "D":
							output += formatName( "D", date.getDay(), dayNamesShort, dayNames );
							break;
						case "o":
							output += formatNumber( "o",
								Math.round( ( new Date( date.getFullYear(), date.getMonth(), date.getDate() ).getTime() - new Date( date.getFullYear(), 0, 0 ).getTime() ) / 86400000 ), 3 );
							break;
						case "m":
							output += formatNumber( "m", date.getMonth() + 1, 2 );
							break;
						case "M":
							output += formatName( "M", date.getMonth(), monthNamesShort, monthNames );
							break;
						case "y":
							output += ( lookAhead( "y" ) ? date.getFullYear() :
								( date.getFullYear() % 100 < 10 ? "0" : "" ) + date.getFullYear() % 100 );
							break;
						case "@":
							output += date.getTime();
							break;
						case "!":
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if ( lookAhead( "'" ) ) {
								output += "'";
							} else {
								literal = true;
							}
							break;
						default:
							output += format.charAt( iFormat );
					}
				}
			}
		}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function( format ) {
		var iFormat,
			chars = "",
			literal = false,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			};

		for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
			if ( literal ) {
				if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
					literal = false;
				} else {
					chars += format.charAt( iFormat );
				}
			} else {
				switch ( format.charAt( iFormat ) ) {
					case "d": case "m": case "y": case "@":
						chars += "0123456789";
						break;
					case "D": case "M":
						return null; // Accept anything
					case "'":
						if ( lookAhead( "'" ) ) {
							chars += "'";
						} else {
							literal = true;
						}
						break;
					default:
						chars += format.charAt( iFormat );
				}
			}
		}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function( inst, name ) {
		return inst.settings[ name ] !== undefined ?
			inst.settings[ name ] : this._defaults[ name ];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function( inst, noDefault ) {
		if ( inst.input.val() === inst.lastVal ) {
			return;
		}

		var dateFormat = this._get( inst, "dateFormat" ),
			dates = inst.lastVal = inst.input ? inst.input.val() : null,
			defaultDate = this._getDefaultDate( inst ),
			date = defaultDate,
			settings = this._getFormatConfig( inst );

		try {
			date = this.parseDate( dateFormat, dates, settings ) || defaultDate;
		} catch ( event ) {
			dates = ( noDefault ? "" : dates );
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = ( dates ? date.getDate() : 0 );
		inst.currentMonth = ( dates ? date.getMonth() : 0 );
		inst.currentYear = ( dates ? date.getFullYear() : 0 );
		this._adjustInstDate( inst );
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function( inst ) {
		return this._restrictMinMax( inst,
			this._determineDate( inst, this._get( inst, "defaultDate" ), new Date() ) );
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function( inst, date, defaultDate ) {
		var offsetNumeric = function( offset ) {
				var date = new Date();
				date.setDate( date.getDate() + offset );
				return date;
			},
			offsetString = function( offset ) {
				try {
					return $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
						offset, $.datepicker._getFormatConfig( inst ) );
				}
				catch ( e ) {

					// Ignore
				}

				var date = ( offset.toLowerCase().match( /^c/ ) ?
					$.datepicker._getDate( inst ) : null ) || new Date(),
					year = date.getFullYear(),
					month = date.getMonth(),
					day = date.getDate(),
					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					matches = pattern.exec( offset );

				while ( matches ) {
					switch ( matches[ 2 ] || "d" ) {
						case "d" : case "D" :
							day += parseInt( matches[ 1 ], 10 ); break;
						case "w" : case "W" :
							day += parseInt( matches[ 1 ], 10 ) * 7; break;
						case "m" : case "M" :
							month += parseInt( matches[ 1 ], 10 );
							day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
							break;
						case "y": case "Y" :
							year += parseInt( matches[ 1 ], 10 );
							day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
							break;
					}
					matches = pattern.exec( offset );
				}
				return new Date( year, month, day );
			},
			newDate = ( date == null || date === "" ? defaultDate : ( typeof date === "string" ? offsetString( date ) :
				( typeof date === "number" ? ( isNaN( date ) ? defaultDate : offsetNumeric( date ) ) : new Date( date.getTime() ) ) ) );

		newDate = ( newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate );
		if ( newDate ) {
			newDate.setHours( 0 );
			newDate.setMinutes( 0 );
			newDate.setSeconds( 0 );
			newDate.setMilliseconds( 0 );
		}
		return this._daylightSavingAdjust( newDate );
	},

	/* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
	_daylightSavingAdjust: function( date ) {
		if ( !date ) {
			return null;
		}
		date.setHours( date.getHours() > 12 ? date.getHours() + 2 : 0 );
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function( inst, date, noChange ) {
		var clear = !date,
			origMonth = inst.selectedMonth,
			origYear = inst.selectedYear,
			newDate = this._restrictMinMax( inst, this._determineDate( inst, date, new Date() ) );

		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ( ( origMonth !== inst.selectedMonth || origYear !== inst.selectedYear ) && !noChange ) {
			this._notifyChange( inst );
		}
		this._adjustInstDate( inst );
		if ( inst.input ) {
			inst.input.val( clear ? "" : this._formatDate( inst ) );
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function( inst ) {
		var startDate = ( !inst.currentYear || ( inst.input && inst.input.val() === "" ) ? null :
			this._daylightSavingAdjust( new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function( inst ) {
		var stepMonths = this._get( inst, "stepMonths" ),
			id = "#" + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find( "[data-handler]" ).map( function() {
			var handler = {
				prev: function() {
					$.datepicker._adjustDate( id, -stepMonths, "M" );
				},
				next: function() {
					$.datepicker._adjustDate( id, +stepMonths, "M" );
				},
				hide: function() {
					$.datepicker._hideDatepicker();
				},
				today: function() {
					$.datepicker._gotoToday( id );
				},
				selectDay: function() {
					$.datepicker._selectDay( id, +this.getAttribute( "data-month" ), +this.getAttribute( "data-year" ), this );
					return false;
				},
				selectMonth: function() {
					$.datepicker._selectMonthYear( id, this, "M" );
					return false;
				},
				selectYear: function() {
					$.datepicker._selectMonthYear( id, this, "Y" );
					return false;
				}
			};
			$( this ).on( this.getAttribute( "data-event" ), handler[ this.getAttribute( "data-handler" ) ] );
		} );
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function( inst ) {
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
			tempDate = new Date(),
			today = this._daylightSavingAdjust(
				new Date( tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate() ) ), // clear time
			isRTL = this._get( inst, "isRTL" ),
			showButtonPanel = this._get( inst, "showButtonPanel" ),
			hideIfNoPrevNext = this._get( inst, "hideIfNoPrevNext" ),
			navigationAsDateFormat = this._get( inst, "navigationAsDateFormat" ),
			numMonths = this._getNumberOfMonths( inst ),
			showCurrentAtPos = this._get( inst, "showCurrentAtPos" ),
			stepMonths = this._get( inst, "stepMonths" ),
			isMultiMonth = ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ),
			currentDate = this._daylightSavingAdjust( ( !inst.currentDay ? new Date( 9999, 9, 9 ) :
				new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) ),
			minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			drawMonth = inst.drawMonth - showCurrentAtPos,
			drawYear = inst.drawYear;

		if ( drawMonth < 0 ) {
			drawMonth += 12;
			drawYear--;
		}
		if ( maxDate ) {
			maxDraw = this._daylightSavingAdjust( new Date( maxDate.getFullYear(),
				maxDate.getMonth() - ( numMonths[ 0 ] * numMonths[ 1 ] ) + 1, maxDate.getDate() ) );
			maxDraw = ( minDate && maxDraw < minDate ? minDate : maxDraw );
			while ( this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 ) ) > maxDraw ) {
				drawMonth--;
				if ( drawMonth < 0 ) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;

		prevText = this._get( inst, "prevText" );
		prevText = ( !navigationAsDateFormat ? prevText : this.formatDate( prevText,
			this._daylightSavingAdjust( new Date( drawYear, drawMonth - stepMonths, 1 ) ),
			this._getFormatConfig( inst ) ) );

		prev = ( this._canAdjustMonth( inst, -1, drawYear, drawMonth ) ?
			"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
			" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" :
			( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" ) );

		nextText = this._get( inst, "nextText" );
		nextText = ( !navigationAsDateFormat ? nextText : this.formatDate( nextText,
			this._daylightSavingAdjust( new Date( drawYear, drawMonth + stepMonths, 1 ) ),
			this._getFormatConfig( inst ) ) );

		next = ( this._canAdjustMonth( inst, +1, drawYear, drawMonth ) ?
			"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
			" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" :
			( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" ) );

		currentText = this._get( inst, "currentText" );
		gotoDate = ( this._get( inst, "gotoCurrent" ) && inst.currentDay ? currentDate : today );
		currentText = ( !navigationAsDateFormat ? currentText :
			this.formatDate( currentText, gotoDate, this._getFormatConfig( inst ) ) );

		controls = ( !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
			this._get( inst, "closeText" ) + "</button>" : "" );

		buttonPanel = ( showButtonPanel ) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + ( isRTL ? controls : "" ) +
			( this._isInRange( inst, gotoDate ) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
			">" + currentText + "</button>" : "" ) + ( isRTL ? "" : controls ) + "</div>" : "";

		firstDay = parseInt( this._get( inst, "firstDay" ), 10 );
		firstDay = ( isNaN( firstDay ) ? 0 : firstDay );

		showWeek = this._get( inst, "showWeek" );
		dayNames = this._get( inst, "dayNames" );
		dayNamesMin = this._get( inst, "dayNamesMin" );
		monthNames = this._get( inst, "monthNames" );
		monthNamesShort = this._get( inst, "monthNamesShort" );
		beforeShowDay = this._get( inst, "beforeShowDay" );
		showOtherMonths = this._get( inst, "showOtherMonths" );
		selectOtherMonths = this._get( inst, "selectOtherMonths" );
		defaultDate = this._getDefaultDate( inst );
		html = "";

		for ( row = 0; row < numMonths[ 0 ]; row++ ) {
			group = "";
			this.maxRows = 4;
			for ( col = 0; col < numMonths[ 1 ]; col++ ) {
				selectedDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, inst.selectedDay ) );
				cornerClass = " ui-corner-all";
				calender = "";
				if ( isMultiMonth ) {
					calender += "<div class='ui-datepicker-group";
					if ( numMonths[ 1 ] > 1 ) {
						switch ( col ) {
							case 0: calender += " ui-datepicker-group-first";
								cornerClass = " ui-corner-" + ( isRTL ? "right" : "left" ); break;
							case numMonths[ 1 ] - 1: calender += " ui-datepicker-group-last";
								cornerClass = " ui-corner-" + ( isRTL ? "left" : "right" ); break;
							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
						}
					}
					calender += "'>";
				}
				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
					( /all|left/.test( cornerClass ) && row === 0 ? ( isRTL ? next : prev ) : "" ) +
					( /all|right/.test( cornerClass ) && row === 0 ? ( isRTL ? prev : next ) : "" ) +
					this._generateMonthYearHeader( inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort ) + // draw month headers
					"</div><table class='ui-datepicker-calendar'><thead>" +
					"<tr>";
				thead = ( showWeek ? "<th class='ui-datepicker-week-col'>" + this._get( inst, "weekHeader" ) + "</th>" : "" );
				for ( dow = 0; dow < 7; dow++ ) { // days of the week
					day = ( dow + firstDay ) % 7;
					thead += "<th scope='col'" + ( ( dow + firstDay + 6 ) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "" ) + ">" +
						"<span title='" + dayNames[ day ] + "'>" + dayNamesMin[ day ] + "</span></th>";
				}
				calender += thead + "</tr></thead><tbody>";
				daysInMonth = this._getDaysInMonth( drawYear, drawMonth );
				if ( drawYear === inst.selectedYear && drawMonth === inst.selectedMonth ) {
					inst.selectedDay = Math.min( inst.selectedDay, daysInMonth );
				}
				leadDays = ( this._getFirstDayOfMonth( drawYear, drawMonth ) - firstDay + 7 ) % 7;
				curRows = Math.ceil( ( leadDays + daysInMonth ) / 7 ); // calculate the number of rows to generate
				numRows = ( isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows ); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				printDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 - leadDays ) );
				for ( dRow = 0; dRow < numRows; dRow++ ) { // create date picker rows
					calender += "<tr>";
					tbody = ( !showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
						this._get( inst, "calculateWeek" )( printDate ) + "</td>" );
					for ( dow = 0; dow < 7; dow++ ) { // create date picker days
						daySettings = ( beforeShowDay ?
							beforeShowDay.apply( ( inst.input ? inst.input[ 0 ] : null ), [ printDate ] ) : [ true, "" ] );
						otherMonth = ( printDate.getMonth() !== drawMonth );
						unselectable = ( otherMonth && !selectOtherMonths ) || !daySettings[ 0 ] ||
							( minDate && printDate < minDate ) || ( maxDate && printDate > maxDate );
						tbody += "<td class='" +
							( ( dow + firstDay + 6 ) % 7 >= 5 ? " ui-datepicker-week-end" : "" ) + // highlight weekends
							( otherMonth ? " ui-datepicker-other-month" : "" ) + // highlight days from other months
							( ( printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent ) || // user pressed key
							( defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ) ?

							// or defaultDate is current printedDate and defaultDate is selectedDate
							" " + this._dayOverClass : "" ) + // highlight selected day
							( unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "" ) +  // highlight unselectable days
							( otherMonth && !showOtherMonths ? "" : " " + daySettings[ 1 ] + // highlight custom dates
							( printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "" ) + // highlight selected day
							( printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "" ) ) + "'" + // highlight today (if different)
							( ( !otherMonth || showOtherMonths ) && daySettings[ 2 ] ? " title='" + daySettings[ 2 ].replace( /'/g, "&#39;" ) + "'" : "" ) + // cell title
							( unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'" ) + ">" + // actions
							( otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
							( unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
							( printDate.getTime() === today.getTime() ? " ui-state-highlight" : "" ) +
							( printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "" ) + // highlight selected day
							( otherMonth ? " ui-priority-secondary" : "" ) + // distinguish dates from other months
							"' href='#'>" + printDate.getDate() + "</a>" ) ) + "</td>"; // display selectable date
						printDate.setDate( printDate.getDate() + 1 );
						printDate = this._daylightSavingAdjust( printDate );
					}
					calender += tbody + "</tr>";
				}
				drawMonth++;
				if ( drawMonth > 11 ) {
					drawMonth = 0;
					drawYear++;
				}
				calender += "</tbody></table>" + ( isMultiMonth ? "</div>" +
							( ( numMonths[ 0 ] > 0 && col === numMonths[ 1 ] - 1 ) ? "<div class='ui-datepicker-row-break'></div>" : "" ) : "" );
				group += calender;
			}
			html += group;
		}
		html += buttonPanel;
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function( inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort ) {

		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
			changeMonth = this._get( inst, "changeMonth" ),
			changeYear = this._get( inst, "changeYear" ),
			showMonthAfterYear = this._get( inst, "showMonthAfterYear" ),
			html = "<div class='ui-datepicker-title'>",
			monthHtml = "";

		// Month selection
		if ( secondary || !changeMonth ) {
			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[ drawMonth ] + "</span>";
		} else {
			inMinYear = ( minDate && minDate.getFullYear() === drawYear );
			inMaxYear = ( maxDate && maxDate.getFullYear() === drawYear );
			monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
			for ( month = 0; month < 12; month++ ) {
				if ( ( !inMinYear || month >= minDate.getMonth() ) && ( !inMaxYear || month <= maxDate.getMonth() ) ) {
					monthHtml += "<option value='" + month + "'" +
						( month === drawMonth ? " selected='selected'" : "" ) +
						">" + monthNamesShort[ month ] + "</option>";
				}
			}
			monthHtml += "</select>";
		}

		if ( !showMonthAfterYear ) {
			html += monthHtml + ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" );
		}

		// Year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = "";
			if ( secondary || !changeYear ) {
				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
			} else {

				// determine range of years to display
				years = this._get( inst, "yearRange" ).split( ":" );
				thisYear = new Date().getFullYear();
				determineYear = function( value ) {
					var year = ( value.match( /c[+\-].*/ ) ? drawYear + parseInt( value.substring( 1 ), 10 ) :
						( value.match( /[+\-].*/ ) ? thisYear + parseInt( value, 10 ) :
						parseInt( value, 10 ) ) );
					return ( isNaN( year ) ? thisYear : year );
				};
				year = determineYear( years[ 0 ] );
				endYear = Math.max( year, determineYear( years[ 1 ] || "" ) );
				year = ( minDate ? Math.max( year, minDate.getFullYear() ) : year );
				endYear = ( maxDate ? Math.min( endYear, maxDate.getFullYear() ) : endYear );
				inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
				for ( ; year <= endYear; year++ ) {
					inst.yearshtml += "<option value='" + year + "'" +
						( year === drawYear ? " selected='selected'" : "" ) +
						">" + year + "</option>";
				}
				inst.yearshtml += "</select>";

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}

		html += this._get( inst, "yearSuffix" );
		if ( showMonthAfterYear ) {
			html += ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" ) + monthHtml;
		}
		html += "</div>"; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function( inst, offset, period ) {
		var year = inst.selectedYear + ( period === "Y" ? offset : 0 ),
			month = inst.selectedMonth + ( period === "M" ? offset : 0 ),
			day = Math.min( inst.selectedDay, this._getDaysInMonth( year, month ) ) + ( period === "D" ? offset : 0 ),
			date = this._restrictMinMax( inst, this._daylightSavingAdjust( new Date( year, month, day ) ) );

		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if ( period === "M" || period === "Y" ) {
			this._notifyChange( inst );
		}
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function( inst, date ) {
		var minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			newDate = ( minDate && date < minDate ? minDate : date );
		return ( maxDate && newDate > maxDate ? maxDate : newDate );
	},

	/* Notify change of month/year. */
	_notifyChange: function( inst ) {
		var onChange = this._get( inst, "onChangeMonthYear" );
		if ( onChange ) {
			onChange.apply( ( inst.input ? inst.input[ 0 ] : null ),
				[ inst.selectedYear, inst.selectedMonth + 1, inst ] );
		}
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function( inst ) {
		var numMonths = this._get( inst, "numberOfMonths" );
		return ( numMonths == null ? [ 1, 1 ] : ( typeof numMonths === "number" ? [ 1, numMonths ] : numMonths ) );
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function( inst, minMax ) {
		return this._determineDate( inst, this._get( inst, minMax + "Date" ), null );
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function( year, month ) {
		return 32 - this._daylightSavingAdjust( new Date( year, month, 32 ) ).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function( year, month ) {
		return new Date( year, month, 1 ).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function( inst, offset, curYear, curMonth ) {
		var numMonths = this._getNumberOfMonths( inst ),
			date = this._daylightSavingAdjust( new Date( curYear,
			curMonth + ( offset < 0 ? offset : numMonths[ 0 ] * numMonths[ 1 ] ), 1 ) );

		if ( offset < 0 ) {
			date.setDate( this._getDaysInMonth( date.getFullYear(), date.getMonth() ) );
		}
		return this._isInRange( inst, date );
	},

	/* Is the given date in the accepted range? */
	_isInRange: function( inst, date ) {
		var yearSplit, currentYear,
			minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			minYear = null,
			maxYear = null,
			years = this._get( inst, "yearRange" );
			if ( years ) {
				yearSplit = years.split( ":" );
				currentYear = new Date().getFullYear();
				minYear = parseInt( yearSplit[ 0 ], 10 );
				maxYear = parseInt( yearSplit[ 1 ], 10 );
				if ( yearSplit[ 0 ].match( /[+\-].*/ ) ) {
					minYear += currentYear;
				}
				if ( yearSplit[ 1 ].match( /[+\-].*/ ) ) {
					maxYear += currentYear;
				}
			}

		return ( ( !minDate || date.getTime() >= minDate.getTime() ) &&
			( !maxDate || date.getTime() <= maxDate.getTime() ) &&
			( !minYear || date.getFullYear() >= minYear ) &&
			( !maxYear || date.getFullYear() <= maxYear ) );
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function( inst ) {
		var shortYearCutoff = this._get( inst, "shortYearCutoff" );
		shortYearCutoff = ( typeof shortYearCutoff !== "string" ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt( shortYearCutoff, 10 ) );
		return { shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get( inst, "dayNamesShort" ), dayNames: this._get( inst, "dayNames" ),
			monthNamesShort: this._get( inst, "monthNamesShort" ), monthNames: this._get( inst, "monthNames" ) };
	},

	/* Format the given date for display. */
	_formatDate: function( inst, day, month, year ) {
		if ( !day ) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = ( day ? ( typeof day === "object" ? day :
			this._daylightSavingAdjust( new Date( year, month, day ) ) ) :
			this._daylightSavingAdjust( new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
		return this.formatDate( this._get( inst, "dateFormat" ), date, this._getFormatConfig( inst ) );
	}
} );

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function datepicker_bindHover( dpDiv ) {
	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
	return dpDiv.on( "mouseout", selector, function() {
			$( this ).removeClass( "ui-state-hover" );
			if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
				$( this ).removeClass( "ui-datepicker-prev-hover" );
			}
			if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
				$( this ).removeClass( "ui-datepicker-next-hover" );
			}
		} )
		.on( "mouseover", selector, datepicker_handleMouseover );
}

function datepicker_handleMouseover() {
	if ( !$.datepicker._isDisabledDatepicker( datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[ 0 ] : datepicker_instActive.input[ 0 ] ) ) {
		$( this ).parents( ".ui-datepicker-calendar" ).find( "a" ).removeClass( "ui-state-hover" );
		$( this ).addClass( "ui-state-hover" );
		if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
			$( this ).addClass( "ui-datepicker-prev-hover" );
		}
		if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
			$( this ).addClass( "ui-datepicker-next-hover" );
		}
	}
}

/* jQuery extend now ignores nulls! */
function datepicker_extendRemove( target, props ) {
	$.extend( target, props );
	for ( var name in props ) {
		if ( props[ name ] == null ) {
			target[ name ] = props[ name ];
		}
	}
	return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function( options ) {

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if ( !$.datepicker.initialized ) {
		$( document ).on( "mousedown", $.datepicker._checkExternalClick );
		$.datepicker.initialized = true;
	}

	/* Append datepicker main container to body if not exist. */
	if ( $( "#" + $.datepicker._mainDivId ).length === 0 ) {
		$( "body" ).append( $.datepicker.dpDiv );
	}

	var otherArgs = Array.prototype.slice.call( arguments, 1 );
	if ( typeof options === "string" && ( options === "isDisabled" || options === "getDate" || options === "widget" ) ) {
		return $.datepicker[ "_" + options + "Datepicker" ].
			apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
	}
	if ( options === "option" && arguments.length === 2 && typeof arguments[ 1 ] === "string" ) {
		return $.datepicker[ "_" + options + "Datepicker" ].
			apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
	}
	return this.each( function() {
		typeof options === "string" ?
			$.datepicker[ "_" + options + "Datepicker" ].
				apply( $.datepicker, [ this ].concat( otherArgs ) ) :
			$.datepicker._attachDatepicker( this, options );
	} );
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.12.1";

var widgetsDatepicker = $.datepicker;




// This file is deprecated
var ie = $.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

/*!
 * jQuery UI Mouse 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Mouse
//>>group: Widgets
//>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
//>>docs: http://api.jqueryui.com/mouse/



var mouseHandled = false;
$( document ).on( "mouseup", function() {
	mouseHandled = false;
} );

var widgetsMouse = $.widget( "ui.mouse", {
	version: "1.12.1",
	options: {
		cancel: "input, textarea, button, select, option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.on( "mousedown." + this.widgetName, function( event ) {
				return that._mouseDown( event );
			} )
			.on( "click." + this.widgetName, function( event ) {
				if ( true === $.data( event.target, that.widgetName + ".preventClickEvent" ) ) {
					$.removeData( event.target, that.widgetName + ".preventClickEvent" );
					event.stopImmediatePropagation();
					return false;
				}
			} );

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.off( "." + this.widgetName );
		if ( this._mouseMoveDelegate ) {
			this.document
				.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
				.off( "mouseup." + this.widgetName, this._mouseUpDelegate );
		}
	},

	_mouseDown: function( event ) {

		// don't let more than one widget handle mouseStart
		if ( mouseHandled ) {
			return;
		}

		this._mouseMoved = false;

		// We may have missed mouseup (out of window)
		( this._mouseStarted && this._mouseUp( event ) );

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = ( event.which === 1 ),

			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = ( typeof this.options.cancel === "string" && event.target.nodeName ?
				$( event.target ).closest( this.options.cancel ).length : false );
		if ( !btnIsLeft || elIsCancel || !this._mouseCapture( event ) ) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if ( !this.mouseDelayMet ) {
			this._mouseDelayTimer = setTimeout( function() {
				that.mouseDelayMet = true;
			}, this.options.delay );
		}

		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
			this._mouseStarted = ( this._mouseStart( event ) !== false );
			if ( !this._mouseStarted ) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if ( true === $.data( event.target, this.widgetName + ".preventClickEvent" ) ) {
			$.removeData( event.target, this.widgetName + ".preventClickEvent" );
		}

		// These delegates are required to keep context
		this._mouseMoveDelegate = function( event ) {
			return that._mouseMove( event );
		};
		this._mouseUpDelegate = function( event ) {
			return that._mouseUp( event );
		};

		this.document
			.on( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.on( "mouseup." + this.widgetName, this._mouseUpDelegate );

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function( event ) {

		// Only check for mouseups outside the document if you've moved inside the document
		// at least once. This prevents the firing of mouseup in the case of IE<9, which will
		// fire a mousemove event if content is placed under the cursor. See #7778
		// Support: IE <9
		if ( this._mouseMoved ) {

			// IE mouseup check - mouseup happened when mouse was out of window
			if ( $.ui.ie && ( !document.documentMode || document.documentMode < 9 ) &&
					!event.button ) {
				return this._mouseUp( event );

			// Iframe mouseup check - mouseup occurred in another document
			} else if ( !event.which ) {

				// Support: Safari <=8 - 9
				// Safari sets which to 0 if you press any of the following keys
				// during a drag (#14461)
				if ( event.originalEvent.altKey || event.originalEvent.ctrlKey ||
						event.originalEvent.metaKey || event.originalEvent.shiftKey ) {
					this.ignoreMissingWhich = true;
				} else if ( !this.ignoreMissingWhich ) {
					return this._mouseUp( event );
				}
			}
		}

		if ( event.which || event.button ) {
			this._mouseMoved = true;
		}

		if ( this._mouseStarted ) {
			this._mouseDrag( event );
			return event.preventDefault();
		}

		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
			this._mouseStarted =
				( this._mouseStart( this._mouseDownEvent, event ) !== false );
			( this._mouseStarted ? this._mouseDrag( event ) : this._mouseUp( event ) );
		}

		return !this._mouseStarted;
	},

	_mouseUp: function( event ) {
		this.document
			.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.off( "mouseup." + this.widgetName, this._mouseUpDelegate );

		if ( this._mouseStarted ) {
			this._mouseStarted = false;

			if ( event.target === this._mouseDownEvent.target ) {
				$.data( event.target, this.widgetName + ".preventClickEvent", true );
			}

			this._mouseStop( event );
		}

		if ( this._mouseDelayTimer ) {
			clearTimeout( this._mouseDelayTimer );
			delete this._mouseDelayTimer;
		}

		this.ignoreMissingWhich = false;
		mouseHandled = false;
		event.preventDefault();
	},

	_mouseDistanceMet: function( event ) {
		return ( Math.max(
				Math.abs( this._mouseDownEvent.pageX - event.pageX ),
				Math.abs( this._mouseDownEvent.pageY - event.pageY )
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function( /* event */ ) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function( /* event */ ) {},
	_mouseDrag: function( /* event */ ) {},
	_mouseStop: function( /* event */ ) {},
	_mouseCapture: function( /* event */ ) { return true; }
} );




// $.ui.plugin is deprecated. Use $.widget() extensions instead.
var plugin = $.ui.plugin = {
	add: function( module, option, set ) {
		var i,
			proto = $.ui[ module ].prototype;
		for ( i in set ) {
			proto.plugins[ i ] = proto.plugins[ i ] || [];
			proto.plugins[ i ].push( [ option, set[ i ] ] );
		}
	},
	call: function( instance, name, args, allowDisconnected ) {
		var i,
			set = instance.plugins[ name ];

		if ( !set ) {
			return;
		}

		if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode ||
				instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
			return;
		}

		for ( i = 0; i < set.length; i++ ) {
			if ( instance.options[ set[ i ][ 0 ] ] ) {
				set[ i ][ 1 ].apply( instance.element, args );
			}
		}
	}
};



var safeBlur = $.ui.safeBlur = function( element ) {

	// Support: IE9 - 10 only
	// If the <body> is blurred, IE will switch windows, see #9420
	if ( element && element.nodeName.toLowerCase() !== "body" ) {
		$( element ).trigger( "blur" );
	}
};


/*!
 * jQuery UI Draggable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Draggable
//>>group: Interactions
//>>description: Enables dragging functionality for any element.
//>>docs: http://api.jqueryui.com/draggable/
//>>demos: http://jqueryui.com/draggable/
//>>css.structure: ../../themes/base/draggable.css



$.widget( "ui.draggable", $.ui.mouse, {
	version: "1.12.1",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// Callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if ( this.options.helper === "original" ) {
			this._setPositionRelative();
		}
		if ( this.options.addClasses ) {
			this._addClass( "ui-draggable" );
		}
		this._setHandleClassName();

		this._mouseInit();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "handle" ) {
			this._removeHandleClassName();
			this._setHandleClassName();
		}
	},

	_destroy: function() {
		if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
			this.destroyOnClear = true;
			return;
		}
		this._removeHandleClassName();
		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var o = this.options;

		// Among others, prevent a drag on a resizable-handle
		if ( this.helper || o.disabled ||
				$( event.target ).closest( ".ui-resizable-handle" ).length > 0 ) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle( event );
		if ( !this.handle ) {
			return false;
		}

		this._blurActiveElement( event );

		this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );

		return true;

	},

	_blockFrames: function( selector ) {
		this.iframeBlocks = this.document.find( selector ).map( function() {
			var iframe = $( this );

			return $( "<div>" )
				.css( "position", "absolute" )
				.appendTo( iframe.parent() )
				.outerWidth( iframe.outerWidth() )
				.outerHeight( iframe.outerHeight() )
				.offset( iframe.offset() )[ 0 ];
		} );
	},

	_unblockFrames: function() {
		if ( this.iframeBlocks ) {
			this.iframeBlocks.remove();
			delete this.iframeBlocks;
		}
	},

	_blurActiveElement: function( event ) {
		var activeElement = $.ui.safeActiveElement( this.document[ 0 ] ),
			target = $( event.target );

		// Don't blur if the event occurred on an element that is within
		// the currently focused element
		// See #10527, #12472
		if ( target.closest( activeElement ).length ) {
			return;
		}

		// Blur any element that currently has focus, see #4261
		$.ui.safeBlur( activeElement );
	},

	_mouseStart: function( event ) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper( event );

		this._addClass( this.helper, "ui-draggable-dragging" );

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent( true );
		this.offsetParent = this.helper.offsetParent();
		this.hasFixedAncestor = this.helper.parents().filter( function() {
				return $( this ).css( "position" ) === "fixed";
			} ).length > 0;

		//The element's absolute position on the page minus margins
		this.positionAbs = this.element.offset();
		this._refreshOffsets( event );

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition( event, false );
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		( o.cursorAt && this._adjustOffsetFromHelper( o.cursorAt ) );

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if ( this._trigger( "start", event ) === false ) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ( $.ui.ddmanager && !o.dropBehaviour ) {
			$.ui.ddmanager.prepareOffsets( this, event );
		}

		// Execute the drag once - this causes the helper not to be visible before getting its
		// correct position
		this._mouseDrag( event, true );

		// If the ddmanager is used for droppables, inform the manager that dragging has started
		// (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart( this, event );
		}

		return true;
	},

	_refreshOffsets: function( event ) {
		this.offset = {
			top: this.positionAbs.top - this.margins.top,
			left: this.positionAbs.left - this.margins.left,
			scroll: false,
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset()
		};

		this.offset.click = {
			left: event.pageX - this.offset.left,
			top: event.pageY - this.offset.top
		};
	},

	_mouseDrag: function( event, noPropagation ) {

		// reset any necessary cached properties (see #5009)
		if ( this.hasFixedAncestor ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition( event, true );
		this.positionAbs = this._convertPositionTo( "absolute" );

		//Call plugins and callbacks and use the resulting position if something is returned
		if ( !noPropagation ) {
			var ui = this._uiHash();
			if ( this._trigger( "drag", event, ui ) === false ) {
				this._mouseUp( new $.Event( "mouseup", event ) );
				return false;
			}
			this.position = ui.position;
		}

		this.helper[ 0 ].style.left = this.position.left + "px";
		this.helper[ 0 ].style.top = this.position.top + "px";

		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.drag( this, event );
		}

		return false;
	},

	_mouseStop: function( event ) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ( $.ui.ddmanager && !this.options.dropBehaviour ) {
			dropped = $.ui.ddmanager.drop( this, event );
		}

		//if a drop comes from outside (a sortable)
		if ( this.dropped ) {
			dropped = this.dropped;
			this.dropped = false;
		}

		if ( ( this.options.revert === "invalid" && !dropped ) ||
				( this.options.revert === "valid" && dropped ) ||
				this.options.revert === true || ( $.isFunction( this.options.revert ) &&
				this.options.revert.call( this.element, dropped ) )
		) {
			$( this.helper ).animate(
				this.originalPosition,
				parseInt( this.options.revertDuration, 10 ),
				function() {
					if ( that._trigger( "stop", event ) !== false ) {
						that._clear();
					}
				}
			);
		} else {
			if ( this._trigger( "stop", event ) !== false ) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function( event ) {
		this._unblockFrames();

		// If the ddmanager is used for droppables, inform the manager that dragging has stopped
		// (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop( this, event );
		}

		// Only need to focus if the event occurred on the draggable itself, see #10527
		if ( this.handleElement.is( event.target ) ) {

			// The interaction is over; whether or not the click resulted in a drag,
			// focus the element
			this.element.trigger( "focus" );
		}

		return $.ui.mouse.prototype._mouseUp.call( this, event );
	},

	cancel: function() {

		if ( this.helper.is( ".ui-draggable-dragging" ) ) {
			this._mouseUp( new $.Event( "mouseup", { target: this.element[ 0 ] } ) );
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function( event ) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_setHandleClassName: function() {
		this.handleElement = this.options.handle ?
			this.element.find( this.options.handle ) : this.element;
		this._addClass( this.handleElement, "ui-draggable-handle" );
	},

	_removeHandleClassName: function() {
		this._removeClass( this.handleElement, "ui-draggable-handle" );
	},

	_createHelper: function( event ) {

		var o = this.options,
			helperIsFunction = $.isFunction( o.helper ),
			helper = helperIsFunction ?
				$( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
				( o.helper === "clone" ?
					this.element.clone().removeAttr( "id" ) :
					this.element );

		if ( !helper.parents( "body" ).length ) {
			helper.appendTo( ( o.appendTo === "parent" ?
				this.element[ 0 ].parentNode :
				o.appendTo ) );
		}

		// Http://bugs.jqueryui.com/ticket/9446
		// a helper function can return the original element
		// which wouldn't have been set to relative in _create
		if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
			this._setPositionRelative();
		}

		if ( helper[ 0 ] !== this.element[ 0 ] &&
				!( /(fixed|absolute)/ ).test( helper.css( "position" ) ) ) {
			helper.css( "position", "absolute" );
		}

		return helper;

	},

	_setPositionRelative: function() {
		if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
			this.element[ 0 ].style.position = "relative";
		}
	},

	_adjustOffsetFromHelper: function( obj ) {
		if ( typeof obj === "string" ) {
			obj = obj.split( " " );
		}
		if ( $.isArray( obj ) ) {
			obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 };
		}
		if ( "left" in obj ) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ( "right" in obj ) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ( "top" in obj ) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ( "bottom" in obj ) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_isRootNode: function( element ) {
		return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset(),
			document = this.document[ 0 ];

		// This is a special case where we need to modify a offset calculated on start, since the
		// following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the
		// next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
		// the document, which means that the scroll is included in the initial calculation of the
		// offset of the parent, and never recalculated upon drag
		if ( this.cssPosition === "absolute" && this.scrollParent[ 0 ] !== document &&
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + ( parseInt( this.offsetParent.css( "borderTopWidth" ), 10 ) || 0 ),
			left: po.left + ( parseInt( this.offsetParent.css( "borderLeftWidth" ), 10 ) || 0 )
		};

	},

	_getRelativeOffset: function() {
		if ( this.cssPosition !== "relative" ) {
			return { top: 0, left: 0 };
		}

		var p = this.element.position(),
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: p.top - ( parseInt( this.helper.css( "top" ), 10 ) || 0 ) +
				( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
			left: p.left - ( parseInt( this.helper.css( "left" ), 10 ) || 0 ) +
				( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
		};

	},

	_cacheMargins: function() {
		this.margins = {
			left: ( parseInt( this.element.css( "marginLeft" ), 10 ) || 0 ),
			top: ( parseInt( this.element.css( "marginTop" ), 10 ) || 0 ),
			right: ( parseInt( this.element.css( "marginRight" ), 10 ) || 0 ),
			bottom: ( parseInt( this.element.css( "marginBottom" ), 10 ) || 0 )
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var isUserScrollable, c, ce,
			o = this.options,
			document = this.document[ 0 ];

		this.relativeContainer = null;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() -
					this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() +
					( $( window ).height() || document.body.parentNode.scrollHeight ) -
					this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document" ) {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) -
					this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if ( !ce ) {
			return;
		}

		isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) +
				( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) +
				( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
			( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
				( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
				this.helperProportions.width -
				this.margins.left -
				this.margins.right,
			( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
				( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
				this.helperProportions.height -
				this.margins.top -
				this.margins.bottom
		];
		this.relativeContainer = c;
	},

	_convertPositionTo: function( d, pos ) {

		if ( !pos ) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: (

				// The absolute mouse position
				pos.top	+

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top * mod -
				( ( this.cssPosition === "fixed" ?
					-this.offset.scroll.top :
					( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod )
			),
			left: (

				// The absolute mouse position
				pos.left +

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left * mod	-
				( ( this.cssPosition === "fixed" ?
					-this.offset.scroll.left :
					( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod )
			)
		};

	},

	_generatePosition: function( event, constrainPosition ) {

		var containment, co, top, left,
			o = this.options,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
			pageX = event.pageX,
			pageY = event.pageY;

		// Cache the scroll
		if ( !scrollIsRootNode || !this.offset.scroll ) {
			this.offset.scroll = {
				top: this.scrollParent.scrollTop(),
				left: this.scrollParent.scrollLeft()
			};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( constrainPosition ) {
			if ( this.containment ) {
				if ( this.relativeContainer ) {
					co = this.relativeContainer.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				} else {
					containment = this.containment;
				}

				if ( event.pageX - this.offset.click.left < containment[ 0 ] ) {
					pageX = containment[ 0 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top < containment[ 1 ] ) {
					pageY = containment[ 1 ] + this.offset.click.top;
				}
				if ( event.pageX - this.offset.click.left > containment[ 2 ] ) {
					pageX = containment[ 2 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top > containment[ 3 ] ) {
					pageY = containment[ 3 ] + this.offset.click.top;
				}
			}

			if ( o.grid ) {

				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid
				// argument errors in IE (see ticket #6950)
				top = o.grid[ 1 ] ? this.originalPageY + Math.round( ( pageY -
					this.originalPageY ) / o.grid[ 1 ] ) * o.grid[ 1 ] : this.originalPageY;
				pageY = containment ? ( ( top - this.offset.click.top >= containment[ 1 ] ||
					top - this.offset.click.top > containment[ 3 ] ) ?
						top :
						( ( top - this.offset.click.top >= containment[ 1 ] ) ?
							top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) : top;

				left = o.grid[ 0 ] ? this.originalPageX +
					Math.round( ( pageX - this.originalPageX ) / o.grid[ 0 ] ) * o.grid[ 0 ] :
					this.originalPageX;
				pageX = containment ? ( ( left - this.offset.click.left >= containment[ 0 ] ||
					left - this.offset.click.left > containment[ 2 ] ) ?
						left :
						( ( left - this.offset.click.left >= containment[ 0 ] ) ?
							left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) : left;
			}

			if ( o.axis === "y" ) {
				pageX = this.originalPageX;
			}

			if ( o.axis === "x" ) {
				pageY = this.originalPageY;
			}
		}

		return {
			top: (

				// The absolute mouse position
				pageY -

				// Click offset (relative to the element)
				this.offset.click.top -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top +
				( this.cssPosition === "fixed" ?
					-this.offset.scroll.top :
					( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
			),
			left: (

				// The absolute mouse position
				pageX -

				// Click offset (relative to the element)
				this.offset.click.left -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left +
				( this.cssPosition === "fixed" ?
					-this.offset.scroll.left :
					( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
			)
		};

	},

	_clear: function() {
		this._removeClass( this.helper, "ui-draggable-dragging" );
		if ( this.helper[ 0 ] !== this.element[ 0 ] && !this.cancelHelperRemoval ) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
		if ( this.destroyOnClear ) {
			this.destroy();
		}
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function( type, event, ui ) {
		ui = ui || this._uiHash();
		$.ui.plugin.call( this, type, [ event, ui, this ], true );

		// Absolute position and offset (see #6884 ) have to be recalculated after plugins
		if ( /^(drag|start|stop)/.test( type ) ) {
			this.positionAbs = this._convertPositionTo( "absolute" );
			ui.offset = this.positionAbs;
		}
		return $.Widget.prototype._trigger.call( this, type, event, ui );
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

} );

$.ui.plugin.add( "draggable", "connectToSortable", {
	start: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		} );

		draggable.sortables = [];
		$( draggable.options.connectToSortable ).each( function() {
			var sortable = $( this ).sortable( "instance" );

			if ( sortable && !sortable.options.disabled ) {
				draggable.sortables.push( sortable );

				// RefreshPositions is called at drag start to refresh the containerCache
				// which is used in drag. This ensures it's initialized and synchronized
				// with any changes that might have happened on the page since initialization.
				sortable.refreshPositions();
				sortable._trigger( "activate", event, uiSortable );
			}
		} );
	},
	stop: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		} );

		draggable.cancelHelperRemoval = false;

		$.each( draggable.sortables, function() {
			var sortable = this;

			if ( sortable.isOver ) {
				sortable.isOver = 0;

				// Allow this sortable to handle removing the helper
				draggable.cancelHelperRemoval = true;
				sortable.cancelHelperRemoval = false;

				// Use _storedCSS To restore properties in the sortable,
				// as this also handles revert (#9675) since the draggable
				// may have modified them in unexpected ways (#8809)
				sortable._storedCSS = {
					position: sortable.placeholder.css( "position" ),
					top: sortable.placeholder.css( "top" ),
					left: sortable.placeholder.css( "left" )
				};

				sortable._mouseStop( event );

				// Once drag has ended, the sortable should return to using
				// its original helper, not the shared helper from draggable
				sortable.options.helper = sortable.options._helper;
			} else {

				// Prevent this Sortable from removing the helper.
				// However, don't set the draggable to remove the helper
				// either as another connected Sortable may yet handle the removal.
				sortable.cancelHelperRemoval = true;

				sortable._trigger( "deactivate", event, uiSortable );
			}
		} );
	},
	drag: function( event, ui, draggable ) {
		$.each( draggable.sortables, function() {
			var innermostIntersecting = false,
				sortable = this;

			// Copy over variables that sortable's _intersectsWith uses
			sortable.positionAbs = draggable.positionAbs;
			sortable.helperProportions = draggable.helperProportions;
			sortable.offset.click = draggable.offset.click;

			if ( sortable._intersectsWith( sortable.containerCache ) ) {
				innermostIntersecting = true;

				$.each( draggable.sortables, function() {

					// Copy over variables that sortable's _intersectsWith uses
					this.positionAbs = draggable.positionAbs;
					this.helperProportions = draggable.helperProportions;
					this.offset.click = draggable.offset.click;

					if ( this !== sortable &&
							this._intersectsWith( this.containerCache ) &&
							$.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
						innermostIntersecting = false;
					}

					return innermostIntersecting;
				} );
			}

			if ( innermostIntersecting ) {

				// If it intersects, we use a little isOver variable and set it once,
				// so that the move-in stuff gets fired only once.
				if ( !sortable.isOver ) {
					sortable.isOver = 1;

					// Store draggable's parent in case we need to reappend to it later.
					draggable._parent = ui.helper.parent();

					sortable.currentItem = ui.helper
						.appendTo( sortable.element )
						.data( "ui-sortable-item", true );

					// Store helper option to later restore it
					sortable.options._helper = sortable.options.helper;

					sortable.options.helper = function() {
						return ui.helper[ 0 ];
					};

					// Fire the start events of the sortable with our passed browser event,
					// and our own helper (so it doesn't create a new one)
					event.target = sortable.currentItem[ 0 ];
					sortable._mouseCapture( event, true );
					sortable._mouseStart( event, true, true );

					// Because the browser event is way off the new appended portlet,
					// modify necessary variables to reflect the changes
					sortable.offset.click.top = draggable.offset.click.top;
					sortable.offset.click.left = draggable.offset.click.left;
					sortable.offset.parent.left -= draggable.offset.parent.left -
						sortable.offset.parent.left;
					sortable.offset.parent.top -= draggable.offset.parent.top -
						sortable.offset.parent.top;

					draggable._trigger( "toSortable", event );

					// Inform draggable that the helper is in a valid drop zone,
					// used solely in the revert option to handle "valid/invalid".
					draggable.dropped = sortable.element;

					// Need to refreshPositions of all sortables in the case that
					// adding to one sortable changes the location of the other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					} );

					// Hack so receive/update callbacks work (mostly)
					draggable.currentItem = draggable.element;
					sortable.fromOutside = draggable;
				}

				if ( sortable.currentItem ) {
					sortable._mouseDrag( event );

					// Copy the sortable's position because the draggable's can potentially reflect
					// a relative position, while sortable is always absolute, which the dragged
					// element has now become. (#8809)
					ui.position = sortable.position;
				}
			} else {

				// If it doesn't intersect with the sortable, and it intersected before,
				// we fake the drag stop of the sortable, but make sure it doesn't remove
				// the helper by using cancelHelperRemoval.
				if ( sortable.isOver ) {

					sortable.isOver = 0;
					sortable.cancelHelperRemoval = true;

					// Calling sortable's mouseStop would trigger a revert,
					// so revert must be temporarily false until after mouseStop is called.
					sortable.options._revert = sortable.options.revert;
					sortable.options.revert = false;

					sortable._trigger( "out", event, sortable._uiHash( sortable ) );
					sortable._mouseStop( event, true );

					// Restore sortable behaviors that were modfied
					// when the draggable entered the sortable area (#9481)
					sortable.options.revert = sortable.options._revert;
					sortable.options.helper = sortable.options._helper;

					if ( sortable.placeholder ) {
						sortable.placeholder.remove();
					}

					// Restore and recalculate the draggable's offset considering the sortable
					// may have modified them in unexpected ways. (#8809, #10669)
					ui.helper.appendTo( draggable._parent );
					draggable._refreshOffsets( event );
					ui.position = draggable._generatePosition( event, true );

					draggable._trigger( "fromSortable", event );

					// Inform draggable that the helper is no longer in a valid drop zone
					draggable.dropped = false;

					// Need to refreshPositions of all sortables just in case removing
					// from one sortable changes the location of other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					} );
				}
			}
		} );
	}
} );

$.ui.plugin.add( "draggable", "cursor", {
	start: function( event, ui, instance ) {
		var t = $( "body" ),
			o = instance.options;

		if ( t.css( "cursor" ) ) {
			o._cursor = t.css( "cursor" );
		}
		t.css( "cursor", o.cursor );
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if ( o._cursor ) {
			$( "body" ).css( "cursor", o._cursor );
		}
	}
} );

$.ui.plugin.add( "draggable", "opacity", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;
		if ( t.css( "opacity" ) ) {
			o._opacity = t.css( "opacity" );
		}
		t.css( "opacity", o.opacity );
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if ( o._opacity ) {
			$( ui.helper ).css( "opacity", o._opacity );
		}
	}
} );

$.ui.plugin.add( "draggable", "scroll", {
	start: function( event, ui, i ) {
		if ( !i.scrollParentNotHidden ) {
			i.scrollParentNotHidden = i.helper.scrollParent( false );
		}

		if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] &&
				i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
			i.overflowOffset = i.scrollParentNotHidden.offset();
		}
	},
	drag: function( event, ui, i  ) {

		var o = i.options,
			scrolled = false,
			scrollParent = i.scrollParentNotHidden[ 0 ],
			document = i.document[ 0 ];

		if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
			if ( !o.axis || o.axis !== "x" ) {
				if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY <
						o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
				} else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
				}
			}

			if ( !o.axis || o.axis !== "y" ) {
				if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX <
						o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
				} else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if ( !o.axis || o.axis !== "x" ) {
				if ( event.pageY - $( document ).scrollTop() < o.scrollSensitivity ) {
					scrolled = $( document ).scrollTop( $( document ).scrollTop() - o.scrollSpeed );
				} else if ( $( window ).height() - ( event.pageY - $( document ).scrollTop() ) <
						o.scrollSensitivity ) {
					scrolled = $( document ).scrollTop( $( document ).scrollTop() + o.scrollSpeed );
				}
			}

			if ( !o.axis || o.axis !== "y" ) {
				if ( event.pageX - $( document ).scrollLeft() < o.scrollSensitivity ) {
					scrolled = $( document ).scrollLeft(
						$( document ).scrollLeft() - o.scrollSpeed
					);
				} else if ( $( window ).width() - ( event.pageX - $( document ).scrollLeft() ) <
						o.scrollSensitivity ) {
					scrolled = $( document ).scrollLeft(
						$( document ).scrollLeft() + o.scrollSpeed
					);
				}
			}

		}

		if ( scrolled !== false && $.ui.ddmanager && !o.dropBehaviour ) {
			$.ui.ddmanager.prepareOffsets( i, event );
		}

	}
} );

$.ui.plugin.add( "draggable", "snap", {
	start: function( event, ui, i ) {

		var o = i.options;

		i.snapElements = [];

		$( o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap )
			.each( function() {
				var $t = $( this ),
					$o = $t.offset();
				if ( this !== i.element[ 0 ] ) {
					i.snapElements.push( {
						item: this,
						width: $t.outerWidth(), height: $t.outerHeight(),
						top: $o.top, left: $o.left
					} );
				}
			} );

	},
	drag: function( event, ui, inst ) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for ( i = inst.snapElements.length - 1; i >= 0; i-- ) {

			l = inst.snapElements[ i ].left - inst.margins.left;
			r = l + inst.snapElements[ i ].width;
			t = inst.snapElements[ i ].top - inst.margins.top;
			b = t + inst.snapElements[ i ].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d ||
					!$.contains( inst.snapElements[ i ].item.ownerDocument,
					inst.snapElements[ i ].item ) ) {
				if ( inst.snapElements[ i ].snapping ) {
					( inst.options.snap.release &&
						inst.options.snap.release.call(
							inst.element,
							event,
							$.extend( inst._uiHash(), { snapItem: inst.snapElements[ i ].item } )
						) );
				}
				inst.snapElements[ i ].snapping = false;
				continue;
			}

			if ( o.snapMode !== "inner" ) {
				ts = Math.abs( t - y2 ) <= d;
				bs = Math.abs( b - y1 ) <= d;
				ls = Math.abs( l - x2 ) <= d;
				rs = Math.abs( r - x1 ) <= d;
				if ( ts ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: t - inst.helperProportions.height,
						left: 0
					} ).top;
				}
				if ( bs ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: b,
						left: 0
					} ).top;
				}
				if ( ls ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: l - inst.helperProportions.width
					} ).left;
				}
				if ( rs ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: r
					} ).left;
				}
			}

			first = ( ts || bs || ls || rs );

			if ( o.snapMode !== "outer" ) {
				ts = Math.abs( t - y1 ) <= d;
				bs = Math.abs( b - y2 ) <= d;
				ls = Math.abs( l - x1 ) <= d;
				rs = Math.abs( r - x2 ) <= d;
				if ( ts ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: t,
						left: 0
					} ).top;
				}
				if ( bs ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: b - inst.helperProportions.height,
						left: 0
					} ).top;
				}
				if ( ls ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: l
					} ).left;
				}
				if ( rs ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: r - inst.helperProportions.width
					} ).left;
				}
			}

			if ( !inst.snapElements[ i ].snapping && ( ts || bs || ls || rs || first ) ) {
				( inst.options.snap.snap &&
					inst.options.snap.snap.call(
						inst.element,
						event,
						$.extend( inst._uiHash(), {
							snapItem: inst.snapElements[ i ].item
						} ) ) );
			}
			inst.snapElements[ i ].snapping = ( ts || bs || ls || rs || first );

		}

	}
} );

$.ui.plugin.add( "draggable", "stack", {
	start: function( event, ui, instance ) {
		var min,
			o = instance.options,
			group = $.makeArray( $( o.stack ) ).sort( function( a, b ) {
				return ( parseInt( $( a ).css( "zIndex" ), 10 ) || 0 ) -
					( parseInt( $( b ).css( "zIndex" ), 10 ) || 0 );
			} );

		if ( !group.length ) { return; }

		min = parseInt( $( group[ 0 ] ).css( "zIndex" ), 10 ) || 0;
		$( group ).each( function( i ) {
			$( this ).css( "zIndex", min + i );
		} );
		this.css( "zIndex", ( min + group.length ) );
	}
} );

$.ui.plugin.add( "draggable", "zIndex", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;

		if ( t.css( "zIndex" ) ) {
			o._zIndex = t.css( "zIndex" );
		}
		t.css( "zIndex", o.zIndex );
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;

		if ( o._zIndex ) {
			$( ui.helper ).css( "zIndex", o._zIndex );
		}
	}
} );

var widgetsDraggable = $.ui.draggable;


/*!
 * jQuery UI Resizable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Resizable
//>>group: Interactions
//>>description: Enables resize functionality for any element.
//>>docs: http://api.jqueryui.com/resizable/
//>>demos: http://jqueryui.com/resizable/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/resizable.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.resizable", $.ui.mouse, {
	version: "1.12.1",
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		classes: {
			"ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se"
		},
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,

		// See #7960
		zIndex: 90,

		// Callbacks
		resize: null,
		start: null,
		stop: null
	},

	_num: function( value ) {
		return parseFloat( value ) || 0;
	},

	_isNumber: function( value ) {
		return !isNaN( parseFloat( value ) );
	},

	_hasScroll: function( el, a ) {

		if ( $( el ).css( "overflow" ) === "hidden" ) {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	},

	_create: function() {

		var margins,
			o = this.options,
			that = this;
		this._addClass( "ui-resizable" );

		$.extend( this, {
			_aspectRatio: !!( o.aspectRatio ),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
		} );

		// Wrap the element if it cannot hold child nodes
		if ( this.element[ 0 ].nodeName.match( /^(canvas|textarea|input|select|button|img)$/i ) ) {

			this.element.wrap(
				$( "<div class='ui-wrapper' style='overflow: hidden;'></div>" ).css( {
					position: this.element.css( "position" ),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css( "top" ),
					left: this.element.css( "left" )
				} )
			);

			this.element = this.element.parent().data(
				"ui-resizable", this.element.resizable( "instance" )
			);

			this.elementIsWrapper = true;

			margins = {
				marginTop: this.originalElement.css( "marginTop" ),
				marginRight: this.originalElement.css( "marginRight" ),
				marginBottom: this.originalElement.css( "marginBottom" ),
				marginLeft: this.originalElement.css( "marginLeft" )
			};

			this.element.css( margins );
			this.originalElement.css( "margin", 0 );

			// support: Safari
			// Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css( "resize" );
			this.originalElement.css( "resize", "none" );

			this._proportionallyResizeElements.push( this.originalElement.css( {
				position: "static",
				zoom: 1,
				display: "block"
			} ) );

			// Support: IE9
			// avoid IE jump (hard set the margin)
			this.originalElement.css( margins );

			this._proportionallyResize();
		}

		this._setupHandles();

		if ( o.autoHide ) {
			$( this.element )
				.on( "mouseenter", function() {
					if ( o.disabled ) {
						return;
					}
					that._removeClass( "ui-resizable-autohide" );
					that._handles.show();
				} )
				.on( "mouseleave", function() {
					if ( o.disabled ) {
						return;
					}
					if ( !that.resizing ) {
						that._addClass( "ui-resizable-autohide" );
						that._handles.hide();
					}
				} );
		}

		this._mouseInit();
	},

	_destroy: function() {

		this._mouseDestroy();

		var wrapper,
			_destroy = function( exp ) {
				$( exp )
					.removeData( "resizable" )
					.removeData( "ui-resizable" )
					.off( ".resizable" )
					.find( ".ui-resizable-handle" )
						.remove();
			};

		// TODO: Unwrap at same DOM position
		if ( this.elementIsWrapper ) {
			_destroy( this.element );
			wrapper = this.element;
			this.originalElement.css( {
				position: wrapper.css( "position" ),
				width: wrapper.outerWidth(),
				height: wrapper.outerHeight(),
				top: wrapper.css( "top" ),
				left: wrapper.css( "left" )
			} ).insertAfter( wrapper );
			wrapper.remove();
		}

		this.originalElement.css( "resize", this.originalResizeStyle );
		_destroy( this.originalElement );

		return this;
	},

	_setOption: function( key, value ) {
		this._super( key, value );

		switch ( key ) {
		case "handles":
			this._removeHandles();
			this._setupHandles();
			break;
		default:
			break;
		}
	},

	_setupHandles: function() {
		var o = this.options, handle, i, n, hname, axis, that = this;
		this.handles = o.handles ||
			( !$( ".ui-resizable-handle", this.element ).length ?
				"e,s,se" : {
					n: ".ui-resizable-n",
					e: ".ui-resizable-e",
					s: ".ui-resizable-s",
					w: ".ui-resizable-w",
					se: ".ui-resizable-se",
					sw: ".ui-resizable-sw",
					ne: ".ui-resizable-ne",
					nw: ".ui-resizable-nw"
				} );

		this._handles = $();
		if ( this.handles.constructor === String ) {

			if ( this.handles === "all" ) {
				this.handles = "n,e,s,w,se,sw,ne,nw";
			}

			n = this.handles.split( "," );
			this.handles = {};

			for ( i = 0; i < n.length; i++ ) {

				handle = $.trim( n[ i ] );
				hname = "ui-resizable-" + handle;
				axis = $( "<div>" );
				this._addClass( axis, "ui-resizable-handle " + hname );

				axis.css( { zIndex: o.zIndex } );

				this.handles[ handle ] = ".ui-resizable-" + handle;
				this.element.append( axis );
			}

		}

		this._renderAxis = function( target ) {

			var i, axis, padPos, padWrapper;

			target = target || this.element;

			for ( i in this.handles ) {

				if ( this.handles[ i ].constructor === String ) {
					this.handles[ i ] = this.element.children( this.handles[ i ] ).first().show();
				} else if ( this.handles[ i ].jquery || this.handles[ i ].nodeType ) {
					this.handles[ i ] = $( this.handles[ i ] );
					this._on( this.handles[ i ], { "mousedown": that._mouseDown } );
				}

				if ( this.elementIsWrapper &&
						this.originalElement[ 0 ]
							.nodeName
							.match( /^(textarea|input|select|button)$/i ) ) {
					axis = $( this.handles[ i ], this.element );

					padWrapper = /sw|ne|nw|se|n|s/.test( i ) ?
						axis.outerHeight() :
						axis.outerWidth();

					padPos = [ "padding",
						/ne|nw|n/.test( i ) ? "Top" :
						/se|sw|s/.test( i ) ? "Bottom" :
						/^e$/.test( i ) ? "Right" : "Left" ].join( "" );

					target.css( padPos, padWrapper );

					this._proportionallyResize();
				}

				this._handles = this._handles.add( this.handles[ i ] );
			}
		};

		// TODO: make renderAxis a prototype function
		this._renderAxis( this.element );

		this._handles = this._handles.add( this.element.find( ".ui-resizable-handle" ) );
		this._handles.disableSelection();

		this._handles.on( "mouseover", function() {
			if ( !that.resizing ) {
				if ( this.className ) {
					axis = this.className.match( /ui-resizable-(se|sw|ne|nw|n|e|s|w)/i );
				}
				that.axis = axis && axis[ 1 ] ? axis[ 1 ] : "se";
			}
		} );

		if ( o.autoHide ) {
			this._handles.hide();
			this._addClass( "ui-resizable-autohide" );
		}
	},

	_removeHandles: function() {
		this._handles.remove();
	},

	_mouseCapture: function( event ) {
		var i, handle,
			capture = false;

		for ( i in this.handles ) {
			handle = $( this.handles[ i ] )[ 0 ];
			if ( handle === event.target || $.contains( handle, event.target ) ) {
				capture = true;
			}
		}

		return !this.options.disabled && capture;
	},

	_mouseStart: function( event ) {

		var curleft, curtop, cursor,
			o = this.options,
			el = this.element;

		this.resizing = true;

		this._renderProxy();

		curleft = this._num( this.helper.css( "left" ) );
		curtop = this._num( this.helper.css( "top" ) );

		if ( o.containment ) {
			curleft += $( o.containment ).scrollLeft() || 0;
			curtop += $( o.containment ).scrollTop() || 0;
		}

		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };

		this.size = this._helper ? {
				width: this.helper.width(),
				height: this.helper.height()
			} : {
				width: el.width(),
				height: el.height()
			};

		this.originalSize = this._helper ? {
				width: el.outerWidth(),
				height: el.outerHeight()
			} : {
				width: el.width(),
				height: el.height()
			};

		this.sizeDiff = {
			width: el.outerWidth() - el.width(),
			height: el.outerHeight() - el.height()
		};

		this.originalPosition = { left: curleft, top: curtop };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		this.aspectRatio = ( typeof o.aspectRatio === "number" ) ?
			o.aspectRatio :
			( ( this.originalSize.width / this.originalSize.height ) || 1 );

		cursor = $( ".ui-resizable-" + this.axis ).css( "cursor" );
		$( "body" ).css( "cursor", cursor === "auto" ? this.axis + "-resize" : cursor );

		this._addClass( "ui-resizable-resizing" );
		this._propagate( "start", event );
		return true;
	},

	_mouseDrag: function( event ) {

		var data, props,
			smp = this.originalMousePosition,
			a = this.axis,
			dx = ( event.pageX - smp.left ) || 0,
			dy = ( event.pageY - smp.top ) || 0,
			trigger = this._change[ a ];

		this._updatePrevProperties();

		if ( !trigger ) {
			return false;
		}

		data = trigger.apply( this, [ event, dx, dy ] );

		this._updateVirtualBoundaries( event.shiftKey );
		if ( this._aspectRatio || event.shiftKey ) {
			data = this._updateRatio( data, event );
		}

		data = this._respectSize( data, event );

		this._updateCache( data );

		this._propagate( "resize", event );

		props = this._applyChanges();

		if ( !this._helper && this._proportionallyResizeElements.length ) {
			this._proportionallyResize();
		}

		if ( !$.isEmptyObject( props ) ) {
			this._updatePrevProperties();
			this._trigger( "resize", event, this.ui() );
			this._applyChanges();
		}

		return false;
	},

	_mouseStop: function( event ) {

		this.resizing = false;
		var pr, ista, soffseth, soffsetw, s, left, top,
			o = this.options, that = this;

		if ( this._helper ) {

			pr = this._proportionallyResizeElements;
			ista = pr.length && ( /textarea/i ).test( pr[ 0 ].nodeName );
			soffseth = ista && this._hasScroll( pr[ 0 ], "left" ) ? 0 : that.sizeDiff.height;
			soffsetw = ista ? 0 : that.sizeDiff.width;

			s = {
				width: ( that.helper.width()  - soffsetw ),
				height: ( that.helper.height() - soffseth )
			};
			left = ( parseFloat( that.element.css( "left" ) ) +
				( that.position.left - that.originalPosition.left ) ) || null;
			top = ( parseFloat( that.element.css( "top" ) ) +
				( that.position.top - that.originalPosition.top ) ) || null;

			if ( !o.animate ) {
				this.element.css( $.extend( s, { top: top, left: left } ) );
			}

			that.helper.height( that.size.height );
			that.helper.width( that.size.width );

			if ( this._helper && !o.animate ) {
				this._proportionallyResize();
			}
		}

		$( "body" ).css( "cursor", "auto" );

		this._removeClass( "ui-resizable-resizing" );

		this._propagate( "stop", event );

		if ( this._helper ) {
			this.helper.remove();
		}

		return false;

	},

	_updatePrevProperties: function() {
		this.prevPosition = {
			top: this.position.top,
			left: this.position.left
		};
		this.prevSize = {
			width: this.size.width,
			height: this.size.height
		};
	},

	_applyChanges: function() {
		var props = {};

		if ( this.position.top !== this.prevPosition.top ) {
			props.top = this.position.top + "px";
		}
		if ( this.position.left !== this.prevPosition.left ) {
			props.left = this.position.left + "px";
		}
		if ( this.size.width !== this.prevSize.width ) {
			props.width = this.size.width + "px";
		}
		if ( this.size.height !== this.prevSize.height ) {
			props.height = this.size.height + "px";
		}

		this.helper.css( props );

		return props;
	},

	_updateVirtualBoundaries: function( forceAspectRatio ) {
		var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
			o = this.options;

		b = {
			minWidth: this._isNumber( o.minWidth ) ? o.minWidth : 0,
			maxWidth: this._isNumber( o.maxWidth ) ? o.maxWidth : Infinity,
			minHeight: this._isNumber( o.minHeight ) ? o.minHeight : 0,
			maxHeight: this._isNumber( o.maxHeight ) ? o.maxHeight : Infinity
		};

		if ( this._aspectRatio || forceAspectRatio ) {
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth / this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth / this.aspectRatio;

			if ( pMinWidth > b.minWidth ) {
				b.minWidth = pMinWidth;
			}
			if ( pMinHeight > b.minHeight ) {
				b.minHeight = pMinHeight;
			}
			if ( pMaxWidth < b.maxWidth ) {
				b.maxWidth = pMaxWidth;
			}
			if ( pMaxHeight < b.maxHeight ) {
				b.maxHeight = pMaxHeight;
			}
		}
		this._vBoundaries = b;
	},

	_updateCache: function( data ) {
		this.offset = this.helper.offset();
		if ( this._isNumber( data.left ) ) {
			this.position.left = data.left;
		}
		if ( this._isNumber( data.top ) ) {
			this.position.top = data.top;
		}
		if ( this._isNumber( data.height ) ) {
			this.size.height = data.height;
		}
		if ( this._isNumber( data.width ) ) {
			this.size.width = data.width;
		}
	},

	_updateRatio: function( data ) {

		var cpos = this.position,
			csize = this.size,
			a = this.axis;

		if ( this._isNumber( data.height ) ) {
			data.width = ( data.height * this.aspectRatio );
		} else if ( this._isNumber( data.width ) ) {
			data.height = ( data.width / this.aspectRatio );
		}

		if ( a === "sw" ) {
			data.left = cpos.left + ( csize.width - data.width );
			data.top = null;
		}
		if ( a === "nw" ) {
			data.top = cpos.top + ( csize.height - data.height );
			data.left = cpos.left + ( csize.width - data.width );
		}

		return data;
	},

	_respectSize: function( data ) {

		var o = this._vBoundaries,
			a = this.axis,
			ismaxw = this._isNumber( data.width ) && o.maxWidth && ( o.maxWidth < data.width ),
			ismaxh = this._isNumber( data.height ) && o.maxHeight && ( o.maxHeight < data.height ),
			isminw = this._isNumber( data.width ) && o.minWidth && ( o.minWidth > data.width ),
			isminh = this._isNumber( data.height ) && o.minHeight && ( o.minHeight > data.height ),
			dw = this.originalPosition.left + this.originalSize.width,
			dh = this.originalPosition.top + this.originalSize.height,
			cw = /sw|nw|w/.test( a ), ch = /nw|ne|n/.test( a );
		if ( isminw ) {
			data.width = o.minWidth;
		}
		if ( isminh ) {
			data.height = o.minHeight;
		}
		if ( ismaxw ) {
			data.width = o.maxWidth;
		}
		if ( ismaxh ) {
			data.height = o.maxHeight;
		}

		if ( isminw && cw ) {
			data.left = dw - o.minWidth;
		}
		if ( ismaxw && cw ) {
			data.left = dw - o.maxWidth;
		}
		if ( isminh && ch ) {
			data.top = dh - o.minHeight;
		}
		if ( ismaxh && ch ) {
			data.top = dh - o.maxHeight;
		}

		// Fixing jump error on top/left - bug #2330
		if ( !data.width && !data.height && !data.left && data.top ) {
			data.top = null;
		} else if ( !data.width && !data.height && !data.top && data.left ) {
			data.left = null;
		}

		return data;
	},

	_getPaddingPlusBorderDimensions: function( element ) {
		var i = 0,
			widths = [],
			borders = [
				element.css( "borderTopWidth" ),
				element.css( "borderRightWidth" ),
				element.css( "borderBottomWidth" ),
				element.css( "borderLeftWidth" )
			],
			paddings = [
				element.css( "paddingTop" ),
				element.css( "paddingRight" ),
				element.css( "paddingBottom" ),
				element.css( "paddingLeft" )
			];

		for ( ; i < 4; i++ ) {
			widths[ i ] = ( parseFloat( borders[ i ] ) || 0 );
			widths[ i ] += ( parseFloat( paddings[ i ] ) || 0 );
		}

		return {
			height: widths[ 0 ] + widths[ 2 ],
			width: widths[ 1 ] + widths[ 3 ]
		};
	},

	_proportionallyResize: function() {

		if ( !this._proportionallyResizeElements.length ) {
			return;
		}

		var prel,
			i = 0,
			element = this.helper || this.element;

		for ( ; i < this._proportionallyResizeElements.length; i++ ) {

			prel = this._proportionallyResizeElements[ i ];

			// TODO: Seems like a bug to cache this.outerDimensions
			// considering that we are in a loop.
			if ( !this.outerDimensions ) {
				this.outerDimensions = this._getPaddingPlusBorderDimensions( prel );
			}

			prel.css( {
				height: ( element.height() - this.outerDimensions.height ) || 0,
				width: ( element.width() - this.outerDimensions.width ) || 0
			} );

		}

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if ( this._helper ) {

			this.helper = this.helper || $( "<div style='overflow:hidden;'></div>" );

			this._addClass( this.helper, this._helper );
			this.helper.css( {
				width: this.element.outerWidth(),
				height: this.element.outerHeight(),
				position: "absolute",
				left: this.elementOffset.left + "px",
				top: this.elementOffset.top + "px",
				zIndex: ++o.zIndex //TODO: Don't modify option
			} );

			this.helper
				.appendTo( "body" )
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function( event, dx ) {
			return { width: this.originalSize.width + dx };
		},
		w: function( event, dx ) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function( event, dx, dy ) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function( event, dx, dy ) {
			return { height: this.originalSize.height + dy };
		},
		se: function( event, dx, dy ) {
			return $.extend( this._change.s.apply( this, arguments ),
				this._change.e.apply( this, [ event, dx, dy ] ) );
		},
		sw: function( event, dx, dy ) {
			return $.extend( this._change.s.apply( this, arguments ),
				this._change.w.apply( this, [ event, dx, dy ] ) );
		},
		ne: function( event, dx, dy ) {
			return $.extend( this._change.n.apply( this, arguments ),
				this._change.e.apply( this, [ event, dx, dy ] ) );
		},
		nw: function( event, dx, dy ) {
			return $.extend( this._change.n.apply( this, arguments ),
				this._change.w.apply( this, [ event, dx, dy ] ) );
		}
	},

	_propagate: function( n, event ) {
		$.ui.plugin.call( this, n, [ event, this.ui() ] );
		( n !== "resize" && this._trigger( n, event, this.ui() ) );
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

} );

/*
 * Resizable Extensions
 */

$.ui.plugin.add( "resizable", "animate", {

	stop: function( event ) {
		var that = $( this ).resizable( "instance" ),
			o = that.options,
			pr = that._proportionallyResizeElements,
			ista = pr.length && ( /textarea/i ).test( pr[ 0 ].nodeName ),
			soffseth = ista && that._hasScroll( pr[ 0 ], "left" ) ? 0 : that.sizeDiff.height,
			soffsetw = ista ? 0 : that.sizeDiff.width,
			style = {
				width: ( that.size.width - soffsetw ),
				height: ( that.size.height - soffseth )
			},
			left = ( parseFloat( that.element.css( "left" ) ) +
				( that.position.left - that.originalPosition.left ) ) || null,
			top = ( parseFloat( that.element.css( "top" ) ) +
				( that.position.top - that.originalPosition.top ) ) || null;

		that.element.animate(
			$.extend( style, top && left ? { top: top, left: left } : {} ), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseFloat( that.element.css( "width" ) ),
						height: parseFloat( that.element.css( "height" ) ),
						top: parseFloat( that.element.css( "top" ) ),
						left: parseFloat( that.element.css( "left" ) )
					};

					if ( pr && pr.length ) {
						$( pr[ 0 ] ).css( { width: data.width, height: data.height } );
					}

					// Propagating resize, and updating values for each animation step
					that._updateCache( data );
					that._propagate( "resize", event );

				}
			}
		);
	}

} );

$.ui.plugin.add( "resizable", "containment", {

	start: function() {
		var element, p, co, ch, cw, width, height,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			el = that.element,
			oc = o.containment,
			ce = ( oc instanceof $ ) ?
				oc.get( 0 ) :
				( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;

		if ( !ce ) {
			return;
		}

		that.containerElement = $( ce );

		if ( /document/.test( oc ) || oc === document ) {
			that.containerOffset = {
				left: 0,
				top: 0
			};
			that.containerPosition = {
				left: 0,
				top: 0
			};

			that.parentData = {
				element: $( document ),
				left: 0,
				top: 0,
				width: $( document ).width(),
				height: $( document ).height() || document.body.parentNode.scrollHeight
			};
		} else {
			element = $( ce );
			p = [];
			$( [ "Top", "Right", "Left", "Bottom" ] ).each( function( i, name ) {
				p[ i ] = that._num( element.css( "padding" + name ) );
			} );

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = {
				height: ( element.innerHeight() - p[ 3 ] ),
				width: ( element.innerWidth() - p[ 1 ] )
			};

			co = that.containerOffset;
			ch = that.containerSize.height;
			cw = that.containerSize.width;
			width = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );
			height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;

			that.parentData = {
				element: ce,
				left: co.left,
				top: co.top,
				width: width,
				height: height
			};
		}
	},

	resize: function( event ) {
		var woset, hoset, isParent, isOffsetRelative,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			co = that.containerOffset,
			cp = that.position,
			pRatio = that._aspectRatio || event.shiftKey,
			cop = {
				top: 0,
				left: 0
			},
			ce = that.containerElement,
			continueResize = true;

		if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {
			cop = co;
		}

		if ( cp.left < ( that._helper ? co.left : 0 ) ) {
			that.size.width = that.size.width +
				( that._helper ?
					( that.position.left - co.left ) :
					( that.position.left - cop.left ) );

			if ( pRatio ) {
				that.size.height = that.size.width / that.aspectRatio;
				continueResize = false;
			}
			that.position.left = o.helper ? co.left : 0;
		}

		if ( cp.top < ( that._helper ? co.top : 0 ) ) {
			that.size.height = that.size.height +
				( that._helper ?
					( that.position.top - co.top ) :
					that.position.top );

			if ( pRatio ) {
				that.size.width = that.size.height * that.aspectRatio;
				continueResize = false;
			}
			that.position.top = that._helper ? co.top : 0;
		}

		isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );
		isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );

		if ( isParent && isOffsetRelative ) {
			that.offset.left = that.parentData.left + that.position.left;
			that.offset.top = that.parentData.top + that.position.top;
		} else {
			that.offset.left = that.element.offset().left;
			that.offset.top = that.element.offset().top;
		}

		woset = Math.abs( that.sizeDiff.width +
			( that._helper ?
				that.offset.left - cop.left :
				( that.offset.left - co.left ) ) );

		hoset = Math.abs( that.sizeDiff.height +
			( that._helper ?
				that.offset.top - cop.top :
				( that.offset.top - co.top ) ) );

		if ( woset + that.size.width >= that.parentData.width ) {
			that.size.width = that.parentData.width - woset;
			if ( pRatio ) {
				that.size.height = that.size.width / that.aspectRatio;
				continueResize = false;
			}
		}

		if ( hoset + that.size.height >= that.parentData.height ) {
			that.size.height = that.parentData.height - hoset;
			if ( pRatio ) {
				that.size.width = that.size.height * that.aspectRatio;
				continueResize = false;
			}
		}

		if ( !continueResize ) {
			that.position.left = that.prevPosition.left;
			that.position.top = that.prevPosition.top;
			that.size.width = that.prevSize.width;
			that.size.height = that.prevSize.height;
		}
	},

	stop: function() {
		var that = $( this ).resizable( "instance" ),
			o = that.options,
			co = that.containerOffset,
			cop = that.containerPosition,
			ce = that.containerElement,
			helper = $( that.helper ),
			ho = helper.offset(),
			w = helper.outerWidth() - that.sizeDiff.width,
			h = helper.outerHeight() - that.sizeDiff.height;

		if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {
			$( this ).css( {
				left: ho.left - cop.left - co.left,
				width: w,
				height: h
			} );
		}

		if ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {
			$( this ).css( {
				left: ho.left - cop.left - co.left,
				width: w,
				height: h
			} );
		}
	}
} );

$.ui.plugin.add( "resizable", "alsoResize", {

	start: function() {
		var that = $( this ).resizable( "instance" ),
			o = that.options;

		$( o.alsoResize ).each( function() {
			var el = $( this );
			el.data( "ui-resizable-alsoresize", {
				width: parseFloat( el.width() ), height: parseFloat( el.height() ),
				left: parseFloat( el.css( "left" ) ), top: parseFloat( el.css( "top" ) )
			} );
		} );
	},

	resize: function( event, ui ) {
		var that = $( this ).resizable( "instance" ),
			o = that.options,
			os = that.originalSize,
			op = that.originalPosition,
			delta = {
				height: ( that.size.height - os.height ) || 0,
				width: ( that.size.width - os.width ) || 0,
				top: ( that.position.top - op.top ) || 0,
				left: ( that.position.left - op.left ) || 0
			};

			$( o.alsoResize ).each( function() {
				var el = $( this ), start = $( this ).data( "ui-resizable-alsoresize" ), style = {},
					css = el.parents( ui.originalElement[ 0 ] ).length ?
							[ "width", "height" ] :
							[ "width", "height", "top", "left" ];

				$.each( css, function( i, prop ) {
					var sum = ( start[ prop ] || 0 ) + ( delta[ prop ] || 0 );
					if ( sum && sum >= 0 ) {
						style[ prop ] = sum || null;
					}
				} );

				el.css( style );
			} );
	},

	stop: function() {
		$( this ).removeData( "ui-resizable-alsoresize" );
	}
} );

$.ui.plugin.add( "resizable", "ghost", {

	start: function() {

		var that = $( this ).resizable( "instance" ), cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost.css( {
			opacity: 0.25,
			display: "block",
			position: "relative",
			height: cs.height,
			width: cs.width,
			margin: 0,
			left: 0,
			top: 0
		} );

		that._addClass( that.ghost, "ui-resizable-ghost" );

		// DEPRECATED
		// TODO: remove after 1.12
		if ( $.uiBackCompat !== false && typeof that.options.ghost === "string" ) {

			// Ghost option
			that.ghost.addClass( this.options.ghost );
		}

		that.ghost.appendTo( that.helper );

	},

	resize: function() {
		var that = $( this ).resizable( "instance" );
		if ( that.ghost ) {
			that.ghost.css( {
				position: "relative",
				height: that.size.height,
				width: that.size.width
			} );
		}
	},

	stop: function() {
		var that = $( this ).resizable( "instance" );
		if ( that.ghost && that.helper ) {
			that.helper.get( 0 ).removeChild( that.ghost.get( 0 ) );
		}
	}

} );

$.ui.plugin.add( "resizable", "grid", {

	resize: function() {
		var outerDimensions,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			cs = that.size,
			os = that.originalSize,
			op = that.originalPosition,
			a = that.axis,
			grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid,
			gridX = ( grid[ 0 ] || 1 ),
			gridY = ( grid[ 1 ] || 1 ),
			ox = Math.round( ( cs.width - os.width ) / gridX ) * gridX,
			oy = Math.round( ( cs.height - os.height ) / gridY ) * gridY,
			newWidth = os.width + ox,
			newHeight = os.height + oy,
			isMaxWidth = o.maxWidth && ( o.maxWidth < newWidth ),
			isMaxHeight = o.maxHeight && ( o.maxHeight < newHeight ),
			isMinWidth = o.minWidth && ( o.minWidth > newWidth ),
			isMinHeight = o.minHeight && ( o.minHeight > newHeight );

		o.grid = grid;

		if ( isMinWidth ) {
			newWidth += gridX;
		}
		if ( isMinHeight ) {
			newHeight += gridY;
		}
		if ( isMaxWidth ) {
			newWidth -= gridX;
		}
		if ( isMaxHeight ) {
			newHeight -= gridY;
		}

		if ( /^(se|s|e)$/.test( a ) ) {
			that.size.width = newWidth;
			that.size.height = newHeight;
		} else if ( /^(ne)$/.test( a ) ) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.top = op.top - oy;
		} else if ( /^(sw)$/.test( a ) ) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.left = op.left - ox;
		} else {
			if ( newHeight - gridY <= 0 || newWidth - gridX <= 0 ) {
				outerDimensions = that._getPaddingPlusBorderDimensions( this );
			}

			if ( newHeight - gridY > 0 ) {
				that.size.height = newHeight;
				that.position.top = op.top - oy;
			} else {
				newHeight = gridY - outerDimensions.height;
				that.size.height = newHeight;
				that.position.top = op.top + os.height - newHeight;
			}
			if ( newWidth - gridX > 0 ) {
				that.size.width = newWidth;
				that.position.left = op.left - ox;
			} else {
				newWidth = gridX - outerDimensions.width;
				that.size.width = newWidth;
				that.position.left = op.left + os.width - newWidth;
			}
		}
	}

} );

var widgetsResizable = $.ui.resizable;


/*!
 * jQuery UI Dialog 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Dialog
//>>group: Widgets
//>>description: Displays customizable dialog windows.
//>>docs: http://api.jqueryui.com/dialog/
//>>demos: http://jqueryui.com/dialog/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/dialog.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.dialog", {
	version: "1.12.1",
	options: {
		appendTo: "body",
		autoOpen: true,
		buttons: [],
		classes: {
			"ui-dialog": "ui-corner-all",
			"ui-dialog-titlebar": "ui-corner-all"
		},
		closeOnEscape: true,
		closeText: "Close",
		draggable: true,
		hide: null,
		height: "auto",
		maxHeight: null,
		maxWidth: null,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: "center",
			at: "center",
			of: window,
			collision: "fit",

			// Ensure the titlebar is always visible
			using: function( pos ) {
				var topOffset = $( this ).css( pos ).offset().top;
				if ( topOffset < 0 ) {
					$( this ).css( "top", pos.top - topOffset );
				}
			}
		},
		resizable: true,
		show: null,
		title: null,
		width: 300,

		// Callbacks
		beforeClose: null,
		close: null,
		drag: null,
		dragStart: null,
		dragStop: null,
		focus: null,
		open: null,
		resize: null,
		resizeStart: null,
		resizeStop: null
	},

	sizeRelatedOptions: {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},

	resizableRelatedOptions: {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	},

	_create: function() {
		this.originalCss = {
			display: this.element[ 0 ].style.display,
			width: this.element[ 0 ].style.width,
			minHeight: this.element[ 0 ].style.minHeight,
			maxHeight: this.element[ 0 ].style.maxHeight,
			height: this.element[ 0 ].style.height
		};
		this.originalPosition = {
			parent: this.element.parent(),
			index: this.element.parent().children().index( this.element )
		};
		this.originalTitle = this.element.attr( "title" );
		if ( this.options.title == null && this.originalTitle != null ) {
			this.options.title = this.originalTitle;
		}

		// Dialogs can't be disabled
		if ( this.options.disabled ) {
			this.options.disabled = false;
		}

		this._createWrapper();

		this.element
			.show()
			.removeAttr( "title" )
			.appendTo( this.uiDialog );

		this._addClass( "ui-dialog-content", "ui-widget-content" );

		this._createTitlebar();
		this._createButtonPane();

		if ( this.options.draggable && $.fn.draggable ) {
			this._makeDraggable();
		}
		if ( this.options.resizable && $.fn.resizable ) {
			this._makeResizable();
		}

		this._isOpen = false;

		this._trackFocus();
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;
		if ( element && ( element.jquery || element.nodeType ) ) {
			return $( element );
		}
		return this.document.find( element || "body" ).eq( 0 );
	},

	_destroy: function() {
		var next,
			originalPosition = this.originalPosition;

		this._untrackInstance();
		this._destroyOverlay();

		this.element
			.removeUniqueId()
			.css( this.originalCss )

			// Without detaching first, the following becomes really slow
			.detach();

		this.uiDialog.remove();

		if ( this.originalTitle ) {
			this.element.attr( "title", this.originalTitle );
		}

		next = originalPosition.parent.children().eq( originalPosition.index );

		// Don't try to place the dialog next to itself (#8613)
		if ( next.length && next[ 0 ] !== this.element[ 0 ] ) {
			next.before( this.element );
		} else {
			originalPosition.parent.append( this.element );
		}
	},

	widget: function() {
		return this.uiDialog;
	},

	disable: $.noop,
	enable: $.noop,

	close: function( event ) {
		var that = this;

		if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
			return;
		}

		this._isOpen = false;
		this._focusedElement = null;
		this._destroyOverlay();
		this._untrackInstance();

		if ( !this.opener.filter( ":focusable" ).trigger( "focus" ).length ) {

			// Hiding a focused element doesn't trigger blur in WebKit
			// so in case we have nothing to focus on, explicitly blur the active element
			// https://bugs.webkit.org/show_bug.cgi?id=47182
			$.ui.safeBlur( $.ui.safeActiveElement( this.document[ 0 ] ) );
		}

		this._hide( this.uiDialog, this.options.hide, function() {
			that._trigger( "close", event );
		} );
	},

	isOpen: function() {
		return this._isOpen;
	},

	moveToTop: function() {
		this._moveToTop();
	},

	_moveToTop: function( event, silent ) {
		var moved = false,
			zIndices = this.uiDialog.siblings( ".ui-front:visible" ).map( function() {
				return +$( this ).css( "z-index" );
			} ).get(),
			zIndexMax = Math.max.apply( null, zIndices );

		if ( zIndexMax >= +this.uiDialog.css( "z-index" ) ) {
			this.uiDialog.css( "z-index", zIndexMax + 1 );
			moved = true;
		}

		if ( moved && !silent ) {
			this._trigger( "focus", event );
		}
		return moved;
	},

	open: function() {
		var that = this;
		if ( this._isOpen ) {
			if ( this._moveToTop() ) {
				this._focusTabbable();
			}
			return;
		}

		this._isOpen = true;
		this.opener = $( $.ui.safeActiveElement( this.document[ 0 ] ) );

		this._size();
		this._position();
		this._createOverlay();
		this._moveToTop( null, true );

		// Ensure the overlay is moved to the top with the dialog, but only when
		// opening. The overlay shouldn't move after the dialog is open so that
		// modeless dialogs opened after the modal dialog stack properly.
		if ( this.overlay ) {
			this.overlay.css( "z-index", this.uiDialog.css( "z-index" ) - 1 );
		}

		this._show( this.uiDialog, this.options.show, function() {
			that._focusTabbable();
			that._trigger( "focus" );
		} );

		// Track the dialog immediately upon openening in case a focus event
		// somehow occurs outside of the dialog before an element inside the
		// dialog is focused (#10152)
		this._makeFocusTarget();

		this._trigger( "open" );
	},

	_focusTabbable: function() {

		// Set focus to the first match:
		// 1. An element that was focused previously
		// 2. First element inside the dialog matching [autofocus]
		// 3. Tabbable element inside the content element
		// 4. Tabbable element inside the buttonpane
		// 5. The close button
		// 6. The dialog itself
		var hasFocus = this._focusedElement;
		if ( !hasFocus ) {
			hasFocus = this.element.find( "[autofocus]" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.element.find( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogButtonPane.find( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogTitlebarClose.filter( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialog;
		}
		hasFocus.eq( 0 ).trigger( "focus" );
	},

	_keepFocus: function( event ) {
		function checkFocus() {
			var activeElement = $.ui.safeActiveElement( this.document[ 0 ] ),
				isActive = this.uiDialog[ 0 ] === activeElement ||
					$.contains( this.uiDialog[ 0 ], activeElement );
			if ( !isActive ) {
				this._focusTabbable();
			}
		}
		event.preventDefault();
		checkFocus.call( this );

		// support: IE
		// IE <= 8 doesn't prevent moving focus even with event.preventDefault()
		// so we check again later
		this._delay( checkFocus );
	},

	_createWrapper: function() {
		this.uiDialog = $( "<div>" )
			.hide()
			.attr( {

				// Setting tabIndex makes the div focusable
				tabIndex: -1,
				role: "dialog"
			} )
			.appendTo( this._appendTo() );

		this._addClass( this.uiDialog, "ui-dialog", "ui-widget ui-widget-content ui-front" );
		this._on( this.uiDialog, {
			keydown: function( event ) {
				if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
						event.keyCode === $.ui.keyCode.ESCAPE ) {
					event.preventDefault();
					this.close( event );
					return;
				}

				// Prevent tabbing out of dialogs
				if ( event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented() ) {
					return;
				}
				var tabbables = this.uiDialog.find( ":tabbable" ),
					first = tabbables.filter( ":first" ),
					last = tabbables.filter( ":last" );

				if ( ( event.target === last[ 0 ] || event.target === this.uiDialog[ 0 ] ) &&
						!event.shiftKey ) {
					this._delay( function() {
						first.trigger( "focus" );
					} );
					event.preventDefault();
				} else if ( ( event.target === first[ 0 ] ||
						event.target === this.uiDialog[ 0 ] ) && event.shiftKey ) {
					this._delay( function() {
						last.trigger( "focus" );
					} );
					event.preventDefault();
				}
			},
			mousedown: function( event ) {
				if ( this._moveToTop( event ) ) {
					this._focusTabbable();
				}
			}
		} );

		// We assume that any existing aria-describedby attribute means
		// that the dialog content is marked up properly
		// otherwise we brute force the content as the description
		if ( !this.element.find( "[aria-describedby]" ).length ) {
			this.uiDialog.attr( {
				"aria-describedby": this.element.uniqueId().attr( "id" )
			} );
		}
	},

	_createTitlebar: function() {
		var uiDialogTitle;

		this.uiDialogTitlebar = $( "<div>" );
		this._addClass( this.uiDialogTitlebar,
			"ui-dialog-titlebar", "ui-widget-header ui-helper-clearfix" );
		this._on( this.uiDialogTitlebar, {
			mousedown: function( event ) {

				// Don't prevent click on close button (#8838)
				// Focusing a dialog that is partially scrolled out of view
				// causes the browser to scroll it into view, preventing the click event
				if ( !$( event.target ).closest( ".ui-dialog-titlebar-close" ) ) {

					// Dialog isn't getting focus when dragging (#8063)
					this.uiDialog.trigger( "focus" );
				}
			}
		} );

		// Support: IE
		// Use type="button" to prevent enter keypresses in textboxes from closing the
		// dialog in IE (#9312)
		this.uiDialogTitlebarClose = $( "<button type='button'></button>" )
			.button( {
				label: $( "<a>" ).text( this.options.closeText ).html(),
				icon: "ui-icon-closethick",
				showLabel: false
			} )
			.appendTo( this.uiDialogTitlebar );

		this._addClass( this.uiDialogTitlebarClose, "ui-dialog-titlebar-close" );
		this._on( this.uiDialogTitlebarClose, {
			click: function( event ) {
				event.preventDefault();
				this.close( event );
			}
		} );

		uiDialogTitle = $( "<span>" ).uniqueId().prependTo( this.uiDialogTitlebar );
		this._addClass( uiDialogTitle, "ui-dialog-title" );
		this._title( uiDialogTitle );

		this.uiDialogTitlebar.prependTo( this.uiDialog );

		this.uiDialog.attr( {
			"aria-labelledby": uiDialogTitle.attr( "id" )
		} );
	},

	_title: function( title ) {
		if ( this.options.title ) {
			title.text( this.options.title );
		} else {
			title.html( "&#160;" );
		}
	},

	_createButtonPane: function() {
		this.uiDialogButtonPane = $( "<div>" );
		this._addClass( this.uiDialogButtonPane, "ui-dialog-buttonpane",
			"ui-widget-content ui-helper-clearfix" );

		this.uiButtonSet = $( "<div>" )
			.appendTo( this.uiDialogButtonPane );
		this._addClass( this.uiButtonSet, "ui-dialog-buttonset" );

		this._createButtons();
	},

	_createButtons: function() {
		var that = this,
			buttons = this.options.buttons;

		// If we already have a button pane, remove it
		this.uiDialogButtonPane.remove();
		this.uiButtonSet.empty();

		if ( $.isEmptyObject( buttons ) || ( $.isArray( buttons ) && !buttons.length ) ) {
			this._removeClass( this.uiDialog, "ui-dialog-buttons" );
			return;
		}

		$.each( buttons, function( name, props ) {
			var click, buttonOptions;
			props = $.isFunction( props ) ?
				{ click: props, text: name } :
				props;

			// Default to a non-submitting button
			props = $.extend( { type: "button" }, props );

			// Change the context for the click callback to be the main element
			click = props.click;
			buttonOptions = {
				icon: props.icon,
				iconPosition: props.iconPosition,
				showLabel: props.showLabel,

				// Deprecated options
				icons: props.icons,
				text: props.text
			};

			delete props.click;
			delete props.icon;
			delete props.iconPosition;
			delete props.showLabel;

			// Deprecated options
			delete props.icons;
			if ( typeof props.text === "boolean" ) {
				delete props.text;
			}

			$( "<button></button>", props )
				.button( buttonOptions )
				.appendTo( that.uiButtonSet )
				.on( "click", function() {
					click.apply( that.element[ 0 ], arguments );
				} );
		} );
		this._addClass( this.uiDialog, "ui-dialog-buttons" );
		this.uiDialogButtonPane.appendTo( this.uiDialog );
	},

	_makeDraggable: function() {
		var that = this,
			options = this.options;

		function filteredUi( ui ) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		this.uiDialog.draggable( {
			cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
			handle: ".ui-dialog-titlebar",
			containment: "document",
			start: function( event, ui ) {
				that._addClass( $( this ), "ui-dialog-dragging" );
				that._blockFrames();
				that._trigger( "dragStart", event, filteredUi( ui ) );
			},
			drag: function( event, ui ) {
				that._trigger( "drag", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				var left = ui.offset.left - that.document.scrollLeft(),
					top = ui.offset.top - that.document.scrollTop();

				options.position = {
					my: "left top",
					at: "left" + ( left >= 0 ? "+" : "" ) + left + " " +
						"top" + ( top >= 0 ? "+" : "" ) + top,
					of: that.window
				};
				that._removeClass( $( this ), "ui-dialog-dragging" );
				that._unblockFrames();
				that._trigger( "dragStop", event, filteredUi( ui ) );
			}
		} );
	},

	_makeResizable: function() {
		var that = this,
			options = this.options,
			handles = options.resizable,

			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = this.uiDialog.css( "position" ),
			resizeHandles = typeof handles === "string" ?
				handles :
				"n,e,s,w,se,sw,ne,nw";

		function filteredUi( ui ) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		this.uiDialog.resizable( {
			cancel: ".ui-dialog-content",
			containment: "document",
			alsoResize: this.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: this._minHeight(),
			handles: resizeHandles,
			start: function( event, ui ) {
				that._addClass( $( this ), "ui-dialog-resizing" );
				that._blockFrames();
				that._trigger( "resizeStart", event, filteredUi( ui ) );
			},
			resize: function( event, ui ) {
				that._trigger( "resize", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				var offset = that.uiDialog.offset(),
					left = offset.left - that.document.scrollLeft(),
					top = offset.top - that.document.scrollTop();

				options.height = that.uiDialog.height();
				options.width = that.uiDialog.width();
				options.position = {
					my: "left top",
					at: "left" + ( left >= 0 ? "+" : "" ) + left + " " +
						"top" + ( top >= 0 ? "+" : "" ) + top,
					of: that.window
				};
				that._removeClass( $( this ), "ui-dialog-resizing" );
				that._unblockFrames();
				that._trigger( "resizeStop", event, filteredUi( ui ) );
			}
		} )
			.css( "position", position );
	},

	_trackFocus: function() {
		this._on( this.widget(), {
			focusin: function( event ) {
				this._makeFocusTarget();
				this._focusedElement = $( event.target );
			}
		} );
	},

	_makeFocusTarget: function() {
		this._untrackInstance();
		this._trackingInstances().unshift( this );
	},

	_untrackInstance: function() {
		var instances = this._trackingInstances(),
			exists = $.inArray( this, instances );
		if ( exists !== -1 ) {
			instances.splice( exists, 1 );
		}
	},

	_trackingInstances: function() {
		var instances = this.document.data( "ui-dialog-instances" );
		if ( !instances ) {
			instances = [];
			this.document.data( "ui-dialog-instances", instances );
		}
		return instances;
	},

	_minHeight: function() {
		var options = this.options;

		return options.height === "auto" ?
			options.minHeight :
			Math.min( options.minHeight, options.height );
	},

	_position: function() {

		// Need to show the dialog to get the actual offset in the position plugin
		var isVisible = this.uiDialog.is( ":visible" );
		if ( !isVisible ) {
			this.uiDialog.show();
		}
		this.uiDialog.position( this.options.position );
		if ( !isVisible ) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var that = this,
			resize = false,
			resizableOptions = {};

		$.each( options, function( key, value ) {
			that._setOption( key, value );

			if ( key in that.sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in that.resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		} );

		if ( resize ) {
			this._size();
			this._position();
		}
		if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
			this.uiDialog.resizable( "option", resizableOptions );
		}
	},

	_setOption: function( key, value ) {
		var isDraggable, isResizable,
			uiDialog = this.uiDialog;

		if ( key === "disabled" ) {
			return;
		}

		this._super( key, value );

		if ( key === "appendTo" ) {
			this.uiDialog.appendTo( this._appendTo() );
		}

		if ( key === "buttons" ) {
			this._createButtons();
		}

		if ( key === "closeText" ) {
			this.uiDialogTitlebarClose.button( {

				// Ensure that we always pass a string
				label: $( "<a>" ).text( "" + this.options.closeText ).html()
			} );
		}

		if ( key === "draggable" ) {
			isDraggable = uiDialog.is( ":data(ui-draggable)" );
			if ( isDraggable && !value ) {
				uiDialog.draggable( "destroy" );
			}

			if ( !isDraggable && value ) {
				this._makeDraggable();
			}
		}

		if ( key === "position" ) {
			this._position();
		}

		if ( key === "resizable" ) {

			// currently resizable, becoming non-resizable
			isResizable = uiDialog.is( ":data(ui-resizable)" );
			if ( isResizable && !value ) {
				uiDialog.resizable( "destroy" );
			}

			// Currently resizable, changing handles
			if ( isResizable && typeof value === "string" ) {
				uiDialog.resizable( "option", "handles", value );
			}

			// Currently non-resizable, becoming resizable
			if ( !isResizable && value !== false ) {
				this._makeResizable();
			}
		}

		if ( key === "title" ) {
			this._title( this.uiDialogTitlebar.find( ".ui-dialog-title" ) );
		}
	},

	_size: function() {

		// If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		// divs will both have width and height set, so we need to reset them
		var nonContentHeight, minContentHeight, maxContentHeight,
			options = this.options;

		// Reset content sizing
		this.element.show().css( {
			width: "auto",
			minHeight: 0,
			maxHeight: "none",
			height: 0
		} );

		if ( options.minWidth > options.width ) {
			options.width = options.minWidth;
		}

		// Reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css( {
			height: "auto",
			width: options.width
		} )
			.outerHeight();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
		maxContentHeight = typeof options.maxHeight === "number" ?
			Math.max( 0, options.maxHeight - nonContentHeight ) :
			"none";

		if ( options.height === "auto" ) {
			this.element.css( {
				minHeight: minContentHeight,
				maxHeight: maxContentHeight,
				height: "auto"
			} );
		} else {
			this.element.height( Math.max( 0, options.height - nonContentHeight ) );
		}

		if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
			this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
		}
	},

	_blockFrames: function() {
		this.iframeBlocks = this.document.find( "iframe" ).map( function() {
			var iframe = $( this );

			return $( "<div>" )
				.css( {
					position: "absolute",
					width: iframe.outerWidth(),
					height: iframe.outerHeight()
				} )
				.appendTo( iframe.parent() )
				.offset( iframe.offset() )[ 0 ];
		} );
	},

	_unblockFrames: function() {
		if ( this.iframeBlocks ) {
			this.iframeBlocks.remove();
			delete this.iframeBlocks;
		}
	},

	_allowInteraction: function( event ) {
		if ( $( event.target ).closest( ".ui-dialog" ).length ) {
			return true;
		}

		// TODO: Remove hack when datepicker implements
		// the .ui-front logic (#8989)
		return !!$( event.target ).closest( ".ui-datepicker" ).length;
	},

	_createOverlay: function() {
		if ( !this.options.modal ) {
			return;
		}

		// We use a delay in case the overlay is created from an
		// event that we're going to be cancelling (#2804)
		var isOpening = true;
		this._delay( function() {
			isOpening = false;
		} );

		if ( !this.document.data( "ui-dialog-overlays" ) ) {

			// Prevent use of anchors and inputs
			// Using _on() for an event handler shared across many instances is
			// safe because the dialogs stack and must be closed in reverse order
			this._on( this.document, {
				focusin: function( event ) {
					if ( isOpening ) {
						return;
					}

					if ( !this._allowInteraction( event ) ) {
						event.preventDefault();
						this._trackingInstances()[ 0 ]._focusTabbable();
					}
				}
			} );
		}

		this.overlay = $( "<div>" )
			.appendTo( this._appendTo() );

		this._addClass( this.overlay, null, "ui-widget-overlay ui-front" );
		this._on( this.overlay, {
			mousedown: "_keepFocus"
		} );
		this.document.data( "ui-dialog-overlays",
			( this.document.data( "ui-dialog-overlays" ) || 0 ) + 1 );
	},

	_destroyOverlay: function() {
		if ( !this.options.modal ) {
			return;
		}

		if ( this.overlay ) {
			var overlays = this.document.data( "ui-dialog-overlays" ) - 1;

			if ( !overlays ) {
				this._off( this.document, "focusin" );
				this.document.removeData( "ui-dialog-overlays" );
			} else {
				this.document.data( "ui-dialog-overlays", overlays );
			}

			this.overlay.remove();
			this.overlay = null;
		}
	}
} );

// DEPRECATED
// TODO: switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for dialogClass option
	$.widget( "ui.dialog", $.ui.dialog, {
		options: {
			dialogClass: ""
		},
		_createWrapper: function() {
			this._super();
			this.uiDialog.addClass( this.options.dialogClass );
		},
		_setOption: function( key, value ) {
			if ( key === "dialogClass" ) {
				this.uiDialog
					.removeClass( this.options.dialogClass )
					.addClass( value );
			}
			this._superApply( arguments );
		}
	} );
}

var widgetsDialog = $.ui.dialog;


/*!
 * jQuery UI Droppable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Droppable
//>>group: Interactions
//>>description: Enables drop targets for draggable elements.
//>>docs: http://api.jqueryui.com/droppable/
//>>demos: http://jqueryui.com/droppable/



$.widget( "ui.droppable", {
	version: "1.12.1",
	widgetEventPrefix: "drop",
	options: {
		accept: "*",
		addClasses: true,
		greedy: false,
		scope: "default",
		tolerance: "intersect",

		// Callbacks
		activate: null,
		deactivate: null,
		drop: null,
		out: null,
		over: null
	},
	_create: function() {

		var proportions,
			o = this.options,
			accept = o.accept;

		this.isover = false;
		this.isout = true;

		this.accept = $.isFunction( accept ) ? accept : function( d ) {
			return d.is( accept );
		};

		this.proportions = function( /* valueToWrite */ ) {
			if ( arguments.length ) {

				// Store the droppable's proportions
				proportions = arguments[ 0 ];
			} else {

				// Retrieve or derive the droppable's proportions
				return proportions ?
					proportions :
					proportions = {
						width: this.element[ 0 ].offsetWidth,
						height: this.element[ 0 ].offsetHeight
					};
			}
		};

		this._addToManager( o.scope );

		o.addClasses && this._addClass( "ui-droppable" );

	},

	_addToManager: function( scope ) {

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];
		$.ui.ddmanager.droppables[ scope ].push( this );
	},

	_splice: function( drop ) {
		var i = 0;
		for ( ; i < drop.length; i++ ) {
			if ( drop[ i ] === this ) {
				drop.splice( i, 1 );
			}
		}
	},

	_destroy: function() {
		var drop = $.ui.ddmanager.droppables[ this.options.scope ];

		this._splice( drop );
	},

	_setOption: function( key, value ) {

		if ( key === "accept" ) {
			this.accept = $.isFunction( value ) ? value : function( d ) {
				return d.is( value );
			};
		} else if ( key === "scope" ) {
			var drop = $.ui.ddmanager.droppables[ this.options.scope ];

			this._splice( drop );
			this._addToManager( value );
		}

		this._super( key, value );
	},

	_activate: function( event ) {
		var draggable = $.ui.ddmanager.current;

		this._addActiveClass();
		if ( draggable ) {
			this._trigger( "activate", event, this.ui( draggable ) );
		}
	},

	_deactivate: function( event ) {
		var draggable = $.ui.ddmanager.current;

		this._removeActiveClass();
		if ( draggable ) {
			this._trigger( "deactivate", event, this.ui( draggable ) );
		}
	},

	_over: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem ||
				draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem ||
				draggable.element ) ) ) {
			this._addHoverClass();
			this._trigger( "over", event, this.ui( draggable ) );
		}

	},

	_out: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem ||
				draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem ||
				draggable.element ) ) ) {
			this._removeHoverClass();
			this._trigger( "out", event, this.ui( draggable ) );
		}

	},

	_drop: function( event, custom ) {

		var draggable = custom || $.ui.ddmanager.current,
			childrenIntersection = false;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem ||
				draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return false;
		}

		this.element
			.find( ":data(ui-droppable)" )
			.not( ".ui-draggable-dragging" )
			.each( function() {
				var inst = $( this ).droppable( "instance" );
				if (
					inst.options.greedy &&
					!inst.options.disabled &&
					inst.options.scope === draggable.options.scope &&
					inst.accept.call(
						inst.element[ 0 ], ( draggable.currentItem || draggable.element )
					) &&
					intersect(
						draggable,
						$.extend( inst, { offset: inst.element.offset() } ),
						inst.options.tolerance, event
					)
				) {
					childrenIntersection = true;
					return false; }
			} );
		if ( childrenIntersection ) {
			return false;
		}

		if ( this.accept.call( this.element[ 0 ],
				( draggable.currentItem || draggable.element ) ) ) {
			this._removeActiveClass();
			this._removeHoverClass();

			this._trigger( "drop", event, this.ui( draggable ) );
			return this.element;
		}

		return false;

	},

	ui: function( c ) {
		return {
			draggable: ( c.currentItem || c.element ),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	},

	// Extension points just to make backcompat sane and avoid duplicating logic
	// TODO: Remove in 1.13 along with call to it below
	_addHoverClass: function() {
		this._addClass( "ui-droppable-hover" );
	},

	_removeHoverClass: function() {
		this._removeClass( "ui-droppable-hover" );
	},

	_addActiveClass: function() {
		this._addClass( "ui-droppable-active" );
	},

	_removeActiveClass: function() {
		this._removeClass( "ui-droppable-active" );
	}
} );

var intersect = $.ui.intersect = ( function() {
	function isOverAxis( x, reference, size ) {
		return ( x >= reference ) && ( x < ( reference + size ) );
	}

	return function( draggable, droppable, toleranceMode, event ) {

		if ( !droppable.offset ) {
			return false;
		}

		var x1 = ( draggable.positionAbs ||
				draggable.position.absolute ).left + draggable.margins.left,
			y1 = ( draggable.positionAbs ||
				draggable.position.absolute ).top + draggable.margins.top,
			x2 = x1 + draggable.helperProportions.width,
			y2 = y1 + draggable.helperProportions.height,
			l = droppable.offset.left,
			t = droppable.offset.top,
			r = l + droppable.proportions().width,
			b = t + droppable.proportions().height;

		switch ( toleranceMode ) {
		case "fit":
			return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
		case "intersect":
			return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half
				x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half
				t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half
				y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half
		case "pointer":
			return isOverAxis( event.pageY, t, droppable.proportions().height ) &&
				isOverAxis( event.pageX, l, droppable.proportions().width );
		case "touch":
			return (
				( y1 >= t && y1 <= b ) || // Top edge touching
				( y2 >= t && y2 <= b ) || // Bottom edge touching
				( y1 < t && y2 > b ) // Surrounded vertically
			) && (
				( x1 >= l && x1 <= r ) || // Left edge touching
				( x2 >= l && x2 <= r ) || // Right edge touching
				( x1 < l && x2 > r ) // Surrounded horizontally
			);
		default:
			return false;
		}
	};
} )();

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { "default": [] },
	prepareOffsets: function( t, event ) {

		var i, j,
			m = $.ui.ddmanager.droppables[ t.options.scope ] || [],
			type = event ? event.type : null, // workaround for #2317
			list = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();

		droppablesLoop: for ( i = 0; i < m.length; i++ ) {

			// No disabled and non-accepted
			if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ],
					( t.currentItem || t.element ) ) ) ) {
				continue;
			}

			// Filter out elements in the current dragged item
			for ( j = 0; j < list.length; j++ ) {
				if ( list[ j ] === m[ i ].element[ 0 ] ) {
					m[ i ].proportions().height = 0;
					continue droppablesLoop;
				}
			}

			m[ i ].visible = m[ i ].element.css( "display" ) !== "none";
			if ( !m[ i ].visible ) {
				continue;
			}

			// Activate the droppable if used directly from draggables
			if ( type === "mousedown" ) {
				m[ i ]._activate.call( m[ i ], event );
			}

			m[ i ].offset = m[ i ].element.offset();
			m[ i ].proportions( {
				width: m[ i ].element[ 0 ].offsetWidth,
				height: m[ i ].element[ 0 ].offsetHeight
			} );

		}

	},
	drop: function( draggable, event ) {

		var dropped = false;

		// Create a copy of the droppables in case the list changes during the drop (#9116)
		$.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {

			if ( !this.options ) {
				return;
			}
			if ( !this.options.disabled && this.visible &&
					intersect( draggable, this, this.options.tolerance, event ) ) {
				dropped = this._drop.call( this, event ) || dropped;
			}

			if ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ],
					( draggable.currentItem || draggable.element ) ) ) {
				this.isout = true;
				this.isover = false;
				this._deactivate.call( this, event );
			}

		} );
		return dropped;

	},
	dragStart: function( draggable, event ) {

		// Listen for scrolling so that if the dragging causes scrolling the position of the
		// droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( "body" ).on( "scroll.droppable", function() {
			if ( !draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
		} );
	},
	drag: function( draggable, event ) {

		// If you have a highly dynamic page, you might try this option. It renders positions
		// every time you move the mouse.
		if ( draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}

		// Run through all droppables and check their positions based on specific tolerance options
		$.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {

			if ( this.options.disabled || this.greedyChild || !this.visible ) {
				return;
			}

			var parentInstance, scope, parent,
				intersects = intersect( draggable, this, this.options.tolerance, event ),
				c = !intersects && this.isover ?
					"isout" :
					( intersects && !this.isover ? "isover" : null );
			if ( !c ) {
				return;
			}

			if ( this.options.greedy ) {

				// find droppable parents with same scope
				scope = this.options.scope;
				parent = this.element.parents( ":data(ui-droppable)" ).filter( function() {
					return $( this ).droppable( "instance" ).options.scope === scope;
				} );

				if ( parent.length ) {
					parentInstance = $( parent[ 0 ] ).droppable( "instance" );
					parentInstance.greedyChild = ( c === "isover" );
				}
			}

			// We just moved into a greedy child
			if ( parentInstance && c === "isover" ) {
				parentInstance.isover = false;
				parentInstance.isout = true;
				parentInstance._out.call( parentInstance, event );
			}

			this[ c ] = true;
			this[ c === "isout" ? "isover" : "isout" ] = false;
			this[ c === "isover" ? "_over" : "_out" ].call( this, event );

			// We just moved out of a greedy child
			if ( parentInstance && c === "isout" ) {
				parentInstance.isout = false;
				parentInstance.isover = true;
				parentInstance._over.call( parentInstance, event );
			}
		} );

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( "body" ).off( "scroll.droppable" );

		// Call prepareOffsets one final time since IE does not fire return scroll events when
		// overflow was caused by drag (see #5003)
		if ( !draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}
	}
};

// DEPRECATED
// TODO: switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for activeClass and hoverClass options
	$.widget( "ui.droppable", $.ui.droppable, {
		options: {
			hoverClass: false,
			activeClass: false
		},
		_addActiveClass: function() {
			this._super();
			if ( this.options.activeClass ) {
				this.element.addClass( this.options.activeClass );
			}
		},
		_removeActiveClass: function() {
			this._super();
			if ( this.options.activeClass ) {
				this.element.removeClass( this.options.activeClass );
			}
		},
		_addHoverClass: function() {
			this._super();
			if ( this.options.hoverClass ) {
				this.element.addClass( this.options.hoverClass );
			}
		},
		_removeHoverClass: function() {
			this._super();
			if ( this.options.hoverClass ) {
				this.element.removeClass( this.options.hoverClass );
			}
		}
	} );
}

var widgetsDroppable = $.ui.droppable;


/*!
 * jQuery UI Progressbar 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Progressbar
//>>group: Widgets
// jscs:disable maximumLineLength
//>>description: Displays a status indicator for loading state, standard percentage, and other progress indicators.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/progressbar/
//>>demos: http://jqueryui.com/progressbar/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/progressbar.css
//>>css.theme: ../../themes/base/theme.css



var widgetsProgressbar = $.widget( "ui.progressbar", {
	version: "1.12.1",
	options: {
		classes: {
			"ui-progressbar": "ui-corner-all",
			"ui-progressbar-value": "ui-corner-left",
			"ui-progressbar-complete": "ui-corner-right"
		},
		max: 100,
		value: 0,

		change: null,
		complete: null
	},

	min: 0,

	_create: function() {

		// Constrain initial value
		this.oldValue = this.options.value = this._constrainedValue();

		this.element.attr( {

			// Only set static values; aria-valuenow and aria-valuemax are
			// set inside _refreshValue()
			role: "progressbar",
			"aria-valuemin": this.min
		} );
		this._addClass( "ui-progressbar", "ui-widget ui-widget-content" );

		this.valueDiv = $( "<div>" ).appendTo( this.element );
		this._addClass( this.valueDiv, "ui-progressbar-value", "ui-widget-header" );
		this._refreshValue();
	},

	_destroy: function() {
		this.element.removeAttr( "role aria-valuemin aria-valuemax aria-valuenow" );

		this.valueDiv.remove();
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this.options.value;
		}

		this.options.value = this._constrainedValue( newValue );
		this._refreshValue();
	},

	_constrainedValue: function( newValue ) {
		if ( newValue === undefined ) {
			newValue = this.options.value;
		}

		this.indeterminate = newValue === false;

		// Sanitize value
		if ( typeof newValue !== "number" ) {
			newValue = 0;
		}

		return this.indeterminate ? false :
			Math.min( this.options.max, Math.max( this.min, newValue ) );
	},

	_setOptions: function( options ) {

		// Ensure "value" option is set after other values (like max)
		var value = options.value;
		delete options.value;

		this._super( options );

		this.options.value = this._constrainedValue( value );
		this._refreshValue();
	},

	_setOption: function( key, value ) {
		if ( key === "max" ) {

			// Don't allow a max less than min
			value = Math.max( this.min, value );
		}
		this._super( key, value );
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this.element.attr( "aria-disabled", value );
		this._toggleClass( null, "ui-state-disabled", !!value );
	},

	_percentage: function() {
		return this.indeterminate ?
			100 :
			100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
	},

	_refreshValue: function() {
		var value = this.options.value,
			percentage = this._percentage();

		this.valueDiv
			.toggle( this.indeterminate || value > this.min )
			.width( percentage.toFixed( 0 ) + "%" );

		this
			._toggleClass( this.valueDiv, "ui-progressbar-complete", null,
				value === this.options.max )
			._toggleClass( "ui-progressbar-indeterminate", null, this.indeterminate );

		if ( this.indeterminate ) {
			this.element.removeAttr( "aria-valuenow" );
			if ( !this.overlayDiv ) {
				this.overlayDiv = $( "<div>" ).appendTo( this.valueDiv );
				this._addClass( this.overlayDiv, "ui-progressbar-overlay" );
			}
		} else {
			this.element.attr( {
				"aria-valuemax": this.options.max,
				"aria-valuenow": value
			} );
			if ( this.overlayDiv ) {
				this.overlayDiv.remove();
				this.overlayDiv = null;
			}
		}

		if ( this.oldValue !== value ) {
			this.oldValue = value;
			this._trigger( "change" );
		}
		if ( value === this.options.max ) {
			this._trigger( "complete" );
		}
	}
} );


/*!
 * jQuery UI Selectable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Selectable
//>>group: Interactions
//>>description: Allows groups of elements to be selected with the mouse.
//>>docs: http://api.jqueryui.com/selectable/
//>>demos: http://jqueryui.com/selectable/
//>>css.structure: ../../themes/base/selectable.css



var widgetsSelectable = $.widget( "ui.selectable", $.ui.mouse, {
	version: "1.12.1",
	options: {
		appendTo: "body",
		autoRefresh: true,
		distance: 0,
		filter: "*",
		tolerance: "touch",

		// Callbacks
		selected: null,
		selecting: null,
		start: null,
		stop: null,
		unselected: null,
		unselecting: null
	},
	_create: function() {
		var that = this;

		this._addClass( "ui-selectable" );

		this.dragged = false;

		// Cache selectee children based on filter
		this.refresh = function() {
			that.elementPos = $( that.element[ 0 ] ).offset();
			that.selectees = $( that.options.filter, that.element[ 0 ] );
			that._addClass( that.selectees, "ui-selectee" );
			that.selectees.each( function() {
				var $this = $( this ),
					selecteeOffset = $this.offset(),
					pos = {
						left: selecteeOffset.left - that.elementPos.left,
						top: selecteeOffset.top - that.elementPos.top
					};
				$.data( this, "selectable-item", {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass( "ui-selected" ),
					selecting: $this.hasClass( "ui-selecting" ),
					unselecting: $this.hasClass( "ui-unselecting" )
				} );
			} );
		};
		this.refresh();

		this._mouseInit();

		this.helper = $( "<div>" );
		this._addClass( this.helper, "ui-selectable-helper" );
	},

	_destroy: function() {
		this.selectees.removeData( "selectable-item" );
		this._mouseDestroy();
	},

	_mouseStart: function( event ) {
		var that = this,
			options = this.options;

		this.opos = [ event.pageX, event.pageY ];
		this.elementPos = $( this.element[ 0 ] ).offset();

		if ( this.options.disabled ) {
			return;
		}

		this.selectees = $( options.filter, this.element[ 0 ] );

		this._trigger( "start", event );

		$( options.appendTo ).append( this.helper );

		// position helper (lasso)
		this.helper.css( {
			"left": event.pageX,
			"top": event.pageY,
			"width": 0,
			"height": 0
		} );

		if ( options.autoRefresh ) {
			this.refresh();
		}

		this.selectees.filter( ".ui-selected" ).each( function() {
			var selectee = $.data( this, "selectable-item" );
			selectee.startselected = true;
			if ( !event.metaKey && !event.ctrlKey ) {
				that._removeClass( selectee.$element, "ui-selected" );
				selectee.selected = false;
				that._addClass( selectee.$element, "ui-unselecting" );
				selectee.unselecting = true;

				// selectable UNSELECTING callback
				that._trigger( "unselecting", event, {
					unselecting: selectee.element
				} );
			}
		} );

		$( event.target ).parents().addBack().each( function() {
			var doSelect,
				selectee = $.data( this, "selectable-item" );
			if ( selectee ) {
				doSelect = ( !event.metaKey && !event.ctrlKey ) ||
					!selectee.$element.hasClass( "ui-selected" );
				that._removeClass( selectee.$element, doSelect ? "ui-unselecting" : "ui-selected" )
					._addClass( selectee.$element, doSelect ? "ui-selecting" : "ui-unselecting" );
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;

				// selectable (UN)SELECTING callback
				if ( doSelect ) {
					that._trigger( "selecting", event, {
						selecting: selectee.element
					} );
				} else {
					that._trigger( "unselecting", event, {
						unselecting: selectee.element
					} );
				}
				return false;
			}
		} );

	},

	_mouseDrag: function( event ) {

		this.dragged = true;

		if ( this.options.disabled ) {
			return;
		}

		var tmp,
			that = this,
			options = this.options,
			x1 = this.opos[ 0 ],
			y1 = this.opos[ 1 ],
			x2 = event.pageX,
			y2 = event.pageY;

		if ( x1 > x2 ) { tmp = x2; x2 = x1; x1 = tmp; }
		if ( y1 > y2 ) { tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css( { left: x1, top: y1, width: x2 - x1, height: y2 - y1 } );

		this.selectees.each( function() {
			var selectee = $.data( this, "selectable-item" ),
				hit = false,
				offset = {};

			//prevent helper from being selected if appendTo: selectable
			if ( !selectee || selectee.element === that.element[ 0 ] ) {
				return;
			}

			offset.left   = selectee.left   + that.elementPos.left;
			offset.right  = selectee.right  + that.elementPos.left;
			offset.top    = selectee.top    + that.elementPos.top;
			offset.bottom = selectee.bottom + that.elementPos.top;

			if ( options.tolerance === "touch" ) {
				hit = ( !( offset.left > x2 || offset.right < x1 || offset.top > y2 ||
                    offset.bottom < y1 ) );
			} else if ( options.tolerance === "fit" ) {
				hit = ( offset.left > x1 && offset.right < x2 && offset.top > y1 &&
                    offset.bottom < y2 );
			}

			if ( hit ) {

				// SELECT
				if ( selectee.selected ) {
					that._removeClass( selectee.$element, "ui-selected" );
					selectee.selected = false;
				}
				if ( selectee.unselecting ) {
					that._removeClass( selectee.$element, "ui-unselecting" );
					selectee.unselecting = false;
				}
				if ( !selectee.selecting ) {
					that._addClass( selectee.$element, "ui-selecting" );
					selectee.selecting = true;

					// selectable SELECTING callback
					that._trigger( "selecting", event, {
						selecting: selectee.element
					} );
				}
			} else {

				// UNSELECT
				if ( selectee.selecting ) {
					if ( ( event.metaKey || event.ctrlKey ) && selectee.startselected ) {
						that._removeClass( selectee.$element, "ui-selecting" );
						selectee.selecting = false;
						that._addClass( selectee.$element, "ui-selected" );
						selectee.selected = true;
					} else {
						that._removeClass( selectee.$element, "ui-selecting" );
						selectee.selecting = false;
						if ( selectee.startselected ) {
							that._addClass( selectee.$element, "ui-unselecting" );
							selectee.unselecting = true;
						}

						// selectable UNSELECTING callback
						that._trigger( "unselecting", event, {
							unselecting: selectee.element
						} );
					}
				}
				if ( selectee.selected ) {
					if ( !event.metaKey && !event.ctrlKey && !selectee.startselected ) {
						that._removeClass( selectee.$element, "ui-selected" );
						selectee.selected = false;

						that._addClass( selectee.$element, "ui-unselecting" );
						selectee.unselecting = true;

						// selectable UNSELECTING callback
						that._trigger( "unselecting", event, {
							unselecting: selectee.element
						} );
					}
				}
			}
		} );

		return false;
	},

	_mouseStop: function( event ) {
		var that = this;

		this.dragged = false;

		$( ".ui-unselecting", this.element[ 0 ] ).each( function() {
			var selectee = $.data( this, "selectable-item" );
			that._removeClass( selectee.$element, "ui-unselecting" );
			selectee.unselecting = false;
			selectee.startselected = false;
			that._trigger( "unselected", event, {
				unselected: selectee.element
			} );
		} );
		$( ".ui-selecting", this.element[ 0 ] ).each( function() {
			var selectee = $.data( this, "selectable-item" );
			that._removeClass( selectee.$element, "ui-selecting" )
				._addClass( selectee.$element, "ui-selected" );
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			that._trigger( "selected", event, {
				selected: selectee.element
			} );
		} );
		this._trigger( "stop", event );

		this.helper.remove();

		return false;
	}

} );


/*!
 * jQuery UI Selectmenu 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Selectmenu
//>>group: Widgets
// jscs:disable maximumLineLength
//>>description: Duplicates and extends the functionality of a native HTML select element, allowing it to be customizable in behavior and appearance far beyond the limitations of a native select.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/selectmenu/
//>>demos: http://jqueryui.com/selectmenu/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/selectmenu.css, ../../themes/base/button.css
//>>css.theme: ../../themes/base/theme.css



var widgetsSelectmenu = $.widget( "ui.selectmenu", [ $.ui.formResetMixin, {
	version: "1.12.1",
	defaultElement: "<select>",
	options: {
		appendTo: null,
		classes: {
			"ui-selectmenu-button-open": "ui-corner-top",
			"ui-selectmenu-button-closed": "ui-corner-all"
		},
		disabled: null,
		icons: {
			button: "ui-icon-triangle-1-s"
		},
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		width: false,

		// Callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		select: null
	},

	_create: function() {
		var selectmenuId = this.element.uniqueId().attr( "id" );
		this.ids = {
			element: selectmenuId,
			button: selectmenuId + "-button",
			menu: selectmenuId + "-menu"
		};

		this._drawButton();
		this._drawMenu();
		this._bindFormResetHandler();

		this._rendered = false;
		this.menuItems = $();
	},

	_drawButton: function() {
		var icon,
			that = this,
			item = this._parseOption(
				this.element.find( "option:selected" ),
				this.element[ 0 ].selectedIndex
			);

		// Associate existing label with the new button
		this.labels = this.element.labels().attr( "for", this.ids.button );
		this._on( this.labels, {
			click: function( event ) {
				this.button.focus();
				event.preventDefault();
			}
		} );

		// Hide original select element
		this.element.hide();

		// Create button
		this.button = $( "<span>", {
			tabindex: this.options.disabled ? -1 : 0,
			id: this.ids.button,
			role: "combobox",
			"aria-expanded": "false",
			"aria-autocomplete": "list",
			"aria-owns": this.ids.menu,
			"aria-haspopup": "true",
			title: this.element.attr( "title" )
		} )
			.insertAfter( this.element );

		this._addClass( this.button, "ui-selectmenu-button ui-selectmenu-button-closed",
			"ui-button ui-widget" );

		icon = $( "<span>" ).appendTo( this.button );
		this._addClass( icon, "ui-selectmenu-icon", "ui-icon " + this.options.icons.button );
		this.buttonItem = this._renderButtonItem( item )
			.appendTo( this.button );

		if ( this.options.width !== false ) {
			this._resizeButton();
		}

		this._on( this.button, this._buttonEvents );
		this.button.one( "focusin", function() {

			// Delay rendering the menu items until the button receives focus.
			// The menu may have already been rendered via a programmatic open.
			if ( !that._rendered ) {
				that._refreshMenu();
			}
		} );
	},

	_drawMenu: function() {
		var that = this;

		// Create menu
		this.menu = $( "<ul>", {
			"aria-hidden": "true",
			"aria-labelledby": this.ids.button,
			id: this.ids.menu
		} );

		// Wrap menu
		this.menuWrap = $( "<div>" ).append( this.menu );
		this._addClass( this.menuWrap, "ui-selectmenu-menu", "ui-front" );
		this.menuWrap.appendTo( this._appendTo() );

		// Initialize menu widget
		this.menuInstance = this.menu
			.menu( {
				classes: {
					"ui-menu": "ui-corner-bottom"
				},
				role: "listbox",
				select: function( event, ui ) {
					event.preventDefault();

					// Support: IE8
					// If the item was selected via a click, the text selection
					// will be destroyed in IE
					that._setSelection();

					that._select( ui.item.data( "ui-selectmenu-item" ), event );
				},
				focus: function( event, ui ) {
					var item = ui.item.data( "ui-selectmenu-item" );

					// Prevent inital focus from firing and check if its a newly focused item
					if ( that.focusIndex != null && item.index !== that.focusIndex ) {
						that._trigger( "focus", event, { item: item } );
						if ( !that.isOpen ) {
							that._select( item, event );
						}
					}
					that.focusIndex = item.index;

					that.button.attr( "aria-activedescendant",
						that.menuItems.eq( item.index ).attr( "id" ) );
				}
			} )
			.menu( "instance" );

		// Don't close the menu on mouseleave
		this.menuInstance._off( this.menu, "mouseleave" );

		// Cancel the menu's collapseAll on document click
		this.menuInstance._closeOnDocumentClick = function() {
			return false;
		};

		// Selects often contain empty items, but never contain dividers
		this.menuInstance._isDivider = function() {
			return false;
		};
	},

	refresh: function() {
		this._refreshMenu();
		this.buttonItem.replaceWith(
			this.buttonItem = this._renderButtonItem(

				// Fall back to an empty object in case there are no options
				this._getSelectedItem().data( "ui-selectmenu-item" ) || {}
			)
		);
		if ( this.options.width === null ) {
			this._resizeButton();
		}
	},

	_refreshMenu: function() {
		var item,
			options = this.element.find( "option" );

		this.menu.empty();

		this._parseOptions( options );
		this._renderMenu( this.menu, this.items );

		this.menuInstance.refresh();
		this.menuItems = this.menu.find( "li" )
			.not( ".ui-selectmenu-optgroup" )
				.find( ".ui-menu-item-wrapper" );

		this._rendered = true;

		if ( !options.length ) {
			return;
		}

		item = this._getSelectedItem();

		// Update the menu to have the correct item focused
		this.menuInstance.focus( null, item );
		this._setAria( item.data( "ui-selectmenu-item" ) );

		// Set disabled state
		this._setOption( "disabled", this.element.prop( "disabled" ) );
	},

	open: function( event ) {
		if ( this.options.disabled ) {
			return;
		}

		// If this is the first time the menu is being opened, render the items
		if ( !this._rendered ) {
			this._refreshMenu();
		} else {

			// Menu clears focus on close, reset focus to selected item
			this._removeClass( this.menu.find( ".ui-state-active" ), null, "ui-state-active" );
			this.menuInstance.focus( null, this._getSelectedItem() );
		}

		// If there are no options, don't open the menu
		if ( !this.menuItems.length ) {
			return;
		}

		this.isOpen = true;
		this._toggleAttr();
		this._resizeMenu();
		this._position();

		this._on( this.document, this._documentClick );

		this._trigger( "open", event );
	},

	_position: function() {
		this.menuWrap.position( $.extend( { of: this.button }, this.options.position ) );
	},

	close: function( event ) {
		if ( !this.isOpen ) {
			return;
		}

		this.isOpen = false;
		this._toggleAttr();

		this.range = null;
		this._off( this.document );

		this._trigger( "close", event );
	},

	widget: function() {
		return this.button;
	},

	menuWidget: function() {
		return this.menu;
	},

	_renderButtonItem: function( item ) {
		var buttonItem = $( "<span>" );

		this._setText( buttonItem, item.label );
		this._addClass( buttonItem, "ui-selectmenu-text" );

		return buttonItem;
	},

	_renderMenu: function( ul, items ) {
		var that = this,
			currentOptgroup = "";

		$.each( items, function( index, item ) {
			var li;

			if ( item.optgroup !== currentOptgroup ) {
				li = $( "<li>", {
					text: item.optgroup
				} );
				that._addClass( li, "ui-selectmenu-optgroup", "ui-menu-divider" +
					( item.element.parent( "optgroup" ).prop( "disabled" ) ?
						" ui-state-disabled" :
						"" ) );

				li.appendTo( ul );

				currentOptgroup = item.optgroup;
			}

			that._renderItemData( ul, item );
		} );
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-selectmenu-item", item );
	},

	_renderItem: function( ul, item ) {
		var li = $( "<li>" ),
			wrapper = $( "<div>", {
				title: item.element.attr( "title" )
			} );

		if ( item.disabled ) {
			this._addClass( li, null, "ui-state-disabled" );
		}
		this._setText( wrapper, item.label );

		return li.append( wrapper ).appendTo( ul );
	},

	_setText: function( element, value ) {
		if ( value ) {
			element.text( value );
		} else {
			element.html( "&#160;" );
		}
	},

	_move: function( direction, event ) {
		var item, next,
			filter = ".ui-menu-item";

		if ( this.isOpen ) {
			item = this.menuItems.eq( this.focusIndex ).parent( "li" );
		} else {
			item = this.menuItems.eq( this.element[ 0 ].selectedIndex ).parent( "li" );
			filter += ":not(.ui-state-disabled)";
		}

		if ( direction === "first" || direction === "last" ) {
			next = item[ direction === "first" ? "prevAll" : "nextAll" ]( filter ).eq( -1 );
		} else {
			next = item[ direction + "All" ]( filter ).eq( 0 );
		}

		if ( next.length ) {
			this.menuInstance.focus( event, next );
		}
	},

	_getSelectedItem: function() {
		return this.menuItems.eq( this.element[ 0 ].selectedIndex ).parent( "li" );
	},

	_toggle: function( event ) {
		this[ this.isOpen ? "close" : "open" ]( event );
	},

	_setSelection: function() {
		var selection;

		if ( !this.range ) {
			return;
		}

		if ( window.getSelection ) {
			selection = window.getSelection();
			selection.removeAllRanges();
			selection.addRange( this.range );

		// Support: IE8
		} else {
			this.range.select();
		}

		// Support: IE
		// Setting the text selection kills the button focus in IE, but
		// restoring the focus doesn't kill the selection.
		this.button.focus();
	},

	_documentClick: {
		mousedown: function( event ) {
			if ( !this.isOpen ) {
				return;
			}

			if ( !$( event.target ).closest( ".ui-selectmenu-menu, #" +
					$.ui.escapeSelector( this.ids.button ) ).length ) {
				this.close( event );
			}
		}
	},

	_buttonEvents: {

		// Prevent text selection from being reset when interacting with the selectmenu (#10144)
		mousedown: function() {
			var selection;

			if ( window.getSelection ) {
				selection = window.getSelection();
				if ( selection.rangeCount ) {
					this.range = selection.getRangeAt( 0 );
				}

			// Support: IE8
			} else {
				this.range = document.selection.createRange();
			}
		},

		click: function( event ) {
			this._setSelection();
			this._toggle( event );
		},

		keydown: function( event ) {
			var preventDefault = true;
			switch ( event.keyCode ) {
			case $.ui.keyCode.TAB:
			case $.ui.keyCode.ESCAPE:
				this.close( event );
				preventDefault = false;
				break;
			case $.ui.keyCode.ENTER:
				if ( this.isOpen ) {
					this._selectFocusedItem( event );
				}
				break;
			case $.ui.keyCode.UP:
				if ( event.altKey ) {
					this._toggle( event );
				} else {
					this._move( "prev", event );
				}
				break;
			case $.ui.keyCode.DOWN:
				if ( event.altKey ) {
					this._toggle( event );
				} else {
					this._move( "next", event );
				}
				break;
			case $.ui.keyCode.SPACE:
				if ( this.isOpen ) {
					this._selectFocusedItem( event );
				} else {
					this._toggle( event );
				}
				break;
			case $.ui.keyCode.LEFT:
				this._move( "prev", event );
				break;
			case $.ui.keyCode.RIGHT:
				this._move( "next", event );
				break;
			case $.ui.keyCode.HOME:
			case $.ui.keyCode.PAGE_UP:
				this._move( "first", event );
				break;
			case $.ui.keyCode.END:
			case $.ui.keyCode.PAGE_DOWN:
				this._move( "last", event );
				break;
			default:
				this.menu.trigger( event );
				preventDefault = false;
			}

			if ( preventDefault ) {
				event.preventDefault();
			}
		}
	},

	_selectFocusedItem: function( event ) {
		var item = this.menuItems.eq( this.focusIndex ).parent( "li" );
		if ( !item.hasClass( "ui-state-disabled" ) ) {
			this._select( item.data( "ui-selectmenu-item" ), event );
		}
	},

	_select: function( item, event ) {
		var oldIndex = this.element[ 0 ].selectedIndex;

		// Change native select element
		this.element[ 0 ].selectedIndex = item.index;
		this.buttonItem.replaceWith( this.buttonItem = this._renderButtonItem( item ) );
		this._setAria( item );
		this._trigger( "select", event, { item: item } );

		if ( item.index !== oldIndex ) {
			this._trigger( "change", event, { item: item } );
		}

		this.close( event );
	},

	_setAria: function( item ) {
		var id = this.menuItems.eq( item.index ).attr( "id" );

		this.button.attr( {
			"aria-labelledby": id,
			"aria-activedescendant": id
		} );
		this.menu.attr( "aria-activedescendant", id );
	},

	_setOption: function( key, value ) {
		if ( key === "icons" ) {
			var icon = this.button.find( "span.ui-icon" );
			this._removeClass( icon, null, this.options.icons.button )
				._addClass( icon, null, value.button );
		}

		this._super( key, value );

		if ( key === "appendTo" ) {
			this.menuWrap.appendTo( this._appendTo() );
		}

		if ( key === "width" ) {
			this._resizeButton();
		}
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this.menuInstance.option( "disabled", value );
		this.button.attr( "aria-disabled", value );
		this._toggleClass( this.button, null, "ui-state-disabled", value );

		this.element.prop( "disabled", value );
		if ( value ) {
			this.button.attr( "tabindex", -1 );
			this.close();
		} else {
			this.button.attr( "tabindex", 0 );
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;

		if ( element ) {
			element = element.jquery || element.nodeType ?
				$( element ) :
				this.document.find( element ).eq( 0 );
		}

		if ( !element || !element[ 0 ] ) {
			element = this.element.closest( ".ui-front, dialog" );
		}

		if ( !element.length ) {
			element = this.document[ 0 ].body;
		}

		return element;
	},

	_toggleAttr: function() {
		this.button.attr( "aria-expanded", this.isOpen );

		// We can't use two _toggleClass() calls here, because we need to make sure
		// we always remove classes first and add them second, otherwise if both classes have the
		// same theme class, it will be removed after we add it.
		this._removeClass( this.button, "ui-selectmenu-button-" +
			( this.isOpen ? "closed" : "open" ) )
			._addClass( this.button, "ui-selectmenu-button-" +
				( this.isOpen ? "open" : "closed" ) )
			._toggleClass( this.menuWrap, "ui-selectmenu-open", null, this.isOpen );

		this.menu.attr( "aria-hidden", !this.isOpen );
	},

	_resizeButton: function() {
		var width = this.options.width;

		// For `width: false`, just remove inline style and stop
		if ( width === false ) {
			this.button.css( "width", "" );
			return;
		}

		// For `width: null`, match the width of the original element
		if ( width === null ) {
			width = this.element.show().outerWidth();
			this.element.hide();
		}

		this.button.outerWidth( width );
	},

	_resizeMenu: function() {
		this.menu.outerWidth( Math.max(
			this.button.outerWidth(),

			// Support: IE10
			// IE10 wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping
			this.menu.width( "" ).outerWidth() + 1
		) );
	},

	_getCreateOptions: function() {
		var options = this._super();

		options.disabled = this.element.prop( "disabled" );

		return options;
	},

	_parseOptions: function( options ) {
		var that = this,
			data = [];
		options.each( function( index, item ) {
			data.push( that._parseOption( $( item ), index ) );
		} );
		this.items = data;
	},

	_parseOption: function( option, index ) {
		var optgroup = option.parent( "optgroup" );

		return {
			element: option,
			index: index,
			value: option.val(),
			label: option.text(),
			optgroup: optgroup.attr( "label" ) || "",
			disabled: optgroup.prop( "disabled" ) || option.prop( "disabled" )
		};
	},

	_destroy: function() {
		this._unbindFormResetHandler();
		this.menuWrap.remove();
		this.button.remove();
		this.element.show();
		this.element.removeUniqueId();
		this.labels.attr( "for", this.ids.element );
	}
} ] );


/*!
 * jQuery UI Slider 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Slider
//>>group: Widgets
//>>description: Displays a flexible slider with ranges and accessibility via keyboard.
//>>docs: http://api.jqueryui.com/slider/
//>>demos: http://jqueryui.com/slider/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/slider.css
//>>css.theme: ../../themes/base/theme.css



var widgetsSlider = $.widget( "ui.slider", $.ui.mouse, {
	version: "1.12.1",
	widgetEventPrefix: "slide",

	options: {
		animate: false,
		classes: {
			"ui-slider": "ui-corner-all",
			"ui-slider-handle": "ui-corner-all",

			// Note: ui-widget-header isn't the most fittingly semantic framework class for this
			// element, but worked best visually with a variety of themes
			"ui-slider-range": "ui-corner-all ui-widget-header"
		},
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null,

		// Callbacks
		change: null,
		slide: null,
		start: null,
		stop: null
	},

	// Number of pages in a slider
	// (how many times can you page up/down to go through the whole range)
	numPages: 5,

	_create: function() {
		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();
		this._calculateNewMax();

		this._addClass( "ui-slider ui-slider-" + this.orientation,
			"ui-widget ui-widget-content" );

		this._refresh();

		this._animateOff = false;
	},

	_refresh: function() {
		this._createRange();
		this._createHandles();
		this._setupEvents();
		this._refreshValue();
	},

	_createHandles: function() {
		var i, handleCount,
			options = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ),
			handle = "<span tabindex='0'></span>",
			handles = [];

		handleCount = ( options.values && options.values.length ) || 1;

		if ( existingHandles.length > handleCount ) {
			existingHandles.slice( handleCount ).remove();
			existingHandles = existingHandles.slice( 0, handleCount );
		}

		for ( i = existingHandles.length; i < handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

		this._addClass( this.handles, "ui-slider-handle", "ui-state-default" );

		this.handle = this.handles.eq( 0 );

		this.handles.each( function( i ) {
			$( this )
				.data( "ui-slider-handle-index", i )
				.attr( "tabIndex", 0 );
		} );
	},

	_createRange: function() {
		var options = this.options;

		if ( options.range ) {
			if ( options.range === true ) {
				if ( !options.values ) {
					options.values = [ this._valueMin(), this._valueMin() ];
				} else if ( options.values.length && options.values.length !== 2 ) {
					options.values = [ options.values[ 0 ], options.values[ 0 ] ];
				} else if ( $.isArray( options.values ) ) {
					options.values = options.values.slice( 0 );
				}
			}

			if ( !this.range || !this.range.length ) {
				this.range = $( "<div>" )
					.appendTo( this.element );

				this._addClass( this.range, "ui-slider-range" );
			} else {
				this._removeClass( this.range, "ui-slider-range-min ui-slider-range-max" );

				// Handle range switching from true to min/max
				this.range.css( {
					"left": "",
					"bottom": ""
				} );
			}
			if ( options.range === "min" || options.range === "max" ) {
				this._addClass( this.range, "ui-slider-range-" + options.range );
			}
		} else {
			if ( this.range ) {
				this.range.remove();
			}
			this.range = null;
		}
	},

	_setupEvents: function() {
		this._off( this.handles );
		this._on( this.handles, this._handleEvents );
		this._hoverable( this.handles );
		this._focusable( this.handles );
	},

	_destroy: function() {
		this.handles.remove();
		if ( this.range ) {
			this.range.remove();
		}

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each( function( i ) {
			var thisDistance = Math.abs( normValue - that.values( i ) );
			if ( ( distance > thisDistance ) ||
				( distance === thisDistance &&
					( i === that._lastChangedValue || that.values( i ) === o.min ) ) ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		} );

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		this._addClass( closestHandle, null, "ui-state-active" );
		closestHandle.trigger( "focus" );

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css( "borderTopWidth" ), 10 ) || 0 ) -
				( parseInt( closestHandle.css( "borderBottomWidth" ), 10 ) || 0 ) +
				( parseInt( closestHandle.css( "marginTop" ), 10 ) || 0 )
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function() {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this._removeClass( this.handles, null, "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left -
				( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top -
				( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_uiHash: function( index, value, values ) {
		var uiHash = {
			handle: this.handles[ index ],
			handleIndex: index,
			value: value !== undefined ? value : this.value()
		};

		if ( this._hasMultipleValues() ) {
			uiHash.value = value !== undefined ? value : this.values( index );
			uiHash.values = values || this.values();
		}

		return uiHash;
	},

	_hasMultipleValues: function() {
		return this.options.values && this.options.values.length;
	},

	_start: function( event, index ) {
		return this._trigger( "start", event, this._uiHash( index ) );
	},

	_slide: function( event, index, newVal ) {
		var allowed, otherVal,
			currentValue = this.value(),
			newValues = this.values();

		if ( this._hasMultipleValues() ) {
			otherVal = this.values( index ? 0 : 1 );
			currentValue = this.values( index );

			if ( this.options.values.length === 2 && this.options.range === true ) {
				newVal =  index === 0 ? Math.min( otherVal, newVal ) : Math.max( otherVal, newVal );
			}

			newValues[ index ] = newVal;
		}

		if ( newVal === currentValue ) {
			return;
		}

		allowed = this._trigger( "slide", event, this._uiHash( index, newVal, newValues ) );

		// A slide can be canceled by returning false from the slide callback
		if ( allowed === false ) {
			return;
		}

		if ( this._hasMultipleValues() ) {
			this.values( index, newVal );
		} else {
			this.value( newVal );
		}
	},

	_stop: function( event, index ) {
		this._trigger( "stop", event, this._uiHash( index ) );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {

			//store the last changed value index for reference when handles overlap
			this._lastChangedValue = index;
			this._trigger( "change", event, this._uiHash( index ) );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this._hasMultipleValues() ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( key === "range" && this.options.range === true ) {
			if ( value === "min" ) {
				this.options.value = this._values( 0 );
				this.options.values = null;
			} else if ( value === "max" ) {
				this.options.value = this._values( this.options.values.length - 1 );
				this.options.values = null;
			}
		}

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		this._super( key, value );

		switch ( key ) {
			case "orientation":
				this._detectOrientation();
				this._removeClass( "ui-slider-horizontal ui-slider-vertical" )
					._addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				if ( this.options.range ) {
					this._refreshRange( value );
				}

				// Reset positioning from previous orientation
				this.handles.css( value === "horizontal" ? "bottom" : "left", "" );
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();

				// Start from the last handle to prevent unreachable handles (#9046)
				for ( i = valsLength - 1; i >= 0; i-- ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
			case "step":
			case "min":
			case "max":
				this._animateOff = true;
				this._calculateNewMax();
				this._refreshValue();
				this._animateOff = false;
				break;
			case "range":
				this._animateOff = true;
				this._refresh();
				this._animateOff = false;
				break;
		}
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this._toggleClass( null, "ui-state-disabled", !!value );
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else if ( this._hasMultipleValues() ) {

			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i += 1 ) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		} else {
			return [];
		}
	},

	// Returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = ( val - this._valueMin() ) % step,
			alignValue = val - valModStep;

		if ( Math.abs( valModStep ) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed( 5 ) );
	},

	_calculateNewMax: function() {
		var max = this.options.max,
			min = this._valueMin(),
			step = this.options.step,
			aboveMin = Math.round( ( max - min ) / step ) * step;
		max = aboveMin + min;
		if ( max > this.options.max ) {

			//If max is not divisible by step, rounding off may increase its value
			max -= step;
		}
		this.max = parseFloat( max.toFixed( this._precision() ) );
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.max;
	},

	_refreshRange: function( orientation ) {
		if ( orientation === "vertical" ) {
			this.range.css( { "width": "", "left": "" } );
		}
		if ( orientation === "horizontal" ) {
			this.range.css( { "height": "", "bottom": "" } );
		}
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this._hasMultipleValues() ) {
			this.handles.each( function( i ) {
				valPercent = ( that.values( i ) - that._valueMin() ) / ( that._valueMax() -
					that._valueMin() ) * 100;
				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === "horizontal" ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
								left: valPercent + "%"
							}, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( {
								width: ( valPercent - lastValPercent ) + "%"
							}, {
								queue: false,
								duration: o.animate
							} );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
								bottom: ( valPercent ) + "%"
							}, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( {
								height: ( valPercent - lastValPercent ) + "%"
							}, {
								queue: false,
								duration: o.animate
							} );
						}
					}
				}
				lastValPercent = valPercent;
			} );
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					width: valPercent + "%"
				}, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					width: ( 100 - valPercent ) + "%"
				}, o.animate );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					height: valPercent + "%"
				}, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					height: ( 100 - valPercent ) + "%"
				}, o.animate );
			}
		}
	},

	_handleEvents: {
		keydown: function( event ) {
			var allowed, curVal, newVal, step,
				index = $( event.target ).data( "ui-slider-handle-index" );

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
				case $.ui.keyCode.END:
				case $.ui.keyCode.PAGE_UP:
				case $.ui.keyCode.PAGE_DOWN:
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					event.preventDefault();
					if ( !this._keySliding ) {
						this._keySliding = true;
						this._addClass( $( event.target ), null, "ui-state-active" );
						allowed = this._start( event, index );
						if ( allowed === false ) {
							return;
						}
					}
					break;
			}

			step = this.options.step;
			if ( this._hasMultipleValues() ) {
				curVal = newVal = this.values( index );
			} else {
				curVal = newVal = this.value();
			}

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
					newVal = this._valueMin();
					break;
				case $.ui.keyCode.END:
					newVal = this._valueMax();
					break;
				case $.ui.keyCode.PAGE_UP:
					newVal = this._trimAlignValue(
						curVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages )
					);
					break;
				case $.ui.keyCode.PAGE_DOWN:
					newVal = this._trimAlignValue(
						curVal - ( ( this._valueMax() - this._valueMin() ) / this.numPages ) );
					break;
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
					if ( curVal === this._valueMax() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal + step );
					break;
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					if ( curVal === this._valueMin() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal - step );
					break;
			}

			this._slide( event, index, newVal );
		},
		keyup: function( event ) {
			var index = $( event.target ).data( "ui-slider-handle-index" );

			if ( this._keySliding ) {
				this._keySliding = false;
				this._stop( event, index );
				this._change( event, index );
				this._removeClass( $( event.target ), null, "ui-state-active" );
			}
		}
	}
} );


/*!
 * jQuery UI Sortable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Sortable
//>>group: Interactions
//>>description: Enables items in a list to be sorted using the mouse.
//>>docs: http://api.jqueryui.com/sortable/
//>>demos: http://jqueryui.com/sortable/
//>>css.structure: ../../themes/base/sortable.css



var widgetsSortable = $.widget( "ui.sortable", $.ui.mouse, {
	version: "1.12.1",
	widgetEventPrefix: "sort",
	ready: false,
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: "> *",
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000,

		// Callbacks
		activate: null,
		beforeStop: null,
		change: null,
		deactivate: null,
		out: null,
		over: null,
		receive: null,
		remove: null,
		sort: null,
		start: null,
		stop: null,
		update: null
	},

	_isOverAxis: function( x, reference, size ) {
		return ( x >= reference ) && ( x < ( reference + size ) );
	},

	_isFloating: function( item ) {
		return ( /left|right/ ).test( item.css( "float" ) ) ||
			( /inline|table-cell/ ).test( item.css( "display" ) );
	},

	_create: function() {
		this.containerCache = {};
		this._addClass( "ui-sortable" );

		//Get the items
		this.refresh();

		//Let's determine the parent's offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

		this._setHandleClassName();

		//We're ready to go
		this.ready = true;

	},

	_setOption: function( key, value ) {
		this._super( key, value );

		if ( key === "handle" ) {
			this._setHandleClassName();
		}
	},

	_setHandleClassName: function() {
		var that = this;
		this._removeClass( this.element.find( ".ui-sortable-handle" ), "ui-sortable-handle" );
		$.each( this.items, function() {
			that._addClass(
				this.instance.options.handle ?
					this.item.find( this.instance.options.handle ) :
					this.item,
				"ui-sortable-handle"
			);
		} );
	},

	_destroy: function() {
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- ) {
			this.items[ i ].item.removeData( this.widgetName + "-item" );
		}

		return this;
	},

	_mouseCapture: function( event, overrideHandle ) {
		var currentItem = null,
			validHandle = false,
			that = this;

		if ( this.reverting ) {
			return false;
		}

		if ( this.options.disabled || this.options.type === "static" ) {
			return false;
		}

		//We have to refresh the items data once first
		this._refreshItems( event );

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		$( event.target ).parents().each( function() {
			if ( $.data( this, that.widgetName + "-item" ) === that ) {
				currentItem = $( this );
				return false;
			}
		} );
		if ( $.data( event.target, that.widgetName + "-item" ) === that ) {
			currentItem = $( event.target );
		}

		if ( !currentItem ) {
			return false;
		}
		if ( this.options.handle && !overrideHandle ) {
			$( this.options.handle, currentItem ).find( "*" ).addBack().each( function() {
				if ( this === event.target ) {
					validHandle = true;
				}
			} );
			if ( !validHandle ) {
				return false;
			}
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function( event, overrideHandle, noActivation ) {

		var i, body,
			o = this.options;

		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to
		// mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper( event );

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend( this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),

			// This is a relative to absolute position minus the actual position calculation -
			// only used for relative positioned helper
			relative: this._getRelativeOffset()
		} );

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css( "position", "absolute" );
		this.cssPosition = this.helper.css( "position" );

		//Generate the original position
		this.originalPosition = this._generatePosition( event );
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		( o.cursorAt && this._adjustOffsetFromHelper( o.cursorAt ) );

		//Cache the former DOM position
		this.domPosition = {
			prev: this.currentItem.prev()[ 0 ],
			parent: this.currentItem.parent()[ 0 ]
		};

		// If the helper is not the original, hide the original so it's not playing any role during
		// the drag, won't cause anything bad this way
		if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if ( o.containment ) {
			this._setContainment();
		}

		if ( o.cursor && o.cursor !== "auto" ) { // cursor option
			body = this.document.find( "body" );

			// Support: IE
			this.storedCursor = body.css( "cursor" );
			body.css( "cursor", o.cursor );

			this.storedStylesheet =
				$( "<style>*{ cursor: " + o.cursor + " !important; }</style>" ).appendTo( body );
		}

		if ( o.opacity ) { // opacity option
			if ( this.helper.css( "opacity" ) ) {
				this._storedOpacity = this.helper.css( "opacity" );
			}
			this.helper.css( "opacity", o.opacity );
		}

		if ( o.zIndex ) { // zIndex option
			if ( this.helper.css( "zIndex" ) ) {
				this._storedZIndex = this.helper.css( "zIndex" );
			}
			this.helper.css( "zIndex", o.zIndex );
		}

		//Prepare scrolling
		if ( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
				this.scrollParent[ 0 ].tagName !== "HTML" ) {
			this.overflowOffset = this.scrollParent.offset();
		}

		//Call callbacks
		this._trigger( "start", event, this._uiHash() );

		//Recache the helper size
		if ( !this._preserveHelperProportions ) {
			this._cacheHelperProportions();
		}

		//Post "activate" events to possible containers
		if ( !noActivation ) {
			for ( i = this.containers.length - 1; i >= 0; i-- ) {
				this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
			}
		}

		//Prepare possible droppables
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.current = this;
		}

		if ( $.ui.ddmanager && !o.dropBehaviour ) {
			$.ui.ddmanager.prepareOffsets( this, event );
		}

		this.dragging = true;

		this._addClass( this.helper, "ui-sortable-helper" );

		// Execute the drag once - this causes the helper not to be visiblebefore getting its
		// correct position
		this._mouseDrag( event );
		return true;

	},

	_mouseDrag: function( event ) {
		var i, item, itemElement, intersection,
			o = this.options,
			scrolled = false;

		//Compute the helpers position
		this.position = this._generatePosition( event );
		this.positionAbs = this._convertPositionTo( "absolute" );

		if ( !this.lastPositionAbs ) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if ( this.options.scroll ) {
			if ( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
					this.scrollParent[ 0 ].tagName !== "HTML" ) {

				if ( ( this.overflowOffset.top + this.scrollParent[ 0 ].offsetHeight ) -
						event.pageY < o.scrollSensitivity ) {
					this.scrollParent[ 0 ].scrollTop =
						scrolled = this.scrollParent[ 0 ].scrollTop + o.scrollSpeed;
				} else if ( event.pageY - this.overflowOffset.top < o.scrollSensitivity ) {
					this.scrollParent[ 0 ].scrollTop =
						scrolled = this.scrollParent[ 0 ].scrollTop - o.scrollSpeed;
				}

				if ( ( this.overflowOffset.left + this.scrollParent[ 0 ].offsetWidth ) -
						event.pageX < o.scrollSensitivity ) {
					this.scrollParent[ 0 ].scrollLeft = scrolled =
						this.scrollParent[ 0 ].scrollLeft + o.scrollSpeed;
				} else if ( event.pageX - this.overflowOffset.left < o.scrollSensitivity ) {
					this.scrollParent[ 0 ].scrollLeft = scrolled =
						this.scrollParent[ 0 ].scrollLeft - o.scrollSpeed;
				}

			} else {

				if ( event.pageY - this.document.scrollTop() < o.scrollSensitivity ) {
					scrolled = this.document.scrollTop( this.document.scrollTop() - o.scrollSpeed );
				} else if ( this.window.height() - ( event.pageY - this.document.scrollTop() ) <
						o.scrollSensitivity ) {
					scrolled = this.document.scrollTop( this.document.scrollTop() + o.scrollSpeed );
				}

				if ( event.pageX - this.document.scrollLeft() < o.scrollSensitivity ) {
					scrolled = this.document.scrollLeft(
						this.document.scrollLeft() - o.scrollSpeed
					);
				} else if ( this.window.width() - ( event.pageX - this.document.scrollLeft() ) <
						o.scrollSensitivity ) {
					scrolled = this.document.scrollLeft(
						this.document.scrollLeft() + o.scrollSpeed
					);
				}

			}

			if ( scrolled !== false && $.ui.ddmanager && !o.dropBehaviour ) {
				$.ui.ddmanager.prepareOffsets( this, event );
			}
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo( "absolute" );

		//Set the helper position
		if ( !this.options.axis || this.options.axis !== "y" ) {
			this.helper[ 0 ].style.left = this.position.left + "px";
		}
		if ( !this.options.axis || this.options.axis !== "x" ) {
			this.helper[ 0 ].style.top = this.position.top + "px";
		}

		//Rearrange
		for ( i = this.items.length - 1; i >= 0; i-- ) {

			//Cache variables and intersection, continue if no intersection
			item = this.items[ i ];
			itemElement = item.item[ 0 ];
			intersection = this._intersectsWithPointer( item );
			if ( !intersection ) {
				continue;
			}

			// Only put the placeholder inside the current Container, skip all
			// items from other containers. This works because when moving
			// an item from one container to another the
			// currentContainer is switched before the placeholder is moved.
			//
			// Without this, moving items in "sub-sortables" can cause
			// the placeholder to jitter between the outer and inner container.
			if ( item.instance !== this.currentContainer ) {
				continue;
			}

			// Cannot intersect with itself
			// no useless actions that have been done before
			// no action if the item moved is the parent of the item checked
			if ( itemElement !== this.currentItem[ 0 ] &&
				this.placeholder[ intersection === 1 ? "next" : "prev" ]()[ 0 ] !== itemElement &&
				!$.contains( this.placeholder[ 0 ], itemElement ) &&
				( this.options.type === "semi-dynamic" ?
					!$.contains( this.element[ 0 ], itemElement ) :
					true
				)
			) {

				this.direction = intersection === 1 ? "down" : "up";

				if ( this.options.tolerance === "pointer" || this._intersectsWithSides( item ) ) {
					this._rearrange( event, item );
				} else {
					break;
				}

				this._trigger( "change", event, this._uiHash() );
				break;
			}
		}

		//Post events to containers
		this._contactContainers( event );

		//Interconnect with droppables
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.drag( this, event );
		}

		//Call callbacks
		this._trigger( "sort", event, this._uiHash() );

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function( event, noPropagation ) {

		if ( !event ) {
			return;
		}

		//If we are using droppables, inform the manager about the drop
		if ( $.ui.ddmanager && !this.options.dropBehaviour ) {
			$.ui.ddmanager.drop( this, event );
		}

		if ( this.options.revert ) {
			var that = this,
				cur = this.placeholder.offset(),
				axis = this.options.axis,
				animation = {};

			if ( !axis || axis === "x" ) {
				animation.left = cur.left - this.offset.parent.left - this.margins.left +
					( this.offsetParent[ 0 ] === this.document[ 0 ].body ?
						0 :
						this.offsetParent[ 0 ].scrollLeft
					);
			}
			if ( !axis || axis === "y" ) {
				animation.top = cur.top - this.offset.parent.top - this.margins.top +
					( this.offsetParent[ 0 ] === this.document[ 0 ].body ?
						0 :
						this.offsetParent[ 0 ].scrollTop
					);
			}
			this.reverting = true;
			$( this.helper ).animate(
				animation,
				parseInt( this.options.revert, 10 ) || 500,
				function() {
					that._clear( event );
				}
			);
		} else {
			this._clear( event, noPropagation );
		}

		return false;

	},

	cancel: function() {

		if ( this.dragging ) {

			this._mouseUp( new $.Event( "mouseup", { target: null } ) );

			if ( this.options.helper === "original" ) {
				this.currentItem.css( this._storedCSS );
				this._removeClass( this.currentItem, "ui-sortable-helper" );
			} else {
				this.currentItem.show();
			}

			//Post deactivating events to containers
			for ( var i = this.containers.length - 1; i >= 0; i-- ) {
				this.containers[ i ]._trigger( "deactivate", null, this._uiHash( this ) );
				if ( this.containers[ i ].containerCache.over ) {
					this.containers[ i ]._trigger( "out", null, this._uiHash( this ) );
					this.containers[ i ].containerCache.over = 0;
				}
			}

		}

		if ( this.placeholder ) {

			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
			// it unbinds ALL events from the original node!
			if ( this.placeholder[ 0 ].parentNode ) {
				this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] );
			}
			if ( this.options.helper !== "original" && this.helper &&
					this.helper[ 0 ].parentNode ) {
				this.helper.remove();
			}

			$.extend( this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			} );

			if ( this.domPosition.prev ) {
				$( this.domPosition.prev ).after( this.currentItem );
			} else {
				$( this.domPosition.parent ).prepend( this.currentItem );
			}
		}

		return this;

	},

	serialize: function( o ) {

		var items = this._getItemsAsjQuery( o && o.connected ),
			str = [];
		o = o || {};

		$( items ).each( function() {
			var res = ( $( o.item || this ).attr( o.attribute || "id" ) || "" )
				.match( o.expression || ( /(.+)[\-=_](.+)/ ) );
			if ( res ) {
				str.push(
					( o.key || res[ 1 ] + "[]" ) +
					"=" + ( o.key && o.expression ? res[ 1 ] : res[ 2 ] ) );
			}
		} );

		if ( !str.length && o.key ) {
			str.push( o.key + "=" );
		}

		return str.join( "&" );

	},

	toArray: function( o ) {

		var items = this._getItemsAsjQuery( o && o.connected ),
			ret = [];

		o = o || {};

		items.each( function() {
			ret.push( $( o.item || this ).attr( o.attribute || "id" ) || "" );
		} );
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function( item ) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height,
			l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height,
			dyClick = this.offset.click.top,
			dxClick = this.offset.click.left,
			isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t &&
				( y1 + dyClick ) < b ),
			isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l &&
				( x1 + dxClick ) < r ),
			isOverElement = isOverElementHeight && isOverElementWidth;

		if ( this.options.tolerance === "pointer" ||
			this.options.forcePointerForContainers ||
			( this.options.tolerance !== "pointer" &&
				this.helperProportions[ this.floating ? "width" : "height" ] >
				item[ this.floating ? "width" : "height" ] )
		) {
			return isOverElement;
		} else {

			return ( l < x1 + ( this.helperProportions.width / 2 ) && // Right Half
				x2 - ( this.helperProportions.width / 2 ) < r && // Left Half
				t < y1 + ( this.helperProportions.height / 2 ) && // Bottom Half
				y2 - ( this.helperProportions.height / 2 ) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function( item ) {
		var verticalDirection, horizontalDirection,
			isOverElementHeight = ( this.options.axis === "x" ) ||
				this._isOverAxis(
					this.positionAbs.top + this.offset.click.top, item.top, item.height ),
			isOverElementWidth = ( this.options.axis === "y" ) ||
				this._isOverAxis(
					this.positionAbs.left + this.offset.click.left, item.left, item.width ),
			isOverElement = isOverElementHeight && isOverElementWidth;

		if ( !isOverElement ) {
			return false;
		}

		verticalDirection = this._getDragVerticalDirection();
		horizontalDirection = this._getDragHorizontalDirection();

		return this.floating ?
			( ( horizontalDirection === "right" || verticalDirection === "down" ) ? 2 : 1 )
			: ( verticalDirection && ( verticalDirection === "down" ? 2 : 1 ) );

	},

	_intersectsWithSides: function( item ) {

		var isOverBottomHalf = this._isOverAxis( this.positionAbs.top +
				this.offset.click.top, item.top + ( item.height / 2 ), item.height ),
			isOverRightHalf = this._isOverAxis( this.positionAbs.left +
				this.offset.click.left, item.left + ( item.width / 2 ), item.width ),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if ( this.floating && horizontalDirection ) {
			return ( ( horizontalDirection === "right" && isOverRightHalf ) ||
				( horizontalDirection === "left" && !isOverRightHalf ) );
		} else {
			return verticalDirection && ( ( verticalDirection === "down" && isOverBottomHalf ) ||
				( verticalDirection === "up" && !isOverBottomHalf ) );
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta !== 0 && ( delta > 0 ? "down" : "up" );
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta !== 0 && ( delta > 0 ? "right" : "left" );
	},

	refresh: function( event ) {
		this._refreshItems( event );
		this._setHandleClassName();
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor === String ?
			[ options.connectWith ] :
			options.connectWith;
	},

	_getItemsAsjQuery: function( connected ) {

		var i, j, cur, inst,
			items = [],
			queries = [],
			connectWith = this._connectWith();

		if ( connectWith && connected ) {
			for ( i = connectWith.length - 1; i >= 0; i-- ) {
				cur = $( connectWith[ i ], this.document[ 0 ] );
				for ( j = cur.length - 1; j >= 0; j-- ) {
					inst = $.data( cur[ j ], this.widgetFullName );
					if ( inst && inst !== this && !inst.options.disabled ) {
						queries.push( [ $.isFunction( inst.options.items ) ?
							inst.options.items.call( inst.element ) :
							$( inst.options.items, inst.element )
								.not( ".ui-sortable-helper" )
								.not( ".ui-sortable-placeholder" ), inst ] );
					}
				}
			}
		}

		queries.push( [ $.isFunction( this.options.items ) ?
			this.options.items
				.call( this.element, null, { options: this.options, item: this.currentItem } ) :
			$( this.options.items, this.element )
				.not( ".ui-sortable-helper" )
				.not( ".ui-sortable-placeholder" ), this ] );

		function addItems() {
			items.push( this );
		}
		for ( i = queries.length - 1; i >= 0; i-- ) {
			queries[ i ][ 0 ].each( addItems );
		}

		return $( items );

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find( ":data(" + this.widgetName + "-item)" );

		this.items = $.grep( this.items, function( item ) {
			for ( var j = 0; j < list.length; j++ ) {
				if ( list[ j ] === item.item[ 0 ] ) {
					return false;
				}
			}
			return true;
		} );

	},

	_refreshItems: function( event ) {

		this.items = [];
		this.containers = [ this ];

		var i, j, cur, inst, targetData, _queries, item, queriesLength,
			items = this.items,
			queries = [ [ $.isFunction( this.options.items ) ?
				this.options.items.call( this.element[ 0 ], event, { item: this.currentItem } ) :
				$( this.options.items, this.element ), this ] ],
			connectWith = this._connectWith();

		//Shouldn't be run the first time through due to massive slow-down
		if ( connectWith && this.ready ) {
			for ( i = connectWith.length - 1; i >= 0; i-- ) {
				cur = $( connectWith[ i ], this.document[ 0 ] );
				for ( j = cur.length - 1; j >= 0; j-- ) {
					inst = $.data( cur[ j ], this.widgetFullName );
					if ( inst && inst !== this && !inst.options.disabled ) {
						queries.push( [ $.isFunction( inst.options.items ) ?
							inst.options.items
								.call( inst.element[ 0 ], event, { item: this.currentItem } ) :
							$( inst.options.items, inst.element ), inst ] );
						this.containers.push( inst );
					}
				}
			}
		}

		for ( i = queries.length - 1; i >= 0; i-- ) {
			targetData = queries[ i ][ 1 ];
			_queries = queries[ i ][ 0 ];

			for ( j = 0, queriesLength = _queries.length; j < queriesLength; j++ ) {
				item = $( _queries[ j ] );

				// Data for target checking (mouse manager)
				item.data( this.widgetName + "-item", targetData );

				items.push( {
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				} );
			}
		}

	},

	refreshPositions: function( fast ) {

		// Determine whether items are being displayed horizontally
		this.floating = this.items.length ?
			this.options.axis === "x" || this._isFloating( this.items[ 0 ].item ) :
			false;

		//This has to be redone because due to the item being moved out/into the offsetParent,
		// the offsetParent's position will change
		if ( this.offsetParent && this.helper ) {
			this.offset.parent = this._getParentOffset();
		}

		var i, item, t, p;

		for ( i = this.items.length - 1; i >= 0; i-- ) {
			item = this.items[ i ];

			//We ignore calculating positions of all connected containers when we're not over them
			if ( item.instance !== this.currentContainer && this.currentContainer &&
					item.item[ 0 ] !== this.currentItem[ 0 ] ) {
				continue;
			}

			t = this.options.toleranceElement ?
				$( this.options.toleranceElement, item.item ) :
				item.item;

			if ( !fast ) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			p = t.offset();
			item.left = p.left;
			item.top = p.top;
		}

		if ( this.options.custom && this.options.custom.refreshContainers ) {
			this.options.custom.refreshContainers.call( this );
		} else {
			for ( i = this.containers.length - 1; i >= 0; i-- ) {
				p = this.containers[ i ].element.offset();
				this.containers[ i ].containerCache.left = p.left;
				this.containers[ i ].containerCache.top = p.top;
				this.containers[ i ].containerCache.width =
					this.containers[ i ].element.outerWidth();
				this.containers[ i ].containerCache.height =
					this.containers[ i ].element.outerHeight();
			}
		}

		return this;
	},

	_createPlaceholder: function( that ) {
		that = that || this;
		var className,
			o = that.options;

		if ( !o.placeholder || o.placeholder.constructor === String ) {
			className = o.placeholder;
			o.placeholder = {
				element: function() {

					var nodeName = that.currentItem[ 0 ].nodeName.toLowerCase(),
						element = $( "<" + nodeName + ">", that.document[ 0 ] );

						that._addClass( element, "ui-sortable-placeholder",
								className || that.currentItem[ 0 ].className )
							._removeClass( element, "ui-sortable-helper" );

					if ( nodeName === "tbody" ) {
						that._createTrPlaceholder(
							that.currentItem.find( "tr" ).eq( 0 ),
							$( "<tr>", that.document[ 0 ] ).appendTo( element )
						);
					} else if ( nodeName === "tr" ) {
						that._createTrPlaceholder( that.currentItem, element );
					} else if ( nodeName === "img" ) {
						element.attr( "src", that.currentItem.attr( "src" ) );
					}

					if ( !className ) {
						element.css( "visibility", "hidden" );
					}

					return element;
				},
				update: function( container, p ) {

					// 1. If a className is set as 'placeholder option, we don't force sizes -
					// the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a
					// class name is specified
					if ( className && !o.forcePlaceholderSize ) {
						return;
					}

					//If the element doesn't have a actual height by itself (without styles coming
					// from a stylesheet), it receives the inline height from the dragged item
					if ( !p.height() ) {
						p.height(
							that.currentItem.innerHeight() -
							parseInt( that.currentItem.css( "paddingTop" ) || 0, 10 ) -
							parseInt( that.currentItem.css( "paddingBottom" ) || 0, 10 ) );
					}
					if ( !p.width() ) {
						p.width(
							that.currentItem.innerWidth() -
							parseInt( that.currentItem.css( "paddingLeft" ) || 0, 10 ) -
							parseInt( that.currentItem.css( "paddingRight" ) || 0, 10 ) );
					}
				}
			};
		}

		//Create the placeholder
		that.placeholder = $( o.placeholder.element.call( that.element, that.currentItem ) );

		//Append it after the actual current item
		that.currentItem.after( that.placeholder );

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update( that, that.placeholder );

	},

	_createTrPlaceholder: function( sourceTr, targetTr ) {
		var that = this;

		sourceTr.children().each( function() {
			$( "<td>&#160;</td>", that.document[ 0 ] )
				.attr( "colspan", $( this ).attr( "colspan" ) || 1 )
				.appendTo( targetTr );
		} );
	},

	_contactContainers: function( event ) {
		var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom,
			floating, axis,
			innermostContainer = null,
			innermostIndex = null;

		// Get innermost container that intersects with item
		for ( i = this.containers.length - 1; i >= 0; i-- ) {

			// Never consider a container that's located within the item itself
			if ( $.contains( this.currentItem[ 0 ], this.containers[ i ].element[ 0 ] ) ) {
				continue;
			}

			if ( this._intersectsWith( this.containers[ i ].containerCache ) ) {

				// If we've already found a container and it's more "inner" than this, then continue
				if ( innermostContainer &&
						$.contains(
							this.containers[ i ].element[ 0 ],
							innermostContainer.element[ 0 ] ) ) {
					continue;
				}

				innermostContainer = this.containers[ i ];
				innermostIndex = i;

			} else {

				// container doesn't intersect. trigger "out" event if necessary
				if ( this.containers[ i ].containerCache.over ) {
					this.containers[ i ]._trigger( "out", event, this._uiHash( this ) );
					this.containers[ i ].containerCache.over = 0;
				}
			}

		}

		// If no intersecting containers found, return
		if ( !innermostContainer ) {
			return;
		}

		// Move the item into the container if it's not there already
		if ( this.containers.length === 1 ) {
			if ( !this.containers[ innermostIndex ].containerCache.over ) {
				this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash( this ) );
				this.containers[ innermostIndex ].containerCache.over = 1;
			}
		} else {

			// When entering a new container, we will find the item with the least distance and
			// append our item near it
			dist = 10000;
			itemWithLeastDistance = null;
			floating = innermostContainer.floating || this._isFloating( this.currentItem );
			posProperty = floating ? "left" : "top";
			sizeProperty = floating ? "width" : "height";
			axis = floating ? "pageX" : "pageY";

			for ( j = this.items.length - 1; j >= 0; j-- ) {
				if ( !$.contains(
						this.containers[ innermostIndex ].element[ 0 ], this.items[ j ].item[ 0 ] )
				) {
					continue;
				}
				if ( this.items[ j ].item[ 0 ] === this.currentItem[ 0 ] ) {
					continue;
				}

				cur = this.items[ j ].item.offset()[ posProperty ];
				nearBottom = false;
				if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {
					nearBottom = true;
				}

				if ( Math.abs( event[ axis ] - cur ) < dist ) {
					dist = Math.abs( event[ axis ] - cur );
					itemWithLeastDistance = this.items[ j ];
					this.direction = nearBottom ? "up" : "down";
				}
			}

			//Check if dropOnEmpty is enabled
			if ( !itemWithLeastDistance && !this.options.dropOnEmpty ) {
				return;
			}

			if ( this.currentContainer === this.containers[ innermostIndex ] ) {
				if ( !this.currentContainer.containerCache.over ) {
					this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash() );
					this.currentContainer.containerCache.over = 1;
				}
				return;
			}

			itemWithLeastDistance ?
				this._rearrange( event, itemWithLeastDistance, null, true ) :
				this._rearrange( event, null, this.containers[ innermostIndex ].element, true );
			this._trigger( "change", event, this._uiHash() );
			this.containers[ innermostIndex ]._trigger( "change", event, this._uiHash( this ) );
			this.currentContainer = this.containers[ innermostIndex ];

			//Update the placeholder
			this.options.placeholder.update( this.currentContainer, this.placeholder );

			this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash( this ) );
			this.containers[ innermostIndex ].containerCache.over = 1;
		}

	},

	_createHelper: function( event ) {

		var o = this.options,
			helper = $.isFunction( o.helper ) ?
				$( o.helper.apply( this.element[ 0 ], [ event, this.currentItem ] ) ) :
				( o.helper === "clone" ? this.currentItem.clone() : this.currentItem );

		//Add the helper to the DOM if that didn't happen already
		if ( !helper.parents( "body" ).length ) {
			$( o.appendTo !== "parent" ?
				o.appendTo :
				this.currentItem[ 0 ].parentNode )[ 0 ].appendChild( helper[ 0 ] );
		}

		if ( helper[ 0 ] === this.currentItem[ 0 ] ) {
			this._storedCSS = {
				width: this.currentItem[ 0 ].style.width,
				height: this.currentItem[ 0 ].style.height,
				position: this.currentItem.css( "position" ),
				top: this.currentItem.css( "top" ),
				left: this.currentItem.css( "left" )
			};
		}

		if ( !helper[ 0 ].style.width || o.forceHelperSize ) {
			helper.width( this.currentItem.width() );
		}
		if ( !helper[ 0 ].style.height || o.forceHelperSize ) {
			helper.height( this.currentItem.height() );
		}

		return helper;

	},

	_adjustOffsetFromHelper: function( obj ) {
		if ( typeof obj === "string" ) {
			obj = obj.split( " " );
		}
		if ( $.isArray( obj ) ) {
			obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 };
		}
		if ( "left" in obj ) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ( "right" in obj ) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ( "top" in obj ) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ( "bottom" in obj ) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the
		// following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the
		// next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
		// the document, which means that the scroll is included in the initial calculation of the
		// offset of the parent, and never recalculated upon drag
		if ( this.cssPosition === "absolute" && this.scrollParent[ 0 ] !== this.document[ 0 ] &&
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		// This needs to be actually done for all browsers, since pageX/pageY includes this
		// information with an ugly IE fix
		if ( this.offsetParent[ 0 ] === this.document[ 0 ].body ||
				( this.offsetParent[ 0 ].tagName &&
				this.offsetParent[ 0 ].tagName.toLowerCase() === "html" && $.ui.ie ) ) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + ( parseInt( this.offsetParent.css( "borderTopWidth" ), 10 ) || 0 ),
			left: po.left + ( parseInt( this.offsetParent.css( "borderLeftWidth" ), 10 ) || 0 )
		};

	},

	_getRelativeOffset: function() {

		if ( this.cssPosition === "relative" ) {
			var p = this.currentItem.position();
			return {
				top: p.top - ( parseInt( this.helper.css( "top" ), 10 ) || 0 ) +
					this.scrollParent.scrollTop(),
				left: p.left - ( parseInt( this.helper.css( "left" ), 10 ) || 0 ) +
					this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: ( parseInt( this.currentItem.css( "marginLeft" ), 10 ) || 0 ),
			top: ( parseInt( this.currentItem.css( "marginTop" ), 10 ) || 0 )
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var ce, co, over,
			o = this.options;
		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}
		if ( o.containment === "document" || o.containment === "window" ) {
			this.containment = [
				0 - this.offset.relative.left - this.offset.parent.left,
				0 - this.offset.relative.top - this.offset.parent.top,
				o.containment === "document" ?
					this.document.width() :
					this.window.width() - this.helperProportions.width - this.margins.left,
				( o.containment === "document" ?
					( this.document.height() || document.body.parentNode.scrollHeight ) :
					this.window.height() || this.document[ 0 ].body.parentNode.scrollHeight
				) - this.helperProportions.height - this.margins.top
			];
		}

		if ( !( /^(document|window|parent)$/ ).test( o.containment ) ) {
			ce = $( o.containment )[ 0 ];
			co = $( o.containment ).offset();
			over = ( $( ce ).css( "overflow" ) !== "hidden" );

			this.containment = [
				co.left + ( parseInt( $( ce ).css( "borderLeftWidth" ), 10 ) || 0 ) +
					( parseInt( $( ce ).css( "paddingLeft" ), 10 ) || 0 ) - this.margins.left,
				co.top + ( parseInt( $( ce ).css( "borderTopWidth" ), 10 ) || 0 ) +
					( parseInt( $( ce ).css( "paddingTop" ), 10 ) || 0 ) - this.margins.top,
				co.left + ( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
					( parseInt( $( ce ).css( "borderLeftWidth" ), 10 ) || 0 ) -
					( parseInt( $( ce ).css( "paddingRight" ), 10 ) || 0 ) -
					this.helperProportions.width - this.margins.left,
				co.top + ( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
					( parseInt( $( ce ).css( "borderTopWidth" ), 10 ) || 0 ) -
					( parseInt( $( ce ).css( "paddingBottom" ), 10 ) || 0 ) -
					this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function( d, pos ) {

		if ( !pos ) {
			pos = this.position;
		}
		var mod = d === "absolute" ? 1 : -1,
			scroll = this.cssPosition === "absolute" &&
				!( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ?
					this.offsetParent :
					this.scrollParent,
			scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName );

		return {
			top: (

				// The absolute mouse position
				pos.top	+

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top * mod -
				( ( this.cssPosition === "fixed" ?
					-this.scrollParent.scrollTop() :
					( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod )
			),
			left: (

				// The absolute mouse position
				pos.left +

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left * mod	-
				( ( this.cssPosition === "fixed" ?
					-this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 :
					scroll.scrollLeft() ) * mod )
			)
		};

	},

	_generatePosition: function( event ) {

		var top, left,
			o = this.options,
			pageX = event.pageX,
			pageY = event.pageY,
			scroll = this.cssPosition === "absolute" &&
				!( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ?
					this.offsetParent :
					this.scrollParent,
				scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName );

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if ( this.cssPosition === "relative" && !( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
				this.scrollParent[ 0 ] !== this.offsetParent[ 0 ] ) ) {
			this.offset.relative = this._getRelativeOffset();
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if ( this.originalPosition ) { //If we are not dragging yet, we won't check for options

			if ( this.containment ) {
				if ( event.pageX - this.offset.click.left < this.containment[ 0 ] ) {
					pageX = this.containment[ 0 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top < this.containment[ 1 ] ) {
					pageY = this.containment[ 1 ] + this.offset.click.top;
				}
				if ( event.pageX - this.offset.click.left > this.containment[ 2 ] ) {
					pageX = this.containment[ 2 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top > this.containment[ 3 ] ) {
					pageY = this.containment[ 3 ] + this.offset.click.top;
				}
			}

			if ( o.grid ) {
				top = this.originalPageY + Math.round( ( pageY - this.originalPageY ) /
					o.grid[ 1 ] ) * o.grid[ 1 ];
				pageY = this.containment ?
					( ( top - this.offset.click.top >= this.containment[ 1 ] &&
						top - this.offset.click.top <= this.containment[ 3 ] ) ?
							top :
							( ( top - this.offset.click.top >= this.containment[ 1 ] ) ?
								top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) :
								top;

				left = this.originalPageX + Math.round( ( pageX - this.originalPageX ) /
					o.grid[ 0 ] ) * o.grid[ 0 ];
				pageX = this.containment ?
					( ( left - this.offset.click.left >= this.containment[ 0 ] &&
						left - this.offset.click.left <= this.containment[ 2 ] ) ?
							left :
							( ( left - this.offset.click.left >= this.containment[ 0 ] ) ?
								left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) :
								left;
			}

		}

		return {
			top: (

				// The absolute mouse position
				pageY -

				// Click offset (relative to the element)
				this.offset.click.top -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top +
				( ( this.cssPosition === "fixed" ?
					-this.scrollParent.scrollTop() :
					( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) )
			),
			left: (

				// The absolute mouse position
				pageX -

				// Click offset (relative to the element)
				this.offset.click.left -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left +
				( ( this.cssPosition === "fixed" ?
					-this.scrollParent.scrollLeft() :
					scrollIsRootNode ? 0 : scroll.scrollLeft() ) )
			)
		};

	},

	_rearrange: function( event, i, a, hardRefresh ) {

		a ? a[ 0 ].appendChild( this.placeholder[ 0 ] ) :
			i.item[ 0 ].parentNode.insertBefore( this.placeholder[ 0 ],
				( this.direction === "down" ? i.item[ 0 ] : i.item[ 0 ].nextSibling ) );

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout,
		// if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var counter = this.counter;

		this._delay( function() {
			if ( counter === this.counter ) {

				//Precompute after each DOM insertion, NOT on mousemove
				this.refreshPositions( !hardRefresh );
			}
		} );

	},

	_clear: function( event, noPropagation ) {

		this.reverting = false;

		// We delay all events that have to be triggered to after the point where the placeholder
		// has been removed and everything else normalized again
		var i,
			delayedTriggers = [];

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets
		// reappended (see #4088)
		if ( !this._noFinalSort && this.currentItem.parent().length ) {
			this.placeholder.before( this.currentItem );
		}
		this._noFinalSort = null;

		if ( this.helper[ 0 ] === this.currentItem[ 0 ] ) {
			for ( i in this._storedCSS ) {
				if ( this._storedCSS[ i ] === "auto" || this._storedCSS[ i ] === "static" ) {
					this._storedCSS[ i ] = "";
				}
			}
			this.currentItem.css( this._storedCSS );
			this._removeClass( this.currentItem, "ui-sortable-helper" );
		} else {
			this.currentItem.show();
		}

		if ( this.fromOutside && !noPropagation ) {
			delayedTriggers.push( function( event ) {
				this._trigger( "receive", event, this._uiHash( this.fromOutside ) );
			} );
		}
		if ( ( this.fromOutside ||
				this.domPosition.prev !==
				this.currentItem.prev().not( ".ui-sortable-helper" )[ 0 ] ||
				this.domPosition.parent !== this.currentItem.parent()[ 0 ] ) && !noPropagation ) {

			// Trigger update callback if the DOM position has changed
			delayedTriggers.push( function( event ) {
				this._trigger( "update", event, this._uiHash() );
			} );
		}

		// Check if the items Container has Changed and trigger appropriate
		// events.
		if ( this !== this.currentContainer ) {
			if ( !noPropagation ) {
				delayedTriggers.push( function( event ) {
					this._trigger( "remove", event, this._uiHash() );
				} );
				delayedTriggers.push( ( function( c ) {
					return function( event ) {
						c._trigger( "receive", event, this._uiHash( this ) );
					};
				} ).call( this, this.currentContainer ) );
				delayedTriggers.push( ( function( c ) {
					return function( event ) {
						c._trigger( "update", event, this._uiHash( this ) );
					};
				} ).call( this, this.currentContainer ) );
			}
		}

		//Post events to containers
		function delayEvent( type, instance, container ) {
			return function( event ) {
				container._trigger( type, event, instance._uiHash( instance ) );
			};
		}
		for ( i = this.containers.length - 1; i >= 0; i-- ) {
			if ( !noPropagation ) {
				delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
			}
			if ( this.containers[ i ].containerCache.over ) {
				delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
				this.containers[ i ].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if ( this.storedCursor ) {
			this.document.find( "body" ).css( "cursor", this.storedCursor );
			this.storedStylesheet.remove();
		}
		if ( this._storedOpacity ) {
			this.helper.css( "opacity", this._storedOpacity );
		}
		if ( this._storedZIndex ) {
			this.helper.css( "zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex );
		}

		this.dragging = false;

		if ( !noPropagation ) {
			this._trigger( "beforeStop", event, this._uiHash() );
		}

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
		// it unbinds ALL events from the original node!
		this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] );

		if ( !this.cancelHelperRemoval ) {
			if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
				this.helper.remove();
			}
			this.helper = null;
		}

		if ( !noPropagation ) {
			for ( i = 0; i < delayedTriggers.length; i++ ) {

				// Trigger all delayed events
				delayedTriggers[ i ].call( this, event );
			}
			this._trigger( "stop", event, this._uiHash() );
		}

		this.fromOutside = false;
		return !this.cancelHelperRemoval;

	},

	_trigger: function() {
		if ( $.Widget.prototype._trigger.apply( this, arguments ) === false ) {
			this.cancel();
		}
	},

	_uiHash: function( _inst ) {
		var inst = _inst || this;
		return {
			helper: inst.helper,
			placeholder: inst.placeholder || $( [] ),
			position: inst.position,
			originalPosition: inst.originalPosition,
			offset: inst.positionAbs,
			item: inst.currentItem,
			sender: _inst ? _inst.element : null
		};
	}

} );


/*!
 * jQuery UI Spinner 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Spinner
//>>group: Widgets
//>>description: Displays buttons to easily input numbers via the keyboard or mouse.
//>>docs: http://api.jqueryui.com/spinner/
//>>demos: http://jqueryui.com/spinner/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/spinner.css
//>>css.theme: ../../themes/base/theme.css



function spinnerModifer( fn ) {
	return function() {
		var previous = this.element.val();
		fn.apply( this, arguments );
		this._refresh();
		if ( previous !== this.element.val() ) {
			this._trigger( "change" );
		}
	};
}

$.widget( "ui.spinner", {
	version: "1.12.1",
	defaultElement: "<input>",
	widgetEventPrefix: "spin",
	options: {
		classes: {
			"ui-spinner": "ui-corner-all",
			"ui-spinner-down": "ui-corner-br",
			"ui-spinner-up": "ui-corner-tr"
		},
		culture: null,
		icons: {
			down: "ui-icon-triangle-1-s",
			up: "ui-icon-triangle-1-n"
		},
		incremental: true,
		max: null,
		min: null,
		numberFormat: null,
		page: 10,
		step: 1,

		change: null,
		spin: null,
		start: null,
		stop: null
	},

	_create: function() {

		// handle string values that need to be parsed
		this._setOption( "max", this.options.max );
		this._setOption( "min", this.options.min );
		this._setOption( "step", this.options.step );

		// Only format if there is a value, prevents the field from being marked
		// as invalid in Firefox, see #9573.
		if ( this.value() !== "" ) {

			// Format the value, but don't constrain.
			this._value( this.element.val(), true );
		}

		this._draw();
		this._on( this._events );
		this._refresh();

		// Turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		} );
	},

	_getCreateOptions: function() {
		var options = this._super();
		var element = this.element;

		$.each( [ "min", "max", "step" ], function( i, option ) {
			var value = element.attr( option );
			if ( value != null && value.length ) {
				options[ option ] = value;
			}
		} );

		return options;
	},

	_events: {
		keydown: function( event ) {
			if ( this._start( event ) && this._keydown( event ) ) {
				event.preventDefault();
			}
		},
		keyup: "_stop",
		focus: function() {
			this.previous = this.element.val();
		},
		blur: function( event ) {
			if ( this.cancelBlur ) {
				delete this.cancelBlur;
				return;
			}

			this._stop();
			this._refresh();
			if ( this.previous !== this.element.val() ) {
				this._trigger( "change", event );
			}
		},
		mousewheel: function( event, delta ) {
			if ( !delta ) {
				return;
			}
			if ( !this.spinning && !this._start( event ) ) {
				return false;
			}

			this._spin( ( delta > 0 ? 1 : -1 ) * this.options.step, event );
			clearTimeout( this.mousewheelTimer );
			this.mousewheelTimer = this._delay( function() {
				if ( this.spinning ) {
					this._stop( event );
				}
			}, 100 );
			event.preventDefault();
		},
		"mousedown .ui-spinner-button": function( event ) {
			var previous;

			// We never want the buttons to have focus; whenever the user is
			// interacting with the spinner, the focus should be on the input.
			// If the input is focused then this.previous is properly set from
			// when the input first received focus. If the input is not focused
			// then we need to set this.previous based on the value before spinning.
			previous = this.element[ 0 ] === $.ui.safeActiveElement( this.document[ 0 ] ) ?
				this.previous : this.element.val();
			function checkFocus() {
				var isActive = this.element[ 0 ] === $.ui.safeActiveElement( this.document[ 0 ] );
				if ( !isActive ) {
					this.element.trigger( "focus" );
					this.previous = previous;

					// support: IE
					// IE sets focus asynchronously, so we need to check if focus
					// moved off of the input because the user clicked on the button.
					this._delay( function() {
						this.previous = previous;
					} );
				}
			}

			// Ensure focus is on (or stays on) the text field
			event.preventDefault();
			checkFocus.call( this );

			// Support: IE
			// IE doesn't prevent moving focus even with event.preventDefault()
			// so we set a flag to know when we should ignore the blur event
			// and check (again) if focus moved off of the input.
			this.cancelBlur = true;
			this._delay( function() {
				delete this.cancelBlur;
				checkFocus.call( this );
			} );

			if ( this._start( event ) === false ) {
				return;
			}

			this._repeat( null, $( event.currentTarget )
				.hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		"mouseup .ui-spinner-button": "_stop",
		"mouseenter .ui-spinner-button": function( event ) {

			// button will add ui-state-active if mouse was down while mouseleave and kept down
			if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
				return;
			}

			if ( this._start( event ) === false ) {
				return false;
			}
			this._repeat( null, $( event.currentTarget )
				.hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},

		// TODO: do we really want to consider this a stop?
		// shouldn't we just stop the repeater and wait until mouseup before
		// we trigger the stop event?
		"mouseleave .ui-spinner-button": "_stop"
	},

	// Support mobile enhanced option and make backcompat more sane
	_enhance: function() {
		this.uiSpinner = this.element
			.attr( "autocomplete", "off" )
			.wrap( "<span>" )
			.parent()

				// Add buttons
				.append(
					"<a></a><a></a>"
				);
	},

	_draw: function() {
		this._enhance();

		this._addClass( this.uiSpinner, "ui-spinner", "ui-widget ui-widget-content" );
		this._addClass( "ui-spinner-input" );

		this.element.attr( "role", "spinbutton" );

		// Button bindings
		this.buttons = this.uiSpinner.children( "a" )
			.attr( "tabIndex", -1 )
			.attr( "aria-hidden", true )
			.button( {
				classes: {
					"ui-button": ""
				}
			} );

		// TODO: Right now button does not support classes this is already updated in button PR
		this._removeClass( this.buttons, "ui-corner-all" );

		this._addClass( this.buttons.first(), "ui-spinner-button ui-spinner-up" );
		this._addClass( this.buttons.last(), "ui-spinner-button ui-spinner-down" );
		this.buttons.first().button( {
			"icon": this.options.icons.up,
			"showLabel": false
		} );
		this.buttons.last().button( {
			"icon": this.options.icons.down,
			"showLabel": false
		} );

		// IE 6 doesn't understand height: 50% for the buttons
		// unless the wrapper has an explicit height
		if ( this.buttons.height() > Math.ceil( this.uiSpinner.height() * 0.5 ) &&
				this.uiSpinner.height() > 0 ) {
			this.uiSpinner.height( this.uiSpinner.height() );
		}
	},

	_keydown: function( event ) {
		var options = this.options,
			keyCode = $.ui.keyCode;

		switch ( event.keyCode ) {
		case keyCode.UP:
			this._repeat( null, 1, event );
			return true;
		case keyCode.DOWN:
			this._repeat( null, -1, event );
			return true;
		case keyCode.PAGE_UP:
			this._repeat( null, options.page, event );
			return true;
		case keyCode.PAGE_DOWN:
			this._repeat( null, -options.page, event );
			return true;
		}

		return false;
	},

	_start: function( event ) {
		if ( !this.spinning && this._trigger( "start", event ) === false ) {
			return false;
		}

		if ( !this.counter ) {
			this.counter = 1;
		}
		this.spinning = true;
		return true;
	},

	_repeat: function( i, steps, event ) {
		i = i || 500;

		clearTimeout( this.timer );
		this.timer = this._delay( function() {
			this._repeat( 40, steps, event );
		}, i );

		this._spin( steps * this.options.step, event );
	},

	_spin: function( step, event ) {
		var value = this.value() || 0;

		if ( !this.counter ) {
			this.counter = 1;
		}

		value = this._adjustValue( value + step * this._increment( this.counter ) );

		if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false ) {
			this._value( value );
			this.counter++;
		}
	},

	_increment: function( i ) {
		var incremental = this.options.incremental;

		if ( incremental ) {
			return $.isFunction( incremental ) ?
				incremental( i ) :
				Math.floor( i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1 );
		}

		return 1;
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_adjustValue: function( value ) {
		var base, aboveMin,
			options = this.options;

		// Make sure we're at a valid step
		// - find out where we are relative to the base (min or 0)
		base = options.min !== null ? options.min : 0;
		aboveMin = value - base;

		// - round to the nearest step
		aboveMin = Math.round( aboveMin / options.step ) * options.step;

		// - rounding is based on 0, so adjust back to our base
		value = base + aboveMin;

		// Fix precision from bad JS floating point math
		value = parseFloat( value.toFixed( this._precision() ) );

		// Clamp the value
		if ( options.max !== null && value > options.max ) {
			return options.max;
		}
		if ( options.min !== null && value < options.min ) {
			return options.min;
		}

		return value;
	},

	_stop: function( event ) {
		if ( !this.spinning ) {
			return;
		}

		clearTimeout( this.timer );
		clearTimeout( this.mousewheelTimer );
		this.counter = 0;
		this.spinning = false;
		this._trigger( "stop", event );
	},

	_setOption: function( key, value ) {
		var prevValue, first, last;

		if ( key === "culture" || key === "numberFormat" ) {
			prevValue = this._parse( this.element.val() );
			this.options[ key ] = value;
			this.element.val( this._format( prevValue ) );
			return;
		}

		if ( key === "max" || key === "min" || key === "step" ) {
			if ( typeof value === "string" ) {
				value = this._parse( value );
			}
		}
		if ( key === "icons" ) {
			first = this.buttons.first().find( ".ui-icon" );
			this._removeClass( first, null, this.options.icons.up );
			this._addClass( first, null, value.up );
			last = this.buttons.last().find( ".ui-icon" );
			this._removeClass( last, null, this.options.icons.down );
			this._addClass( last, null, value.down );
		}

		this._super( key, value );
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this._toggleClass( this.uiSpinner, null, "ui-state-disabled", !!value );
		this.element.prop( "disabled", !!value );
		this.buttons.button( value ? "disable" : "enable" );
	},

	_setOptions: spinnerModifer( function( options ) {
		this._super( options );
	} ),

	_parse: function( val ) {
		if ( typeof val === "string" && val !== "" ) {
			val = window.Globalize && this.options.numberFormat ?
				Globalize.parseFloat( val, 10, this.options.culture ) : +val;
		}
		return val === "" || isNaN( val ) ? null : val;
	},

	_format: function( value ) {
		if ( value === "" ) {
			return "";
		}
		return window.Globalize && this.options.numberFormat ?
			Globalize.format( value, this.options.numberFormat, this.options.culture ) :
			value;
	},

	_refresh: function() {
		this.element.attr( {
			"aria-valuemin": this.options.min,
			"aria-valuemax": this.options.max,

			// TODO: what should we do with values that can't be parsed?
			"aria-valuenow": this._parse( this.element.val() )
		} );
	},

	isValid: function() {
		var value = this.value();

		// Null is invalid
		if ( value === null ) {
			return false;
		}

		// If value gets adjusted, it's invalid
		return value === this._adjustValue( value );
	},

	// Update the value without triggering change
	_value: function( value, allowAny ) {
		var parsed;
		if ( value !== "" ) {
			parsed = this._parse( value );
			if ( parsed !== null ) {
				if ( !allowAny ) {
					parsed = this._adjustValue( parsed );
				}
				value = this._format( parsed );
			}
		}
		this.element.val( value );
		this._refresh();
	},

	_destroy: function() {
		this.element
			.prop( "disabled", false )
			.removeAttr( "autocomplete role aria-valuemin aria-valuemax aria-valuenow" );

		this.uiSpinner.replaceWith( this.element );
	},

	stepUp: spinnerModifer( function( steps ) {
		this._stepUp( steps );
	} ),
	_stepUp: function( steps ) {
		if ( this._start() ) {
			this._spin( ( steps || 1 ) * this.options.step );
			this._stop();
		}
	},

	stepDown: spinnerModifer( function( steps ) {
		this._stepDown( steps );
	} ),
	_stepDown: function( steps ) {
		if ( this._start() ) {
			this._spin( ( steps || 1 ) * -this.options.step );
			this._stop();
		}
	},

	pageUp: spinnerModifer( function( pages ) {
		this._stepUp( ( pages || 1 ) * this.options.page );
	} ),

	pageDown: spinnerModifer( function( pages ) {
		this._stepDown( ( pages || 1 ) * this.options.page );
	} ),

	value: function( newVal ) {
		if ( !arguments.length ) {
			return this._parse( this.element.val() );
		}
		spinnerModifer( this._value ).call( this, newVal );
	},

	widget: function() {
		return this.uiSpinner;
	}
} );

// DEPRECATED
// TODO: switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for spinner html extension points
	$.widget( "ui.spinner", $.ui.spinner, {
		_enhance: function() {
			this.uiSpinner = this.element
				.attr( "autocomplete", "off" )
				.wrap( this._uiSpinnerHtml() )
				.parent()

					// Add buttons
					.append( this._buttonHtml() );
		},
		_uiSpinnerHtml: function() {
			return "<span>";
		},

		_buttonHtml: function() {
			return "<a></a><a></a>";
		}
	} );
}

var widgetsSpinner = $.ui.spinner;


/*!
 * jQuery UI Tabs 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Tabs
//>>group: Widgets
//>>description: Transforms a set of container elements into a tab structure.
//>>docs: http://api.jqueryui.com/tabs/
//>>demos: http://jqueryui.com/tabs/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/tabs.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.tabs", {
	version: "1.12.1",
	delay: 300,
	options: {
		active: null,
		classes: {
			"ui-tabs": "ui-corner-all",
			"ui-tabs-nav": "ui-corner-all",
			"ui-tabs-panel": "ui-corner-bottom",
			"ui-tabs-tab": "ui-corner-top"
		},
		collapsible: false,
		event: "click",
		heightStyle: "content",
		hide: null,
		show: null,

		// Callbacks
		activate: null,
		beforeActivate: null,
		beforeLoad: null,
		load: null
	},

	_isLocal: ( function() {
		var rhash = /#.*$/;

		return function( anchor ) {
			var anchorUrl, locationUrl;

			anchorUrl = anchor.href.replace( rhash, "" );
			locationUrl = location.href.replace( rhash, "" );

			// Decoding may throw an error if the URL isn't UTF-8 (#9518)
			try {
				anchorUrl = decodeURIComponent( anchorUrl );
			} catch ( error ) {}
			try {
				locationUrl = decodeURIComponent( locationUrl );
			} catch ( error ) {}

			return anchor.hash.length > 1 && anchorUrl === locationUrl;
		};
	} )(),

	_create: function() {
		var that = this,
			options = this.options;

		this.running = false;

		this._addClass( "ui-tabs", "ui-widget ui-widget-content" );
		this._toggleClass( "ui-tabs-collapsible", null, options.collapsible );

		this._processTabs();
		options.active = this._initialActive();

		// Take disabling tabs via class attribute from HTML
		// into account and update option properly.
		if ( $.isArray( options.disabled ) ) {
			options.disabled = $.unique( options.disabled.concat(
				$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
					return that.tabs.index( li );
				} )
			) ).sort();
		}

		// Check for length avoids error when initializing empty list
		if ( this.options.active !== false && this.anchors.length ) {
			this.active = this._findActive( options.active );
		} else {
			this.active = $();
		}

		this._refresh();

		if ( this.active.length ) {
			this.load( options.active );
		}
	},

	_initialActive: function() {
		var active = this.options.active,
			collapsible = this.options.collapsible,
			locationHash = location.hash.substring( 1 );

		if ( active === null ) {

			// check the fragment identifier in the URL
			if ( locationHash ) {
				this.tabs.each( function( i, tab ) {
					if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
						active = i;
						return false;
					}
				} );
			}

			// Check for a tab marked active via a class
			if ( active === null ) {
				active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
			}

			// No active tab, set to false
			if ( active === null || active === -1 ) {
				active = this.tabs.length ? 0 : false;
			}
		}

		// Handle numbers: negative, out of range
		if ( active !== false ) {
			active = this.tabs.index( this.tabs.eq( active ) );
			if ( active === -1 ) {
				active = collapsible ? false : 0;
			}
		}

		// Don't allow collapsible: false and active: false
		if ( !collapsible && active === false && this.anchors.length ) {
			active = 0;
		}

		return active;
	},

	_getCreateEventData: function() {
		return {
			tab: this.active,
			panel: !this.active.length ? $() : this._getPanelForTab( this.active )
		};
	},

	_tabKeydown: function( event ) {
		var focusedTab = $( $.ui.safeActiveElement( this.document[ 0 ] ) ).closest( "li" ),
			selectedIndex = this.tabs.index( focusedTab ),
			goingForward = true;

		if ( this._handlePageNav( event ) ) {
			return;
		}

		switch ( event.keyCode ) {
		case $.ui.keyCode.RIGHT:
		case $.ui.keyCode.DOWN:
			selectedIndex++;
			break;
		case $.ui.keyCode.UP:
		case $.ui.keyCode.LEFT:
			goingForward = false;
			selectedIndex--;
			break;
		case $.ui.keyCode.END:
			selectedIndex = this.anchors.length - 1;
			break;
		case $.ui.keyCode.HOME:
			selectedIndex = 0;
			break;
		case $.ui.keyCode.SPACE:

			// Activate only, no collapsing
			event.preventDefault();
			clearTimeout( this.activating );
			this._activate( selectedIndex );
			return;
		case $.ui.keyCode.ENTER:

			// Toggle (cancel delayed activation, allow collapsing)
			event.preventDefault();
			clearTimeout( this.activating );

			// Determine if we should collapse or activate
			this._activate( selectedIndex === this.options.active ? false : selectedIndex );
			return;
		default:
			return;
		}

		// Focus the appropriate tab, based on which key was pressed
		event.preventDefault();
		clearTimeout( this.activating );
		selectedIndex = this._focusNextTab( selectedIndex, goingForward );

		// Navigating with control/command key will prevent automatic activation
		if ( !event.ctrlKey && !event.metaKey ) {

			// Update aria-selected immediately so that AT think the tab is already selected.
			// Otherwise AT may confuse the user by stating that they need to activate the tab,
			// but the tab will already be activated by the time the announcement finishes.
			focusedTab.attr( "aria-selected", "false" );
			this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );

			this.activating = this._delay( function() {
				this.option( "active", selectedIndex );
			}, this.delay );
		}
	},

	_panelKeydown: function( event ) {
		if ( this._handlePageNav( event ) ) {
			return;
		}

		// Ctrl+up moves focus to the current tab
		if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
			event.preventDefault();
			this.active.trigger( "focus" );
		}
	},

	// Alt+page up/down moves focus to the previous/next tab (and activates)
	_handlePageNav: function( event ) {
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
			this._activate( this._focusNextTab( this.options.active - 1, false ) );
			return true;
		}
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
			this._activate( this._focusNextTab( this.options.active + 1, true ) );
			return true;
		}
	},

	_findNextTab: function( index, goingForward ) {
		var lastTabIndex = this.tabs.length - 1;

		function constrain() {
			if ( index > lastTabIndex ) {
				index = 0;
			}
			if ( index < 0 ) {
				index = lastTabIndex;
			}
			return index;
		}

		while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
			index = goingForward ? index + 1 : index - 1;
		}

		return index;
	},

	_focusNextTab: function( index, goingForward ) {
		index = this._findNextTab( index, goingForward );
		this.tabs.eq( index ).trigger( "focus" );
		return index;
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {

			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		this._super( key, value );

		if ( key === "collapsible" ) {
			this._toggleClass( "ui-tabs-collapsible", null, value );

			// Setting collapsible: false while collapsed; open first panel
			if ( !value && this.options.active === false ) {
				this._activate( 0 );
			}
		}

		if ( key === "event" ) {
			this._setupEvents( value );
		}

		if ( key === "heightStyle" ) {
			this._setupHeightStyle( value );
		}
	},

	_sanitizeSelector: function( hash ) {
		return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
	},

	refresh: function() {
		var options = this.options,
			lis = this.tablist.children( ":has(a[href])" );

		// Get disabled tabs from class attribute from HTML
		// this will get converted to a boolean if needed in _refresh()
		options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
			return lis.index( tab );
		} );

		this._processTabs();

		// Was collapsed or no tabs
		if ( options.active === false || !this.anchors.length ) {
			options.active = false;
			this.active = $();

		// was active, but active tab is gone
		} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {

			// all remaining tabs are disabled
			if ( this.tabs.length === options.disabled.length ) {
				options.active = false;
				this.active = $();

			// activate previous tab
			} else {
				this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
			}

		// was active, active tab still exists
		} else {

			// make sure active index is correct
			options.active = this.tabs.index( this.active );
		}

		this._refresh();
	},

	_refresh: function() {
		this._setOptionDisabled( this.options.disabled );
		this._setupEvents( this.options.event );
		this._setupHeightStyle( this.options.heightStyle );

		this.tabs.not( this.active ).attr( {
			"aria-selected": "false",
			"aria-expanded": "false",
			tabIndex: -1
		} );
		this.panels.not( this._getPanelForTab( this.active ) )
			.hide()
			.attr( {
				"aria-hidden": "true"
			} );

		// Make sure one tab is in the tab order
		if ( !this.active.length ) {
			this.tabs.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active
				.attr( {
					"aria-selected": "true",
					"aria-expanded": "true",
					tabIndex: 0
				} );
			this._addClass( this.active, "ui-tabs-active", "ui-state-active" );
			this._getPanelForTab( this.active )
				.show()
				.attr( {
					"aria-hidden": "false"
				} );
		}
	},

	_processTabs: function() {
		var that = this,
			prevTabs = this.tabs,
			prevAnchors = this.anchors,
			prevPanels = this.panels;

		this.tablist = this._getList().attr( "role", "tablist" );
		this._addClass( this.tablist, "ui-tabs-nav",
			"ui-helper-reset ui-helper-clearfix ui-widget-header" );

		// Prevent users from focusing disabled tabs via click
		this.tablist
			.on( "mousedown" + this.eventNamespace, "> li", function( event ) {
				if ( $( this ).is( ".ui-state-disabled" ) ) {
					event.preventDefault();
				}
			} )

			// Support: IE <9
			// Preventing the default action in mousedown doesn't prevent IE
			// from focusing the element, so if the anchor gets focused, blur.
			// We don't have to worry about focusing the previously focused
			// element since clicking on a non-focusable element should focus
			// the body anyway.
			.on( "focus" + this.eventNamespace, ".ui-tabs-anchor", function() {
				if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
					this.blur();
				}
			} );

		this.tabs = this.tablist.find( "> li:has(a[href])" )
			.attr( {
				role: "tab",
				tabIndex: -1
			} );
		this._addClass( this.tabs, "ui-tabs-tab", "ui-state-default" );

		this.anchors = this.tabs.map( function() {
			return $( "a", this )[ 0 ];
		} )
			.attr( {
				role: "presentation",
				tabIndex: -1
			} );
		this._addClass( this.anchors, "ui-tabs-anchor" );

		this.panels = $();

		this.anchors.each( function( i, anchor ) {
			var selector, panel, panelId,
				anchorId = $( anchor ).uniqueId().attr( "id" ),
				tab = $( anchor ).closest( "li" ),
				originalAriaControls = tab.attr( "aria-controls" );

			// Inline tab
			if ( that._isLocal( anchor ) ) {
				selector = anchor.hash;
				panelId = selector.substring( 1 );
				panel = that.element.find( that._sanitizeSelector( selector ) );

			// remote tab
			} else {

				// If the tab doesn't already have aria-controls,
				// generate an id by using a throw-away element
				panelId = tab.attr( "aria-controls" ) || $( {} ).uniqueId()[ 0 ].id;
				selector = "#" + panelId;
				panel = that.element.find( selector );
				if ( !panel.length ) {
					panel = that._createPanel( panelId );
					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
				}
				panel.attr( "aria-live", "polite" );
			}

			if ( panel.length ) {
				that.panels = that.panels.add( panel );
			}
			if ( originalAriaControls ) {
				tab.data( "ui-tabs-aria-controls", originalAriaControls );
			}
			tab.attr( {
				"aria-controls": panelId,
				"aria-labelledby": anchorId
			} );
			panel.attr( "aria-labelledby", anchorId );
		} );

		this.panels.attr( "role", "tabpanel" );
		this._addClass( this.panels, "ui-tabs-panel", "ui-widget-content" );

		// Avoid memory leaks (#10056)
		if ( prevTabs ) {
			this._off( prevTabs.not( this.tabs ) );
			this._off( prevAnchors.not( this.anchors ) );
			this._off( prevPanels.not( this.panels ) );
		}
	},

	// Allow overriding how to find the list for rare usage scenarios (#7715)
	_getList: function() {
		return this.tablist || this.element.find( "ol, ul" ).eq( 0 );
	},

	_createPanel: function( id ) {
		return $( "<div>" )
			.attr( "id", id )
			.data( "ui-tabs-destroy", true );
	},

	_setOptionDisabled: function( disabled ) {
		var currentItem, li, i;

		if ( $.isArray( disabled ) ) {
			if ( !disabled.length ) {
				disabled = false;
			} else if ( disabled.length === this.anchors.length ) {
				disabled = true;
			}
		}

		// Disable tabs
		for ( i = 0; ( li = this.tabs[ i ] ); i++ ) {
			currentItem = $( li );
			if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
				currentItem.attr( "aria-disabled", "true" );
				this._addClass( currentItem, null, "ui-state-disabled" );
			} else {
				currentItem.removeAttr( "aria-disabled" );
				this._removeClass( currentItem, null, "ui-state-disabled" );
			}
		}

		this.options.disabled = disabled;

		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null,
			disabled === true );
	},

	_setupEvents: function( event ) {
		var events = {};
		if ( event ) {
			$.each( event.split( " " ), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			} );
		}

		this._off( this.anchors.add( this.tabs ).add( this.panels ) );

		// Always prevent the default action, even when disabled
		this._on( true, this.anchors, {
			click: function( event ) {
				event.preventDefault();
			}
		} );
		this._on( this.anchors, events );
		this._on( this.tabs, { keydown: "_tabKeydown" } );
		this._on( this.panels, { keydown: "_panelKeydown" } );

		this._focusable( this.tabs );
		this._hoverable( this.tabs );
	},

	_setupHeightStyle: function( heightStyle ) {
		var maxHeight,
			parent = this.element.parent();

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			maxHeight -= this.element.outerHeight() - this.element.height();

			this.element.siblings( ":visible" ).each( function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			} );

			this.element.children().not( this.panels ).each( function() {
				maxHeight -= $( this ).outerHeight( true );
			} );

			this.panels.each( function() {
				$( this ).height( Math.max( 0, maxHeight -
					$( this ).innerHeight() + $( this ).height() ) );
			} )
				.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.panels.each( function() {
				maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
			} ).height( maxHeight );
		}
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			anchor = $( event.currentTarget ),
			tab = anchor.closest( "li" ),
			clickedIsActive = tab[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : this._getPanelForTab( tab ),
			toHide = !active.length ? $() : this._getPanelForTab( active ),
			eventData = {
				oldTab: active,
				oldPanel: toHide,
				newTab: collapsing ? $() : tab,
				newPanel: toShow
			};

		event.preventDefault();

		if ( tab.hasClass( "ui-state-disabled" ) ||

				// tab is already loading
				tab.hasClass( "ui-tabs-loading" ) ||

				// can't switch durning an animation
				this.running ||

				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||

				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.tabs.index( tab );

		this.active = clickedIsActive ? $() : tab;
		if ( this.xhr ) {
			this.xhr.abort();
		}

		if ( !toHide.length && !toShow.length ) {
			$.error( "jQuery UI Tabs: Mismatching fragment identifier." );
		}

		if ( toShow.length ) {
			this.load( this.tabs.index( tab ), event );
		}
		this._toggle( event, eventData );
	},

	// Handles show/hide for selecting tabs
	_toggle: function( event, eventData ) {
		var that = this,
			toShow = eventData.newPanel,
			toHide = eventData.oldPanel;

		this.running = true;

		function complete() {
			that.running = false;
			that._trigger( "activate", event, eventData );
		}

		function show() {
			that._addClass( eventData.newTab.closest( "li" ), "ui-tabs-active", "ui-state-active" );

			if ( toShow.length && that.options.show ) {
				that._show( toShow, that.options.show, complete );
			} else {
				toShow.show();
				complete();
			}
		}

		// Start out by hiding, then showing, then completing
		if ( toHide.length && this.options.hide ) {
			this._hide( toHide, this.options.hide, function() {
				that._removeClass( eventData.oldTab.closest( "li" ),
					"ui-tabs-active", "ui-state-active" );
				show();
			} );
		} else {
			this._removeClass( eventData.oldTab.closest( "li" ),
				"ui-tabs-active", "ui-state-active" );
			toHide.hide();
			show();
		}

		toHide.attr( "aria-hidden", "true" );
		eventData.oldTab.attr( {
			"aria-selected": "false",
			"aria-expanded": "false"
		} );

		// If we're switching tabs, remove the old tab from the tab order.
		// If we're opening from collapsed state, remove the previous tab from the tab order.
		// If we're collapsing, then keep the collapsing tab in the tab order.
		if ( toShow.length && toHide.length ) {
			eventData.oldTab.attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.tabs.filter( function() {
				return $( this ).attr( "tabIndex" ) === 0;
			} )
				.attr( "tabIndex", -1 );
		}

		toShow.attr( "aria-hidden", "false" );
		eventData.newTab.attr( {
			"aria-selected": "true",
			"aria-expanded": "true",
			tabIndex: 0
		} );
	},

	_activate: function( index ) {
		var anchor,
			active = this._findActive( index );

		// Trying to activate the already active panel
		if ( active[ 0 ] === this.active[ 0 ] ) {
			return;
		}

		// Trying to collapse, simulate a click on the current active header
		if ( !active.length ) {
			active = this.active;
		}

		anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
		this._eventHandler( {
			target: anchor,
			currentTarget: anchor,
			preventDefault: $.noop
		} );
	},

	_findActive: function( index ) {
		return index === false ? $() : this.tabs.eq( index );
	},

	_getIndex: function( index ) {

		// meta-function to give users option to provide a href string instead of a numerical index.
		if ( typeof index === "string" ) {
			index = this.anchors.index( this.anchors.filter( "[href$='" +
				$.ui.escapeSelector( index ) + "']" ) );
		}

		return index;
	},

	_destroy: function() {
		if ( this.xhr ) {
			this.xhr.abort();
		}

		this.tablist
			.removeAttr( "role" )
			.off( this.eventNamespace );

		this.anchors
			.removeAttr( "role tabIndex" )
			.removeUniqueId();

		this.tabs.add( this.panels ).each( function() {
			if ( $.data( this, "ui-tabs-destroy" ) ) {
				$( this ).remove();
			} else {
				$( this ).removeAttr( "role tabIndex " +
					"aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded" );
			}
		} );

		this.tabs.each( function() {
			var li = $( this ),
				prev = li.data( "ui-tabs-aria-controls" );
			if ( prev ) {
				li
					.attr( "aria-controls", prev )
					.removeData( "ui-tabs-aria-controls" );
			} else {
				li.removeAttr( "aria-controls" );
			}
		} );

		this.panels.show();

		if ( this.options.heightStyle !== "content" ) {
			this.panels.css( "height", "" );
		}
	},

	enable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === false ) {
			return;
		}

		if ( index === undefined ) {
			disabled = false;
		} else {
			index = this._getIndex( index );
			if ( $.isArray( disabled ) ) {
				disabled = $.map( disabled, function( num ) {
					return num !== index ? num : null;
				} );
			} else {
				disabled = $.map( this.tabs, function( li, num ) {
					return num !== index ? num : null;
				} );
			}
		}
		this._setOptionDisabled( disabled );
	},

	disable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === true ) {
			return;
		}

		if ( index === undefined ) {
			disabled = true;
		} else {
			index = this._getIndex( index );
			if ( $.inArray( index, disabled ) !== -1 ) {
				return;
			}
			if ( $.isArray( disabled ) ) {
				disabled = $.merge( [ index ], disabled ).sort();
			} else {
				disabled = [ index ];
			}
		}
		this._setOptionDisabled( disabled );
	},

	load: function( index, event ) {
		index = this._getIndex( index );
		var that = this,
			tab = this.tabs.eq( index ),
			anchor = tab.find( ".ui-tabs-anchor" ),
			panel = this._getPanelForTab( tab ),
			eventData = {
				tab: tab,
				panel: panel
			},
			complete = function( jqXHR, status ) {
				if ( status === "abort" ) {
					that.panels.stop( false, true );
				}

				that._removeClass( tab, "ui-tabs-loading" );
				panel.removeAttr( "aria-busy" );

				if ( jqXHR === that.xhr ) {
					delete that.xhr;
				}
			};

		// Not remote
		if ( this._isLocal( anchor[ 0 ] ) ) {
			return;
		}

		this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

		// Support: jQuery <1.8
		// jQuery <1.8 returns false if the request is canceled in beforeSend,
		// but as of 1.8, $.ajax() always returns a jqXHR object.
		if ( this.xhr && this.xhr.statusText !== "canceled" ) {
			this._addClass( tab, "ui-tabs-loading" );
			panel.attr( "aria-busy", "true" );

			this.xhr
				.done( function( response, status, jqXHR ) {

					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout( function() {
						panel.html( response );
						that._trigger( "load", event, eventData );

						complete( jqXHR, status );
					}, 1 );
				} )
				.fail( function( jqXHR, status ) {

					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout( function() {
						complete( jqXHR, status );
					}, 1 );
				} );
		}
	},

	_ajaxSettings: function( anchor, event, eventData ) {
		var that = this;
		return {

			// Support: IE <11 only
			// Strip any hash that exists to prevent errors with the Ajax request
			url: anchor.attr( "href" ).replace( /#.*$/, "" ),
			beforeSend: function( jqXHR, settings ) {
				return that._trigger( "beforeLoad", event,
					$.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );
			}
		};
	},

	_getPanelForTab: function( tab ) {
		var id = $( tab ).attr( "aria-controls" );
		return this.element.find( this._sanitizeSelector( "#" + id ) );
	}
} );

// DEPRECATED
// TODO: Switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for ui-tab class (now ui-tabs-tab)
	$.widget( "ui.tabs", $.ui.tabs, {
		_processTabs: function() {
			this._superApply( arguments );
			this._addClass( this.tabs, "ui-tab" );
		}
	} );
}

var widgetsTabs = $.ui.tabs;


/*!
 * jQuery UI Tooltip 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Tooltip
//>>group: Widgets
//>>description: Shows additional information for any element on hover or focus.
//>>docs: http://api.jqueryui.com/tooltip/
//>>demos: http://jqueryui.com/tooltip/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/tooltip.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.tooltip", {
	version: "1.12.1",
	options: {
		classes: {
			"ui-tooltip": "ui-corner-all ui-widget-shadow"
		},
		content: function() {

			// support: IE<9, Opera in jQuery <1.7
			// .text() can't accept undefined, so coerce to a string
			var title = $( this ).attr( "title" ) || "";

			// Escape title, since we're going from an attribute to raw HTML
			return $( "<a>" ).text( title ).html();
		},
		hide: true,

		// Disabled elements have inconsistent behavior across browsers (#8661)
		items: "[title]:not([disabled])",
		position: {
			my: "left top+15",
			at: "left bottom",
			collision: "flipfit flip"
		},
		show: true,
		track: false,

		// Callbacks
		close: null,
		open: null
	},

	_addDescribedBy: function( elem, id ) {
		var describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ );
		describedby.push( id );
		elem
			.data( "ui-tooltip-id", id )
			.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
	},

	_removeDescribedBy: function( elem ) {
		var id = elem.data( "ui-tooltip-id" ),
			describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ ),
			index = $.inArray( id, describedby );

		if ( index !== -1 ) {
			describedby.splice( index, 1 );
		}

		elem.removeData( "ui-tooltip-id" );
		describedby = $.trim( describedby.join( " " ) );
		if ( describedby ) {
			elem.attr( "aria-describedby", describedby );
		} else {
			elem.removeAttr( "aria-describedby" );
		}
	},

	_create: function() {
		this._on( {
			mouseover: "open",
			focusin: "open"
		} );

		// IDs of generated tooltips, needed for destroy
		this.tooltips = {};

		// IDs of parent tooltips where we removed the title attribute
		this.parents = {};

		// Append the aria-live region so tooltips announce correctly
		this.liveRegion = $( "<div>" )
			.attr( {
				role: "log",
				"aria-live": "assertive",
				"aria-relevant": "additions"
			} )
			.appendTo( this.document[ 0 ].body );
		this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" );

		this.disabledTitles = $( [] );
	},

	_setOption: function( key, value ) {
		var that = this;

		this._super( key, value );

		if ( key === "content" ) {
			$.each( this.tooltips, function( id, tooltipData ) {
				that._updateContent( tooltipData.element );
			} );
		}
	},

	_setOptionDisabled: function( value ) {
		this[ value ? "_disable" : "_enable" ]();
	},

	_disable: function() {
		var that = this;

		// Close open tooltips
		$.each( this.tooltips, function( id, tooltipData ) {
			var event = $.Event( "blur" );
			event.target = event.currentTarget = tooltipData.element[ 0 ];
			that.close( event, true );
		} );

		// Remove title attributes to prevent native tooltips
		this.disabledTitles = this.disabledTitles.add(
			this.element.find( this.options.items ).addBack()
				.filter( function() {
					var element = $( this );
					if ( element.is( "[title]" ) ) {
						return element
							.data( "ui-tooltip-title", element.attr( "title" ) )
							.removeAttr( "title" );
					}
				} )
		);
	},

	_enable: function() {

		// restore title attributes
		this.disabledTitles.each( function() {
			var element = $( this );
			if ( element.data( "ui-tooltip-title" ) ) {
				element.attr( "title", element.data( "ui-tooltip-title" ) );
			}
		} );
		this.disabledTitles = $( [] );
	},

	open: function( event ) {
		var that = this,
			target = $( event ? event.target : this.element )

				// we need closest here due to mouseover bubbling,
				// but always pointing at the same event target
				.closest( this.options.items );

		// No element to show a tooltip for or the tooltip is already open
		if ( !target.length || target.data( "ui-tooltip-id" ) ) {
			return;
		}

		if ( target.attr( "title" ) ) {
			target.data( "ui-tooltip-title", target.attr( "title" ) );
		}

		target.data( "ui-tooltip-open", true );

		// Kill parent tooltips, custom or native, for hover
		if ( event && event.type === "mouseover" ) {
			target.parents().each( function() {
				var parent = $( this ),
					blurEvent;
				if ( parent.data( "ui-tooltip-open" ) ) {
					blurEvent = $.Event( "blur" );
					blurEvent.target = blurEvent.currentTarget = this;
					that.close( blurEvent, true );
				}
				if ( parent.attr( "title" ) ) {
					parent.uniqueId();
					that.parents[ this.id ] = {
						element: this,
						title: parent.attr( "title" )
					};
					parent.attr( "title", "" );
				}
			} );
		}

		this._registerCloseHandlers( event, target );
		this._updateContent( target, event );
	},

	_updateContent: function( target, event ) {
		var content,
			contentOption = this.options.content,
			that = this,
			eventType = event ? event.type : null;

		if ( typeof contentOption === "string" || contentOption.nodeType ||
				contentOption.jquery ) {
			return this._open( event, target, contentOption );
		}

		content = contentOption.call( target[ 0 ], function( response ) {

			// IE may instantly serve a cached response for ajax requests
			// delay this call to _open so the other call to _open runs first
			that._delay( function() {

				// Ignore async response if tooltip was closed already
				if ( !target.data( "ui-tooltip-open" ) ) {
					return;
				}

				// JQuery creates a special event for focusin when it doesn't
				// exist natively. To improve performance, the native event
				// object is reused and the type is changed. Therefore, we can't
				// rely on the type being correct after the event finished
				// bubbling, so we set it back to the previous value. (#8740)
				if ( event ) {
					event.type = eventType;
				}
				this._open( event, target, response );
			} );
		} );
		if ( content ) {
			this._open( event, target, content );
		}
	},

	_open: function( event, target, content ) {
		var tooltipData, tooltip, delayedShow, a11yContent,
			positionOption = $.extend( {}, this.options.position );

		if ( !content ) {
			return;
		}

		// Content can be updated multiple times. If the tooltip already
		// exists, then just update the content and bail.
		tooltipData = this._find( target );
		if ( tooltipData ) {
			tooltipData.tooltip.find( ".ui-tooltip-content" ).html( content );
			return;
		}

		// If we have a title, clear it to prevent the native tooltip
		// we have to check first to avoid defining a title if none exists
		// (we don't want to cause an element to start matching [title])
		//
		// We use removeAttr only for key events, to allow IE to export the correct
		// accessible attributes. For mouse events, set to empty string to avoid
		// native tooltip showing up (happens only when removing inside mouseover).
		if ( target.is( "[title]" ) ) {
			if ( event && event.type === "mouseover" ) {
				target.attr( "title", "" );
			} else {
				target.removeAttr( "title" );
			}
		}

		tooltipData = this._tooltip( target );
		tooltip = tooltipData.tooltip;
		this._addDescribedBy( target, tooltip.attr( "id" ) );
		tooltip.find( ".ui-tooltip-content" ).html( content );

		// Support: Voiceover on OS X, JAWS on IE <= 9
		// JAWS announces deletions even when aria-relevant="additions"
		// Voiceover will sometimes re-read the entire log region's contents from the beginning
		this.liveRegion.children().hide();
		a11yContent = $( "<div>" ).html( tooltip.find( ".ui-tooltip-content" ).html() );
		a11yContent.removeAttr( "name" ).find( "[name]" ).removeAttr( "name" );
		a11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" );
		a11yContent.appendTo( this.liveRegion );

		function position( event ) {
			positionOption.of = event;
			if ( tooltip.is( ":hidden" ) ) {
				return;
			}
			tooltip.position( positionOption );
		}
		if ( this.options.track && event && /^mouse/.test( event.type ) ) {
			this._on( this.document, {
				mousemove: position
			} );

			// trigger once to override element-relative positioning
			position( event );
		} else {
			tooltip.position( $.extend( {
				of: target
			}, this.options.position ) );
		}

		tooltip.hide();

		this._show( tooltip, this.options.show );

		// Handle tracking tooltips that are shown with a delay (#8644). As soon
		// as the tooltip is visible, position the tooltip using the most recent
		// event.
		// Adds the check to add the timers only when both delay and track options are set (#14682)
		if ( this.options.track && this.options.show && this.options.show.delay ) {
			delayedShow = this.delayedShow = setInterval( function() {
				if ( tooltip.is( ":visible" ) ) {
					position( positionOption.of );
					clearInterval( delayedShow );
				}
			}, $.fx.interval );
		}

		this._trigger( "open", event, { tooltip: tooltip } );
	},

	_registerCloseHandlers: function( event, target ) {
		var events = {
			keyup: function( event ) {
				if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
					var fakeEvent = $.Event( event );
					fakeEvent.currentTarget = target[ 0 ];
					this.close( fakeEvent, true );
				}
			}
		};

		// Only bind remove handler for delegated targets. Non-delegated
		// tooltips will handle this in destroy.
		if ( target[ 0 ] !== this.element[ 0 ] ) {
			events.remove = function() {
				this._removeTooltip( this._find( target ).tooltip );
			};
		}

		if ( !event || event.type === "mouseover" ) {
			events.mouseleave = "close";
		}
		if ( !event || event.type === "focusin" ) {
			events.focusout = "close";
		}
		this._on( true, target, events );
	},

	close: function( event ) {
		var tooltip,
			that = this,
			target = $( event ? event.currentTarget : this.element ),
			tooltipData = this._find( target );

		// The tooltip may already be closed
		if ( !tooltipData ) {

			// We set ui-tooltip-open immediately upon open (in open()), but only set the
			// additional data once there's actually content to show (in _open()). So even if the
			// tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
			// the period between open() and _open().
			target.removeData( "ui-tooltip-open" );
			return;
		}

		tooltip = tooltipData.tooltip;

		// Disabling closes the tooltip, so we need to track when we're closing
		// to avoid an infinite loop in case the tooltip becomes disabled on close
		if ( tooltipData.closing ) {
			return;
		}

		// Clear the interval for delayed tracking tooltips
		clearInterval( this.delayedShow );

		// Only set title if we had one before (see comment in _open())
		// If the title attribute has changed since open(), don't restore
		if ( target.data( "ui-tooltip-title" ) && !target.attr( "title" ) ) {
			target.attr( "title", target.data( "ui-tooltip-title" ) );
		}

		this._removeDescribedBy( target );

		tooltipData.hiding = true;
		tooltip.stop( true );
		this._hide( tooltip, this.options.hide, function() {
			that._removeTooltip( $( this ) );
		} );

		target.removeData( "ui-tooltip-open" );
		this._off( target, "mouseleave focusout keyup" );

		// Remove 'remove' binding only on delegated targets
		if ( target[ 0 ] !== this.element[ 0 ] ) {
			this._off( target, "remove" );
		}
		this._off( this.document, "mousemove" );

		if ( event && event.type === "mouseleave" ) {
			$.each( this.parents, function( id, parent ) {
				$( parent.element ).attr( "title", parent.title );
				delete that.parents[ id ];
			} );
		}

		tooltipData.closing = true;
		this._trigger( "close", event, { tooltip: tooltip } );
		if ( !tooltipData.hiding ) {
			tooltipData.closing = false;
		}
	},

	_tooltip: function( element ) {
		var tooltip = $( "<div>" ).attr( "role", "tooltip" ),
			content = $( "<div>" ).appendTo( tooltip ),
			id = tooltip.uniqueId().attr( "id" );

		this._addClass( content, "ui-tooltip-content" );
		this._addClass( tooltip, "ui-tooltip", "ui-widget ui-widget-content" );

		tooltip.appendTo( this._appendTo( element ) );

		return this.tooltips[ id ] = {
			element: element,
			tooltip: tooltip
		};
	},

	_find: function( target ) {
		var id = target.data( "ui-tooltip-id" );
		return id ? this.tooltips[ id ] : null;
	},

	_removeTooltip: function( tooltip ) {
		tooltip.remove();
		delete this.tooltips[ tooltip.attr( "id" ) ];
	},

	_appendTo: function( target ) {
		var element = target.closest( ".ui-front, dialog" );

		if ( !element.length ) {
			element = this.document[ 0 ].body;
		}

		return element;
	},

	_destroy: function() {
		var that = this;

		// Close open tooltips
		$.each( this.tooltips, function( id, tooltipData ) {

			// Delegate to close method to handle common cleanup
			var event = $.Event( "blur" ),
				element = tooltipData.element;
			event.target = event.currentTarget = element[ 0 ];
			that.close( event, true );

			// Remove immediately; destroying an open tooltip doesn't use the
			// hide animation
			$( "#" + id ).remove();

			// Restore the title
			if ( element.data( "ui-tooltip-title" ) ) {

				// If the title attribute has changed since open(), don't restore
				if ( !element.attr( "title" ) ) {
					element.attr( "title", element.data( "ui-tooltip-title" ) );
				}
				element.removeData( "ui-tooltip-title" );
			}
		} );
		this.liveRegion.remove();
	}
} );

// DEPRECATED
// TODO: Switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for tooltipClass option
	$.widget( "ui.tooltip", $.ui.tooltip, {
		options: {
			tooltipClass: null
		},
		_tooltip: function() {
			var tooltipData = this._superApply( arguments );
			if ( this.options.tooltipClass ) {
				tooltipData.tooltip.addClass( this.options.tooltipClass );
			}
			return tooltipData;
		}
	} );
}

var widgetsTooltip = $.ui.tooltip;




}));
/* Russian (UTF-8) initialisation for the jQuery UI date picker plugin. */
/* Written by Andrew Stromnov (stromnov@gmail.com). */
( function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define( [ "../widgets/datepicker" ], factory );
	} else {

		// Browser globals
		factory( jQuery.datepicker );
	}
}( function( datepicker ) {

datepicker.regional.ru = {
	closeText: "Закрыть",
	prevText: "&#x3C;Пред",
	nextText: "След&#x3E;",
	currentText: "Сегодня",
	monthNames: [ "Январь","Февраль","Март","Апрель","Май","Июнь",
	"Июль","Август","Сентябрь","Октябрь","Ноябрь","Декабрь" ],
	monthNamesShort: [ "Янв","Фев","Мар","Апр","Май","Июн",
	"Июл","Авг","Сен","Окт","Ноя","Дек" ],
	dayNames: [ "воскресенье","понедельник","вторник","среда","четверг","пятница","суббота" ],
	dayNamesShort: [ "вск","пнд","втр","срд","чтв","птн","сбт" ],
	dayNamesMin: [ "Вс","Пн","Вт","Ср","Чт","Пт","Сб" ],
	weekHeader: "Нед",
	dateFormat: "dd.mm.yy",
	firstDay: 1,
	isRTL: false,
	showMonthAfterYear: false,
	yearSuffix: "" };
datepicker.setDefaults( datepicker.regional.ru );

return datepicker.regional.ru;

} ) );

/*!
 * jQuery Cookie Plugin v1.4.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2013 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD
		define(['jquery'], factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		factory(require('jquery'));
	} else {
		// Browser globals
		factory(jQuery);
	}
}(function ($) {

	var pluses = /\+/g;

	function encode(s) {
		return config.raw ? s : encodeURIComponent(s);
	}

	function decode(s) {
		return config.raw ? s : decodeURIComponent(s);
	}

	function stringifyCookieValue(value) {
		return encode(config.json ? JSON.stringify(value) : String(value));
	}

	function parseCookieValue(s) {
		if (s.indexOf('"') === 0) {
			// This is a quoted cookie as according to RFC2068, unescape...
			s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
		}

		try {
			// Replace server-side written pluses with spaces.
			// If we can't decode the cookie, ignore it, it's unusable.
			// If we can't parse the cookie, ignore it, it's unusable.
			s = decodeURIComponent(s.replace(pluses, ' '));
			return config.json ? JSON.parse(s) : s;
		} catch(e) {}
	}

	function read(s, converter) {
		var value = config.raw ? s : parseCookieValue(s);
		return $.isFunction(converter) ? converter(value) : value;
	}

	var config = $.cookie = function (key, value, options) {

		// Write

		if (value !== undefined && !$.isFunction(value)) {
			options = $.extend({}, config.defaults, options);

			if (typeof options.expires === 'number') {
				var days = options.expires, t = options.expires = new Date();
				t.setTime(+t + days * 864e+5);
			}

			return (document.cookie = [
				encode(key), '=', stringifyCookieValue(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path    ? '; path=' + options.path : '',
				options.domain  ? '; domain=' + options.domain : '',
				options.secure  ? '; secure' : ''
			].join(''));
		}

		// Read

		var result = key ? undefined : {};

		// To prevent the for loop in the first place assign an empty array
		// in case there are no cookies at all. Also prevents odd result when
		// calling $.cookie().
		var cookies = document.cookie ? document.cookie.split('; ') : [];

		for (var i = 0, l = cookies.length; i < l; i++) {
			var parts = cookies[i].split('=');
			var name = decode(parts.shift());
			var cookie = parts.join('=');

			if (key && key === name) {
				// If second argument (value) is a function it's a converter...
				result = read(cookie, value);
				break;
			}

			// Prevent storing a cookie that we couldn't decode.
			if (!key && (cookie = read(cookie)) !== undefined) {
				result[name] = cookie;
			}
		}

		return result;
	};

	config.defaults = {};

	$.removeCookie = function (key, options) {
		if ($.cookie(key) === undefined) {
			return false;
		}

		// Must not alter options, thus extending a fresh object...
		$.cookie(key, '', $.extend({}, options, { expires: -1 }));
		return !$.cookie(key);
	};

}));

/*! jQuery Timepicker Addon - v1.6.3 - 2016-04-20
* http://trentrichardson.com/examples/timepicker
* Copyright (c) 2016 Trent Richardson; Licensed MIT */
(function (factory) {
	if (typeof define === 'function' && define.amd) {
		define(['jquery', 'jquery-ui'], factory);
	} else {
		factory(jQuery);
	}
}(function ($) {

	/*
	* Lets not redefine timepicker, Prevent "Uncaught RangeError: Maximum call stack size exceeded"
	*/
	$.ui.timepicker = $.ui.timepicker || {};
	if ($.ui.timepicker.version) {
		return;
	}

	/*
	* Extend jQueryUI, get it started with our version number
	*/
	$.extend($.ui, {
		timepicker: {
			version: "1.6.3"
		}
	});

	/*
	* Timepicker manager.
	* Use the singleton instance of this class, $.timepicker, to interact with the time picker.
	* Settings for (groups of) time pickers are maintained in an instance object,
	* allowing multiple different settings on the same page.
	*/
	var Timepicker = function () {
		this.regional = []; // Available regional settings, indexed by language code
		this.regional[''] = { // Default regional settings
			currentText: 'Now',
			closeText: 'Done',
			amNames: ['AM', 'A'],
			pmNames: ['PM', 'P'],
			timeFormat: 'HH:mm',
			timeSuffix: '',
			timeOnlyTitle: 'Choose Time',
			timeText: 'Time',
			hourText: 'Hour',
			minuteText: 'Minute',
			secondText: 'Second',
			millisecText: 'Millisecond',
			microsecText: 'Microsecond',
			timezoneText: 'Time Zone',
			isRTL: false
		};
		this._defaults = { // Global defaults for all the datetime picker instances
			showButtonPanel: true,
			timeOnly: false,
			timeOnlyShowDate: false,
			showHour: null,
			showMinute: null,
			showSecond: null,
			showMillisec: null,
			showMicrosec: null,
			showTimezone: null,
			showTime: true,
			stepHour: 1,
			stepMinute: 1,
			stepSecond: 1,
			stepMillisec: 1,
			stepMicrosec: 1,
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			microsec: 0,
			timezone: null,
			hourMin: 0,
			minuteMin: 0,
			secondMin: 0,
			millisecMin: 0,
			microsecMin: 0,
			hourMax: 23,
			minuteMax: 59,
			secondMax: 59,
			millisecMax: 999,
			microsecMax: 999,
			minDateTime: null,
			maxDateTime: null,
			maxTime: null,
			minTime: null,
			onSelect: null,
			hourGrid: 0,
			minuteGrid: 0,
			secondGrid: 0,
			millisecGrid: 0,
			microsecGrid: 0,
			alwaysSetTime: true,
			separator: ' ',
			altFieldTimeOnly: true,
			altTimeFormat: null,
			altSeparator: null,
			altTimeSuffix: null,
			altRedirectFocus: true,
			pickerTimeFormat: null,
			pickerTimeSuffix: null,
			showTimepicker: true,
			timezoneList: null,
			addSliderAccess: false,
			sliderAccessArgs: null,
			controlType: 'slider',
			oneLine: false,
			defaultValue: null,
			parse: 'strict',
			afterInject: null
		};
		$.extend(this._defaults, this.regional['']);
	};

	$.extend(Timepicker.prototype, {
		$input: null,
		$altInput: null,
		$timeObj: null,
		inst: null,
		hour_slider: null,
		minute_slider: null,
		second_slider: null,
		millisec_slider: null,
		microsec_slider: null,
		timezone_select: null,
		maxTime: null,
		minTime: null,
		hour: 0,
		minute: 0,
		second: 0,
		millisec: 0,
		microsec: 0,
		timezone: null,
		hourMinOriginal: null,
		minuteMinOriginal: null,
		secondMinOriginal: null,
		millisecMinOriginal: null,
		microsecMinOriginal: null,
		hourMaxOriginal: null,
		minuteMaxOriginal: null,
		secondMaxOriginal: null,
		millisecMaxOriginal: null,
		microsecMaxOriginal: null,
		ampm: '',
		formattedDate: '',
		formattedTime: '',
		formattedDateTime: '',
		timezoneList: null,
		units: ['hour', 'minute', 'second', 'millisec', 'microsec'],
		support: {},
		control: null,

		/*
		* Override the default settings for all instances of the time picker.
		* @param  {Object} settings  object - the new settings to use as defaults (anonymous object)
		* @return {Object} the manager object
		*/
		setDefaults: function (settings) {
			extendRemove(this._defaults, settings || {});
			return this;
		},

		/*
		* Create a new Timepicker instance
		*/
		_newInst: function ($input, opts) {
			var tp_inst = new Timepicker(),
				inlineSettings = {},
				fns = {},
				overrides, i;

			for (var attrName in this._defaults) {
				if (this._defaults.hasOwnProperty(attrName)) {
					var attrValue = $input.attr('time:' + attrName);
					if (attrValue) {
						try {
							inlineSettings[attrName] = eval(attrValue);
						} catch (err) {
							inlineSettings[attrName] = attrValue;
						}
					}
				}
			}

			overrides = {
				beforeShow: function (input, dp_inst) {
					if ($.isFunction(tp_inst._defaults.evnts.beforeShow)) {
						return tp_inst._defaults.evnts.beforeShow.call($input[0], input, dp_inst, tp_inst);
					}
				},
				onChangeMonthYear: function (year, month, dp_inst) {
					// Update the time as well : this prevents the time from disappearing from the $input field.
					// tp_inst._updateDateTime(dp_inst);
					if ($.isFunction(tp_inst._defaults.evnts.onChangeMonthYear)) {
						tp_inst._defaults.evnts.onChangeMonthYear.call($input[0], year, month, dp_inst, tp_inst);
					}
				},
				onClose: function (dateText, dp_inst) {
					if (tp_inst.timeDefined === true && $input.val() !== '') {
						tp_inst._updateDateTime(dp_inst);
					}
					if ($.isFunction(tp_inst._defaults.evnts.onClose)) {
						tp_inst._defaults.evnts.onClose.call($input[0], dateText, dp_inst, tp_inst);
					}
				}
			};
			for (i in overrides) {
				if (overrides.hasOwnProperty(i)) {
					fns[i] = opts[i] || this._defaults[i] || null;
				}
			}

			tp_inst._defaults = $.extend({}, this._defaults, inlineSettings, opts, overrides, {
				evnts: fns,
				timepicker: tp_inst // add timepicker as a property of datepicker: $.datepicker._get(dp_inst, 'timepicker');
			});
			tp_inst.amNames = $.map(tp_inst._defaults.amNames, function (val) {
				return val.toUpperCase();
			});
			tp_inst.pmNames = $.map(tp_inst._defaults.pmNames, function (val) {
				return val.toUpperCase();
			});

			// detect which units are supported
			tp_inst.support = detectSupport(
					tp_inst._defaults.timeFormat +
					(tp_inst._defaults.pickerTimeFormat ? tp_inst._defaults.pickerTimeFormat : '') +
					(tp_inst._defaults.altTimeFormat ? tp_inst._defaults.altTimeFormat : ''));

			// controlType is string - key to our this._controls
			if (typeof(tp_inst._defaults.controlType) === 'string') {
				if (tp_inst._defaults.controlType === 'slider' && typeof($.ui.slider) === 'undefined') {
					tp_inst._defaults.controlType = 'select';
				}
				tp_inst.control = tp_inst._controls[tp_inst._defaults.controlType];
			}
			// controlType is an object and must implement create, options, value methods
			else {
				tp_inst.control = tp_inst._defaults.controlType;
			}

			// prep the timezone options
			var timezoneList = [-720, -660, -600, -570, -540, -480, -420, -360, -300, -270, -240, -210, -180, -120, -60,
					0, 60, 120, 180, 210, 240, 270, 300, 330, 345, 360, 390, 420, 480, 525, 540, 570, 600, 630, 660, 690, 720, 765, 780, 840];
			if (tp_inst._defaults.timezoneList !== null) {
				timezoneList = tp_inst._defaults.timezoneList;
			}
			var tzl = timezoneList.length, tzi = 0, tzv = null;
			if (tzl > 0 && typeof timezoneList[0] !== 'object') {
				for (; tzi < tzl; tzi++) {
					tzv = timezoneList[tzi];
					timezoneList[tzi] = { value: tzv, label: $.timepicker.timezoneOffsetString(tzv, tp_inst.support.iso8601) };
				}
			}
			tp_inst._defaults.timezoneList = timezoneList;

			// set the default units
			tp_inst.timezone = tp_inst._defaults.timezone !== null ? $.timepicker.timezoneOffsetNumber(tp_inst._defaults.timezone) :
							((new Date()).getTimezoneOffset() * -1);
			tp_inst.hour = tp_inst._defaults.hour < tp_inst._defaults.hourMin ? tp_inst._defaults.hourMin :
							tp_inst._defaults.hour > tp_inst._defaults.hourMax ? tp_inst._defaults.hourMax : tp_inst._defaults.hour;
			tp_inst.minute = tp_inst._defaults.minute < tp_inst._defaults.minuteMin ? tp_inst._defaults.minuteMin :
							tp_inst._defaults.minute > tp_inst._defaults.minuteMax ? tp_inst._defaults.minuteMax : tp_inst._defaults.minute;
			tp_inst.second = tp_inst._defaults.second < tp_inst._defaults.secondMin ? tp_inst._defaults.secondMin :
							tp_inst._defaults.second > tp_inst._defaults.secondMax ? tp_inst._defaults.secondMax : tp_inst._defaults.second;
			tp_inst.millisec = tp_inst._defaults.millisec < tp_inst._defaults.millisecMin ? tp_inst._defaults.millisecMin :
							tp_inst._defaults.millisec > tp_inst._defaults.millisecMax ? tp_inst._defaults.millisecMax : tp_inst._defaults.millisec;
			tp_inst.microsec = tp_inst._defaults.microsec < tp_inst._defaults.microsecMin ? tp_inst._defaults.microsecMin :
							tp_inst._defaults.microsec > tp_inst._defaults.microsecMax ? tp_inst._defaults.microsecMax : tp_inst._defaults.microsec;
			tp_inst.ampm = '';
			tp_inst.$input = $input;

			if (tp_inst._defaults.altField) {
				tp_inst.$altInput = $(tp_inst._defaults.altField);
				if (tp_inst._defaults.altRedirectFocus === true) {
					tp_inst.$altInput.css({
						cursor: 'pointer'
					}).focus(function () {
						$input.trigger("focus");
					});
				}
			}

			if (tp_inst._defaults.minDate === 0 || tp_inst._defaults.minDateTime === 0) {
				tp_inst._defaults.minDate = new Date();
			}
			if (tp_inst._defaults.maxDate === 0 || tp_inst._defaults.maxDateTime === 0) {
				tp_inst._defaults.maxDate = new Date();
			}

			// datepicker needs minDate/maxDate, timepicker needs minDateTime/maxDateTime..
			if (tp_inst._defaults.minDate !== undefined && tp_inst._defaults.minDate instanceof Date) {
				tp_inst._defaults.minDateTime = new Date(tp_inst._defaults.minDate.getTime());
			}
			if (tp_inst._defaults.minDateTime !== undefined && tp_inst._defaults.minDateTime instanceof Date) {
				tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime());
			}
			if (tp_inst._defaults.maxDate !== undefined && tp_inst._defaults.maxDate instanceof Date) {
				tp_inst._defaults.maxDateTime = new Date(tp_inst._defaults.maxDate.getTime());
			}
			if (tp_inst._defaults.maxDateTime !== undefined && tp_inst._defaults.maxDateTime instanceof Date) {
				tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime());
			}
			tp_inst.$input.bind('focus', function () {
				tp_inst._onFocus();
			});

			return tp_inst;
		},

		/*
		* add our sliders to the calendar
		*/
		_addTimePicker: function (dp_inst) {
			var currDT = $.trim((this.$altInput && this._defaults.altFieldTimeOnly) ? this.$input.val() + ' ' + this.$altInput.val() : this.$input.val());

			this.timeDefined = this._parseTime(currDT);
			this._limitMinMaxDateTime(dp_inst, false);
			this._injectTimePicker();
			this._afterInject();
		},

		/*
		* parse the time string from input value or _setTime
		*/
		_parseTime: function (timeString, withDate) {
			if (!this.inst) {
				this.inst = $.datepicker._getInst(this.$input[0]);
			}

			if (withDate || !this._defaults.timeOnly) {
				var dp_dateFormat = $.datepicker._get(this.inst, 'dateFormat');
				try {
					var parseRes = parseDateTimeInternal(dp_dateFormat, this._defaults.timeFormat, timeString, $.datepicker._getFormatConfig(this.inst), this._defaults);
					if (!parseRes.timeObj) {
						return false;
					}
					$.extend(this, parseRes.timeObj);
				} catch (err) {
					$.timepicker.log("Error parsing the date/time string: " + err +
									"\ndate/time string = " + timeString +
									"\ntimeFormat = " + this._defaults.timeFormat +
									"\ndateFormat = " + dp_dateFormat);
					return false;
				}
				return true;
			} else {
				var timeObj = $.datepicker.parseTime(this._defaults.timeFormat, timeString, this._defaults);
				if (!timeObj) {
					return false;
				}
				$.extend(this, timeObj);
				return true;
			}
		},

		/*
		* Handle callback option after injecting timepicker
		*/
		_afterInject: function() {
			var o = this.inst.settings;
			if ($.isFunction(o.afterInject)) {
				o.afterInject.call(this);
			}
		},

		/*
		* generate and inject html for timepicker into ui datepicker
		*/
		_injectTimePicker: function () {
			var $dp = this.inst.dpDiv,
				o = this.inst.settings,
				tp_inst = this,
				litem = '',
				uitem = '',
				show = null,
				max = {},
				gridSize = {},
				size = null,
				i = 0,
				l = 0;

			// Prevent displaying twice
			if ($dp.find("div.ui-timepicker-div").length === 0 && o.showTimepicker) {
				var noDisplay = ' ui_tpicker_unit_hide',
					html = '<div class="ui-timepicker-div' + (o.isRTL ? ' ui-timepicker-rtl' : '') + (o.oneLine && o.controlType === 'select' ? ' ui-timepicker-oneLine' : '') + '"><dl>' + '<dt class="ui_tpicker_time_label' + ((o.showTime) ? '' : noDisplay) + '">' + o.timeText + '</dt>' +
								'<dd class="ui_tpicker_time '+ ((o.showTime) ? '' : noDisplay) + '"><input class="ui_tpicker_time_input" ' + (o.timeInput ? '' : 'disabled') + '/></dd>';

				// Create the markup
				for (i = 0, l = this.units.length; i < l; i++) {
					litem = this.units[i];
					uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1);
					show = o['show' + uitem] !== null ? o['show' + uitem] : this.support[litem];

					// Added by Peter Medeiros:
					// - Figure out what the hour/minute/second max should be based on the step values.
					// - Example: if stepMinute is 15, then minMax is 45.
					max[litem] = parseInt((o[litem + 'Max'] - ((o[litem + 'Max'] - o[litem + 'Min']) % o['step' + uitem])), 10);
					gridSize[litem] = 0;

					html += '<dt class="ui_tpicker_' + litem + '_label' + (show ? '' : noDisplay) + '">' + o[litem + 'Text'] + '</dt>' +
								'<dd class="ui_tpicker_' + litem + (show ? '' : noDisplay) + '"><div class="ui_tpicker_' + litem + '_slider' + (show ? '' : noDisplay) + '"></div>';

					if (show && o[litem + 'Grid'] > 0) {
						html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';

						if (litem === 'hour') {
							for (var h = o[litem + 'Min']; h <= max[litem]; h += parseInt(o[litem + 'Grid'], 10)) {
								gridSize[litem]++;
								var tmph = $.datepicker.formatTime(this.support.ampm ? 'hht' : 'HH', {hour: h}, o);
								html += '<td data-for="' + litem + '">' + tmph + '</td>';
							}
						}
						else {
							for (var m = o[litem + 'Min']; m <= max[litem]; m += parseInt(o[litem + 'Grid'], 10)) {
								gridSize[litem]++;
								html += '<td data-for="' + litem + '">' + ((m < 10) ? '0' : '') + m + '</td>';
							}
						}

						html += '</tr></table></div>';
					}
					html += '</dd>';
				}

				// Timezone
				var showTz = o.showTimezone !== null ? o.showTimezone : this.support.timezone;
				html += '<dt class="ui_tpicker_timezone_label' + (showTz ? '' : noDisplay) + '">' + o.timezoneText + '</dt>';
				html += '<dd class="ui_tpicker_timezone' + (showTz ? '' : noDisplay) + '"></dd>';

				// Create the elements from string
				html += '</dl></div>';
				var $tp = $(html);

				// if we only want time picker...
				if (o.timeOnly === true) {
					$tp.prepend('<div class="ui-widget-header ui-helper-clearfix ui-corner-all">' + '<div class="ui-datepicker-title">' + o.timeOnlyTitle + '</div>' + '</div>');
					$dp.find('.ui-datepicker-header, .ui-datepicker-calendar').hide();
				}

				// add sliders, adjust grids, add events
				for (i = 0, l = tp_inst.units.length; i < l; i++) {
					litem = tp_inst.units[i];
					uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1);
					show = o['show' + uitem] !== null ? o['show' + uitem] : this.support[litem];

					// add the slider
					tp_inst[litem + '_slider'] = tp_inst.control.create(tp_inst, $tp.find('.ui_tpicker_' + litem + '_slider'), litem, tp_inst[litem], o[litem + 'Min'], max[litem], o['step' + uitem]);

					// adjust the grid and add click event
					if (show && o[litem + 'Grid'] > 0) {
						size = 100 * gridSize[litem] * o[litem + 'Grid'] / (max[litem] - o[litem + 'Min']);
						$tp.find('.ui_tpicker_' + litem + ' table').css({
							width: size + "%",
							marginLeft: o.isRTL ? '0' : ((size / (-2 * gridSize[litem])) + "%"),
							marginRight: o.isRTL ? ((size / (-2 * gridSize[litem])) + "%") : '0',
							borderCollapse: 'collapse'
						}).find("td").click(function (e) {
								var $t = $(this),
									h = $t.html(),
									n = parseInt(h.replace(/[^0-9]/g), 10),
									ap = h.replace(/[^apm]/ig),
									f = $t.data('for'); // loses scope, so we use data-for

								if (f === 'hour') {
									if (ap.indexOf('p') !== -1 && n < 12) {
										n += 12;
									}
									else {
										if (ap.indexOf('a') !== -1 && n === 12) {
											n = 0;
										}
									}
								}

								tp_inst.control.value(tp_inst, tp_inst[f + '_slider'], litem, n);

								tp_inst._onTimeChange();
								tp_inst._onSelectHandler();
							}).css({
								cursor: 'pointer',
								width: (100 / gridSize[litem]) + '%',
								textAlign: 'center',
								overflow: 'hidden'
							});
					} // end if grid > 0
				} // end for loop

				// Add timezone options
				this.timezone_select = $tp.find('.ui_tpicker_timezone').append('<select></select>').find("select");
				$.fn.append.apply(this.timezone_select,
				$.map(o.timezoneList, function (val, idx) {
					return $("<option />").val(typeof val === "object" ? val.value : val).text(typeof val === "object" ? val.label : val);
				}));
				if (typeof(this.timezone) !== "undefined" && this.timezone !== null && this.timezone !== "") {
					var local_timezone = (new Date(this.inst.selectedYear, this.inst.selectedMonth, this.inst.selectedDay, 12)).getTimezoneOffset() * -1;
					if (local_timezone === this.timezone) {
						selectLocalTimezone(tp_inst);
					} else {
						this.timezone_select.val(this.timezone);
					}
				} else {
					if (typeof(this.hour) !== "undefined" && this.hour !== null && this.hour !== "") {
						this.timezone_select.val(o.timezone);
					} else {
						selectLocalTimezone(tp_inst);
					}
				}
				this.timezone_select.change(function () {
					tp_inst._onTimeChange();
					tp_inst._onSelectHandler();
					tp_inst._afterInject();
				});
				// End timezone options

				// inject timepicker into datepicker
				var $buttonPanel = $dp.find('.ui-datepicker-buttonpane');
				if ($buttonPanel.length) {
					$buttonPanel.before($tp);
				} else {
					$dp.append($tp);
				}

				this.$timeObj = $tp.find('.ui_tpicker_time_input');
				this.$timeObj.change(function () {
					var timeFormat = tp_inst.inst.settings.timeFormat;
					var parsedTime = $.datepicker.parseTime(timeFormat, this.value);
					var update = new Date();
					if (parsedTime) {
						update.setHours(parsedTime.hour);
						update.setMinutes(parsedTime.minute);
						update.setSeconds(parsedTime.second);
						$.datepicker._setTime(tp_inst.inst, update);
					} else {
						this.value = tp_inst.formattedTime;
						this.blur();
					}
				});

				if (this.inst !== null) {
					var timeDefined = this.timeDefined;
					this._onTimeChange();
					this.timeDefined = timeDefined;
				}

				// slideAccess integration: http://trentrichardson.com/2011/11/11/jquery-ui-sliders-and-touch-accessibility/
				if (this._defaults.addSliderAccess) {
					var sliderAccessArgs = this._defaults.sliderAccessArgs,
						rtl = this._defaults.isRTL;
					sliderAccessArgs.isRTL = rtl;

					setTimeout(function () { // fix for inline mode
						if ($tp.find('.ui-slider-access').length === 0) {
							$tp.find('.ui-slider:visible').sliderAccess(sliderAccessArgs);

							// fix any grids since sliders are shorter
							var sliderAccessWidth = $tp.find('.ui-slider-access:eq(0)').outerWidth(true);
							if (sliderAccessWidth) {
								$tp.find('table:visible').each(function () {
									var $g = $(this),
										oldWidth = $g.outerWidth(),
										oldMarginLeft = $g.css(rtl ? 'marginRight' : 'marginLeft').toString().replace('%', ''),
										newWidth = oldWidth - sliderAccessWidth,
										newMarginLeft = ((oldMarginLeft * newWidth) / oldWidth) + '%',
										css = { width: newWidth, marginRight: 0, marginLeft: 0 };
									css[rtl ? 'marginRight' : 'marginLeft'] = newMarginLeft;
									$g.css(css);
								});
							}
						}
					}, 10);
				}
				// end slideAccess integration

				tp_inst._limitMinMaxDateTime(this.inst, true);
			}
		},

		/*
		* This function tries to limit the ability to go outside the
		* min/max date range
		*/
		_limitMinMaxDateTime: function (dp_inst, adjustSliders) {
			var o = this._defaults,
				dp_date = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay);

			if (!this._defaults.showTimepicker) {
				return;
			} // No time so nothing to check here

			if ($.datepicker._get(dp_inst, 'minDateTime') !== null && $.datepicker._get(dp_inst, 'minDateTime') !== undefined && dp_date) {
				var minDateTime = $.datepicker._get(dp_inst, 'minDateTime'),
					minDateTimeDate = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMinOriginal === null || this.minuteMinOriginal === null || this.secondMinOriginal === null || this.millisecMinOriginal === null || this.microsecMinOriginal === null) {
					this.hourMinOriginal = o.hourMin;
					this.minuteMinOriginal = o.minuteMin;
					this.secondMinOriginal = o.secondMin;
					this.millisecMinOriginal = o.millisecMin;
					this.microsecMinOriginal = o.microsecMin;
				}

				if (dp_inst.settings.timeOnly || minDateTimeDate.getTime() === dp_date.getTime()) {
					this._defaults.hourMin = minDateTime.getHours();
					if (this.hour <= this._defaults.hourMin) {
						this.hour = this._defaults.hourMin;
						this._defaults.minuteMin = minDateTime.getMinutes();
						if (this.minute <= this._defaults.minuteMin) {
							this.minute = this._defaults.minuteMin;
							this._defaults.secondMin = minDateTime.getSeconds();
							if (this.second <= this._defaults.secondMin) {
								this.second = this._defaults.secondMin;
								this._defaults.millisecMin = minDateTime.getMilliseconds();
								if (this.millisec <= this._defaults.millisecMin) {
									this.millisec = this._defaults.millisecMin;
									this._defaults.microsecMin = minDateTime.getMicroseconds();
								} else {
									if (this.microsec < this._defaults.microsecMin) {
										this.microsec = this._defaults.microsecMin;
									}
									this._defaults.microsecMin = this.microsecMinOriginal;
								}
							} else {
								this._defaults.millisecMin = this.millisecMinOriginal;
								this._defaults.microsecMin = this.microsecMinOriginal;
							}
						} else {
							this._defaults.secondMin = this.secondMinOriginal;
							this._defaults.millisecMin = this.millisecMinOriginal;
							this._defaults.microsecMin = this.microsecMinOriginal;
						}
					} else {
						this._defaults.minuteMin = this.minuteMinOriginal;
						this._defaults.secondMin = this.secondMinOriginal;
						this._defaults.millisecMin = this.millisecMinOriginal;
						this._defaults.microsecMin = this.microsecMinOriginal;
					}
				} else {
					this._defaults.hourMin = this.hourMinOriginal;
					this._defaults.minuteMin = this.minuteMinOriginal;
					this._defaults.secondMin = this.secondMinOriginal;
					this._defaults.millisecMin = this.millisecMinOriginal;
					this._defaults.microsecMin = this.microsecMinOriginal;
				}
			}

			if ($.datepicker._get(dp_inst, 'maxDateTime') !== null && $.datepicker._get(dp_inst, 'maxDateTime') !== undefined && dp_date) {
				var maxDateTime = $.datepicker._get(dp_inst, 'maxDateTime'),
					maxDateTimeDate = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMaxOriginal === null || this.minuteMaxOriginal === null || this.secondMaxOriginal === null || this.millisecMaxOriginal === null) {
					this.hourMaxOriginal = o.hourMax;
					this.minuteMaxOriginal = o.minuteMax;
					this.secondMaxOriginal = o.secondMax;
					this.millisecMaxOriginal = o.millisecMax;
					this.microsecMaxOriginal = o.microsecMax;
				}

				if (dp_inst.settings.timeOnly || maxDateTimeDate.getTime() === dp_date.getTime()) {
					this._defaults.hourMax = maxDateTime.getHours();
					if (this.hour >= this._defaults.hourMax) {
						this.hour = this._defaults.hourMax;
						this._defaults.minuteMax = maxDateTime.getMinutes();
						if (this.minute >= this._defaults.minuteMax) {
							this.minute = this._defaults.minuteMax;
							this._defaults.secondMax = maxDateTime.getSeconds();
							if (this.second >= this._defaults.secondMax) {
								this.second = this._defaults.secondMax;
								this._defaults.millisecMax = maxDateTime.getMilliseconds();
								if (this.millisec >= this._defaults.millisecMax) {
									this.millisec = this._defaults.millisecMax;
									this._defaults.microsecMax = maxDateTime.getMicroseconds();
								} else {
									if (this.microsec > this._defaults.microsecMax) {
										this.microsec = this._defaults.microsecMax;
									}
									this._defaults.microsecMax = this.microsecMaxOriginal;
								}
							} else {
								this._defaults.millisecMax = this.millisecMaxOriginal;
								this._defaults.microsecMax = this.microsecMaxOriginal;
							}
						} else {
							this._defaults.secondMax = this.secondMaxOriginal;
							this._defaults.millisecMax = this.millisecMaxOriginal;
							this._defaults.microsecMax = this.microsecMaxOriginal;
						}
					} else {
						this._defaults.minuteMax = this.minuteMaxOriginal;
						this._defaults.secondMax = this.secondMaxOriginal;
						this._defaults.millisecMax = this.millisecMaxOriginal;
						this._defaults.microsecMax = this.microsecMaxOriginal;
					}
				} else {
					this._defaults.hourMax = this.hourMaxOriginal;
					this._defaults.minuteMax = this.minuteMaxOriginal;
					this._defaults.secondMax = this.secondMaxOriginal;
					this._defaults.millisecMax = this.millisecMaxOriginal;
					this._defaults.microsecMax = this.microsecMaxOriginal;
				}
			}

			if (dp_inst.settings.minTime!==null) {
				var tempMinTime=new Date("01/01/1970 " + dp_inst.settings.minTime);
				if (this.hour<tempMinTime.getHours()) {
					this.hour=this._defaults.hourMin=tempMinTime.getHours();
					this.minute=this._defaults.minuteMin=tempMinTime.getMinutes();
				} else if (this.hour===tempMinTime.getHours() && this.minute<tempMinTime.getMinutes()) {
					this.minute=this._defaults.minuteMin=tempMinTime.getMinutes();
				} else {
					if (this._defaults.hourMin<tempMinTime.getHours()) {
						this._defaults.hourMin=tempMinTime.getHours();
						this._defaults.minuteMin=tempMinTime.getMinutes();
					} else if (this._defaults.hourMin===tempMinTime.getHours()===this.hour && this._defaults.minuteMin<tempMinTime.getMinutes()) {
						this._defaults.minuteMin=tempMinTime.getMinutes();
					} else {
						this._defaults.minuteMin=0;
					}
				}
			}

			if (dp_inst.settings.maxTime!==null) {
				var tempMaxTime=new Date("01/01/1970 " + dp_inst.settings.maxTime);
				if (this.hour>tempMaxTime.getHours()) {
					this.hour=this._defaults.hourMax=tempMaxTime.getHours();
					this.minute=this._defaults.minuteMax=tempMaxTime.getMinutes();
				} else if (this.hour===tempMaxTime.getHours() && this.minute>tempMaxTime.getMinutes()) {
					this.minute=this._defaults.minuteMax=tempMaxTime.getMinutes();
				} else {
					if (this._defaults.hourMax>tempMaxTime.getHours()) {
						this._defaults.hourMax=tempMaxTime.getHours();
						this._defaults.minuteMax=tempMaxTime.getMinutes();
					} else if (this._defaults.hourMax===tempMaxTime.getHours()===this.hour && this._defaults.minuteMax>tempMaxTime.getMinutes()) {
						this._defaults.minuteMax=tempMaxTime.getMinutes();
					} else {
						this._defaults.minuteMax=59;
					}
				}
			}

			if (adjustSliders !== undefined && adjustSliders === true) {
				var hourMax = parseInt((this._defaults.hourMax - ((this._defaults.hourMax - this._defaults.hourMin) % this._defaults.stepHour)), 10),
					minMax = parseInt((this._defaults.minuteMax - ((this._defaults.minuteMax - this._defaults.minuteMin) % this._defaults.stepMinute)), 10),
					secMax = parseInt((this._defaults.secondMax - ((this._defaults.secondMax - this._defaults.secondMin) % this._defaults.stepSecond)), 10),
					millisecMax = parseInt((this._defaults.millisecMax - ((this._defaults.millisecMax - this._defaults.millisecMin) % this._defaults.stepMillisec)), 10),
					microsecMax = parseInt((this._defaults.microsecMax - ((this._defaults.microsecMax - this._defaults.microsecMin) % this._defaults.stepMicrosec)), 10);

				if (this.hour_slider) {
					this.control.options(this, this.hour_slider, 'hour', { min: this._defaults.hourMin, max: hourMax, step: this._defaults.stepHour });
					this.control.value(this, this.hour_slider, 'hour', this.hour - (this.hour % this._defaults.stepHour));
				}
				if (this.minute_slider) {
					this.control.options(this, this.minute_slider, 'minute', { min: this._defaults.minuteMin, max: minMax, step: this._defaults.stepMinute });
					this.control.value(this, this.minute_slider, 'minute', this.minute - (this.minute % this._defaults.stepMinute));
				}
				if (this.second_slider) {
					this.control.options(this, this.second_slider, 'second', { min: this._defaults.secondMin, max: secMax, step: this._defaults.stepSecond });
					this.control.value(this, this.second_slider, 'second', this.second - (this.second % this._defaults.stepSecond));
				}
				if (this.millisec_slider) {
					this.control.options(this, this.millisec_slider, 'millisec', { min: this._defaults.millisecMin, max: millisecMax, step: this._defaults.stepMillisec });
					this.control.value(this, this.millisec_slider, 'millisec', this.millisec - (this.millisec % this._defaults.stepMillisec));
				}
				if (this.microsec_slider) {
					this.control.options(this, this.microsec_slider, 'microsec', { min: this._defaults.microsecMin, max: microsecMax, step: this._defaults.stepMicrosec });
					this.control.value(this, this.microsec_slider, 'microsec', this.microsec - (this.microsec % this._defaults.stepMicrosec));
				}
			}

		},

		/*
		* when a slider moves, set the internal time...
		* on time change is also called when the time is updated in the text field
		*/
		_onTimeChange: function () {
			if (!this._defaults.showTimepicker) {
                                return;
			}
			var hour = (this.hour_slider) ? this.control.value(this, this.hour_slider, 'hour') : false,
				minute = (this.minute_slider) ? this.control.value(this, this.minute_slider, 'minute') : false,
				second = (this.second_slider) ? this.control.value(this, this.second_slider, 'second') : false,
				millisec = (this.millisec_slider) ? this.control.value(this, this.millisec_slider, 'millisec') : false,
				microsec = (this.microsec_slider) ? this.control.value(this, this.microsec_slider, 'microsec') : false,
				timezone = (this.timezone_select) ? this.timezone_select.val() : false,
				o = this._defaults,
				pickerTimeFormat = o.pickerTimeFormat || o.timeFormat,
				pickerTimeSuffix = o.pickerTimeSuffix || o.timeSuffix;

			if (typeof(hour) === 'object') {
				hour = false;
			}
			if (typeof(minute) === 'object') {
				minute = false;
			}
			if (typeof(second) === 'object') {
				second = false;
			}
			if (typeof(millisec) === 'object') {
				millisec = false;
			}
			if (typeof(microsec) === 'object') {
				microsec = false;
			}
			if (typeof(timezone) === 'object') {
				timezone = false;
			}

			if (hour !== false) {
				hour = parseInt(hour, 10);
			}
			if (minute !== false) {
				minute = parseInt(minute, 10);
			}
			if (second !== false) {
				second = parseInt(second, 10);
			}
			if (millisec !== false) {
				millisec = parseInt(millisec, 10);
			}
			if (microsec !== false) {
				microsec = parseInt(microsec, 10);
			}
			if (timezone !== false) {
				timezone = timezone.toString();
			}

			var ampm = o[hour < 12 ? 'amNames' : 'pmNames'][0];

			// If the update was done in the input field, the input field should not be updated.
			// If the update was done using the sliders, update the input field.
			var hasChanged = (
						hour !== parseInt(this.hour,10) || // sliders should all be numeric
						minute !== parseInt(this.minute,10) ||
						second !== parseInt(this.second,10) ||
						millisec !== parseInt(this.millisec,10) ||
						microsec !== parseInt(this.microsec,10) ||
						(this.ampm.length > 0 && (hour < 12) !== ($.inArray(this.ampm.toUpperCase(), this.amNames) !== -1)) ||
						(this.timezone !== null && timezone !== this.timezone.toString()) // could be numeric or "EST" format, so use toString()
					);

			if (hasChanged) {

				if (hour !== false) {
					this.hour = hour;
				}
				if (minute !== false) {
					this.minute = minute;
				}
				if (second !== false) {
					this.second = second;
				}
				if (millisec !== false) {
					this.millisec = millisec;
				}
				if (microsec !== false) {
					this.microsec = microsec;
				}
				if (timezone !== false) {
					this.timezone = timezone;
				}

				if (!this.inst) {
					this.inst = $.datepicker._getInst(this.$input[0]);
				}

				this._limitMinMaxDateTime(this.inst, true);
			}
			if (this.support.ampm) {
				this.ampm = ampm;
			}

			// Updates the time within the timepicker
			this.formattedTime = $.datepicker.formatTime(o.timeFormat, this, o);
			if (this.$timeObj) {
				if (pickerTimeFormat === o.timeFormat) {
					this.$timeObj.val(this.formattedTime + pickerTimeSuffix);
				}
				else {
					this.$timeObj.val($.datepicker.formatTime(pickerTimeFormat, this, o) + pickerTimeSuffix);
				}
				if (this.$timeObj[0].setSelectionRange) {
					var sPos = this.$timeObj[0].selectionStart;
					var ePos = this.$timeObj[0].selectionEnd;
					this.$timeObj[0].setSelectionRange(sPos, ePos);
				}
			}

			this.timeDefined = true;
			if (hasChanged) {
				this._updateDateTime();
				//this.$input.focus(); // may automatically open the picker on setDate
			}
		},

		/*
		* call custom onSelect.
		* bind to sliders slidestop, and grid click.
		*/
		_onSelectHandler: function () {
			var onSelect = this._defaults.onSelect || this.inst.settings.onSelect;
			var inputEl = this.$input ? this.$input[0] : null;
			if (onSelect && inputEl) {
				onSelect.apply(inputEl, [this.formattedDateTime, this]);
			}
		},

		/*
		* update our input with the new date time..
		*/
		_updateDateTime: function (dp_inst) {
			dp_inst = this.inst || dp_inst;
			var dtTmp = (dp_inst.currentYear > 0?
							new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay) :
							new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay)),
				dt = $.datepicker._daylightSavingAdjust(dtTmp),
				//dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay)),
				//dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay)),
				dateFmt = $.datepicker._get(dp_inst, 'dateFormat'),
				formatCfg = $.datepicker._getFormatConfig(dp_inst),
				timeAvailable = dt !== null && this.timeDefined;
			this.formattedDate = $.datepicker.formatDate(dateFmt, (dt === null ? new Date() : dt), formatCfg);
			var formattedDateTime = this.formattedDate;

			// if a slider was changed but datepicker doesn't have a value yet, set it
			if (dp_inst.lastVal === "") {
                dp_inst.currentYear = dp_inst.selectedYear;
                dp_inst.currentMonth = dp_inst.selectedMonth;
                dp_inst.currentDay = dp_inst.selectedDay;
            }

			/*
			* remove following lines to force every changes in date picker to change the input value
			* Bug descriptions: when an input field has a default value, and click on the field to pop up the date picker.
			* If the user manually empty the value in the input field, the date picker will never change selected value.
			*/
			//if (dp_inst.lastVal !== undefined && (dp_inst.lastVal.length > 0 && this.$input.val().length === 0)) {
			//	return;
			//}

			if (this._defaults.timeOnly === true && this._defaults.timeOnlyShowDate === false) {
				formattedDateTime = this.formattedTime;
			} else if ((this._defaults.timeOnly !== true && (this._defaults.alwaysSetTime || timeAvailable)) || (this._defaults.timeOnly === true && this._defaults.timeOnlyShowDate === true)) {
				formattedDateTime += this._defaults.separator + this.formattedTime + this._defaults.timeSuffix;
			}

			this.formattedDateTime = formattedDateTime;

			if (!this._defaults.showTimepicker) {
				this.$input.val(this.formattedDate);
			} else if (this.$altInput && this._defaults.timeOnly === false && this._defaults.altFieldTimeOnly === true) {
				this.$altInput.val(this.formattedTime);
				this.$input.val(this.formattedDate);
			} else if (this.$altInput) {
				this.$input.val(formattedDateTime);
				var altFormattedDateTime = '',
					altSeparator = this._defaults.altSeparator !== null ? this._defaults.altSeparator : this._defaults.separator,
					altTimeSuffix = this._defaults.altTimeSuffix !== null ? this._defaults.altTimeSuffix : this._defaults.timeSuffix;

				if (!this._defaults.timeOnly) {
					if (this._defaults.altFormat) {
						altFormattedDateTime = $.datepicker.formatDate(this._defaults.altFormat, (dt === null ? new Date() : dt), formatCfg);
					}
					else {
						altFormattedDateTime = this.formattedDate;
					}

					if (altFormattedDateTime) {
						altFormattedDateTime += altSeparator;
					}
				}

				if (this._defaults.altTimeFormat !== null) {
					altFormattedDateTime += $.datepicker.formatTime(this._defaults.altTimeFormat, this, this._defaults) + altTimeSuffix;
				}
				else {
					altFormattedDateTime += this.formattedTime + altTimeSuffix;
				}
				this.$altInput.val(altFormattedDateTime);
			} else {
				this.$input.val(formattedDateTime);
			}

			this.$input.trigger("change");
		},

		_onFocus: function () {
			if (!this.$input.val() && this._defaults.defaultValue) {
				this.$input.val(this._defaults.defaultValue);
				var inst = $.datepicker._getInst(this.$input.get(0)),
					tp_inst = $.datepicker._get(inst, 'timepicker');
				if (tp_inst) {
					if (tp_inst._defaults.timeOnly && (inst.input.val() !== inst.lastVal)) {
						try {
							$.datepicker._updateDatepicker(inst);
						} catch (err) {
							$.timepicker.log(err);
						}
					}
				}
			}
		},

		/*
		* Small abstraction to control types
		* We can add more, just be sure to follow the pattern: create, options, value
		*/
		_controls: {
			// slider methods
			slider: {
				create: function (tp_inst, obj, unit, val, min, max, step) {
					var rtl = tp_inst._defaults.isRTL; // if rtl go -60->0 instead of 0->60
					return obj.prop('slide', null).slider({
						orientation: "horizontal",
						value: rtl ? val * -1 : val,
						min: rtl ? max * -1 : min,
						max: rtl ? min * -1 : max,
						step: step,
						slide: function (event, ui) {
							tp_inst.control.value(tp_inst, $(this), unit, rtl ? ui.value * -1 : ui.value);
							tp_inst._onTimeChange();
						},
						stop: function (event, ui) {
							tp_inst._onSelectHandler();
						}
					});
				},
				options: function (tp_inst, obj, unit, opts, val) {
					if (tp_inst._defaults.isRTL) {
						if (typeof(opts) === 'string') {
							if (opts === 'min' || opts === 'max') {
								if (val !== undefined) {
									return obj.slider(opts, val * -1);
								}
								return Math.abs(obj.slider(opts));
							}
							return obj.slider(opts);
						}
						var min = opts.min,
							max = opts.max;
						opts.min = opts.max = null;
						if (min !== undefined) {
							opts.max = min * -1;
						}
						if (max !== undefined) {
							opts.min = max * -1;
						}
						return obj.slider(opts);
					}
					if (typeof(opts) === 'string' && val !== undefined) {
						return obj.slider(opts, val);
					}
					return obj.slider(opts);
				},
				value: function (tp_inst, obj, unit, val) {
					if (tp_inst._defaults.isRTL) {
						if (val !== undefined) {
							return obj.slider('value', val * -1);
						}
						return Math.abs(obj.slider('value'));
					}
					if (val !== undefined) {
						return obj.slider('value', val);
					}
					return obj.slider('value');
				}
			},
			// select methods
			select: {
				create: function (tp_inst, obj, unit, val, min, max, step) {
					var sel = '<select class="ui-timepicker-select ui-state-default ui-corner-all" data-unit="' + unit + '" data-min="' + min + '" data-max="' + max + '" data-step="' + step + '">',
						format = tp_inst._defaults.pickerTimeFormat || tp_inst._defaults.timeFormat;

					for (var i = min; i <= max; i += step) {
						sel += '<option value="' + i + '"' + (i === val ? ' selected' : '') + '>';
						if (unit === 'hour') {
							sel += $.datepicker.formatTime($.trim(format.replace(/[^ht ]/ig, '')), {hour: i}, tp_inst._defaults);
						}
						else if (unit === 'millisec' || unit === 'microsec' || i >= 10) { sel += i; }
						else {sel += '0' + i.toString(); }
						sel += '</option>';
					}
					sel += '</select>';

					obj.children('select').remove();

					$(sel).appendTo(obj).change(function (e) {
						tp_inst._onTimeChange();
						tp_inst._onSelectHandler();
						tp_inst._afterInject();
					});

					return obj;
				},
				options: function (tp_inst, obj, unit, opts, val) {
					var o = {},
						$t = obj.children('select');
					if (typeof(opts) === 'string') {
						if (val === undefined) {
							return $t.data(opts);
						}
						o[opts] = val;
					}
					else { o = opts; }
					return tp_inst.control.create(tp_inst, obj, $t.data('unit'), $t.val(), o.min>=0 ? o.min : $t.data('min'), o.max || $t.data('max'), o.step || $t.data('step'));
				},
				value: function (tp_inst, obj, unit, val) {
					var $t = obj.children('select');
					if (val !== undefined) {
						return $t.val(val);
					}
					return $t.val();
				}
			}
		} // end _controls

	});

	$.fn.extend({
		/*
		* shorthand just to use timepicker.
		*/
		timepicker: function (o) {
			o = o || {};
			var tmp_args = Array.prototype.slice.call(arguments);

			if (typeof o === 'object') {
				tmp_args[0] = $.extend(o, {
					timeOnly: true
				});
			}

			return $(this).each(function () {
				$.fn.datetimepicker.apply($(this), tmp_args);
			});
		},

		/*
		* extend timepicker to datepicker
		*/
		datetimepicker: function (o) {
			o = o || {};
			var tmp_args = arguments;

			if (typeof(o) === 'string') {
				if (o === 'getDate'  || (o === 'option' && tmp_args.length === 2 && typeof (tmp_args[1]) === 'string')) {
					return $.fn.datepicker.apply($(this[0]), tmp_args);
				} else {
					return this.each(function () {
						var $t = $(this);
						$t.datepicker.apply($t, tmp_args);
					});
				}
			} else {
				return this.each(function () {
					var $t = $(this);
					$t.datepicker($.timepicker._newInst($t, o)._defaults);
				});
			}
		}
	});

	/*
	* Public Utility to parse date and time
	*/
	$.datepicker.parseDateTime = function (dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var parseRes = parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings);
		if (parseRes.timeObj) {
			var t = parseRes.timeObj;
			parseRes.date.setHours(t.hour, t.minute, t.second, t.millisec);
			parseRes.date.setMicroseconds(t.microsec);
		}

		return parseRes.date;
	};

	/*
	* Public utility to parse time
	*/
	$.datepicker.parseTime = function (timeFormat, timeString, options) {
		var o = extendRemove(extendRemove({}, $.timepicker._defaults), options || {}),
			iso8601 = (timeFormat.replace(/\'.*?\'/g, '').indexOf('Z') !== -1);

		// Strict parse requires the timeString to match the timeFormat exactly
		var strictParse = function (f, s, o) {

			// pattern for standard and localized AM/PM markers
			var getPatternAmpm = function (amNames, pmNames) {
				var markers = [];
				if (amNames) {
					$.merge(markers, amNames);
				}
				if (pmNames) {
					$.merge(markers, pmNames);
				}
				markers = $.map(markers, function (val) {
					return val.replace(/[.*+?|()\[\]{}\\]/g, '\\$&');
				});
				return '(' + markers.join('|') + ')?';
			};

			// figure out position of time elements.. cause js cant do named captures
			var getFormatPositions = function (timeFormat) {
				var finds = timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|c{1}|t{1,2}|z|'.*?')/g),
					orders = {
						h: -1,
						m: -1,
						s: -1,
						l: -1,
						c: -1,
						t: -1,
						z: -1
					};

				if (finds) {
					for (var i = 0; i < finds.length; i++) {
						if (orders[finds[i].toString().charAt(0)] === -1) {
							orders[finds[i].toString().charAt(0)] = i + 1;
						}
					}
				}
				return orders;
			};

			var regstr = '^' + f.toString()
					.replace(/([hH]{1,2}|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function (match) {
							var ml = match.length;
							switch (match.charAt(0).toLowerCase()) {
							case 'h':
								return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
							case 'm':
								return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
							case 's':
								return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
							case 'l':
								return '(\\d?\\d?\\d)';
							case 'c':
								return '(\\d?\\d?\\d)';
							case 'z':
								return '(z|[-+]\\d\\d:?\\d\\d|\\S+)?';
							case 't':
								return getPatternAmpm(o.amNames, o.pmNames);
							default:    // literal escaped in quotes
								return '(' + match.replace(/\'/g, "").replace(/(\.|\$|\^|\\|\/|\(|\)|\[|\]|\?|\+|\*)/g, function (m) { return "\\" + m; }) + ')?';
							}
						})
					.replace(/\s/g, '\\s?') +
					o.timeSuffix + '$',
				order = getFormatPositions(f),
				ampm = '',
				treg;

			treg = s.match(new RegExp(regstr, 'i'));

			var resTime = {
				hour: 0,
				minute: 0,
				second: 0,
				millisec: 0,
				microsec: 0
			};

			if (treg) {
				if (order.t !== -1) {
					if (treg[order.t] === undefined || treg[order.t].length === 0) {
						ampm = '';
						resTime.ampm = '';
					} else {
						ampm = $.inArray(treg[order.t].toUpperCase(), $.map(o.amNames, function (x,i) { return x.toUpperCase(); })) !== -1 ? 'AM' : 'PM';
						resTime.ampm = o[ampm === 'AM' ? 'amNames' : 'pmNames'][0];
					}
				}

				if (order.h !== -1) {
					if (ampm === 'AM' && treg[order.h] === '12') {
						resTime.hour = 0; // 12am = 0 hour
					} else {
						if (ampm === 'PM' && treg[order.h] !== '12') {
							resTime.hour = parseInt(treg[order.h], 10) + 12; // 12pm = 12 hour, any other pm = hour + 12
						} else {
							resTime.hour = Number(treg[order.h]);
						}
					}
				}

				if (order.m !== -1) {
					resTime.minute = Number(treg[order.m]);
				}
				if (order.s !== -1) {
					resTime.second = Number(treg[order.s]);
				}
				if (order.l !== -1) {
					resTime.millisec = Number(treg[order.l]);
				}
				if (order.c !== -1) {
					resTime.microsec = Number(treg[order.c]);
				}
				if (order.z !== -1 && treg[order.z] !== undefined) {
					resTime.timezone = $.timepicker.timezoneOffsetNumber(treg[order.z]);
				}


				return resTime;
			}
			return false;
		};// end strictParse

		// First try JS Date, if that fails, use strictParse
		var looseParse = function (f, s, o) {
			try {
				var d = new Date('2012-01-01 ' + s);
				if (isNaN(d.getTime())) {
					d = new Date('2012-01-01T' + s);
					if (isNaN(d.getTime())) {
						d = new Date('01/01/2012 ' + s);
						if (isNaN(d.getTime())) {
							throw "Unable to parse time with native Date: " + s;
						}
					}
				}

				return {
					hour: d.getHours(),
					minute: d.getMinutes(),
					second: d.getSeconds(),
					millisec: d.getMilliseconds(),
					microsec: d.getMicroseconds(),
					timezone: d.getTimezoneOffset() * -1
				};
			}
			catch (err) {
				try {
					return strictParse(f, s, o);
				}
				catch (err2) {
					$.timepicker.log("Unable to parse \ntimeString: " + s + "\ntimeFormat: " + f);
				}
			}
			return false;
		}; // end looseParse

		if (typeof o.parse === "function") {
			return o.parse(timeFormat, timeString, o);
		}
		if (o.parse === 'loose') {
			return looseParse(timeFormat, timeString, o);
		}
		return strictParse(timeFormat, timeString, o);
	};

	/**
	 * Public utility to format the time
	 * @param {string} format format of the time
	 * @param {Object} time Object not a Date for timezones
	 * @param {Object} [options] essentially the regional[].. amNames, pmNames, ampm
	 * @returns {string} the formatted time
	 */
	$.datepicker.formatTime = function (format, time, options) {
		options = options || {};
		options = $.extend({}, $.timepicker._defaults, options);
		time = $.extend({
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			microsec: 0,
			timezone: null
		}, time);

		var tmptime = format,
			ampmName = options.amNames[0],
			hour = parseInt(time.hour, 10);

		if (hour > 11) {
			ampmName = options.pmNames[0];
		}

		tmptime = tmptime.replace(/(?:HH?|hh?|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function (match) {
			switch (match) {
			case 'HH':
				return ('0' + hour).slice(-2);
			case 'H':
				return hour;
			case 'hh':
				return ('0' + convert24to12(hour)).slice(-2);
			case 'h':
				return convert24to12(hour);
			case 'mm':
				return ('0' + time.minute).slice(-2);
			case 'm':
				return time.minute;
			case 'ss':
				return ('0' + time.second).slice(-2);
			case 's':
				return time.second;
			case 'l':
				return ('00' + time.millisec).slice(-3);
			case 'c':
				return ('00' + time.microsec).slice(-3);
			case 'z':
				return $.timepicker.timezoneOffsetString(time.timezone === null ? options.timezone : time.timezone, false);
			case 'Z':
				return $.timepicker.timezoneOffsetString(time.timezone === null ? options.timezone : time.timezone, true);
			case 'T':
				return ampmName.charAt(0).toUpperCase();
			case 'TT':
				return ampmName.toUpperCase();
			case 't':
				return ampmName.charAt(0).toLowerCase();
			case 'tt':
				return ampmName.toLowerCase();
			default:
				return match.replace(/'/g, "");
			}
		});

		return tmptime;
	};

	/*
	* the bad hack :/ override datepicker so it doesn't close on select
	// inspired: http://stackoverflow.com/questions/1252512/jquery-datepicker-prevent-closing-picker-when-clicking-a-date/1762378#1762378
	*/
	$.datepicker._base_selectDate = $.datepicker._selectDate;
	$.datepicker._selectDate = function (id, dateStr) {
		var inst = this._getInst($(id)[0]),
			tp_inst = this._get(inst, 'timepicker'),
			was_inline;

		if (tp_inst && inst.settings.showTimepicker) {
			tp_inst._limitMinMaxDateTime(inst, true);
			was_inline = inst.inline;
			inst.inline = inst.stay_open = true;
			//This way the onSelect handler called from calendarpicker get the full dateTime
			this._base_selectDate(id, dateStr);
			inst.inline = was_inline;
			inst.stay_open = false;
			this._notifyChange(inst);
			this._updateDatepicker(inst);
		} else {
			this._base_selectDate(id, dateStr);
		}
	};

	/*
	* second bad hack :/ override datepicker so it triggers an event when changing the input field
	* and does not redraw the datepicker on every selectDate event
	*/
	$.datepicker._base_updateDatepicker = $.datepicker._updateDatepicker;
	$.datepicker._updateDatepicker = function (inst) {

		// don't popup the datepicker if there is another instance already opened
		var input = inst.input[0];
		if ($.datepicker._curInst && $.datepicker._curInst !== inst && $.datepicker._datepickerShowing && $.datepicker._lastInput !== input) {
			return;
		}

		if (typeof(inst.stay_open) !== 'boolean' || inst.stay_open === false) {

			this._base_updateDatepicker(inst);

			// Reload the time control when changing something in the input text field.
			var tp_inst = this._get(inst, 'timepicker');
			if (tp_inst) {
				tp_inst._addTimePicker(inst);
			}
		}
	};

	/*
	* third bad hack :/ override datepicker so it allows spaces and colon in the input field
	*/
	$.datepicker._base_doKeyPress = $.datepicker._doKeyPress;
	$.datepicker._doKeyPress = function (event) {
		var inst = $.datepicker._getInst(event.target),
			tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if ($.datepicker._get(inst, 'constrainInput')) {
				var ampm = tp_inst.support.ampm,
					tz = tp_inst._defaults.showTimezone !== null ? tp_inst._defaults.showTimezone : tp_inst.support.timezone,
					dateChars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat')),
					datetimeChars = tp_inst._defaults.timeFormat.toString()
											.replace(/[hms]/g, '')
											.replace(/TT/g, ampm ? 'APM' : '')
											.replace(/Tt/g, ampm ? 'AaPpMm' : '')
											.replace(/tT/g, ampm ? 'AaPpMm' : '')
											.replace(/T/g, ampm ? 'AP' : '')
											.replace(/tt/g, ampm ? 'apm' : '')
											.replace(/t/g, ampm ? 'ap' : '') +
											" " + tp_inst._defaults.separator +
											tp_inst._defaults.timeSuffix +
											(tz ? tp_inst._defaults.timezoneList.join('') : '') +
											(tp_inst._defaults.amNames.join('')) + (tp_inst._defaults.pmNames.join('')) +
											dateChars,
					chr = String.fromCharCode(event.charCode === undefined ? event.keyCode : event.charCode);
				return event.ctrlKey || (chr < ' ' || !dateChars || datetimeChars.indexOf(chr) > -1);
			}
		}

		return $.datepicker._base_doKeyPress(event);
	};

	/*
	* Fourth bad hack :/ override _updateAlternate function used in inline mode to init altField
	* Update any alternate field to synchronise with the main field.
	*/
	$.datepicker._base_updateAlternate = $.datepicker._updateAlternate;
	$.datepicker._updateAlternate = function (inst) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var altField = tp_inst._defaults.altField;
			if (altField) { // update alternate field too
				var altFormat = tp_inst._defaults.altFormat || tp_inst._defaults.dateFormat,
					date = this._getDate(inst),
					formatCfg = $.datepicker._getFormatConfig(inst),
					altFormattedDateTime = '',
					altSeparator = tp_inst._defaults.altSeparator ? tp_inst._defaults.altSeparator : tp_inst._defaults.separator,
					altTimeSuffix = tp_inst._defaults.altTimeSuffix ? tp_inst._defaults.altTimeSuffix : tp_inst._defaults.timeSuffix,
					altTimeFormat = tp_inst._defaults.altTimeFormat !== null ? tp_inst._defaults.altTimeFormat : tp_inst._defaults.timeFormat;

				altFormattedDateTime += $.datepicker.formatTime(altTimeFormat, tp_inst, tp_inst._defaults) + altTimeSuffix;
				if (!tp_inst._defaults.timeOnly && !tp_inst._defaults.altFieldTimeOnly && date !== null) {
					if (tp_inst._defaults.altFormat) {
						altFormattedDateTime = $.datepicker.formatDate(tp_inst._defaults.altFormat, date, formatCfg) + altSeparator + altFormattedDateTime;
					}
					else {
						altFormattedDateTime = tp_inst.formattedDate + altSeparator + altFormattedDateTime;
					}
				}
				$(altField).val( inst.input.val() ? altFormattedDateTime : "");
			}
		}
		else {
			$.datepicker._base_updateAlternate(inst);
		}
	};

	/*
	* Override key up event to sync manual input changes.
	*/
	$.datepicker._base_doKeyUp = $.datepicker._doKeyUp;
	$.datepicker._doKeyUp = function (event) {
		var inst = $.datepicker._getInst(event.target),
			tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if (tp_inst._defaults.timeOnly && (inst.input.val() !== inst.lastVal)) {
				try {
					$.datepicker._updateDatepicker(inst);
				} catch (err) {
					$.timepicker.log(err);
				}
			}
		}

		return $.datepicker._base_doKeyUp(event);
	};

	/*
	* override "Today" button to also grab the time and set it to input field.
	*/
	$.datepicker._base_gotoToday = $.datepicker._gotoToday;
	$.datepicker._gotoToday = function (id) {
		var inst = this._getInst($(id)[0]);
		this._base_gotoToday(id);
		var tp_inst = this._get(inst, 'timepicker');
		if (!tp_inst) {
		  return;
		}

		var tzoffset = $.timepicker.timezoneOffsetNumber(tp_inst.timezone);
		var now = new Date();
		now.setMinutes(now.getMinutes() + now.getTimezoneOffset() + parseInt(tzoffset, 10));
		this._setTime(inst, now);
		this._setDate(inst, now);
		tp_inst._onSelectHandler();
	};

	/*
	* Disable & enable the Time in the datetimepicker
	*/
	$.datepicker._disableTimepickerDatepicker = function (target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			inst.settings.showTimepicker = false;
			tp_inst._defaults.showTimepicker = false;
			tp_inst._updateDateTime(inst);
		}
	};

	$.datepicker._enableTimepickerDatepicker = function (target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			inst.settings.showTimepicker = true;
			tp_inst._defaults.showTimepicker = true;
			tp_inst._addTimePicker(inst); // Could be disabled on page load
			tp_inst._updateDateTime(inst);
		}
	};

	/*
	* Create our own set time function
	*/
	$.datepicker._setTime = function (inst, date) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var defaults = tp_inst._defaults;

			// calling _setTime with no date sets time to defaults
			tp_inst.hour = date ? date.getHours() : defaults.hour;
			tp_inst.minute = date ? date.getMinutes() : defaults.minute;
			tp_inst.second = date ? date.getSeconds() : defaults.second;
			tp_inst.millisec = date ? date.getMilliseconds() : defaults.millisec;
			tp_inst.microsec = date ? date.getMicroseconds() : defaults.microsec;

			//check if within min/max times..
			tp_inst._limitMinMaxDateTime(inst, true);

			tp_inst._onTimeChange();
			tp_inst._updateDateTime(inst);
		}
	};

	/*
	* Create new public method to set only time, callable as $().datepicker('setTime', date)
	*/
	$.datepicker._setTimeDatepicker = function (target, date, withDate) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			this._setDateFromField(inst);
			var tp_date;
			if (date) {
				if (typeof date === "string") {
					tp_inst._parseTime(date, withDate);
					tp_date = new Date();
					tp_date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
					tp_date.setMicroseconds(tp_inst.microsec);
				} else {
					tp_date = new Date(date.getTime());
					tp_date.setMicroseconds(date.getMicroseconds());
				}
				if (tp_date.toString() === 'Invalid Date') {
					tp_date = undefined;
				}
				this._setTime(inst, tp_date);
			}
		}

	};

	/*
	* override setDate() to allow setting time too within Date object
	*/
	$.datepicker._base_setDateDatepicker = $.datepicker._setDateDatepicker;
	$.datepicker._setDateDatepicker = function (target, _date) {
		var inst = this._getInst(target);
		var date = _date;
		if (!inst) {
			return;
		}

		if (typeof(_date) === 'string') {
			date = new Date(_date);
			if (!date.getTime()) {
				this._base_setDateDatepicker.apply(this, arguments);
				date = $(target).datepicker('getDate');
			}
		}

		var tp_inst = this._get(inst, 'timepicker');
		var tp_date;
		if (date instanceof Date) {
			tp_date = new Date(date.getTime());
			tp_date.setMicroseconds(date.getMicroseconds());
		} else {
			tp_date = date;
		}

		// This is important if you are using the timezone option, javascript's Date
		// object will only return the timezone offset for the current locale, so we
		// adjust it accordingly.  If not using timezone option this won't matter..
		// If a timezone is different in tp, keep the timezone as is
		if (tp_inst && tp_date) {
			// look out for DST if tz wasn't specified
			if (!tp_inst.support.timezone && tp_inst._defaults.timezone === null) {
				tp_inst.timezone = tp_date.getTimezoneOffset() * -1;
			}
			date = $.timepicker.timezoneAdjust(date, $.timepicker.timezoneOffsetString(-date.getTimezoneOffset()), tp_inst.timezone);
			tp_date = $.timepicker.timezoneAdjust(tp_date, $.timepicker.timezoneOffsetString(-tp_date.getTimezoneOffset()), tp_inst.timezone);
		}

		this._updateDatepicker(inst);
		this._base_setDateDatepicker.apply(this, arguments);
		this._setTimeDatepicker(target, tp_date, true);
	};

	/*
	* override getDate() to allow getting time too within Date object
	*/
	$.datepicker._base_getDateDatepicker = $.datepicker._getDateDatepicker;
	$.datepicker._getDateDatepicker = function (target, noDefault) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			// if it hasn't yet been defined, grab from field
			if (inst.lastVal === undefined) {
				this._setDateFromField(inst, noDefault);
			}

			var date = this._getDate(inst);

			var currDT = null;

			if (tp_inst.$altInput && tp_inst._defaults.altFieldTimeOnly) {
				currDT = tp_inst.$input.val() + ' ' + tp_inst.$altInput.val();
			}
			else if (tp_inst.$input.get(0).tagName !== 'INPUT' && tp_inst.$altInput) {
				/**
				 * in case the datetimepicker has been applied to a non-input tag for inline UI,
				 * and the user has not configured the plugin to display only time in altInput,
				 * pick current date time from the altInput (and hope for the best, for now, until "ER1" is applied)
				 *
				 * @todo ER1. Since altInput can have a totally difference format, convert it to standard format by reading input format from "altFormat" and "altTimeFormat" option values
				 */
				currDT = tp_inst.$altInput.val();
			}
			else {
				currDT = tp_inst.$input.val();
			}

			if (date && tp_inst._parseTime(currDT, !inst.settings.timeOnly)) {
				date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
				date.setMicroseconds(tp_inst.microsec);

				// This is important if you are using the timezone option, javascript's Date
				// object will only return the timezone offset for the current locale, so we
				// adjust it accordingly.  If not using timezone option this won't matter..
				if (tp_inst.timezone != null) {
					// look out for DST if tz wasn't specified
					if (!tp_inst.support.timezone && tp_inst._defaults.timezone === null) {
						tp_inst.timezone = date.getTimezoneOffset() * -1;
					}
					date = $.timepicker.timezoneAdjust(date, tp_inst.timezone, $.timepicker.timezoneOffsetString(-date.getTimezoneOffset()));
				}
			}
			return date;
		}
		return this._base_getDateDatepicker(target, noDefault);
	};

	/*
	* override parseDate() because UI 1.8.14 throws an error about "Extra characters"
	* An option in datapicker to ignore extra format characters would be nicer.
	*/
	$.datepicker._base_parseDate = $.datepicker.parseDate;
	$.datepicker.parseDate = function (format, value, settings) {
		var date;
		try {
			date = this._base_parseDate(format, value, settings);
		} catch (err) {
			// Hack!  The error message ends with a colon, a space, and
			// the "extra" characters.  We rely on that instead of
			// attempting to perfectly reproduce the parsing algorithm.
			if (err.indexOf(":") >= 0) {
				date = this._base_parseDate(format, value.substring(0, value.length - (err.length - err.indexOf(':') - 2)), settings);
				$.timepicker.log("Error parsing the date string: " + err + "\ndate string = " + value + "\ndate format = " + format);
			} else {
				throw err;
			}
		}
		return date;
	};

	/*
	* override formatDate to set date with time to the input
	*/
	$.datepicker._base_formatDate = $.datepicker._formatDate;
	$.datepicker._formatDate = function (inst, day, month, year) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			tp_inst._updateDateTime(inst);
			return tp_inst.$input.val();
		}
		return this._base_formatDate(inst);
	};

	/*
	* override options setter to add time to maxDate(Time) and minDate(Time). MaxDate
	*/
	$.datepicker._base_optionDatepicker = $.datepicker._optionDatepicker;
	$.datepicker._optionDatepicker = function (target, name, value) {
		var inst = this._getInst(target),
			name_clone;
		if (!inst) {
			return null;
		}

		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var min = null,
				max = null,
				onselect = null,
				overrides = tp_inst._defaults.evnts,
				fns = {},
				prop,
				ret,
				oldVal,
				$target;
			if (typeof name === 'string') { // if min/max was set with the string
				if (name === 'minDate' || name === 'minDateTime') {
					min = value;
				} else if (name === 'maxDate' || name === 'maxDateTime') {
					max = value;
				} else if (name === 'onSelect') {
					onselect = value;
				} else if (overrides.hasOwnProperty(name)) {
					if (typeof (value) === 'undefined') {
						return overrides[name];
					}
					fns[name] = value;
					name_clone = {}; //empty results in exiting function after overrides updated
				}
			} else if (typeof name === 'object') { //if min/max was set with the JSON
				if (name.minDate) {
					min = name.minDate;
				} else if (name.minDateTime) {
					min = name.minDateTime;
				} else if (name.maxDate) {
					max = name.maxDate;
				} else if (name.maxDateTime) {
					max = name.maxDateTime;
				}
				for (prop in overrides) {
					if (overrides.hasOwnProperty(prop) && name[prop]) {
						fns[prop] = name[prop];
					}
				}
			}
			for (prop in fns) {
				if (fns.hasOwnProperty(prop)) {
					overrides[prop] = fns[prop];
					if (!name_clone) { name_clone = $.extend({}, name); }
					delete name_clone[prop];
				}
			}
			if (name_clone && isEmptyObject(name_clone)) { return; }
			if (min) { //if min was set
				if (min === 0) {
					min = new Date();
				} else {
					min = new Date(min);
				}
				tp_inst._defaults.minDate = min;
				tp_inst._defaults.minDateTime = min;
			} else if (max) { //if max was set
				if (max === 0) {
					max = new Date();
				} else {
					max = new Date(max);
				}
				tp_inst._defaults.maxDate = max;
				tp_inst._defaults.maxDateTime = max;
			} else if (onselect) {
				tp_inst._defaults.onSelect = onselect;
			}

			// Datepicker will override our date when we call _base_optionDatepicker when
			// calling minDate/maxDate, so we will first grab the value, call
			// _base_optionDatepicker, then set our value back.
			if(min || max){
				$target = $(target);
				oldVal = $target.datetimepicker('getDate');
				ret = this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
				$target.datetimepicker('setDate', oldVal);
				return ret;
			}
		}
		if (value === undefined) {
			return this._base_optionDatepicker.call($.datepicker, target, name);
		}
		return this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
	};

	/*
	* jQuery isEmptyObject does not check hasOwnProperty - if someone has added to the object prototype,
	* it will return false for all objects
	*/
	var isEmptyObject = function (obj) {
		var prop;
		for (prop in obj) {
			if (obj.hasOwnProperty(prop)) {
				return false;
			}
		}
		return true;
	};

	/*
	* jQuery extend now ignores nulls!
	*/
	var extendRemove = function (target, props) {
		$.extend(target, props);
		for (var name in props) {
			if (props[name] === null || props[name] === undefined) {
				target[name] = props[name];
			}
		}
		return target;
	};

	/*
	* Determine by the time format which units are supported
	* Returns an object of booleans for each unit
	*/
	var detectSupport = function (timeFormat) {
		var tf = timeFormat.replace(/'.*?'/g, '').toLowerCase(), // removes literals
			isIn = function (f, t) { // does the format contain the token?
					return f.indexOf(t) !== -1 ? true : false;
				};
		return {
				hour: isIn(tf, 'h'),
				minute: isIn(tf, 'm'),
				second: isIn(tf, 's'),
				millisec: isIn(tf, 'l'),
				microsec: isIn(tf, 'c'),
				timezone: isIn(tf, 'z'),
				ampm: isIn(tf, 't') && isIn(timeFormat, 'h'),
				iso8601: isIn(timeFormat, 'Z')
			};
	};

	/*
	* Converts 24 hour format into 12 hour
	* Returns 12 hour without leading 0
	*/
	var convert24to12 = function (hour) {
		hour %= 12;

		if (hour === 0) {
			hour = 12;
		}

		return String(hour);
	};

	var computeEffectiveSetting = function (settings, property) {
		return settings && settings[property] ? settings[property] : $.timepicker._defaults[property];
	};

	/*
	* Splits datetime string into date and time substrings.
	* Throws exception when date can't be parsed
	* Returns {dateString: dateString, timeString: timeString}
	*/
	var splitDateTime = function (dateTimeString, timeSettings) {
		// The idea is to get the number separator occurrences in datetime and the time format requested (since time has
		// fewer unknowns, mostly numbers and am/pm). We will use the time pattern to split.
		var separator = computeEffectiveSetting(timeSettings, 'separator'),
			format = computeEffectiveSetting(timeSettings, 'timeFormat'),
			timeParts = format.split(separator), // how many occurrences of separator may be in our format?
			timePartsLen = timeParts.length,
			allParts = dateTimeString.split(separator),
			allPartsLen = allParts.length;

		if (allPartsLen > 1) {
			return {
				dateString: allParts.splice(0, allPartsLen - timePartsLen).join(separator),
				timeString: allParts.splice(0, timePartsLen).join(separator)
			};
		}

		return {
			dateString: dateTimeString,
			timeString: ''
		};
	};

	/*
	* Internal function to parse datetime interval
	* Returns: {date: Date, timeObj: Object}, where
	*   date - parsed date without time (type Date)
	*   timeObj = {hour: , minute: , second: , millisec: , microsec: } - parsed time. Optional
	*/
	var parseDateTimeInternal = function (dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var date,
			parts,
			parsedTime;

		parts = splitDateTime(dateTimeString, timeSettings);
		date = $.datepicker._base_parseDate(dateFormat, parts.dateString, dateSettings);

		if (parts.timeString === '') {
			return {
				date: date
			};
		}

		parsedTime = $.datepicker.parseTime(timeFormat, parts.timeString, timeSettings);

		if (!parsedTime) {
			throw 'Wrong time format';
		}

		return {
			date: date,
			timeObj: parsedTime
		};
	};

	/*
	* Internal function to set timezone_select to the local timezone
	*/
	var selectLocalTimezone = function (tp_inst, date) {
		if (tp_inst && tp_inst.timezone_select) {
			var now = date || new Date();
			tp_inst.timezone_select.val(-now.getTimezoneOffset());
		}
	};

	/*
	* Create a Singleton Instance
	*/
	$.timepicker = new Timepicker();

	/**
	 * Get the timezone offset as string from a date object (eg '+0530' for UTC+5.5)
	 * @param {number} tzMinutes if not a number, less than -720 (-1200), or greater than 840 (+1400) this value is returned
	 * @param {boolean} iso8601 if true formats in accordance to iso8601 "+12:45"
	 * @return {string}
	 */
	$.timepicker.timezoneOffsetString = function (tzMinutes, iso8601) {
		if (isNaN(tzMinutes) || tzMinutes > 840 || tzMinutes < -720) {
			return tzMinutes;
		}

		var off = tzMinutes,
			minutes = off % 60,
			hours = (off - minutes) / 60,
			iso = iso8601 ? ':' : '',
			tz = (off >= 0 ? '+' : '-') + ('0' + Math.abs(hours)).slice(-2) + iso + ('0' + Math.abs(minutes)).slice(-2);

		if (tz === '+00:00') {
			return 'Z';
		}
		return tz;
	};

	/**
	 * Get the number in minutes that represents a timezone string
	 * @param  {string} tzString formatted like "+0500", "-1245", "Z"
	 * @return {number} the offset minutes or the original string if it doesn't match expectations
	 */
	$.timepicker.timezoneOffsetNumber = function (tzString) {
		var normalized = tzString.toString().replace(':', ''); // excuse any iso8601, end up with "+1245"

		if (normalized.toUpperCase() === 'Z') { // if iso8601 with Z, its 0 minute offset
			return 0;
		}

		if (!/^(\-|\+)\d{4}$/.test(normalized)) { // possibly a user defined tz, so just give it back
			return parseInt(tzString, 10);
		}

		return ((normalized.substr(0, 1) === '-' ? -1 : 1) * // plus or minus
					((parseInt(normalized.substr(1, 2), 10) * 60) + // hours (converted to minutes)
					parseInt(normalized.substr(3, 2), 10))); // minutes
	};

	/**
	 * No way to set timezone in js Date, so we must adjust the minutes to compensate. (think setDate, getDate)
	 * @param  {Date} date
	 * @param  {string} fromTimezone formatted like "+0500", "-1245"
	 * @param  {string} toTimezone formatted like "+0500", "-1245"
	 * @return {Date}
	 */
	$.timepicker.timezoneAdjust = function (date, fromTimezone, toTimezone) {
		var fromTz = $.timepicker.timezoneOffsetNumber(fromTimezone);
		var toTz = $.timepicker.timezoneOffsetNumber(toTimezone);
		if (!isNaN(toTz)) {
			date.setMinutes(date.getMinutes() + (-fromTz) - (-toTz));
		}
		return date;
	};

	/**
	 * Calls `timepicker()` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * n.b. The input value must be correctly formatted (reformatting is not supported)
	 * @param  {Element} startTime
	 * @param  {Element} endTime
	 * @param  {Object} options Options for the timepicker() call
	 * @return {jQuery}
	 */
	$.timepicker.timeRange = function (startTime, endTime, options) {
		return $.timepicker.handleRange('timepicker', startTime, endTime, options);
	};

	/**
	 * Calls `datetimepicker` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * @param  {Element} startTime
	 * @param  {Element} endTime
	 * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
	 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
	 * @param  {string} method Can be used to specify the type of picker to be added
	 * @return {jQuery}
	 */
	$.timepicker.datetimeRange = function (startTime, endTime, options) {
		$.timepicker.handleRange('datetimepicker', startTime, endTime, options);
	};

	/**
	 * Calls `datepicker` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * @param  {Element} startTime
	 * @param  {Element} endTime
	 * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
	 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
	 * @return {jQuery}
	 */
	$.timepicker.dateRange = function (startTime, endTime, options) {
		$.timepicker.handleRange('datepicker', startTime, endTime, options);
	};

	/**
	 * Calls `method` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * @param  {string} method Can be used to specify the type of picker to be added
	 * @param  {Element} startTime
	 * @param  {Element} endTime
	 * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
	 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
	 * @return {jQuery}
	 */
	$.timepicker.handleRange = function (method, startTime, endTime, options) {
		options = $.extend({}, {
			minInterval: 0, // min allowed interval in milliseconds
			maxInterval: 0, // max allowed interval in milliseconds
			start: {},      // options for start picker
			end: {}         // options for end picker
		}, options);

		// for the mean time this fixes an issue with calling getDate with timepicker()
		var timeOnly = false;
		if(method === 'timepicker'){
			timeOnly = true;
			method = 'datetimepicker';
		}

		function checkDates(changed, other) {
			var startdt = startTime[method]('getDate'),
				enddt = endTime[method]('getDate'),
				changeddt = changed[method]('getDate');

			if (startdt !== null) {
				var minDate = new Date(startdt.getTime()),
					maxDate = new Date(startdt.getTime());

				minDate.setMilliseconds(minDate.getMilliseconds() + options.minInterval);
				maxDate.setMilliseconds(maxDate.getMilliseconds() + options.maxInterval);

				if (options.minInterval > 0 && minDate > enddt) { // minInterval check
					endTime[method]('setDate', minDate);
				}
				else if (options.maxInterval > 0 && maxDate < enddt) { // max interval check
					endTime[method]('setDate', maxDate);
				}
				else if (startdt > enddt) {
					other[method]('setDate', changeddt);
				}
			}
		}

		function selected(changed, other, option) {
			if (!changed.val()) {
				return;
			}
			var date = changed[method].call(changed, 'getDate');
			if (date !== null && options.minInterval > 0) {
				if (option === 'minDate') {
					date.setMilliseconds(date.getMilliseconds() + options.minInterval);
				}
				if (option === 'maxDate') {
					date.setMilliseconds(date.getMilliseconds() - options.minInterval);
				}
			}

			if (date.getTime) {
				other[method].call(other, 'option', option, date);
			}
		}

		$.fn[method].call(startTime, $.extend({
			timeOnly: timeOnly,
			onClose: function (dateText, inst) {
				checkDates($(this), endTime);
			},
			onSelect: function (selectedDateTime) {
				selected($(this), endTime, 'minDate');
			}
		}, options, options.start));
		$.fn[method].call(endTime, $.extend({
			timeOnly: timeOnly,
			onClose: function (dateText, inst) {
				checkDates($(this), startTime);
			},
			onSelect: function (selectedDateTime) {
				selected($(this), startTime, 'maxDate');
			}
		}, options, options.end));

		checkDates(startTime, endTime);

		selected(startTime, endTime, 'minDate');
		selected(endTime, startTime, 'maxDate');

		return $([startTime.get(0), endTime.get(0)]);
	};

	/**
	 * Log error or data to the console during error or debugging
	 * @param  {Object} err pass any type object to log to the console during error or debugging
	 * @return {void}
	 */
	$.timepicker.log = function () {
		// Older IE (9, maybe 10) throw error on accessing `window.console.log.apply`, so check first.
		if (window.console && window.console.log && window.console.log.apply) {
			window.console.log.apply(window.console, Array.prototype.slice.call(arguments));
		}
	};

	/*
	 * Add util object to allow access to private methods for testability.
	 */
	$.timepicker._util = {
		_extendRemove: extendRemove,
		_isEmptyObject: isEmptyObject,
		_convert24to12: convert24to12,
		_detectSupport: detectSupport,
		_selectLocalTimezone: selectLocalTimezone,
		_computeEffectiveSetting: computeEffectiveSetting,
		_splitDateTime: splitDateTime,
		_parseDateTimeInternal: parseDateTimeInternal
	};

	/*
	* Microsecond support
	*/
	if (!Date.prototype.getMicroseconds) {
		Date.prototype.microseconds = 0;
		Date.prototype.getMicroseconds = function () { return this.microseconds; };
		Date.prototype.setMicroseconds = function (m) {
			this.setMilliseconds(this.getMilliseconds() + Math.floor(m / 1000));
			this.microseconds = m % 1000;
			return this;
		};
	}

	/*
	* Keep up with the version
	*/
	$.timepicker.version = "1.6.3";

}));

/* Russian translation for the jQuery Timepicker Addon */
/* Written by Trent Richardson */
(function($) {
	$.timepicker.regional['ru'] = {
		timeOnlyTitle: 'Выберите время',
		timeText: 'Время',
		hourText: 'Часы',
		minuteText: 'Минуты',
		secondText: 'Секунды',
		millisecText: 'Миллисекунды',
		microsecText: 'Микросекунды',
		timezoneText: 'Часовой пояс',
		currentText: 'Сейчас',
		closeText: 'Закрыть',
		timeFormat: 'HH:mm',
		timeSuffix: '',
		amNames: ['AM', 'A'],
		pmNames: ['PM', 'P'],
		isRTL: false
	};
	$.timepicker.setDefaults($.timepicker.regional['ru']);
})(jQuery);

/* 
  @package NOTY - Dependency-free notification library 
  @version version: 3.2.0-beta 
  @contributors https://github.com/needim/noty/graphs/contributors 
  @documentation Examples and Documentation - https://ned.im/noty 
  @license Licensed under the MIT licenses: http://www.opensource.org/licenses/mit-license.php 
*/

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Noty", [], factory);
	else if(typeof exports === 'object')
		exports["Noty"] = factory();
	else
		root["Noty"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.css = exports.deepExtend = exports.animationEndEvents = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.inArray = inArray;
exports.stopPropagation = stopPropagation;
exports.generateID = generateID;
exports.outerHeight = outerHeight;
exports.addListener = addListener;
exports.hasClass = hasClass;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.remove = remove;
exports.classList = classList;
exports.visibilityChangeFlow = visibilityChangeFlow;
exports.createAudioElements = createAudioElements;

var _api = __webpack_require__(1);

var API = _interopRequireWildcard(_api);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var animationEndEvents = exports.animationEndEvents = 'webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend';

function inArray(needle, haystack, argStrict) {
  var key = void 0;
  var strict = !!argStrict;

  if (strict) {
    for (key in haystack) {
      if (haystack.hasOwnProperty(key) && haystack[key] === needle) {
        return true;
      }
    }
  } else {
    for (key in haystack) {
      if (haystack.hasOwnProperty(key) && haystack[key] === needle) {
        return true;
      }
    }
  }
  return false;
}

function stopPropagation(evt) {
  evt = evt || window.event;

  if (typeof evt.stopPropagation !== 'undefined') {
    evt.stopPropagation();
  } else {
    evt.cancelBubble = true;
  }
}

var deepExtend = exports.deepExtend = function deepExtend(out) {
  out = out || {};

  for (var i = 1; i < arguments.length; i++) {
    var obj = arguments[i];

    if (!obj) continue;

    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        if (Array.isArray(obj[key])) {
          out[key] = obj[key];
        } else if (_typeof(obj[key]) === 'object' && obj[key] !== null) {
          out[key] = deepExtend(out[key], obj[key]);
        } else {
          out[key] = obj[key];
        }
      }
    }
  }

  return out;
};

function generateID() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  var id = 'noty_' + prefix + '_';

  id += 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0;
    var v = c === 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });

  return id;
}

function outerHeight(el) {
  var height = el.offsetHeight;
  var style = window.getComputedStyle(el);

  height += parseInt(style.marginTop) + parseInt(style.marginBottom);
  return height;
}

var css = exports.css = function () {
  var cssPrefixes = ['Webkit', 'O', 'Moz', 'ms'];
  var cssProps = {};

  function camelCase(string) {
    return string.replace(/^-ms-/, 'ms-').replace(/-([\da-z])/gi, function (match, letter) {
      return letter.toUpperCase();
    });
  }

  function getVendorProp(name) {
    var style = document.body.style;
    if (name in style) return name;

    var i = cssPrefixes.length;
    var capName = name.charAt(0).toUpperCase() + name.slice(1);
    var vendorName = void 0;

    while (i--) {
      vendorName = cssPrefixes[i] + capName;
      if (vendorName in style) return vendorName;
    }

    return name;
  }

  function getStyleProp(name) {
    name = camelCase(name);
    return cssProps[name] || (cssProps[name] = getVendorProp(name));
  }

  function applyCss(element, prop, value) {
    prop = getStyleProp(prop);
    element.style[prop] = value;
  }

  return function (element, properties) {
    var args = arguments;
    var prop = void 0;
    var value = void 0;

    if (args.length === 2) {
      for (prop in properties) {
        if (properties.hasOwnProperty(prop)) {
          value = properties[prop];
          if (value !== undefined && properties.hasOwnProperty(prop)) {
            applyCss(element, prop, value);
          }
        }
      }
    } else {
      applyCss(element, args[1], args[2]);
    }
  };
}();

function addListener(el, events, cb) {
  var useCapture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  events = events.split(' ');
  for (var i = 0; i < events.length; i++) {
    if (document.addEventListener) {
      el.addEventListener(events[i], cb, useCapture);
    } else if (document.attachEvent) {
      el.attachEvent('on' + events[i], cb);
    }
  }
}

function hasClass(element, name) {
  var list = typeof element === 'string' ? element : classList(element);
  return list.indexOf(' ' + name + ' ') >= 0;
}

function addClass(element, name) {
  var oldList = classList(element);
  var newList = oldList + name;

  if (hasClass(oldList, name)) return;

  // Trim the opening space.
  element.className = newList.substring(1);
}

function removeClass(element, name) {
  var oldList = classList(element);
  var newList = void 0;

  if (!hasClass(element, name)) return;

  // Replace the class name.
  newList = oldList.replace(' ' + name + ' ', ' ');

  // Trim the opening and closing spaces.
  element.className = newList.substring(1, newList.length - 1);
}

function remove(element) {
  if (element.parentNode) {
    element.parentNode.removeChild(element);
  }
}

function classList(element) {
  return (' ' + (element && element.className || '') + ' ').replace(/\s+/gi, ' ');
}

function visibilityChangeFlow() {
  var hidden = void 0;
  var visibilityChange = void 0;
  if (typeof document.hidden !== 'undefined') {
    // Opera 12.10 and Firefox 18 and later support
    hidden = 'hidden';
    visibilityChange = 'visibilitychange';
  } else if (typeof document.msHidden !== 'undefined') {
    hidden = 'msHidden';
    visibilityChange = 'msvisibilitychange';
  } else if (typeof document.webkitHidden !== 'undefined') {
    hidden = 'webkitHidden';
    visibilityChange = 'webkitvisibilitychange';
  }

  function onVisibilityChange() {
    API.PageHidden = document[hidden];
    handleVisibilityChange();
  }

  function onBlur() {
    API.PageHidden = true;
    handleVisibilityChange();
  }

  function onFocus() {
    API.PageHidden = false;
    handleVisibilityChange();
  }

  function handleVisibilityChange() {
    if (API.PageHidden) stopAll();else resumeAll();
  }

  function stopAll() {
    setTimeout(function () {
      Object.keys(API.Store).forEach(function (id) {
        if (API.Store.hasOwnProperty(id)) {
          if (API.Store[id].options.visibilityControl) {
            API.Store[id].stop();
          }
        }
      });
    }, 100);
  }

  function resumeAll() {
    setTimeout(function () {
      Object.keys(API.Store).forEach(function (id) {
        if (API.Store.hasOwnProperty(id)) {
          if (API.Store[id].options.visibilityControl) {
            API.Store[id].resume();
          }
        }
      });
      API.queueRenderAll();
    }, 100);
  }

  if (visibilityChange) {
    addListener(document, visibilityChange, onVisibilityChange);
  }

  addListener(window, 'blur', onBlur);
  addListener(window, 'focus', onFocus);
}

function createAudioElements(ref) {
  if (ref.hasSound) {
    var audioElement = document.createElement('audio');

    ref.options.sounds.sources.forEach(function (s) {
      var source = document.createElement('source');
      source.src = s;
      source.type = 'audio/' + getExtension(s);
      audioElement.appendChild(source);
    });

    if (ref.barDom) {
      ref.barDom.appendChild(audioElement);
    } else {
      document.querySelector('body').appendChild(audioElement);
    }

    audioElement.volume = ref.options.sounds.volume;

    if (!ref.soundPlayed) {
      audioElement.play();
      ref.soundPlayed = true;
    }

    audioElement.onended = function () {
      remove(audioElement);
    };
  }
}

function getExtension(fileName) {
  return fileName.match(/\.([^.]+)$/)[1];
}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Defaults = exports.Store = exports.Queues = exports.DefaultMaxVisible = exports.docTitle = exports.DocModalCount = exports.PageHidden = undefined;
exports.getQueueCounts = getQueueCounts;
exports.addToQueue = addToQueue;
exports.removeFromQueue = removeFromQueue;
exports.queueRender = queueRender;
exports.queueRenderAll = queueRenderAll;
exports.ghostFix = ghostFix;
exports.build = build;
exports.hasButtons = hasButtons;
exports.handleModal = handleModal;
exports.handleModalClose = handleModalClose;
exports.queueClose = queueClose;
exports.dequeueClose = dequeueClose;
exports.fire = fire;
exports.openFlow = openFlow;
exports.closeFlow = closeFlow;

var _utils = __webpack_require__(0);

var Utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var PageHidden = exports.PageHidden = false;
var DocModalCount = exports.DocModalCount = 0;

var DocTitleProps = {
  originalTitle: null,
  count: 0,
  changed: false,
  timer: -1
};

var docTitle = exports.docTitle = {
  increment: function increment() {
    DocTitleProps.count++;

    docTitle._update();
  },

  decrement: function decrement() {
    DocTitleProps.count--;

    if (DocTitleProps.count <= 0) {
      docTitle._clear();
      return;
    }

    docTitle._update();
  },

  _update: function _update() {
    var title = document.title;

    if (!DocTitleProps.changed) {
      DocTitleProps.originalTitle = title;
      document.title = '(' + DocTitleProps.count + ') ' + title;
      DocTitleProps.changed = true;
    } else {
      document.title = '(' + DocTitleProps.count + ') ' + DocTitleProps.originalTitle;
    }
  },

  _clear: function _clear() {
    if (DocTitleProps.changed) {
      DocTitleProps.count = 0;
      document.title = DocTitleProps.originalTitle;
      DocTitleProps.changed = false;
    }
  }
};

var DefaultMaxVisible = exports.DefaultMaxVisible = 5;

var Queues = exports.Queues = {
  global: {
    maxVisible: DefaultMaxVisible,
    queue: []
  }
};

var Store = exports.Store = {};

var Defaults = exports.Defaults = {
  type: 'alert',
  layout: 'topRight',
  theme: 'mint',
  text: '',
  timeout: false,
  progressBar: true,
  closeWith: ['click'],
  animation: {
    open: 'noty_effects_open',
    close: 'noty_effects_close'
  },
  id: false,
  force: false,
  killer: false,
  queue: 'global',
  container: false,
  buttons: [],
  callbacks: {
    beforeShow: null,
    onShow: null,
    afterShow: null,
    onClose: null,
    afterClose: null,
    onClick: null,
    onHover: null,
    onTemplate: null
  },
  sounds: {
    sources: [],
    volume: 1,
    conditions: []
  },
  titleCount: {
    conditions: []
  },
  modal: false,
  visibilityControl: false

  /**
   * @param {string} queueName
   * @return {object}
   */
};function getQueueCounts() {
  var queueName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'global';

  var count = 0;
  var max = DefaultMaxVisible;

  if (Queues.hasOwnProperty(queueName)) {
    max = Queues[queueName].maxVisible;
    Object.keys(Store).forEach(function (i) {
      if (Store[i].options.queue === queueName && !Store[i].closed) count++;
    });
  }

  return {
    current: count,
    maxVisible: max
  };
}

/**
 * @param {Noty} ref
 * @return {void}
 */
function addToQueue(ref) {
  if (!Queues.hasOwnProperty(ref.options.queue)) {
    Queues[ref.options.queue] = { maxVisible: DefaultMaxVisible, queue: [] };
  }

  Queues[ref.options.queue].queue.push(ref);
}

/**
 * @param {Noty} ref
 * @return {void}
 */
function removeFromQueue(ref) {
  if (Queues.hasOwnProperty(ref.options.queue)) {
    var queue = [];
    Object.keys(Queues[ref.options.queue].queue).forEach(function (i) {
      if (Queues[ref.options.queue].queue[i].id !== ref.id) {
        queue.push(Queues[ref.options.queue].queue[i]);
      }
    });
    Queues[ref.options.queue].queue = queue;
  }
}

/**
 * @param {string} queueName
 * @return {void}
 */
function queueRender() {
  var queueName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'global';

  if (Queues.hasOwnProperty(queueName)) {
    var noty = Queues[queueName].queue.shift();

    if (noty) noty.show();
  }
}

/**
 * @return {void}
 */
function queueRenderAll() {
  Object.keys(Queues).forEach(function (queueName) {
    queueRender(queueName);
  });
}

/**
 * @param {Noty} ref
 * @return {void}
 */
function ghostFix(ref) {
  var ghostID = Utils.generateID('ghost');
  var ghost = document.createElement('div');
  ghost.setAttribute('id', ghostID);
  Utils.css(ghost, {
    height: Utils.outerHeight(ref.barDom) + 'px'
  });

  ref.barDom.insertAdjacentHTML('afterend', ghost.outerHTML);

  Utils.remove(ref.barDom);
  ghost = document.getElementById(ghostID);
  Utils.addClass(ghost, 'noty_fix_effects_height');
  Utils.addListener(ghost, Utils.animationEndEvents, function () {
    Utils.remove(ghost);
  });
}

/**
 * @param {Noty} ref
 * @return {void}
 */
function build(ref) {
  findOrCreateContainer(ref);

  var markup = '<div class="noty_body">' + ref.options.text + '</div>' + buildButtons(ref) + '<div class="noty_progressbar"></div>';

  ref.barDom = document.createElement('div');
  ref.barDom.setAttribute('id', ref.id);
  Utils.addClass(ref.barDom, 'noty_bar noty_type__' + ref.options.type + ' noty_theme__' + ref.options.theme);

  ref.barDom.innerHTML = markup;

  fire(ref, 'onTemplate');
}

/**
 * @param {Noty} ref
 * @return {boolean}
 */
function hasButtons(ref) {
  return !!(ref.options.buttons && Object.keys(ref.options.buttons).length);
}

/**
 * @param {Noty} ref
 * @return {string}
 */
function buildButtons(ref) {
  if (hasButtons(ref)) {
    var buttons = document.createElement('div');
    Utils.addClass(buttons, 'noty_buttons');

    Object.keys(ref.options.buttons).forEach(function (key) {
      buttons.appendChild(ref.options.buttons[key].dom);
    });

    ref.options.buttons.forEach(function (btn) {
      buttons.appendChild(btn.dom);
    });
    return buttons.outerHTML;
  }
  return '';
}

/**
 * @param {Noty} ref
 * @return {void}
 */
function handleModal(ref) {
  if (ref.options.modal) {
    if (DocModalCount === 0) {
      createModal(ref);
    }

    exports.DocModalCount = DocModalCount += 1;
  }
}

/**
 * @param {Noty} ref
 * @return {void}
 */
function handleModalClose(ref) {
  if (ref.options.modal && DocModalCount > 0) {
    exports.DocModalCount = DocModalCount -= 1;

    if (DocModalCount <= 0) {
      var modal = document.querySelector('.noty_modal');

      if (modal) {
        Utils.removeClass(modal, 'noty_modal_open');
        Utils.addClass(modal, 'noty_modal_close');
        Utils.addListener(modal, Utils.animationEndEvents, function () {
          Utils.remove(modal);
        });
      }
    }
  }
}

/**
 * @return {void}
 */
function createModal() {
  var body = document.querySelector('body');
  var modal = document.createElement('div');
  Utils.addClass(modal, 'noty_modal');
  body.insertBefore(modal, body.firstChild);
  Utils.addClass(modal, 'noty_modal_open');

  Utils.addListener(modal, Utils.animationEndEvents, function () {
    Utils.removeClass(modal, 'noty_modal_open');
  });
}

/**
 * @param {Noty} ref
 * @return {void}
 */
function findOrCreateContainer(ref) {
  if (ref.options.container) {
    ref.layoutDom = document.querySelector(ref.options.container);
    return;
  }

  var layoutID = 'noty_layout__' + ref.options.layout;
  ref.layoutDom = document.querySelector('div#' + layoutID);

  if (!ref.layoutDom) {
    ref.layoutDom = document.createElement('div');
    ref.layoutDom.setAttribute('id', layoutID);
    ref.layoutDom.setAttribute('role', 'alert');
    ref.layoutDom.setAttribute('aria-live', 'polite');
    Utils.addClass(ref.layoutDom, 'noty_layout');
    document.querySelector('body').appendChild(ref.layoutDom);
  }
}

/**
 * @param {Noty} ref
 * @return {void}
 */
function queueClose(ref) {
  if (ref.options.timeout) {
    if (ref.options.progressBar && ref.progressDom) {
      Utils.css(ref.progressDom, {
        transition: 'width ' + ref.options.timeout + 'ms linear',
        width: '0%'
      });
    }

    clearTimeout(ref.closeTimer);

    ref.closeTimer = setTimeout(function () {
      ref.close();
    }, ref.options.timeout);
  }
}

/**
 * @param {Noty} ref
 * @return {void}
 */
function dequeueClose(ref) {
  if (ref.options.timeout && ref.closeTimer) {
    clearTimeout(ref.closeTimer);
    ref.closeTimer = -1;

    if (ref.options.progressBar && ref.progressDom) {
      Utils.css(ref.progressDom, {
        transition: 'width 0ms linear',
        width: '100%'
      });
    }
  }
}

/**
 * @param {Noty} ref
 * @param {string} eventName
 * @return {void}
 */
function fire(ref, eventName) {
  if (ref.listeners.hasOwnProperty(eventName)) {
    ref.listeners[eventName].forEach(function (cb) {
      if (typeof cb === 'function') {
        cb.apply(ref);
      }
    });
  }
}

/**
 * @param {Noty} ref
 * @return {void}
 */
function openFlow(ref) {
  fire(ref, 'afterShow');
  queueClose(ref);

  Utils.addListener(ref.barDom, 'mouseenter', function () {
    dequeueClose(ref);
  });

  Utils.addListener(ref.barDom, 'mouseleave', function () {
    queueClose(ref);
  });
}

/**
 * @param {Noty} ref
 * @return {void}
 */
function closeFlow(ref) {
  delete Store[ref.id];
  ref.closing = false;
  fire(ref, 'afterClose');

  Utils.remove(ref.barDom);

  if (ref.layoutDom.querySelectorAll('.noty_bar').length === 0 && !ref.options.container) {
    Utils.remove(ref.layoutDom);
  }

  if (Utils.inArray('docVisible', ref.options.titleCount.conditions) || Utils.inArray('docHidden', ref.options.titleCount.conditions)) {
    docTitle.decrement();
  }

  queueRender(ref.options.queue);
}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NotyButton = undefined;

var _utils = __webpack_require__(0);

var Utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NotyButton = exports.NotyButton = function NotyButton(html, classes, cb) {
  var _this = this;

  var attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  _classCallCheck(this, NotyButton);

  this.dom = document.createElement('button');
  this.dom.innerHTML = html;
  this.id = attributes.id = attributes.id || Utils.generateID('button');
  this.cb = cb;
  Object.keys(attributes).forEach(function (propertyName) {
    _this.dom.setAttribute(propertyName, attributes[propertyName]);
  });
  Utils.addClass(this.dom, classes || 'noty_btn');

  return this;
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Push = exports.Push = function () {
  function Push() {
    var workerPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/service-worker.js';

    _classCallCheck(this, Push);

    this.subData = {};
    this.workerPath = workerPath;
    this.listeners = {
      onPermissionGranted: [],
      onPermissionDenied: [],
      onSubscriptionSuccess: [],
      onSubscriptionCancel: [],
      onWorkerError: [],
      onWorkerSuccess: [],
      onWorkerNotSupported: []
    };
    return this;
  }

  /**
   * @param {string} eventName
   * @param {function} cb
   * @return {Push}
   */


  _createClass(Push, [{
    key: 'on',
    value: function on(eventName) {
      var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

      if (typeof cb === 'function' && this.listeners.hasOwnProperty(eventName)) {
        this.listeners[eventName].push(cb);
      }

      return this;
    }
  }, {
    key: 'fire',
    value: function fire(eventName) {
      var _this = this;

      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      if (this.listeners.hasOwnProperty(eventName)) {
        this.listeners[eventName].forEach(function (cb) {
          if (typeof cb === 'function') {
            cb.apply(_this, params);
          }
        });
      }
    }
  }, {
    key: 'create',
    value: function create() {
      console.log('NOT IMPLEMENTED YET');
    }

    /**
     * @return {boolean}
     */

  }, {
    key: 'isSupported',
    value: function isSupported() {
      var result = false;

      try {
        result = window.Notification || window.webkitNotifications || navigator.mozNotification || window.external && window.external.msIsSiteMode() !== undefined;
      } catch (e) {}

      return result;
    }

    /**
     * @return {string}
     */

  }, {
    key: 'getPermissionStatus',
    value: function getPermissionStatus() {
      var perm = 'default';

      if (window.Notification && window.Notification.permissionLevel) {
        perm = window.Notification.permissionLevel;
      } else if (window.webkitNotifications && window.webkitNotifications.checkPermission) {
        switch (window.webkitNotifications.checkPermission()) {
          case 1:
            perm = 'default';
            break;
          case 0:
            perm = 'granted';
            break;
          default:
            perm = 'denied';
        }
      } else if (window.Notification && window.Notification.permission) {
        perm = window.Notification.permission;
      } else if (navigator.mozNotification) {
        perm = 'granted';
      } else if (window.external && window.external.msIsSiteMode() !== undefined) {
        perm = window.external.msIsSiteMode() ? 'granted' : 'default';
      }

      return perm.toString().toLowerCase();
    }

    /**
     * @return {string}
     */

  }, {
    key: 'getEndpoint',
    value: function getEndpoint(subscription) {
      var endpoint = subscription.endpoint;
      var subscriptionId = subscription.subscriptionId;

      // fix for Chrome < 45
      if (subscriptionId && endpoint.indexOf(subscriptionId) === -1) {
        endpoint += '/' + subscriptionId;
      }

      return endpoint;
    }

    /**
     * @return {boolean}
     */

  }, {
    key: 'isSWRegistered',
    value: function isSWRegistered() {
      try {
        return navigator.serviceWorker.controller.state === 'activated';
      } catch (e) {
        return false;
      }
    }

    /**
     * @return {void}
     */

  }, {
    key: 'unregisterWorker',
    value: function unregisterWorker() {
      var self = this;
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.getRegistrations().then(function (registrations) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = registrations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var registration = _step.value;

              registration.unregister();
              self.fire('onSubscriptionCancel');
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        });
      }
    }

    /**
     * @return {void}
     */

  }, {
    key: 'requestSubscription',
    value: function requestSubscription() {
      var _this2 = this;

      var userVisibleOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      var self = this;
      var current = this.getPermissionStatus();
      var cb = function cb(result) {
        if (result === 'granted') {
          _this2.fire('onPermissionGranted');

          if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register(_this2.workerPath).then(function () {
              navigator.serviceWorker.ready.then(function (serviceWorkerRegistration) {
                self.fire('onWorkerSuccess');
                serviceWorkerRegistration.pushManager.subscribe({
                  userVisibleOnly: userVisibleOnly
                }).then(function (subscription) {
                  var key = subscription.getKey('p256dh');
                  var token = subscription.getKey('auth');

                  self.subData = {
                    endpoint: self.getEndpoint(subscription),
                    p256dh: key ? window.btoa(String.fromCharCode.apply(null, new Uint8Array(key))) : null,
                    auth: token ? window.btoa(String.fromCharCode.apply(null, new Uint8Array(token))) : null
                  };

                  self.fire('onSubscriptionSuccess', [self.subData]);
                }).catch(function (err) {
                  self.fire('onWorkerError', [err]);
                });
              });
            });
          } else {
            self.fire('onWorkerNotSupported');
          }
        } else if (result === 'denied') {
          _this2.fire('onPermissionDenied');
          _this2.unregisterWorker();
        }
      };

      if (current === 'default') {
        if (window.Notification && window.Notification.requestPermission) {
          window.Notification.requestPermission(cb);
        } else if (window.webkitNotifications && window.webkitNotifications.checkPermission) {
          window.webkitNotifications.requestPermission(cb);
        }
      } else {
        cb(current);
      }
    }
  }]);

  return Push;
}();

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {var require;/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   4.1.1
 */

(function (global, factory) {
	 true ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}

var _isArray = undefined;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = undefined;
var customSchedulerFn = undefined;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var r = require;
    var vertx = __webpack_require__(9);
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = undefined;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && "function" === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var _arguments = arguments;

  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;

  if (_state) {
    (function () {
      var callback = _arguments[_state - 1];
      asap(function () {
        return invokeCallback(_state, child, callback, parent._result);
      });
    })();
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(16);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var GET_THEN_ERROR = new ErrorObject();

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    GET_THEN_ERROR.error = error;
    return GET_THEN_ERROR;
  }
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === GET_THEN_ERROR) {
      reject(promise, GET_THEN_ERROR.error);
      GET_THEN_ERROR.error = null;
    } else if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;

  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = undefined,
      callback = undefined,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function ErrorObject() {
  this.error = null;
}

var TRY_CATCH_ERROR = new ErrorObject();

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = undefined,
      error = undefined,
      succeeded = undefined,
      failed = undefined;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value.error = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
      resolve(promise, value);
    } else if (failed) {
      reject(promise, error);
    } else if (settled === FULFILLED) {
      fulfill(promise, value);
    } else if (settled === REJECTED) {
      reject(promise, value);
    }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function Enumerator$1(Constructor, input) {
  this._instanceConstructor = Constructor;
  this.promise = new Constructor(noop);

  if (!this.promise[PROMISE_ID]) {
    makePromise(this.promise);
  }

  if (isArray(input)) {
    this.length = input.length;
    this._remaining = input.length;

    this._result = new Array(this.length);

    if (this.length === 0) {
      fulfill(this.promise, this._result);
    } else {
      this.length = this.length || 0;
      this._enumerate(input);
      if (this._remaining === 0) {
        fulfill(this.promise, this._result);
      }
    }
  } else {
    reject(this.promise, validationError());
  }
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

Enumerator$1.prototype._enumerate = function (input) {
  for (var i = 0; this._state === PENDING && i < input.length; i++) {
    this._eachEntry(input[i], i);
  }
};

Enumerator$1.prototype._eachEntry = function (entry, i) {
  var c = this._instanceConstructor;
  var resolve$$1 = c.resolve;

  if (resolve$$1 === resolve$1) {
    var _then = getThen(entry);

    if (_then === then && entry._state !== PENDING) {
      this._settledAt(entry._state, i, entry._result);
    } else if (typeof _then !== 'function') {
      this._remaining--;
      this._result[i] = entry;
    } else if (c === Promise$2) {
      var promise = new c(noop);
      handleMaybeThenable(promise, entry, _then);
      this._willSettleAt(promise, i);
    } else {
      this._willSettleAt(new c(function (resolve$$1) {
        return resolve$$1(entry);
      }), i);
    }
  } else {
    this._willSettleAt(resolve$$1(entry), i);
  }
};

Enumerator$1.prototype._settledAt = function (state, i, value) {
  var promise = this.promise;

  if (promise._state === PENDING) {
    this._remaining--;

    if (state === REJECTED) {
      reject(promise, value);
    } else {
      this._result[i] = value;
    }
  }

  if (this._remaining === 0) {
    fulfill(promise, this._result);
  }
};

Enumerator$1.prototype._willSettleAt = function (promise, i) {
  var enumerator = this;

  subscribe(promise, undefined, function (value) {
    return enumerator._settledAt(FULFILLED, i, value);
  }, function (reason) {
    return enumerator._settledAt(REJECTED, i, reason);
  });
};

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all$1(entries) {
  return new Enumerator$1(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race$1(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {function} resolver
  Useful for tooling.
  @constructor
*/
function Promise$2(resolver) {
  this[PROMISE_ID] = nextId();
  this._result = this._state = undefined;
  this._subscribers = [];

  if (noop !== resolver) {
    typeof resolver !== 'function' && needsResolver();
    this instanceof Promise$2 ? initializePromise(this, resolver) : needsNew();
  }
}

Promise$2.all = all$1;
Promise$2.race = race$1;
Promise$2.resolve = resolve$1;
Promise$2.reject = reject$1;
Promise$2._setScheduler = setScheduler;
Promise$2._setAsap = setAsap;
Promise$2._asap = asap;

Promise$2.prototype = {
  constructor: Promise$2,

  /**
    The primary way of interacting with a promise is through its `then` method,
    which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.
  
    ```js
    findUser().then(function(user){
      // user is available
    }, function(reason){
      // user is unavailable, and you are given the reason why
    });
    ```
  
    Chaining
    --------
  
    The return value of `then` is itself a promise.  This second, 'downstream'
    promise is resolved with the return value of the first promise's fulfillment
    or rejection handler, or rejected if the handler throws an exception.
  
    ```js
    findUser().then(function (user) {
      return user.name;
    }, function (reason) {
      return 'default name';
    }).then(function (userName) {
      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
      // will be `'default name'`
    });
  
    findUser().then(function (user) {
      throw new Error('Found user, but still unhappy');
    }, function (reason) {
      throw new Error('`findUser` rejected and we're unhappy');
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
    });
    ```
    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
  
    ```js
    findUser().then(function (user) {
      throw new PedagogicalException('Upstream error');
    }).then(function (value) {
      // never reached
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // The `PedgagocialException` is propagated all the way down to here
    });
    ```
  
    Assimilation
    ------------
  
    Sometimes the value you want to propagate to a downstream promise can only be
    retrieved asynchronously. This can be achieved by returning a promise in the
    fulfillment or rejection handler. The downstream promise will then be pending
    until the returned promise is settled. This is called *assimilation*.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // The user's comments are now available
    });
    ```
  
    If the assimliated promise rejects, then the downstream promise will also reject.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // If `findCommentsByAuthor` fulfills, we'll have the value here
    }, function (reason) {
      // If `findCommentsByAuthor` rejects, we'll have the reason here
    });
    ```
  
    Simple Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let result;
  
    try {
      result = findResult();
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
    findResult(function(result, err){
      if (err) {
        // failure
      } else {
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findResult().then(function(result){
      // success
    }, function(reason){
      // failure
    });
    ```
  
    Advanced Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let author, books;
  
    try {
      author = findAuthor();
      books  = findBooksByAuthor(author);
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
  
    function foundBooks(books) {
  
    }
  
    function failure(reason) {
  
    }
  
    findAuthor(function(author, err){
      if (err) {
        failure(err);
        // failure
      } else {
        try {
          findBoooksByAuthor(author, function(books, err) {
            if (err) {
              failure(err);
            } else {
              try {
                foundBooks(books);
              } catch(reason) {
                failure(reason);
              }
            }
          });
        } catch(error) {
          failure(err);
        }
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findAuthor().
      then(findBooksByAuthor).
      then(function(books){
        // found books
    }).catch(function(reason){
      // something went wrong
    });
    ```
  
    @method then
    @param {Function} onFulfilled
    @param {Function} onRejected
    Useful for tooling.
    @return {Promise}
  */
  then: then,

  /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
  
    ```js
    function findAuthor(){
      throw new Error('couldn't find that author');
    }
  
    // synchronous
    try {
      findAuthor();
    } catch(reason) {
      // something went wrong
    }
  
    // async with promises
    findAuthor().catch(function(reason){
      // something went wrong
    });
    ```
  
    @method catch
    @param {Function} onRejection
    Useful for tooling.
    @return {Promise}
  */
  'catch': function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};

/*global self*/
function polyfill$1() {
    var local = undefined;

    if (typeof global !== 'undefined') {
        local = global;
    } else if (typeof self !== 'undefined') {
        local = self;
    } else {
        try {
            local = Function('return this')();
        } catch (e) {
            throw new Error('polyfill failed because global object is unavailable in this environment');
        }
    }

    var P = local.Promise;

    if (P) {
        var promiseToString = null;
        try {
            promiseToString = Object.prototype.toString.call(P.resolve());
        } catch (e) {
            // silently ignored
        }

        if (promiseToString === '[object Promise]' && !P.cast) {
            return;
        }
    }

    local.Promise = Promise$2;
}

// Strange compat..
Promise$2.polyfill = polyfill$1;
Promise$2.Promise = Promise$2;

return Promise$2;

})));

//# sourceMappingURL=es6-promise.map

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(8)))

/***/ }),
/* 5 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global VERSION */

__webpack_require__(5);

var _es6Promise = __webpack_require__(4);

var _es6Promise2 = _interopRequireDefault(_es6Promise);

var _utils = __webpack_require__(0);

var Utils = _interopRequireWildcard(_utils);

var _api = __webpack_require__(1);

var API = _interopRequireWildcard(_api);

var _button = __webpack_require__(2);

var _push = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Noty = function () {
  /**
   * @param {object} options
   * @return {Noty}
   */
  function Noty() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Noty);

    this.options = Utils.deepExtend({}, API.Defaults, options);

    if (API.Store[this.options.id]) {
      return API.Store[this.options.id];
    }

    this.id = this.options.id || Utils.generateID('bar');
    this.closeTimer = -1;
    this.barDom = null;
    this.layoutDom = null;
    this.progressDom = null;
    this.showing = false;
    this.shown = false;
    this.closed = false;
    this.closing = false;
    this.killable = this.options.timeout || this.options.closeWith.length > 0;
    this.hasSound = this.options.sounds.sources.length > 0;
    this.soundPlayed = false;
    this.listeners = {
      beforeShow: [],
      onShow: [],
      afterShow: [],
      onClose: [],
      afterClose: [],
      onClick: [],
      onHover: [],
      onTemplate: []
    };
    this.promises = {
      show: null,
      close: null
    };
    this.on('beforeShow', this.options.callbacks.beforeShow);
    this.on('onShow', this.options.callbacks.onShow);
    this.on('afterShow', this.options.callbacks.afterShow);
    this.on('onClose', this.options.callbacks.onClose);
    this.on('afterClose', this.options.callbacks.afterClose);
    this.on('onClick', this.options.callbacks.onClick);
    this.on('onHover', this.options.callbacks.onHover);
    this.on('onTemplate', this.options.callbacks.onTemplate);

    return this;
  }

  /**
   * @param {string} eventName
   * @param {function} cb
   * @return {Noty}
   */


  _createClass(Noty, [{
    key: 'on',
    value: function on(eventName) {
      var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

      if (typeof cb === 'function' && this.listeners.hasOwnProperty(eventName)) {
        this.listeners[eventName].push(cb);
      }

      return this;
    }

    /**
     * @return {Noty}
     */

  }, {
    key: 'show',
    value: function show() {
      var _this = this;

      if (this.showing || this.shown) {
        return this; // preventing multiple show
      }

      if (this.options.killer === true) {
        Noty.closeAll();
      } else if (typeof this.options.killer === 'string') {
        Noty.closeAll(this.options.killer);
      }

      var queueCounts = API.getQueueCounts(this.options.queue);

      if (queueCounts.current >= queueCounts.maxVisible || API.PageHidden && this.options.visibilityControl) {
        API.addToQueue(this);

        if (API.PageHidden && this.hasSound && Utils.inArray('docHidden', this.options.sounds.conditions)) {
          Utils.createAudioElements(this);
        }

        if (API.PageHidden && Utils.inArray('docHidden', this.options.titleCount.conditions)) {
          API.docTitle.increment();
        }

        return this;
      }

      API.Store[this.id] = this;

      API.fire(this, 'beforeShow');

      this.showing = true;

      if (this.closing) {
        this.showing = false;
        return this;
      }

      API.build(this);
      API.handleModal(this);

      if (this.options.force) {
        this.layoutDom.insertBefore(this.barDom, this.layoutDom.firstChild);
      } else {
        this.layoutDom.appendChild(this.barDom);
      }

      if (this.hasSound && !this.soundPlayed && Utils.inArray('docVisible', this.options.sounds.conditions)) {
        Utils.createAudioElements(this);
      }

      if (Utils.inArray('docVisible', this.options.titleCount.conditions)) {
        API.docTitle.increment();
      }

      this.shown = true;
      this.closed = false;

      // bind button events if any
      if (API.hasButtons(this)) {
        Object.keys(this.options.buttons).forEach(function (key) {
          var btn = _this.barDom.querySelector('#' + _this.options.buttons[key].id);
          Utils.addListener(btn, 'click', function (e) {
            Utils.stopPropagation(e);
            _this.options.buttons[key].cb(_this);
          });
        });
      }

      this.progressDom = this.barDom.querySelector('.noty_progressbar');

      if (Utils.inArray('click', this.options.closeWith)) {
        Utils.addClass(this.barDom, 'noty_close_with_click');
        Utils.addListener(this.barDom, 'click', function (e) {
          Utils.stopPropagation(e);
          API.fire(_this, 'onClick');
          _this.close();
        }, false);
      }

      Utils.addListener(this.barDom, 'mouseenter', function () {
        API.fire(_this, 'onHover');
      }, false);

      if (this.options.timeout) Utils.addClass(this.barDom, 'noty_has_timeout');
      if (this.options.progressBar) {
        Utils.addClass(this.barDom, 'noty_has_progressbar');
      }

      if (Utils.inArray('button', this.options.closeWith)) {
        Utils.addClass(this.barDom, 'noty_close_with_button');

        var closeButton = document.createElement('div');
        Utils.addClass(closeButton, 'noty_close_button');
        closeButton.innerHTML = '×';
        this.barDom.appendChild(closeButton);

        Utils.addListener(closeButton, 'click', function (e) {
          Utils.stopPropagation(e);
          _this.close();
        }, false);
      }

      API.fire(this, 'onShow');

      if (this.options.animation.open === null) {
        this.promises.show = new _es6Promise2.default(function (resolve) {
          resolve();
        });
      } else if (typeof this.options.animation.open === 'function') {
        this.promises.show = new _es6Promise2.default(this.options.animation.open.bind(this));
      } else {
        Utils.addClass(this.barDom, this.options.animation.open);
        this.promises.show = new _es6Promise2.default(function (resolve) {
          Utils.addListener(_this.barDom, Utils.animationEndEvents, function () {
            Utils.removeClass(_this.barDom, _this.options.animation.open);
            resolve();
          });
        });
      }

      this.promises.show.then(function () {
        var _t = _this;
        setTimeout(function () {
          API.openFlow(_t);
        }, 100);
      });

      return this;
    }

    /**
     * @return {Noty}
     */

  }, {
    key: 'stop',
    value: function stop() {
      API.dequeueClose(this);
      return this;
    }

    /**
     * @return {Noty}
     */

  }, {
    key: 'resume',
    value: function resume() {
      API.queueClose(this);
      return this;
    }

    /**
     * @param {int|boolean} ms
     * @return {Noty}
     */

  }, {
    key: 'setTimeout',
    value: function (_setTimeout) {
      function setTimeout(_x) {
        return _setTimeout.apply(this, arguments);
      }

      setTimeout.toString = function () {
        return _setTimeout.toString();
      };

      return setTimeout;
    }(function (ms) {
      this.stop();
      this.options.timeout = ms;

      if (this.barDom) {
        if (this.options.timeout) {
          Utils.addClass(this.barDom, 'noty_has_timeout');
        } else {
          Utils.removeClass(this.barDom, 'noty_has_timeout');
        }

        var _t = this;
        setTimeout(function () {
          // ugly fix for progressbar display bug
          _t.resume();
        }, 100);
      }

      return this;
    })

    /**
     * @param {string} html
     * @param {boolean} optionsOverride
     * @return {Noty}
     */

  }, {
    key: 'setText',
    value: function setText(html) {
      var optionsOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (this.barDom) {
        this.barDom.querySelector('.noty_body').innerHTML = html;
      }

      if (optionsOverride) this.options.text = html;

      return this;
    }

    /**
     * @param {string} type
     * @param {boolean} optionsOverride
     * @return {Noty}
     */

  }, {
    key: 'setType',
    value: function setType(type) {
      var _this2 = this;

      var optionsOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (this.barDom) {
        var classList = Utils.classList(this.barDom).split(' ');

        classList.forEach(function (c) {
          if (c.substring(0, 11) === 'noty_type__') {
            Utils.removeClass(_this2.barDom, c);
          }
        });

        Utils.addClass(this.barDom, 'noty_type__' + type);
      }

      if (optionsOverride) this.options.type = type;

      return this;
    }

    /**
     * @param {string} theme
     * @param {boolean} optionsOverride
     * @return {Noty}
     */

  }, {
    key: 'setTheme',
    value: function setTheme(theme) {
      var _this3 = this;

      var optionsOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (this.barDom) {
        var classList = Utils.classList(this.barDom).split(' ');

        classList.forEach(function (c) {
          if (c.substring(0, 12) === 'noty_theme__') {
            Utils.removeClass(_this3.barDom, c);
          }
        });

        Utils.addClass(this.barDom, 'noty_theme__' + theme);
      }

      if (optionsOverride) this.options.theme = theme;

      return this;
    }

    /**
     * @return {Noty}
     */

  }, {
    key: 'close',
    value: function close() {
      var _this4 = this;

      if (this.closed) return this;

      if (!this.shown) {
        // it's in the queue
        API.removeFromQueue(this);
        return this;
      }

      API.fire(this, 'onClose');

      this.closing = true;

      if (this.options.animation.close === null || this.options.animation.close === false) {
        this.promises.close = new _es6Promise2.default(function (resolve) {
          resolve();
        });
      } else if (typeof this.options.animation.close === 'function') {
        this.promises.close = new _es6Promise2.default(this.options.animation.close.bind(this));
      } else {
        Utils.addClass(this.barDom, this.options.animation.close);
        this.promises.close = new _es6Promise2.default(function (resolve) {
          Utils.addListener(_this4.barDom, Utils.animationEndEvents, function () {
            if (_this4.options.force) {
              Utils.remove(_this4.barDom);
            } else {
              API.ghostFix(_this4);
            }
            resolve();
          });
        });
      }

      this.promises.close.then(function () {
        API.closeFlow(_this4);
        API.handleModalClose(_this4);
      });

      this.closed = true;

      return this;
    }

    // API functions

    /**
     * @param {boolean|string} queueName
     * @return {Noty}
     */

  }], [{
    key: 'closeAll',
    value: function closeAll() {
      var queueName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      Object.keys(API.Store).forEach(function (id) {
        if (queueName) {
          if (API.Store[id].options.queue === queueName && API.Store[id].killable) {
            API.Store[id].close();
          }
        } else if (API.Store[id].killable) {
          API.Store[id].close();
        }
      });
      return this;
    }

    /**
     * @param {string} queueName
     * @return {Noty}
     */

  }, {
    key: 'clearQueue',
    value: function clearQueue() {
      var queueName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'global';

      if (API.Queues.hasOwnProperty(queueName)) {
        API.Queues[queueName].queue = [];
      }
      return this;
    }

    /**
     * @return {API.Queues}
     */

  }, {
    key: 'overrideDefaults',


    /**
     * @param {Object} obj
     * @return {Noty}
     */
    value: function overrideDefaults(obj) {
      API.Defaults = Utils.deepExtend({}, API.Defaults, obj);
      return this;
    }

    /**
     * @param {int} amount
     * @param {string} queueName
     * @return {Noty}
     */

  }, {
    key: 'setMaxVisible',
    value: function setMaxVisible() {
      var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : API.DefaultMaxVisible;
      var queueName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'global';

      if (!API.Queues.hasOwnProperty(queueName)) {
        API.Queues[queueName] = { maxVisible: amount, queue: [] };
      }

      API.Queues[queueName].maxVisible = amount;
      return this;
    }

    /**
     * @param {string} innerHtml
     * @param {String} classes
     * @param {Function} cb
     * @param {Object} attributes
     * @return {NotyButton}
     */

  }, {
    key: 'button',
    value: function button(innerHtml) {
      var classes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var cb = arguments[2];
      var attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      return new _button.NotyButton(innerHtml, classes, cb, attributes);
    }

    /**
     * @return {string}
     */

  }, {
    key: 'version',
    value: function version() {
      return "3.2.0-beta";
    }

    /**
     * @param {String} workerPath
     * @return {Push}
     */

  }, {
    key: 'Push',
    value: function Push(workerPath) {
      return new _push.Push(workerPath);
    }
  }, {
    key: 'Queues',
    get: function get() {
      return API.Queues;
    }

    /**
     * @return {API.PageHidden}
     */

  }, {
    key: 'PageHidden',
    get: function get() {
      return API.PageHidden;
    }
  }]);

  return Noty;
}();

// Document visibility change controller


exports.default = Noty;
if (typeof window !== 'undefined') {
  Utils.visibilityChangeFlow();
}
module.exports = exports['default'];

/***/ }),
/* 7 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 8 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })
/******/ ]);
});
//# sourceMappingURL=noty.js.map
/*!
 * sly 1.6.1 - 8th Aug 2015
 * https://github.com/darsain/sly
 *
 * Licensed under the MIT license.
 * http://opensource.org/licenses/MIT
 */

;(function ($, w, undefined) {
	'use strict';

	var pluginName = 'sly';
	var className  = 'Sly';
	var namespace  = pluginName;

	// Local WindowAnimationTiming interface
	var cAF = w.cancelAnimationFrame || w.cancelRequestAnimationFrame;
	var rAF = w.requestAnimationFrame;

	// Support indicators
	var transform, gpuAcceleration;

	// Other global values
	var $doc = $(document);
	var dragInitEvents = 'touchstart.' + namespace + ' mousedown.' + namespace;
	var dragMouseEvents = 'mousemove.' + namespace + ' mouseup.' + namespace;
	var dragTouchEvents = 'touchmove.' + namespace + ' touchend.' + namespace;
	var wheelEvent = (document.implementation.hasFeature('Event.wheel', '3.0') ? 'wheel.' : 'mousewheel.') + namespace;
	var clickEvent = 'click.' + namespace;
	var mouseDownEvent = 'mousedown.' + namespace;
	var interactiveElements = ['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA'];
	var tmpArray = [];
	var time;

	// Math shorthands
	var abs = Math.abs;
	var sqrt = Math.sqrt;
	var pow = Math.pow;
	var round = Math.round;
	var max = Math.max;
	var min = Math.min;

	// Keep track of last fired global wheel event
	var lastGlobalWheel = 0;
	$doc.on(wheelEvent, function (event) {
		var sly = event.originalEvent[namespace];
		var time = +new Date();
		// Update last global wheel time, but only when event didn't originate
		// in Sly frame, or the origin was less than scrollHijack time ago
		if (!sly || sly.options.scrollHijack < time - lastGlobalWheel) lastGlobalWheel = time;
	});

	/**
	 * Sly.
	 *
	 * @class
	 *
	 * @param {Element} frame       DOM element of sly container.
	 * @param {Object}  options     Object with options.
	 * @param {Object}  callbackMap Callbacks map.
	 */
	function Sly(frame, options, callbackMap) {
		if (!(this instanceof Sly)) return new Sly(frame, options, callbackMap);

		// Extend options
		var o = $.extend({}, Sly.defaults, options);

		// Private variables
		var self = this;
		var parallax = isNumber(frame);

		// Frame
		var $frame = $(frame);
		var $slidee = o.slidee ? $(o.slidee).eq(0) : $frame.children().eq(0);
		var frameSize = 0;
		var slideeSize = 0;
		var pos = {
			start: 0,
			center: 0,
			end: 0,
			cur: 0,
			dest: 0
		};

		// Scrollbar
		var $sb = $(o.scrollBar).eq(0);
		var $handle = $sb.children().eq(0);
		var sbSize = 0;
		var handleSize = 0;
		var hPos = {
			start: 0,
			end: 0,
			cur: 0
		};

		// Pagesbar
		var $pb = $(o.pagesBar);
		var $pages = 0;
		var pages = [];

		// Items
		var $items = 0;
		var items = [];
		var rel = {
			firstItem: 0,
			lastItem: 0,
			centerItem: 0,
			activeItem: null,
			activePage: 0
		};

		// Styles
		var frameStyles = new StyleRestorer($frame[0]);
		var slideeStyles = new StyleRestorer($slidee[0]);
		var sbStyles = new StyleRestorer($sb[0]);
		var handleStyles = new StyleRestorer($handle[0]);

		// Navigation type booleans
		var basicNav = o.itemNav === 'basic';
		var forceCenteredNav = o.itemNav === 'forceCentered';
		var centeredNav = o.itemNav === 'centered' || forceCenteredNav;
		var itemNav = !parallax && (basicNav || centeredNav || forceCenteredNav);

		// Miscellaneous
		var $scrollSource = o.scrollSource ? $(o.scrollSource) : $frame;
		var $dragSource = o.dragSource ? $(o.dragSource) : $frame;
		var $forwardButton = $(o.forward);
		var $backwardButton = $(o.backward);
		var $prevButton = $(o.prev);
		var $nextButton = $(o.next);
		var $prevPageButton = $(o.prevPage);
		var $nextPageButton = $(o.nextPage);
		var callbacks = {};
		var last = {};
		var animation = {};
		var move = {};
		var dragging = {
			released: 1
		};
		var scrolling = {
			last: 0,
			delta: 0,
			resetTime: 200
		};
		var renderID = 0;
		var historyID = 0;
		var cycleID = 0;
		var continuousID = 0;
		var i, l;

		// Normalizing frame
		if (!parallax) {
			frame = $frame[0];
		}

		// Expose properties
		self.initialized = 0;
		self.frame = frame;
		self.slidee = $slidee[0];
		self.pos = pos;
		self.rel = rel;
		self.items = items;
		self.pages = pages;
		self.isPaused = 0;
		self.options = o;
		self.dragging = dragging;

		/**
		 * Loading function.
		 *
		 * Populate arrays, set sizes, bind events, ...
		 *
		 * @param {Boolean} [isInit] Whether load is called from within self.init().
		 * @return {Void}
		 */
		function load(isInit) {
			// Local variables
			var lastItemsCount = 0;
			var lastPagesCount = pages.length;

			// Save old position
			pos.old = $.extend({}, pos);

			// Reset global variables
			frameSize = parallax ? 0 : $frame[o.horizontal ? 'width' : 'height']();
			sbSize = $sb[o.horizontal ? 'width' : 'height']();
			slideeSize = parallax ? frame : $slidee[o.horizontal ? 'outerWidth' : 'outerHeight']();
			pages.length = 0;

			// Set position limits & relatives
			pos.start = 0;
			pos.end = max(slideeSize - frameSize, 0);

			// Sizes & offsets for item based navigations
			if (itemNav) {
				// Save the number of current items
				lastItemsCount = items.length;

				// Reset itemNav related variables
				$items = $slidee.children(o.itemSelector);
				items.length = 0;

				// Needed variables
				var paddingStart = getPx($slidee, o.horizontal ? 'paddingLeft' : 'paddingTop');
				var paddingEnd = getPx($slidee, o.horizontal ? 'paddingRight' : 'paddingBottom');
				var borderBox = $($items).css('boxSizing') === 'border-box';
				var areFloated = $items.css('float') !== 'none';
				var ignoredMargin = 0;
				var lastItemIndex = $items.length - 1;
				var lastItem;

				// Reset slideeSize
				slideeSize = 0;

				// Iterate through items
				$items.each(function (i, element) {
					// Item
					var $item = $(element);
					var rect = element.getBoundingClientRect();
					var itemSize = round(o.horizontal ? rect.width || rect.right - rect.left : rect.height || rect.bottom - rect.top);
					var itemMarginStart = getPx($item, o.horizontal ? 'marginLeft' : 'marginTop');
					var itemMarginEnd = getPx($item, o.horizontal ? 'marginRight' : 'marginBottom');
					var itemSizeFull = itemSize + itemMarginStart + itemMarginEnd;
					var singleSpaced = !itemMarginStart || !itemMarginEnd;
					var item = {};
					item.el = element;
					item.size = singleSpaced ? itemSize : itemSizeFull;
					item.half = item.size / 2;
					item.start = slideeSize + (singleSpaced ? itemMarginStart : 0);
					item.center = item.start - round(frameSize / 2 - item.size / 2);
					item.end = item.start - frameSize + item.size;

					// Account for slidee padding
					if (!i) {
						slideeSize += paddingStart;
					}

					// Increment slidee size for size of the active element
					slideeSize += itemSizeFull;

					// Try to account for vertical margin collapsing in vertical mode
					// It's not bulletproof, but should work in 99% of cases
					if (!o.horizontal && !areFloated) {
						// Subtract smaller margin, but only when top margin is not 0, and this is not the first element
						if (itemMarginEnd && itemMarginStart && i > 0) {
							slideeSize -= min(itemMarginStart, itemMarginEnd);
						}
					}

					// Things to be done on last item
					if (i === lastItemIndex) {
						item.end += paddingEnd;
						slideeSize += paddingEnd;
						ignoredMargin = singleSpaced ? itemMarginEnd : 0;
					}

					// Add item object to items array
					items.push(item);
					lastItem = item;
				});

				// Resize SLIDEE to fit all items
				$slidee[0].style[o.horizontal ? 'width' : 'height'] = (borderBox ? slideeSize: slideeSize - paddingStart - paddingEnd) + 'px';

				// Adjust internal SLIDEE size for last margin
				slideeSize -= ignoredMargin;

				// Set limits
				if (items.length) {
					pos.start =  items[0][forceCenteredNav ? 'center' : 'start'];
					pos.end = forceCenteredNav ? lastItem.center : frameSize < slideeSize ? lastItem.end : pos.start;
				} else {
					pos.start = pos.end = 0;
				}
			}

			// Calculate SLIDEE center position
			pos.center = round(pos.end / 2 + pos.start / 2);

			// Update relative positions
			updateRelatives();

			// Scrollbar
			if ($handle.length && sbSize > 0) {
				// Stretch scrollbar handle to represent the visible area
				if (o.dynamicHandle) {
					handleSize = pos.start === pos.end ? sbSize : round(sbSize * frameSize / slideeSize);
					handleSize = within(handleSize, o.minHandleSize, sbSize);
					$handle[0].style[o.horizontal ? 'width' : 'height'] = handleSize + 'px';
				} else {
					handleSize = $handle[o.horizontal ? 'outerWidth' : 'outerHeight']();
				}

				hPos.end = sbSize - handleSize;

				if (!renderID) {
					syncScrollbar();
				}
			}

			// Pages
			if (!parallax && frameSize > 0) {
				var tempPagePos = pos.start;
				var pagesHtml = '';

				// Populate pages array
				if (itemNav) {
					$.each(items, function (i, item) {
						if (forceCenteredNav) {
							pages.push(item.center);
						} else if (item.start + item.size > tempPagePos && tempPagePos <= pos.end) {
							tempPagePos = item.start;
							pages.push(tempPagePos);
							tempPagePos += frameSize;
							if (tempPagePos > pos.end && tempPagePos < pos.end + frameSize) {
								pages.push(pos.end);
							}
						}
					});
				} else {
					while (tempPagePos - frameSize < pos.end) {
						pages.push(tempPagePos);
						tempPagePos += frameSize;
					}
				}

				// Pages bar
				if ($pb[0] && lastPagesCount !== pages.length) {
					for (var i = 0; i < pages.length; i++) {
						pagesHtml += o.pageBuilder.call(self, i);
					}
					$pages = $pb.html(pagesHtml).children();
					$pages.eq(rel.activePage).addClass(o.activeClass);
				}
			}

			// Extend relative variables object with some useful info
			rel.slideeSize = slideeSize;
			rel.frameSize = frameSize;
			rel.sbSize = sbSize;
			rel.handleSize = handleSize;

			// Activate requested position
			if (itemNav) {
				if (isInit && o.startAt != null) {
					activate(o.startAt);
					self[centeredNav ? 'toCenter' : 'toStart'](o.startAt);
				}
				// Fix possible overflowing
				var activeItem = items[rel.activeItem];
				slideTo(centeredNav && activeItem ? activeItem.center : within(pos.dest, pos.start, pos.end));
			} else {
				if (isInit) {
					if (o.startAt != null) slideTo(o.startAt, 1);
				} else {
					// Fix possible overflowing
					slideTo(within(pos.dest, pos.start, pos.end));
				}
			}

			// Trigger load event
			trigger('load');
		}
		self.reload = function () { load(); };

		/**
		 * Animate to a position.
		 *
		 * @param {Int}  newPos    New position.
		 * @param {Bool} immediate Reposition immediately without an animation.
		 * @param {Bool} dontAlign Do not align items, use the raw position passed in first argument.
		 *
		 * @return {Void}
		 */
		function slideTo(newPos, immediate, dontAlign) {
			// Align items
			if (itemNav && dragging.released && !dontAlign) {
				var tempRel = getRelatives(newPos);
				var isNotBordering = newPos > pos.start && newPos < pos.end;

				if (centeredNav) {
					if (isNotBordering) {
						newPos = items[tempRel.centerItem].center;
					}
					if (forceCenteredNav && o.activateMiddle) {
						activate(tempRel.centerItem);
					}
				} else if (isNotBordering) {
					newPos = items[tempRel.firstItem].start;
				}
			}

			// Handle overflowing position limits
			if (dragging.init && dragging.slidee && o.elasticBounds) {
				if (newPos > pos.end) {
					newPos = pos.end + (newPos - pos.end) / 6;
				} else if (newPos < pos.start) {
					newPos = pos.start + (newPos - pos.start) / 6;
				}
			} else {
				newPos = within(newPos, pos.start, pos.end);
			}

			// Update the animation object
			animation.start = +new Date();
			animation.time = 0;
			animation.from = pos.cur;
			animation.to = newPos;
			animation.delta = newPos - pos.cur;
			animation.tweesing = dragging.tweese || dragging.init && !dragging.slidee;
			animation.immediate = !animation.tweesing && (immediate || dragging.init && dragging.slidee || !o.speed);

			// Reset dragging tweesing request
			dragging.tweese = 0;

			// Start animation rendering
			if (newPos !== pos.dest) {
				pos.dest = newPos;
				trigger('change');
				if (!renderID) {
					render();
				}
			}

			// Reset next cycle timeout
			resetCycle();

			// Synchronize states
			updateRelatives();
			updateButtonsState();
			syncPagesbar();
		}

		/**
		 * Render animation frame.
		 *
		 * @return {Void}
		 */
		function render() {
			if (!self.initialized) {
				return;
			}

			// If first render call, wait for next animationFrame
			if (!renderID) {
				renderID = rAF(render);
				if (dragging.released) {
					trigger('moveStart');
				}
				return;
			}

			// If immediate repositioning is requested, don't animate.
			if (animation.immediate) {
				pos.cur = animation.to;
			}
			// Use tweesing for animations without known end point
			else if (animation.tweesing) {
				animation.tweeseDelta = animation.to - pos.cur;
				// Fuck Zeno's paradox
				if (abs(animation.tweeseDelta) < 0.1) {
					pos.cur = animation.to;
				} else {
					pos.cur += animation.tweeseDelta * (dragging.released ? o.swingSpeed : o.syncSpeed);
				}
			}
			// Use tweening for basic animations with known end point
			else {
				animation.time = min(+new Date() - animation.start, o.speed);
				pos.cur = animation.from + animation.delta * $.easing[o.easing](animation.time/o.speed, animation.time, 0, 1, o.speed);
			}

			// If there is nothing more to render break the rendering loop, otherwise request new animation frame.
			if (animation.to === pos.cur) {
				pos.cur = animation.to;
				dragging.tweese = renderID = 0;
			} else {
				renderID = rAF(render);
			}

			trigger('move');

			// Update SLIDEE position
			if (!parallax) {
				if (transform) {
					$slidee[0].style[transform] = gpuAcceleration + (o.horizontal ? 'translateX' : 'translateY') + '(' + (-pos.cur) + 'px)';
				} else {
					$slidee[0].style[o.horizontal ? 'left' : 'top'] = -round(pos.cur) + 'px';
				}
			}

			// When animation reached the end, and dragging is not active, trigger moveEnd
			if (!renderID && dragging.released) {
				trigger('moveEnd');
			}

			syncScrollbar();
		}

		/**
		 * Synchronizes scrollbar with the SLIDEE.
		 *
		 * @return {Void}
		 */
		function syncScrollbar() {
			if ($handle.length) {
				hPos.cur = pos.start === pos.end ? 0 : (((dragging.init && !dragging.slidee) ? pos.dest : pos.cur) - pos.start) / (pos.end - pos.start) * hPos.end;
				hPos.cur = within(round(hPos.cur), hPos.start, hPos.end);
				if (last.hPos !== hPos.cur) {
					last.hPos = hPos.cur;
					if (transform) {
						$handle[0].style[transform] = gpuAcceleration + (o.horizontal ? 'translateX' : 'translateY') + '(' + hPos.cur + 'px)';
					} else {
						$handle[0].style[o.horizontal ? 'left' : 'top'] = hPos.cur + 'px';
					}
				}
			}
		}

		/**
		 * Synchronizes pagesbar with SLIDEE.
		 *
		 * @return {Void}
		 */
		function syncPagesbar() {
			if ($pages[0] && last.page !== rel.activePage) {
				last.page = rel.activePage;
				$pages.removeClass(o.activeClass).eq(rel.activePage).addClass(o.activeClass);
				trigger('activePage', last.page);
			}
		}

		/**
		 * Returns the position object.
		 *
		 * @param {Mixed} item
		 *
		 * @return {Object}
		 */
		self.getPos = function (item) {
			if (itemNav) {
				var index = getIndex(item);
				return index !== -1 ? items[index] : false;
			} else {
				var $item = $slidee.find(item).eq(0);

				if ($item[0]) {
					var offset = o.horizontal ? $item.offset().left - $slidee.offset().left : $item.offset().top - $slidee.offset().top;
					var size = $item[o.horizontal ? 'outerWidth' : 'outerHeight']();

					return {
						start: offset,
						center: offset - frameSize / 2 + size / 2,
						end: offset - frameSize + size,
						size: size
					};
				} else {
					return false;
				}
			}
		};

		/**
		 * Continuous move in a specified direction.
		 *
		 * @param  {Bool} forward True for forward movement, otherwise it'll go backwards.
		 * @param  {Int}  speed   Movement speed in pixels per frame. Overrides options.moveBy value.
		 *
		 * @return {Void}
		 */
		self.moveBy = function (speed) {
			move.speed = speed;
			// If already initiated, or there is nowhere to move, abort
			if (dragging.init || !move.speed || pos.cur === (move.speed > 0 ? pos.end : pos.start)) {
				return;
			}
			// Initiate move object
			move.lastTime = +new Date();
			move.startPos = pos.cur;
			// Set dragging as initiated
			continuousInit('button');
			dragging.init = 1;
			// Start movement
			trigger('moveStart');
			cAF(continuousID);
			moveLoop();
		};

		/**
		 * Continuous movement loop.
		 *
		 * @return {Void}
		 */
		function moveLoop() {
			// If there is nowhere to move anymore, stop
			if (!move.speed || pos.cur === (move.speed > 0 ? pos.end : pos.start)) {
				self.stop();
			}
			// Request new move loop if it hasn't been stopped
			continuousID = dragging.init ? rAF(moveLoop) : 0;
			// Update move object
			move.now = +new Date();
			move.pos = pos.cur + (move.now - move.lastTime) / 1000 * move.speed;
			// Slide
			slideTo(dragging.init ? move.pos : round(move.pos));
			// Normally, this is triggered in render(), but if there
			// is nothing to render, we have to do it manually here.
			if (!dragging.init && pos.cur === pos.dest) {
				trigger('moveEnd');
			}
			// Update times for future iteration
			move.lastTime = move.now;
		}

		/**
		 * Stops continuous movement.
		 *
		 * @return {Void}
		 */
		self.stop = function () {
			if (dragging.source === 'button') {
				dragging.init = 0;
				dragging.released = 1;
			}
		};

		/**
		 * Activate previous item.
		 *
		 * @return {Void}
		 */
		self.prev = function () {
			self.activate(rel.activeItem == null ? 0 : rel.activeItem - 1);
		};

		/**
		 * Activate next item.
		 *
		 * @return {Void}
		 */
		self.next = function () {
			self.activate(rel.activeItem == null ? 0 : rel.activeItem + 1);
		};

		/**
		 * Activate previous page.
		 *
		 * @return {Void}
		 */
		self.prevPage = function () {
			self.activatePage(rel.activePage - 1);
		};

		/**
		 * Activate next page.
		 *
		 * @return {Void}
		 */
		self.nextPage = function () {
			self.activatePage(rel.activePage + 1);
		};

		/**
		 * Slide SLIDEE by amount of pixels.
		 *
		 * @param {Int}  delta     Pixels/Items. Positive means forward, negative means backward.
		 * @param {Bool} immediate Reposition immediately without an animation.
		 *
		 * @return {Void}
		 */
		self.slideBy = function (delta, immediate) {
			if (!delta) {
				return;
			}
			if (itemNav) {
				self[centeredNav ? 'toCenter' : 'toStart'](
					within((centeredNav ? rel.centerItem : rel.firstItem) + o.scrollBy * delta, 0, items.length)
				);
			} else {
				slideTo(pos.dest + delta, immediate);
			}
		};

		/**
		 * Animate SLIDEE to a specific position.
		 *
		 * @param {Int}  pos       New position.
		 * @param {Bool} immediate Reposition immediately without an animation.
		 *
		 * @return {Void}
		 */
		self.slideTo = function (pos, immediate) {
			slideTo(pos, immediate);
		};

		/**
		 * Core method for handling `toLocation` methods.
		 *
		 * @param  {String} location
		 * @param  {Mixed}  item
		 * @param  {Bool}   immediate
		 *
		 * @return {Void}
		 */
		function to(location, item, immediate) {
			// Optional arguments logic
			if (type(item) === 'boolean') {
				immediate = item;
				item = undefined;
			}

			if (item === undefined) {
				slideTo(pos[location], immediate);
			} else {
				// You can't align items to sides of the frame
				// when centered navigation type is enabled
				if (centeredNav && location !== 'center') {
					return;
				}

				var itemPos = self.getPos(item);
				if (itemPos) {
					slideTo(itemPos[location], immediate, !centeredNav);
				}
			}
		}

		/**
		 * Animate element or the whole SLIDEE to the start of the frame.
		 *
		 * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.
		 * @param {Bool}  immediate Reposition immediately without an animation.
		 *
		 * @return {Void}
		 */
		self.toStart = function (item, immediate) {
			to('start', item, immediate);
		};

		/**
		 * Animate element or the whole SLIDEE to the end of the frame.
		 *
		 * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.
		 * @param {Bool}  immediate Reposition immediately without an animation.
		 *
		 * @return {Void}
		 */
		self.toEnd = function (item, immediate) {
			to('end', item, immediate);
		};

		/**
		 * Animate element or the whole SLIDEE to the center of the frame.
		 *
		 * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.
		 * @param {Bool}  immediate Reposition immediately without an animation.
		 *
		 * @return {Void}
		 */
		self.toCenter = function (item, immediate) {
			to('center', item, immediate);
		};

		/**
		 * Get the index of an item in SLIDEE.
		 *
		 * @param {Mixed} item     Item DOM element.
		 *
		 * @return {Int}  Item index, or -1 if not found.
		 */
		function getIndex(item) {
			return item != null ?
					isNumber(item) ?
						item >= 0 && item < items.length ? item : -1 :
						$items.index(item) :
					-1;
		}
		// Expose getIndex without lowering the compressibility of it,
		// as it is used quite often throughout Sly.
		self.getIndex = getIndex;

		/**
		 * Get index of an item in SLIDEE based on a variety of input types.
		 *
		 * @param  {Mixed} item DOM element, positive or negative integer.
		 *
		 * @return {Int}   Item index, or -1 if not found.
		 */
		function getRelativeIndex(item) {
			return getIndex(isNumber(item) && item < 0 ? item + items.length : item);
		}

		/**
		 * Activates an item.
		 *
		 * @param  {Mixed} item Item DOM element, or index starting at 0.
		 *
		 * @return {Mixed} Activated item index or false on fail.
		 */
		function activate(item, force) {
			var index = getIndex(item);

			if (!itemNav || index < 0) {
				return false;
			}

			// Update classes, last active index, and trigger active event only when there
			// has been a change. Otherwise just return the current active index.
			if (last.active !== index || force) {
				// Update classes
				$items.eq(rel.activeItem).removeClass(o.activeClass);
				$items.eq(index).addClass(o.activeClass);

				last.active = rel.activeItem = index;

				updateButtonsState();
				trigger('active', index);
			}

			return index;
		}

		/**
		 * Activates an item and helps with further navigation when o.smart is enabled.
		 *
		 * @param {Mixed} item      Item DOM element, or index starting at 0.
		 * @param {Bool}  immediate Whether to reposition immediately in smart navigation.
		 *
		 * @return {Void}
		 */
		self.activate = function (item, immediate) {
			var index = activate(item);

			// Smart navigation
			if (o.smart && index !== false) {
				// When centeredNav is enabled, center the element.
				// Otherwise, determine where to position the element based on its current position.
				// If the element is currently on the far end side of the frame, assume that user is
				// moving forward and animate it to the start of the visible frame, and vice versa.
				if (centeredNav) {
					self.toCenter(index, immediate);
				} else if (index >= rel.lastItem) {
					self.toStart(index, immediate);
				} else if (index <= rel.firstItem) {
					self.toEnd(index, immediate);
				} else {
					resetCycle();
				}
			}
		};

		/**
		 * Activates a page.
		 *
		 * @param {Int}  index     Page index, starting from 0.
		 * @param {Bool} immediate Whether to reposition immediately without animation.
		 *
		 * @return {Void}
		 */
		self.activatePage = function (index, immediate) {
			if (isNumber(index)) {
				slideTo(pages[within(index, 0, pages.length - 1)], immediate);
			}
		};

		/**
		 * Return relative positions of items based on their visibility within FRAME.
		 *
		 * @param {Int} slideePos Position of SLIDEE.
		 *
		 * @return {Void}
		 */
		function getRelatives(slideePos) {
			slideePos = within(isNumber(slideePos) ? slideePos : pos.dest, pos.start, pos.end);

			var relatives = {};
			var centerOffset = forceCenteredNav ? 0 : frameSize / 2;

			// Determine active page
			if (!parallax) {
				for (var p = 0, pl = pages.length; p < pl; p++) {
					if (slideePos >= pos.end || p === pages.length - 1) {
						relatives.activePage = pages.length - 1;
						break;
					}

					if (slideePos <= pages[p] + centerOffset) {
						relatives.activePage = p;
						break;
					}
				}
			}

			// Relative item indexes
			if (itemNav) {
				var first = false;
				var last = false;
				var center = false;

				// From start
				for (var i = 0, il = items.length; i < il; i++) {
					// First item
					if (first === false && slideePos <= items[i].start + items[i].half) {
						first = i;
					}

					// Center item
					if (center === false && slideePos <= items[i].center + items[i].half) {
						center = i;
					}

					// Last item
					if (i === il - 1 || slideePos <= items[i].end + items[i].half) {
						last = i;
						break;
					}
				}

				// Safe assignment, just to be sure the false won't be returned
				relatives.firstItem = isNumber(first) ? first : 0;
				relatives.centerItem = isNumber(center) ? center : relatives.firstItem;
				relatives.lastItem = isNumber(last) ? last : relatives.centerItem;
			}

			return relatives;
		}

		/**
		 * Update object with relative positions.
		 *
		 * @param {Int} newPos
		 *
		 * @return {Void}
		 */
		function updateRelatives(newPos) {
			$.extend(rel, getRelatives(newPos));
		}

		/**
		 * Disable navigation buttons when needed.
		 *
		 * Adds disabledClass, and when the button is <button> or <input>, activates :disabled state.
		 *
		 * @return {Void}
		 */
		function updateButtonsState() {
			var isStart = pos.dest <= pos.start;
			var isEnd = pos.dest >= pos.end;
			var slideePosState = (isStart ? 1 : 0) | (isEnd ? 2 : 0);

			// Update paging buttons only if there has been a change in SLIDEE position
			if (last.slideePosState !== slideePosState) {
				last.slideePosState = slideePosState;

				if ($prevPageButton.is('button,input')) {
					$prevPageButton.prop('disabled', isStart);
				}

				if ($nextPageButton.is('button,input')) {
					$nextPageButton.prop('disabled', isEnd);
				}

				$prevPageButton.add($backwardButton)[isStart ? 'addClass' : 'removeClass'](o.disabledClass);
				$nextPageButton.add($forwardButton)[isEnd ? 'addClass' : 'removeClass'](o.disabledClass);
			}

			// Forward & Backward buttons need a separate state caching because we cannot "property disable"
			// them while they are being used, as disabled buttons stop emitting mouse events.
			if (last.fwdbwdState !== slideePosState && dragging.released) {
				last.fwdbwdState = slideePosState;

				if ($backwardButton.is('button,input')) {
					$backwardButton.prop('disabled', isStart);
				}

				if ($forwardButton.is('button,input')) {
					$forwardButton.prop('disabled', isEnd);
				}
			}

			// Item navigation
			if (itemNav && rel.activeItem != null) {
				var isFirst = rel.activeItem === 0;
				var isLast = rel.activeItem >= items.length - 1;
				var itemsButtonState = (isFirst ? 1 : 0) | (isLast ? 2 : 0);

				if (last.itemsButtonState !== itemsButtonState) {
					last.itemsButtonState = itemsButtonState;

					if ($prevButton.is('button,input')) {
						$prevButton.prop('disabled', isFirst);
					}

					if ($nextButton.is('button,input')) {
						$nextButton.prop('disabled', isLast);
					}

					$prevButton[isFirst ? 'addClass' : 'removeClass'](o.disabledClass);
					$nextButton[isLast ? 'addClass' : 'removeClass'](o.disabledClass);
				}
			}
		}

		/**
		 * Resume cycling.
		 *
		 * @param {Int} priority Resume pause with priority lower or equal than this. Used internally for pauseOnHover.
		 *
		 * @return {Void}
		 */
		self.resume = function (priority) {
			if (!o.cycleBy || !o.cycleInterval || o.cycleBy === 'items' && (!items[0] || rel.activeItem == null) || priority < self.isPaused) {
				return;
			}

			self.isPaused = 0;

			if (cycleID) {
				cycleID = clearTimeout(cycleID);
			} else {
				trigger('resume');
			}

			cycleID = setTimeout(function () {
				trigger('cycle');
				switch (o.cycleBy) {
					case 'items':
						self.activate(rel.activeItem >= items.length - 1 ? 0 : rel.activeItem + 1);
						break;

					case 'pages':
						self.activatePage(rel.activePage >= pages.length - 1 ? 0 : rel.activePage + 1);
						break;
				}
			}, o.cycleInterval);
		};

		/**
		 * Pause cycling.
		 *
		 * @param {Int} priority Pause priority. 100 is default. Used internally for pauseOnHover.
		 *
		 * @return {Void}
		 */
		self.pause = function (priority) {
			if (priority < self.isPaused) {
				return;
			}

			self.isPaused = priority || 100;

			if (cycleID) {
				cycleID = clearTimeout(cycleID);
				trigger('pause');
			}
		};

		/**
		 * Toggle cycling.
		 *
		 * @return {Void}
		 */
		self.toggle = function () {
			self[cycleID ? 'pause' : 'resume']();
		};

		/**
		 * Updates a signle or multiple option values.
		 *
		 * @param {Mixed} name  Name of the option that should be updated, or object that will extend the options.
		 * @param {Mixed} value New option value.
		 *
		 * @return {Void}
		 */
		self.set = function (name, value) {
			if ($.isPlainObject(name)) {
				$.extend(o, name);
			} else if (o.hasOwnProperty(name)) {
				o[name] = value;
			}
		};

		/**
		 * Add one or multiple items to the SLIDEE end, or a specified position index.
		 *
		 * @param {Mixed} element Node element, or HTML string.
		 * @param {Int}   index   Index of a new item position. By default item is appended at the end.
		 *
		 * @return {Void}
		 */
		self.add = function (element, index) {
			var $element = $(element);

			if (itemNav) {
				// Insert the element(s)
				if (index == null || !items[0] || index >= items.length) {
					$element.appendTo($slidee);
				} else if (items.length) {
					$element.insertBefore(items[index].el);
				}

				// Adjust the activeItem index
				if (rel.activeItem != null && index <= rel.activeItem) {
					last.active = rel.activeItem += $element.length;
				}
			} else {
				$slidee.append($element);
			}

			// Reload
			load();
		};

		/**
		 * Remove an item from SLIDEE.
		 *
		 * @param {Mixed} element Item index, or DOM element.
		 * @param {Int}   index   Index of a new item position. By default item is appended at the end.
		 *
		 * @return {Void}
		 */
		self.remove = function (element) {
			if (itemNav) {
				var index = getRelativeIndex(element);

				if (index > -1) {
					// Remove the element
					$items.eq(index).remove();

					// If the current item is being removed, activate new one after reload
					var reactivate = index === rel.activeItem;

					// Adjust the activeItem index
					if (rel.activeItem != null && index < rel.activeItem) {
						last.active = --rel.activeItem;
					}

					// Reload
					load();

					// Activate new item at the removed position
					if (reactivate) {
						last.active = null;
						self.activate(rel.activeItem);
					}
				}
			} else {
				$(element).remove();
				load();
			}
		};

		/**
		 * Helps re-arranging items.
		 *
		 * @param  {Mixed} item     Item DOM element, or index starting at 0. Use negative numbers to select items from the end.
		 * @param  {Mixed} position Item insertion anchor. Accepts same input types as item argument.
		 * @param  {Bool}  after    Insert after instead of before the anchor.
		 *
		 * @return {Void}
		 */
		function moveItem(item, position, after) {
			item = getRelativeIndex(item);
			position = getRelativeIndex(position);

			// Move only if there is an actual change requested
			if (item > -1 && position > -1 && item !== position && (!after || position !== item - 1) && (after || position !== item + 1)) {
				$items.eq(item)[after ? 'insertAfter' : 'insertBefore'](items[position].el);

				var shiftStart = item < position ? item : (after ? position : position - 1);
				var shiftEnd = item > position ? item : (after ? position + 1 : position);
				var shiftsUp = item > position;

				// Update activeItem index
				if (rel.activeItem != null) {
					if (item === rel.activeItem) {
						last.active = rel.activeItem = after ? (shiftsUp ? position + 1 : position) : (shiftsUp ? position : position - 1);
					} else if (rel.activeItem > shiftStart && rel.activeItem < shiftEnd) {
						last.active = rel.activeItem += shiftsUp ? 1 : -1;
					}
				}

				// Reload
				load();
			}
		}

		/**
		 * Move item after the target anchor.
		 *
		 * @param  {Mixed} item     Item to be moved. Can be DOM element or item index.
		 * @param  {Mixed} position Target position anchor. Can be DOM element or item index.
		 *
		 * @return {Void}
		 */
		self.moveAfter = function (item, position) {
			moveItem(item, position, 1);
		};

		/**
		 * Move item before the target anchor.
		 *
		 * @param  {Mixed} item     Item to be moved. Can be DOM element or item index.
		 * @param  {Mixed} position Target position anchor. Can be DOM element or item index.
		 *
		 * @return {Void}
		 */
		self.moveBefore = function (item, position) {
			moveItem(item, position);
		};

		/**
		 * Registers callbacks.
		 *
		 * @param  {Mixed} name  Event name, or callbacks map.
		 * @param  {Mixed} fn    Callback, or an array of callback functions.
		 *
		 * @return {Void}
		 */
		self.on = function (name, fn) {
			// Callbacks map
			if (type(name) === 'object') {
				for (var key in name) {
					if (name.hasOwnProperty(key)) {
						self.on(key, name[key]);
					}
				}
			// Callback
			} else if (type(fn) === 'function') {
				var names = name.split(' ');
				for (var n = 0, nl = names.length; n < nl; n++) {
					callbacks[names[n]] = callbacks[names[n]] || [];
					if (callbackIndex(names[n], fn) === -1) {
						callbacks[names[n]].push(fn);
					}
				}
			// Callbacks array
			} else if (type(fn) === 'array') {
				for (var f = 0, fl = fn.length; f < fl; f++) {
					self.on(name, fn[f]);
				}
			}
		};

		/**
		 * Registers callbacks to be executed only once.
		 *
		 * @param  {Mixed} name  Event name, or callbacks map.
		 * @param  {Mixed} fn    Callback, or an array of callback functions.
		 *
		 * @return {Void}
		 */
		self.one = function (name, fn) {
			function proxy() {
				fn.apply(self, arguments);
				self.off(name, proxy);
			}
			self.on(name, proxy);
		};

		/**
		 * Remove one or all callbacks.
		 *
		 * @param  {String} name Event name.
		 * @param  {Mixed}  fn   Callback, or an array of callback functions. Omit to remove all callbacks.
		 *
		 * @return {Void}
		 */
		self.off = function (name, fn) {
			if (fn instanceof Array) {
				for (var f = 0, fl = fn.length; f < fl; f++) {
					self.off(name, fn[f]);
				}
			} else {
				var names = name.split(' ');
				for (var n = 0, nl = names.length; n < nl; n++) {
					callbacks[names[n]] = callbacks[names[n]] || [];
					if (fn == null) {
						callbacks[names[n]].length = 0;
					} else {
						var index = callbackIndex(names[n], fn);
						if (index !== -1) {
							callbacks[names[n]].splice(index, 1);
						}
					}
				}
			}
		};

		/**
		 * Returns callback array index.
		 *
		 * @param  {String}   name Event name.
		 * @param  {Function} fn   Function
		 *
		 * @return {Int} Callback array index, or -1 if isn't registered.
		 */
		function callbackIndex(name, fn) {
			for (var i = 0, l = callbacks[name].length; i < l; i++) {
				if (callbacks[name][i] === fn) {
					return i;
				}
			}
			return -1;
		}

		/**
		 * Reset next cycle timeout.
		 *
		 * @return {Void}
		 */
		function resetCycle() {
			if (dragging.released && !self.isPaused) {
				self.resume();
			}
		}

		/**
		 * Calculate SLIDEE representation of handle position.
		 *
		 * @param  {Int} handlePos
		 *
		 * @return {Int}
		 */
		function handleToSlidee(handlePos) {
			return round(within(handlePos, hPos.start, hPos.end) / hPos.end * (pos.end - pos.start)) + pos.start;
		}

		/**
		 * Keeps track of a dragging delta history.
		 *
		 * @return {Void}
		 */
		function draggingHistoryTick() {
			// Looking at this, I know what you're thinking :) But as we need only 4 history states, doing it this way
			// as opposed to a proper loop is ~25 bytes smaller (when minified with GCC), a lot faster, and doesn't
			// generate garbage. The loop version would create 2 new variables on every tick. Unexaptable!
			dragging.history[0] = dragging.history[1];
			dragging.history[1] = dragging.history[2];
			dragging.history[2] = dragging.history[3];
			dragging.history[3] = dragging.delta;
		}

		/**
		 * Initialize continuous movement.
		 *
		 * @return {Void}
		 */
		function continuousInit(source) {
			dragging.released = 0;
			dragging.source = source;
			dragging.slidee = source === 'slidee';
		}

		/**
		 * Dragging initiator.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function dragInit(event) {
			var isTouch = event.type === 'touchstart';
			var source = event.data.source;
			var isSlidee = source === 'slidee';

			// Ignore when already in progress, or interactive element in non-touch navivagion
			if (dragging.init || !isTouch && isInteractive(event.target)) {
				return;
			}

			// Handle dragging conditions
			if (source === 'handle' && (!o.dragHandle || hPos.start === hPos.end)) {
				return;
			}

			// SLIDEE dragging conditions
			if (isSlidee && !(isTouch ? o.touchDragging : o.mouseDragging && event.which < 2)) {
				return;
			}

			if (!isTouch) {
				// prevents native image dragging in Firefox
				stopDefault(event);
			}

			// Reset dragging object
			continuousInit(source);

			// Properties used in dragHandler
			dragging.init = 0;
			dragging.$source = $(event.target);
			dragging.touch = isTouch;
			dragging.pointer = isTouch ? event.originalEvent.touches[0] : event;
			dragging.initX = dragging.pointer.pageX;
			dragging.initY = dragging.pointer.pageY;
			dragging.initPos = isSlidee ? pos.cur : hPos.cur;
			dragging.start = +new Date();
			dragging.time = 0;
			dragging.path = 0;
			dragging.delta = 0;
			dragging.locked = 0;
			dragging.history = [0, 0, 0, 0];
			dragging.pathToLock = isSlidee ? isTouch ? 30 : 10 : 0;

			// Bind dragging events
			$doc.on(isTouch ? dragTouchEvents : dragMouseEvents, dragHandler);

			// Pause ongoing cycle
			self.pause(1);

			// Add dragging class
			(isSlidee ? $slidee : $handle).addClass(o.draggedClass);

			// Trigger moveStart event
			trigger('moveStart');

			// Keep track of a dragging path history. This is later used in the
			// dragging release swing calculation when dragging SLIDEE.
			if (isSlidee) {
				historyID = setInterval(draggingHistoryTick, 10);
			}
		}

		/**
		 * Handler for dragging scrollbar handle or SLIDEE.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function dragHandler(event) {
			dragging.released = event.type === 'mouseup' || event.type === 'touchend';
			dragging.pointer = dragging.touch ? event.originalEvent[dragging.released ? 'changedTouches' : 'touches'][0] : event;
			dragging.pathX = dragging.pointer.pageX - dragging.initX;
			dragging.pathY = dragging.pointer.pageY - dragging.initY;
			dragging.path = sqrt(pow(dragging.pathX, 2) + pow(dragging.pathY, 2));
			dragging.delta = o.horizontal ? dragging.pathX : dragging.pathY;

			if (!dragging.released && dragging.path < 1) return;

			// We haven't decided whether this is a drag or not...
			if (!dragging.init) {
				// If the drag path was very short, maybe it's not a drag?
				if (dragging.path < o.dragThreshold) {
					// If the pointer was released, the path will not become longer and it's
					// definitely not a drag. If not released yet, decide on next iteration
					return dragging.released ? dragEnd() : undefined;
				}
				else {
					// If dragging path is sufficiently long we can confidently start a drag
					// if drag is in different direction than scroll, ignore it
					if (o.horizontal ? abs(dragging.pathX) > abs(dragging.pathY) : abs(dragging.pathX) < abs(dragging.pathY)) {
						dragging.init = 1;
					} else {
						return dragEnd();
					}
				}
			}

			stopDefault(event);

			// Disable click on a source element, as it is unwelcome when dragging
			if (!dragging.locked && dragging.path > dragging.pathToLock && dragging.slidee) {
				dragging.locked = 1;
				dragging.$source.on(clickEvent, disableOneEvent);
			}

			// Cancel dragging on release
			if (dragging.released) {
				dragEnd();

				// Adjust path with a swing on mouse release
				if (o.releaseSwing && dragging.slidee) {
					dragging.swing = (dragging.delta - dragging.history[0]) / 40 * 300;
					dragging.delta += dragging.swing;
					dragging.tweese = abs(dragging.swing) > 10;
				}
			}

			slideTo(dragging.slidee ? round(dragging.initPos - dragging.delta) : handleToSlidee(dragging.initPos + dragging.delta));
		}

		/**
		 * Stops dragging and cleans up after it.
		 *
		 * @return {Void}
		 */
		function dragEnd() {
			clearInterval(historyID);
			dragging.released = true;
			$doc.off(dragging.touch ? dragTouchEvents : dragMouseEvents, dragHandler);
			(dragging.slidee ? $slidee : $handle).removeClass(o.draggedClass);

			// Make sure that disableOneEvent is not active in next tick.
			setTimeout(function () {
				dragging.$source.off(clickEvent, disableOneEvent);
			});

			// Normally, this is triggered in render(), but if there
			// is nothing to render, we have to do it manually here.
			if (pos.cur === pos.dest && dragging.init) {
				trigger('moveEnd');
			}

			// Resume ongoing cycle
			self.resume(1);

			dragging.init = 0;
		}

		/**
		 * Check whether element is interactive.
		 *
		 * @return {Boolean}
		 */
		function isInteractive(element) {
			return ~$.inArray(element.nodeName, interactiveElements) || $(element).is(o.interactive);
		}

		/**
		 * Continuous movement cleanup on mouseup.
		 *
		 * @return {Void}
		 */
		function movementReleaseHandler() {
			self.stop();
			$doc.off('mouseup', movementReleaseHandler);
		}

		/**
		 * Buttons navigation handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function buttonsHandler(event) {
			/*jshint validthis:true */
			stopDefault(event);
			switch (this) {
				case $forwardButton[0]:
				case $backwardButton[0]:
					self.moveBy($forwardButton.is(this) ? o.moveBy : -o.moveBy);
					$doc.on('mouseup', movementReleaseHandler);
					break;

				case $prevButton[0]:
					self.prev();
					break;

				case $nextButton[0]:
					self.next();
					break;

				case $prevPageButton[0]:
					self.prevPage();
					break;

				case $nextPageButton[0]:
					self.nextPage();
					break;
			}
		}

		/**
		 * Mouse wheel delta normalization.
		 *
		 * @param  {Event} event
		 *
		 * @return {Int}
		 */
		function normalizeWheelDelta(event) {
			// wheelDelta needed only for IE8-
			scrolling.curDelta = ((o.horizontal ? event.deltaY || event.deltaX : event.deltaY) || -event.wheelDelta);
			scrolling.curDelta /= event.deltaMode === 1 ? 3 : 100;
			if (!itemNav) {
				return scrolling.curDelta;
			}
			time = +new Date();
			if (scrolling.last < time - scrolling.resetTime) {
				scrolling.delta = 0;
			}
			scrolling.last = time;
			scrolling.delta += scrolling.curDelta;
			if (abs(scrolling.delta) < 1) {
				scrolling.finalDelta = 0;
			} else {
				scrolling.finalDelta = round(scrolling.delta / 1);
				scrolling.delta %= 1;
			}
			return scrolling.finalDelta;
		}

		/**
		 * Mouse scrolling handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function scrollHandler(event) {
			// Mark event as originating in a Sly instance
			event.originalEvent[namespace] = self;
			// Don't hijack global scrolling
			var time = +new Date();
			if (lastGlobalWheel + o.scrollHijack > time && $scrollSource[0] !== document && $scrollSource[0] !== window) {
				lastGlobalWheel = time;
				return;
			}
			// Ignore if there is no scrolling to be done
			if (!o.scrollBy || pos.start === pos.end) {
				return;
			}
			var delta = normalizeWheelDelta(event.originalEvent);
			// Trap scrolling only when necessary and/or requested
			if (o.scrollTrap || delta > 0 && pos.dest < pos.end || delta < 0 && pos.dest > pos.start) {
				stopDefault(event, 1);
			}
			self.slideBy(o.scrollBy * delta);
		}

		/**
		 * Scrollbar click handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function scrollbarHandler(event) {
			// Only clicks on scroll bar. Ignore the handle.
			if (o.clickBar && event.target === $sb[0]) {
				stopDefault(event);
				// Calculate new handle position and sync SLIDEE to it
				slideTo(handleToSlidee((o.horizontal ? event.pageX - $sb.offset().left : event.pageY - $sb.offset().top) - handleSize / 2));
			}
		}

		/**
		 * Keyboard input handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function keyboardHandler(event) {
			if (!o.keyboardNavBy) {
				return;
			}

			switch (event.which) {
				// Left or Up
				case o.horizontal ? 37 : 38:
					stopDefault(event);
					self[o.keyboardNavBy === 'pages' ? 'prevPage' : 'prev']();
					break;

				// Right or Down
				case o.horizontal ? 39 : 40:
					stopDefault(event);
					self[o.keyboardNavBy === 'pages' ? 'nextPage' : 'next']();
					break;
			}
		}

		/**
		 * Click on item activation handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function activateHandler(event) {
			/*jshint validthis:true */

			// Ignore clicks on interactive elements.
			if (isInteractive(this)) {
				event.originalEvent[namespace + 'ignore'] = true;
				return;
			}

			// Ignore events that:
			// - are not originating from direct SLIDEE children
			// - originated from interactive elements
			if (this.parentNode !== $slidee[0] || event.originalEvent[namespace + 'ignore']) return;

			self.activate(this);
		}

		/**
		 * Click on page button handler.
		 *
		 * @param {Event} event
		 *
		 * @return {Void}
		 */
		function activatePageHandler() {
			/*jshint validthis:true */
			// Accept only events from direct pages bar children.
			if (this.parentNode === $pb[0]) {
				self.activatePage($pages.index(this));
			}
		}

		/**
		 * Pause on hover handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function pauseOnHoverHandler(event) {
			if (o.pauseOnHover) {
				self[event.type === 'mouseenter' ? 'pause' : 'resume'](2);
			}
		}

		/**
		 * Trigger callbacks for event.
		 *
		 * @param  {String} name Event name.
		 * @param  {Mixed}  argX Arguments passed to callbacks.
		 *
		 * @return {Void}
		 */
		function trigger(name, arg1) {
			if (callbacks[name]) {
				l = callbacks[name].length;
				// Callbacks will be stored and executed from a temporary array to not
				// break the execution queue when one of the callbacks unbinds itself.
				tmpArray.length = 0;
				for (i = 0; i < l; i++) {
					tmpArray.push(callbacks[name][i]);
				}
				// Execute the callbacks
				for (i = 0; i < l; i++) {
					tmpArray[i].call(self, name, arg1);
				}
			}
		}

		/**
		 * Destroys instance and everything it created.
		 *
		 * @return {Void}
		 */
		self.destroy = function () {
			// Remove the reference to itself
			Sly.removeInstance(frame);

			// Unbind all events
			$scrollSource
				.add($handle)
				.add($sb)
				.add($pb)
				.add($forwardButton)
				.add($backwardButton)
				.add($prevButton)
				.add($nextButton)
				.add($prevPageButton)
				.add($nextPageButton)
				.off('.' + namespace);

			// Unbinding specifically as to not nuke out other instances
			$doc.off('keydown', keyboardHandler);

			// Remove classes
			$prevButton
				.add($nextButton)
				.add($prevPageButton)
				.add($nextPageButton)
				.removeClass(o.disabledClass);

			if ($items && rel.activeItem != null) {
				$items.eq(rel.activeItem).removeClass(o.activeClass);
			}

			// Remove page items
			$pb.empty();

			if (!parallax) {
				// Unbind events from frame
				$frame.off('.' + namespace);
				// Restore original styles
				frameStyles.restore();
				slideeStyles.restore();
				sbStyles.restore();
				handleStyles.restore();
				// Remove the instance from element data storage
				$.removeData(frame, namespace);
			}

			// Clean up collections
			items.length = pages.length = 0;
			last = {};

			// Reset initialized status and return the instance
			self.initialized = 0;
			return self;
		};

		/**
		 * Initialize.
		 *
		 * @return {Object}
		 */
		self.init = function () {
			if (self.initialized) {
				return;
			}

			// Disallow multiple instances on the same element
			if (Sly.getInstance(frame)) throw new Error('There is already a Sly instance on this element');

			// Store the reference to itself
			Sly.storeInstance(frame, self);

			// Register callbacks map
			self.on(callbackMap);

			// Save styles
			var holderProps = ['overflow', 'position'];
			var movableProps = ['position', 'webkitTransform', 'msTransform', 'transform', 'left', 'top', 'width', 'height'];
			frameStyles.save.apply(frameStyles, holderProps);
			sbStyles.save.apply(sbStyles, holderProps);
			slideeStyles.save.apply(slideeStyles, movableProps);
			handleStyles.save.apply(handleStyles, movableProps);

			// Set required styles
			var $movables = $handle;
			if (!parallax) {
				$movables = $movables.add($slidee);
				$frame.css('overflow', 'hidden');
				if (!transform && $frame.css('position') === 'static') {
					$frame.css('position', 'relative');
				}
			}
			if (transform) {
				if (gpuAcceleration) {
					$movables.css(transform, gpuAcceleration);
				}
			} else {
				if ($sb.css('position') === 'static') {
					$sb.css('position', 'relative');
				}
				$movables.css({ position: 'absolute' });
			}

			// Navigation buttons
			if (o.forward) {
				$forwardButton.on(mouseDownEvent, buttonsHandler);
			}
			if (o.backward) {
				$backwardButton.on(mouseDownEvent, buttonsHandler);
			}
			if (o.prev) {
				$prevButton.on(clickEvent, buttonsHandler);
			}
			if (o.next) {
				$nextButton.on(clickEvent, buttonsHandler);
			}
			if (o.prevPage) {
				$prevPageButton.on(clickEvent, buttonsHandler);
			}
			if (o.nextPage) {
				$nextPageButton.on(clickEvent, buttonsHandler);
			}

			// Scrolling navigation
			$scrollSource.on(wheelEvent, scrollHandler);

			// Clicking on scrollbar navigation
			if ($sb[0]) {
				$sb.on(clickEvent, scrollbarHandler);
			}

			// Click on items navigation
			if (itemNav && o.activateOn) {
				$frame.on(o.activateOn + '.' + namespace, '*', activateHandler);
			}

			// Pages navigation
			if ($pb[0] && o.activatePageOn) {
				$pb.on(o.activatePageOn + '.' + namespace, '*', activatePageHandler);
			}

			// Dragging navigation
			$dragSource.on(dragInitEvents, { source: 'slidee' }, dragInit);

			// Scrollbar dragging navigation
			if ($handle) {
				$handle.on(dragInitEvents, { source: 'handle' }, dragInit);
			}

			// Keyboard navigation
			$doc.on('keydown', keyboardHandler);

			if (!parallax) {
				// Pause on hover
				$frame.on('mouseenter.' + namespace + ' mouseleave.' + namespace, pauseOnHoverHandler);
				// Reset native FRAME element scroll
				$frame.on('scroll.' + namespace, resetScroll);
			}

			// Mark instance as initialized
			self.initialized = 1;

			// Load
			load(true);

			// Initiate automatic cycling
			if (o.cycleBy && !parallax) {
				self[o.startPaused ? 'pause' : 'resume']();
			}

			// Return instance
			return self;
		};
	}

	Sly.getInstance = function (element) {
		return $.data(element, namespace);
	};

	Sly.storeInstance = function (element, sly) {
		return $.data(element, namespace, sly);
	};

	Sly.removeInstance = function (element) {
		return $.removeData(element, namespace);
	};

	/**
	 * Return type of the value.
	 *
	 * @param  {Mixed} value
	 *
	 * @return {String}
	 */
	function type(value) {
		if (value == null) {
			return String(value);
		}

		if (typeof value === 'object' || typeof value === 'function') {
			return Object.prototype.toString.call(value).match(/\s([a-z]+)/i)[1].toLowerCase() || 'object';
		}

		return typeof value;
	}

	/**
	 * Event preventDefault & stopPropagation helper.
	 *
	 * @param {Event} event     Event object.
	 * @param {Bool}  noBubbles Cancel event bubbling.
	 *
	 * @return {Void}
	 */
	function stopDefault(event, noBubbles) {
		event.preventDefault();
		if (noBubbles) {
			event.stopPropagation();
		}
	}

	/**
	 * Disables an event it was triggered on and unbinds itself.
	 *
	 * @param  {Event} event
	 *
	 * @return {Void}
	 */
	function disableOneEvent(event) {
		/*jshint validthis:true */
		stopDefault(event, 1);
		$(this).off(event.type, disableOneEvent);
	}

	/**
	 * Resets native element scroll values to 0.
	 *
	 * @return {Void}
	 */
	function resetScroll() {
		/*jshint validthis:true */
		this.scrollLeft = 0;
		this.scrollTop = 0;
	}

	/**
	 * Check if variable is a number.
	 *
	 * @param {Mixed} value
	 *
	 * @return {Boolean}
	 */
	function isNumber(value) {
		return !isNaN(parseFloat(value)) && isFinite(value);
	}

	/**
	 * Parse style to pixels.
	 *
	 * @param {Object}   $item    jQuery object with element.
	 * @param {Property} property CSS property to get the pixels from.
	 *
	 * @return {Int}
	 */
	function getPx($item, property) {
		return 0 | round(String($item.css(property)).replace(/[^\-0-9.]/g, ''));
	}

	/**
	 * Make sure that number is within the limits.
	 *
	 * @param {Number} number
	 * @param {Number} min
	 * @param {Number} max
	 *
	 * @return {Number}
	 */
	function within(number, min, max) {
		return number < min ? min : number > max ? max : number;
	}

	/**
	 * Saves element styles for later restoration.
	 *
	 * Example:
	 *   var styles = new StyleRestorer(frame);
	 *   styles.save('position');
	 *   element.style.position = 'absolute';
	 *   styles.restore(); // restores to state before the assignment above
	 *
	 * @param {Element} element
	 */
	function StyleRestorer(element) {
		var self = {};
		self.style = {};
		self.save = function () {
			if (!element || !element.nodeType) return;
			for (var i = 0; i < arguments.length; i++) {
				self.style[arguments[i]] = element.style[arguments[i]];
			}
			return self;
		};
		self.restore = function () {
			if (!element || !element.nodeType) return;
			for (var prop in self.style) {
				if (self.style.hasOwnProperty(prop)) element.style[prop] = self.style[prop];
			}
			return self;
		};
		return self;
	}

	// Local WindowAnimationTiming interface polyfill
	(function (w) {
		rAF = w.requestAnimationFrame
			|| w.webkitRequestAnimationFrame
			|| fallback;

		/**
		* Fallback implementation.
		*/
		var prev = new Date().getTime();
		function fallback(fn) {
			var curr = new Date().getTime();
			var ms = Math.max(0, 16 - (curr - prev));
			var req = setTimeout(fn, ms);
			prev = curr;
			return req;
		}

		/**
		* Cancel.
		*/
		var cancel = w.cancelAnimationFrame
			|| w.webkitCancelAnimationFrame
			|| w.clearTimeout;

		cAF = function(id){
			cancel.call(w, id);
		};
	}(window));

	// Feature detects
	(function () {
		var prefixes = ['', 'Webkit', 'Moz', 'ms', 'O'];
		var el = document.createElement('div');

		function testProp(prop) {
			for (var p = 0, pl = prefixes.length; p < pl; p++) {
				var prefixedProp = prefixes[p] ? prefixes[p] + prop.charAt(0).toUpperCase() + prop.slice(1) : prop;
				if (el.style[prefixedProp] != null) {
					return prefixedProp;
				}
			}
		}

		// Global support indicators
		transform = testProp('transform');
		gpuAcceleration = testProp('perspective') ? 'translateZ(0) ' : '';
	}());

	// Expose class globally
	w[className] = Sly;

	// jQuery proxy
	$.fn[pluginName] = function (options, callbackMap) {
		var method, methodArgs;

		// Attributes logic
		if (!$.isPlainObject(options)) {
			if (type(options) === 'string' || options === false) {
				method = options === false ? 'destroy' : options;
				methodArgs = Array.prototype.slice.call(arguments, 1);
			}
			options = {};
		}

		// Apply to all elements
		return this.each(function (i, element) {
			// Call with prevention against multiple instantiations
			var plugin = Sly.getInstance(element);

			if (!plugin && !method) {
				// Create a new object if it doesn't exist yet
				plugin = new Sly(element, options, callbackMap).init();
			} else if (plugin && method) {
				// Call method
				if (plugin[method]) {
					plugin[method].apply(plugin, methodArgs);
				}
			}
		});
	};

	// Default options
	Sly.defaults = {
		slidee:     null,  // Selector, DOM element, or jQuery object with DOM element representing SLIDEE.
		horizontal: false, // Switch to horizontal mode.

		// Item based navigation
		itemNav:        null,  // Item navigation type. Can be: 'basic', 'centered', 'forceCentered'.
		itemSelector:   null,  // Select only items that match this selector.
		smart:          false, // Repositions the activated item to help with further navigation.
		activateOn:     null,  // Activate an item on this event. Can be: 'click', 'mouseenter', ...
		activateMiddle: false, // Always activate the item in the middle of the FRAME. forceCentered only.

		// Scrolling
		scrollSource: null,  // Element for catching the mouse wheel scrolling. Default is FRAME.
		scrollBy:     0,     // Pixels or items to move per one mouse scroll. 0 to disable scrolling.
		scrollHijack: 300,   // Milliseconds since last wheel event after which it is acceptable to hijack global scroll.
		scrollTrap:   false, // Don't bubble scrolling when hitting scrolling limits.

		// Dragging
		dragSource:    null,  // Selector or DOM element for catching dragging events. Default is FRAME.
		mouseDragging: false, // Enable navigation by dragging the SLIDEE with mouse cursor.
		touchDragging: false, // Enable navigation by dragging the SLIDEE with touch events.
		releaseSwing:  false, // Ease out on dragging swing release.
		swingSpeed:    0.2,   // Swing synchronization speed, where: 1 = instant, 0 = infinite.
		elasticBounds: false, // Stretch SLIDEE position limits when dragging past FRAME boundaries.
		dragThreshold: 3,     // Distance in pixels before Sly recognizes dragging.
		interactive:   null,  // Selector for special interactive elements.

		// Scrollbar
		scrollBar:     null,  // Selector or DOM element for scrollbar container.
		dragHandle:    false, // Whether the scrollbar handle should be draggable.
		dynamicHandle: false, // Scrollbar handle represents the ratio between hidden and visible content.
		minHandleSize: 50,    // Minimal height or width (depends on sly direction) of a handle in pixels.
		clickBar:      false, // Enable navigation by clicking on scrollbar.
		syncSpeed:     0.5,   // Handle => SLIDEE synchronization speed, where: 1 = instant, 0 = infinite.

		// Pagesbar
		pagesBar:       null, // Selector or DOM element for pages bar container.
		activatePageOn: null, // Event used to activate page. Can be: click, mouseenter, ...
		pageBuilder:          // Page item generator.
			function (index) {
				return '<li>' + (index + 1) + '</li>';
			},

		// Navigation buttons
		forward:  null, // Selector or DOM element for "forward movement" button.
		backward: null, // Selector or DOM element for "backward movement" button.
		prev:     null, // Selector or DOM element for "previous item" button.
		next:     null, // Selector or DOM element for "next item" button.
		prevPage: null, // Selector or DOM element for "previous page" button.
		nextPage: null, // Selector or DOM element for "next page" button.

		// Automated cycling
		cycleBy:       null,  // Enable automatic cycling by 'items' or 'pages'.
		cycleInterval: 5000,  // Delay between cycles in milliseconds.
		pauseOnHover:  false, // Pause cycling when mouse hovers over the FRAME.
		startPaused:   false, // Whether to start in paused sate.

		// Mixed options
		moveBy:        300,     // Speed in pixels per second used by forward and backward buttons.
		speed:         0,       // Animations speed in milliseconds. 0 to disable animations.
		easing:        'swing', // Easing for duration based (tweening) animations.
		startAt:       null,    // Starting offset in pixels or items.
		keyboardNavBy: null,    // Enable keyboard navigation by 'items' or 'pages'.

		// Classes
		draggedClass:  'dragged', // Class for dragged elements (like SLIDEE or scrollbar handle).
		activeClass:   'active',  // Class for active items and pages.
		disabledClass: 'disabled' // Class for disabled navigation elements.
	};
}(jQuery, window));

$(function() {
    $('ul.a2lix_translationsLocales').on('click', 'a', function(evt) {
        evt.preventDefault();

        var target = $(this).attr('data-target');
        $('li:has(a[data-target="' + target + '"]), div' + target, 'div.a2lix_translations').addClass('active')
            .siblings().removeClass('active');
    });

    $('div.a2lix_translationsLocalesSelector').on('change', 'input', function(evt) {
        var $tabs = $('ul.a2lix_translationsLocales');

        $('div.a2lix_translationsLocalesSelector').find('input').each(function() {
            $tabs.find('li:has(a[data-target=".a2lix_translationsFields-' + this.value + '"])').toggle(this.checked);
        });

        $('ul.a2lix_translationsLocales li:visible:first').find('a').trigger('click');
    }).trigger('change');
});

/**
 * @author William DURAND <william.durand1@gmail.com>
 * @license MIT Licensed
 */
!function(e,a){"function"==typeof define&&define.amd?define("Translator",a):"object"==typeof module&&module.exports?module.exports=a():e.Translator=a()}(this,function(){"use strict";function e(e,a){var s,n=p.placeHolderPrefix,c=p.placeHolderSuffix;for(s in a){var r=new RegExp(n+s+c,"g");if(r.test(e)){var t=String(a[s]).replace(new RegExp("\\$","g"),"$$$$");e=e.replace(r,t)}}return e}function a(e,a,n,c,r){var t=n||c||r,i=a,u=t.split("_")[0];if(!(t in l))if(u in l)t=u;else{if(!(r in l))return e;t=r}if(void 0===i||null===i)for(var o=0;o<f.length;o++)if(s(t,f[o],e)||s(u,f[o],e)||s(r,f[o],e)){i=f[o];break}if(s(t,i,e))return l[t][i][e];for(var h,d,p,m;t.length>2&&(h=t.length,d=t.split(/[\s_]+/),p=d[d.length-1],m=p.length,1!==d.length);)if(t=t.substring(0,h-(m+1)),s(t,i,e))return l[t][i][e];return s(r,i,e)?l[r][i][e]:e}function s(e,a,s){return e in l&&(a in l[e]&&s in l[e][a])}function n(e,a,s){var n,t,i=[],l=[],u=e.split(p.pluralSeparator),f=[];for(n=0;n<u.length;n++){var m=u[n];h.test(m)?(f=m.match(h),i[f[0]]=f[f.length-1]):o.test(m)?(f=m.match(o),l.push(f[1])):l.push(m)}for(t in i)if(d.test(t))if(f=t.match(d),f[1]){var g,v=f[2].split(",");for(g in v)if(a==v[g])return i[t]}else{var b=c(f[4]),k=c(f[5]);if(("["===f[3]?a>=b:a>b)&&("]"===f[6]?a<=k:a<k))return i[t]}return l[r(a,s)]||l[0]||void 0}function c(e){return"-Inf"===e?Number.NEGATIVE_INFINITY:"+Inf"===e||"Inf"===e?Number.POSITIVE_INFINITY:parseInt(e,10)}function r(e,a){var s=a;switch("pt_BR"===s&&(s="xbr"),s.length>3&&(s=s.split("_")[0]),s){case"bo":case"dz":case"id":case"ja":case"jv":case"ka":case"km":case"kn":case"ko":case"ms":case"th":case"tr":case"vi":case"zh":return 0;case"af":case"az":case"bn":case"bg":case"ca":case"da":case"de":case"el":case"en":case"eo":case"es":case"et":case"eu":case"fa":case"fi":case"fo":case"fur":case"fy":case"gl":case"gu":case"ha":case"he":case"hu":case"is":case"it":case"ku":case"lb":case"ml":case"mn":case"mr":case"nah":case"nb":case"ne":case"nl":case"nn":case"no":case"om":case"or":case"pa":case"pap":case"ps":case"pt":case"so":case"sq":case"sv":case"sw":case"ta":case"te":case"tk":case"ur":case"zu":return 1==e?0:1;case"am":case"bh":case"fil":case"fr":case"gun":case"hi":case"ln":case"mg":case"nso":case"xbr":case"ti":case"wa":return 0===e||1==e?0:1;case"be":case"bs":case"hr":case"ru":case"sr":case"uk":return e%10==1&&e%100!=11?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2;case"cs":case"sk":return 1==e?0:e>=2&&e<=4?1:2;case"ga":return 1==e?0:2==e?1:2;case"lt":return e%10==1&&e%100!=11?0:e%10>=2&&(e%100<10||e%100>=20)?1:2;case"sl":return e%100==1?0:e%100==2?1:e%100==3||e%100==4?2:3;case"mk":return e%10==1?0:1;case"mt":return 1==e?0:0===e||e%100>1&&e%100<11?1:e%100>10&&e%100<20?2:3;case"lv":return 0===e?0:e%10==1&&e%100!=11?1:2;case"pl":return 1==e?0:e%10>=2&&e%10<=4&&(e%100<12||e%100>14)?1:2;case"cy":return 1==e?0:2==e?1:8==e||11==e?2:3;case"ro":return 1==e?0:0===e||e%100>0&&e%100<20?1:2;case"ar":return 0===e?0:1==e?1:2==e?2:e>=3&&e<=10?3:e>=11&&e<=99?4:5;default:return 0}}function t(e,a){for(var s=0;s<e.length;s++)if(a===e[s])return!0;return!1}function i(){return"undefined"!=typeof document?document.documentElement.lang.replace("-","_"):u}var l={},u="en",f=[],o=new RegExp(/^\w+\: +(.+)$/),h=new RegExp(/^\s*((\{\s*(\-?\d+[\s*,\s*\-?\d+]*)\s*\})|([\[\]])\s*(-Inf|\-?\d+)\s*,\s*(\+?Inf|\-?\d+)\s*([\[\]]))\s?(.+?)$/),d=new RegExp(/^\s*(\{\s*(\-?\d+[\s*,\s*\-?\d+]*)\s*\})|([\[\]])\s*(-Inf|\-?\d+)\s*,\s*(\+?Inf|\-?\d+)\s*([\[\]])/),p={locale:i(),fallback:u,placeHolderPrefix:"%",placeHolderSuffix:"%",defaultDomain:"messages",pluralSeparator:"|",add:function(e,a,s,n){var c=n||this.locale||this.fallback,r=s||this.defaultDomain;return l[c]||(l[c]={}),l[c][r]||(l[c][r]={}),l[c][r][e]=a,!1===t(f,r)&&f.push(r),this},trans:function(s,n,c,r){return e(a(s,c,r,this.locale,this.fallback),n||{})},transChoice:function(s,c,r,t,i){var l=a(s,t,i,this.locale,this.fallback),u=parseInt(c,10);return r=r||{},void 0===r.count&&(r.count=c),void 0===l||isNaN(u)||(l=n(l,u,i||this.locale||this.fallback)),e(l,r)},fromJSON:function(e){if("string"==typeof e&&(e=JSON.parse(e)),e.locale&&(this.locale=e.locale),e.fallback&&(this.fallback=e.fallback),e.defaultDomain&&(this.defaultDomain=e.defaultDomain),e.translations)for(var a in e.translations)for(var s in e.translations[a])for(var n in e.translations[a][s])this.add(n,e.translations[a][s][n],s,a);return this},reset:function(){l={},f=[],this.locale=i()}};return p});
var AJAX_LOADER  = '<span class="ajax_loader"></span>';
var NOTY_TIMEOUT = 1500;

var notify = function (text, type) {
    if (!text) {
        return;
    }

    new Noty({
        text:    Translator.trans(text),
        type:    type || 'success',
        theme:   'bootstrap-v3',
        timeout: NOTY_TIMEOUT
    }).show();
};

var onAjaxFail = function (jqXHR) {
    var message = 'exception.' + jqXHR.status;
    var translated = Translator.trans(message);

    if (translated === message) {
        translated = Translator.trans('exception.500');
    }

    notify(translated, 'error');
};

$(document).bind('ajaxComplete', function () {
    $('.ajax_loader').remove();

    $('a, form').removeData('submitted');
});

var YandexTranslator = (function () {
    return {
        translate: function (text, from, to, successCallback) {
            if ('undefined' === typeof YANDEX_TRANSLATE_API_KEY || '' === YANDEX_TRANSLATE_API_KEY) {
                console.log('Non empty "YANDEX_TRANSLATE_API_KEY" variable must be defined, skip translating.');

                successCallback(text);

                return;
            }

            var lang = from + '-' + to;
            var url = 'https://translate.yandex.net/api/v1.5/tr.json/translate?key=' + YANDEX_TRANSLATE_API_KEY + '&text=' + text + '&lang=' + lang;

            $.ajax({
                url: url
            }).done(function (response) {
                if (200 !== response.code) {
                    console.log(response);

                    return;
                }

                successCallback(response.text[0]);
            });
        }
    };
})();

$(document).ready(function () {
    $('body').on('submit', 'form.ajax[action][method]', function (e) {
        e.preventDefault();

        var $form = $(this);

        if ($form.data('submitted')) {
            return;
        }

        $form
            .data('submitted', true)
            .find('[type="submit"]').append(AJAX_LOADER);

        $.ajax({
            url:         $form.attr('action'),
            type:        $form.attr('method'),
            data:        new FormData($form[0]),
            contentType: false,
            processData: false
        }).done(function (data) {
            notify(data.message, data.success ? 'success' : 'error');

            if (data.html) {
                $form.replaceWith(data.html);
            }
            if (null !== data.redirectUrl) {
                setTimeout(function () {
                    document.location.href = data.redirectUrl;
                }, NOTY_TIMEOUT);
            }
        }).fail(onAjaxFail);
    });
});

$(document).ready(function () {
    $('body')
        .on('change', 'input[type="checkbox"].batch_delete_check[data-id]', function () {
            var $check = $(this);
            var $context = $check.closest('.property_forms');
            var $checkAll = $context.find('input[type="checkbox"].batch_delete_check_all');
            var $form = $context.find('form.batch_delete_form');
            var $submit = $form.find('[type="submit"]:first');

            $form.find('input[type="checkbox"][value="' + $check.data('id') + '"]')[0].checked = this.checked;

            if (!this.checked) {
                $checkAll[0].checked = false;

                if ($submit.is(':visible') && 0 === $('input[type="checkbox"].batch_delete_check[data-id]:checked').length) {
                    $submit.hide();
                }

                return;
            }

            var $checks = $context.find('input[type="checkbox"].batch_delete_check[data-id]');

            $checkAll[0].checked = $checks.length === $checks.filter(':checked').length;
            $submit.show();
        })
        .on('change', 'input[type="checkbox"].batch_delete_check_all', function () {
            var checked = this.checked;

            $(this).closest('.property_forms').find('input[type="checkbox"].batch_delete_check').each(function () {
                this.checked = checked;

                $(this).trigger('change');
            });
        });
});

$(document).ready(function () {
    var SCROLL_SPEED = -1 !== navigator.userAgent.indexOf('Firefox') ? 10 : 1;

    var searchResultsMousewheel = function (e) {
        var delta;

        if (e.originalEvent) {
            delta = e.originalEvent.deltaY || -e.originalEvent.wheelDelta || e.originalEvent.detail;
        }
        if (delta == null) {
            return null;
        }

        e.preventDefault();

        return this.search_results.scrollTop(delta * (e.type === 'DOMMouseScroll' ? 40 : SCROLL_SPEED) + this.search_results.scrollTop());
    };

    var init;
    (init = function (context) {
        $(context || 'body').find('select:visible').each(function () {
            $(this)
                .chosen({
                    allow_single_deselect:     true,
                    no_results_text:           Translator.trans('chosen.no_results_text'),
                    placeholder_text_multiple: Translator.trans('chosen.placeholder_text_multiple'),
                    placeholder_text_single:   Translator.trans('chosen.placeholder_text_single'),
                    search_contains:           true
                })
                .change(function () {
                    $(this).trigger('chosen:updated');
                })
                .data('chosen').search_results_mousewheel = searchResultsMousewheel;
        });
    })();

    $(document)
        .on('formCollectionAdd', function (e, form) {
            init(form);
        })
        .on('propertyFormSubmit', function (e, form) {
            init(form);
        })
        .on('searchComplete', function (e, results) {
            init(results);
        })
        .on('spoilerOpen', function (e, spoiler) {
            init(spoiler);
        });
});

$(document).ready(function () {
    $.extend($.colorbox.settings, {
        maxWidth:  '90%',
        opacity:   0.7,
        scrolling: false,
        trapFocus: false
    });

    var translatable = [
        'current',
        'previous',
        'next',
        'close',
        'xhrError',
        'imgError',
        'slideshowStart',
        'slideshowStop'
    ];
    var locale = {};

    for (var i = 0; i < translatable.length; i++) {
        locale[translatable[i]] = Translator.trans('colorbox.' + translatable[i]);
    }

    var init;
    (init = function (context) {
        $(context)
            .on('click', 'a.colorbox_ajax[href]', function (e) {
                e.preventDefault();

                var $link = $(this);

                var url = $link.attr('href');

                if (!url || '#' === url) {
                    return;
                }

                $.colorbox($.extend({}, locale, {
                    href:  url,
                    title: $link.attr('title') || $link.data('title')
                }));
            })
            .find('.colorbox').colorbox(locale);
    })('body');

    $(document).on('searchComplete', function (e, results) {
        init(results);
    });
});

$(document).ready(function () {
    $('.main_options_container .permissions input').hide();

    $('body').on('click', '.main_options_container .permission[data-checkbox][data-class-checked][data-class-unchecked]', function() {
        var $button = $(this);
        var checkbox = document.getElementById($button.data('checkbox'));

        if ($button.hasClass($button.data('class-checked'))) {
            $button
                .removeClass($button.data('class-checked'))
                .addClass($button.data('class-unchecked'));
            checkbox.checked = false;

            return;
        }

        $button
            .removeClass($button.data('class-unchecked'))
            .addClass($button.data('class-checked'));
        checkbox.checked = true;
    });
});

$(document).ready(function () {
    var locale = 'en' !== LOCALE ? LOCALE : '';
    var translations = {
        datepicker: $.datepicker.regional['undefined' !== typeof $.datepicker.regional[locale] ? locale : ''],
        timepicker: $.timepicker.regional['undefined' !== typeof $.timepicker.regional[locale] ? locale : '']
    };

    var options = $.extend({}, translations.datepicker, translations.timepicker, {
        dateFormat: 'dd.mm.yy'
    });

    var init;
    (init = function (context) {
        ['date', 'datetime', 'time'].map(function (type) {
            $(context || 'body').find('input.' + type)[type + 'picker'](options);
        });
    })();

    $(document)
        .on('ajaxSuccess', init)
        .on('formCollectionAdd', function (e, $newElement) {
            init($newElement);
        });
});

$(function () {
    var selector = '.type_boolean.name_enabled input[type="checkbox"]:first';

    var init;
    (init = function () {
        $('.property_forms .section_table table').find('tr[data-level]').each(function () {
            var $row = $(this);

            var $checkbox = $row.find(selector),
                level     = $row.data('level');

            if (!$checkbox.length) {
                return;
            }
            if ($row.next('tr[data-level="' + (level + 1) + '"]').length) {
                $checkbox.data('reload-page', 1);
            }
            if (level < 2 || $checkbox.is(':checked')) {
                return;
            }

            var $parent = $row.prevAll('tr[data-level="' + (level - 1) + '"]:first').find(selector);

            $checkbox.removeAttr('disabled');

            if (!$parent.is(':checked') || $parent.is(':disabled')) {
                $checkbox.attr('disabled', 'disabled');
            }
        });
    })();
    $(document).on('ajaxSuccess', init);
});

Dropzone.autoDiscover = false;

$(document).ready(function () {
    $('.dropzone[data-files][data-url]').each(function () {
        var $dropzone = $(this);

        var $files = $dropzone.parents('form').first().find($dropzone.data('files') + '[data-prototype]');
        var filePrototype = $files.data('prototype');

        var defaultMessage = Translator.trans('dropzone.default_message');

        if ($dropzone.data('description')) {
            defaultMessage += '<br><br><b>' + Translator.trans($dropzone.data('description')) + '</b>';
        }

        var dropzone = new Dropzone('#' + $dropzone.attr('id'), {
            acceptedFiles:       $dropzone.data('accepted-files'),
            addRemoveLinks:      true,
            dictDefaultMessage:  defaultMessage,
            dictFileTooBig:      Translator.trans('dropzone.file_too_big'),
            dictInvalidFileType: Translator.trans('dropzone.invalid_file_type'),
            dictRemoveFile:      Translator.trans('dropzone.remove_file'),
            filesizeBase:        1024,
            maxFilesize:         $dropzone.data('max-filesize'),
            url:                 $dropzone.data('url')
        });

        dropzone
            .on('success', function (file, response) {
                var $file = $(filePrototype.replace(/__name__/g, $files.children().length));

                $file.find('.filename').val(response[0]);
                $file.find('.original_filename').val(file.name);

                $files.append($file);
            })
            .on('removedfile', function (file) {
                $files.find('.original_filename[value="' + file.name + '"]').parents('.table_row:first').remove();
            });
    });
});

$(function () {
    var buttons = {
        'add':    '<button class="collection_add" type="button">' + Translator.trans('form_collections.add') + '</button>',
        'delete': '<button class="collection_delete" type="button">' + Translator.trans('form_collections.delete') + '</button>'
    };

    var updateLabels = function ($collection) {
        if ($collection.data('allow-add')) {
            $collection.children().each(function (index) {
                $(this).children('label:first').text(index + 1);
            });
        }
    };

    var init;
    (init = function (context) {
        $(context || 'body').find('.collection[data-prototype]:not([data-autoinit="0"])').each(function () {
            var $collection = $(this);

            if ($collection.data('allow-delete')) {
                $collection.children().each(function () {
                    $(this).append(buttons.delete);
                });
            }
            if ($collection.data('allow-add')) {
                updateLabels($collection);

                $collection.append(buttons.add);
            }
        });
    })();
    $(document).on('formCollectionAdd', function (e, item) {
        init(item);
    });

    $('body')
        .on('click', 'form .collection .collection_delete', function () {
            var $button = $(this);

            // Fetch collection node before (!) item removal
            var $collection = $button.closest('.collection[data-prototype]');

            $button.closest('div').remove();

            updateLabels($collection);
        })
        .on('click', 'form .collection[data-prototype] .collection_add', function () {
            var $button = $(this);

            var $collection = $button.closest('.collection[data-prototype]');

            var index = $collection.data('index'),
                name  = $collection.data('name') || '';

            var item = $collection.data('prototype')
                .replace(new RegExp(name + '___name__', 'g'), name + '_' + index)
                .replace(new RegExp('\\[' + name + '\\]\\[__name__\\]', 'g'), '[' + name + '][' + index + ']');

            var $item = $(item);

            if ($collection.data('allow-delete')) {
                $item.append(buttons.delete);
            }

            $button.before($item);

            updateLabels($collection);

            $(document).trigger('formCollectionAdd', $item);

            $collection.data('index', index + 1);
        });
});

$(document).ready(function () {
    $('body')
        .on('click', '.image_delete[data-url]', function (e) {
            e.preventDefault();

            var $link = $(this);

            if ($link.data('submitted') || !confirm(Translator.trans('image.action.delete.confirm'))) {
                return;
            }

            $link.data('submitted', true);

            var $image = $link.closest('.image');

            $.ajax({
                url:  $link.data('url'),
                type: 'post'
            }).done(function () {
                $image.remove();

                notify('image.action.delete.success');
            }).fail(onAjaxFail);
        })
        .on('click', '.image_toggle_enabled[data-disable-title][data-disable-url][data-enable-title][data-enable-url]', function (e) {
            e.preventDefault();

            var $link = $(this);

            if ($link.hasClass('image_disable')) {
                $.ajax({
                    url:  $link.data('disable-url'),
                    type: 'post'
                }).done(function () {
                    $link
                        .removeClass('image_disable')
                        .addClass('image_enable')
                        .attr('title', $link.data('enable-title'));

                    notify('image.action.disable.success');
                }).fail(onAjaxFail);

                return;
            }

            $.ajax({
                url:  $link.data('enable-url'),
                type: 'post'
            }).done(function () {
                $link
                    .removeClass('image_enable')
                    .addClass('image_disable')
                    .attr('title', $link.data('disable-title'));

                notify('image.action.enable.success');
            }).fail(onAjaxFail);
        });

    var $sortable = $('.table_row .images[data-sort-url]');

    if ($sortable.length) {
        $sortable.sortable({
            placeholder: 'ui-state-highlight',
            update:      function () {
                $.ajax({
                    url:  $sortable.data('sort-url'),
                    type: 'post',
                    data: {
                        ids: $sortable.find('.image[data-id]').map(function () {
                            return $(this).data('id');
                        }).get()
                    }
                }).fail(onAjaxFail);
            }
        });
        $sortable.disableSelection();
    }
});

$(function () {
    var selector = '[data-master][data-show-on]';

    var isSlaveVisible = function ($master, showOn) {
        if ($master.is(':checkbox')) {
            return (+$master.is(':checked')).toString() === showOn;
        }

        var value = $master.val().toString();

        if ($master.is('select') && $master.prop('multiple')) {
            if (!$.isArray(showOn)) {
                return value.indexOf(showOn) >= 0;
            }
            for (var i = 0; i < showOn.length; i++) {
                if (value.indexOf(showOn[i]) >= 0) {
                    return true;
                }
            }

            return false;
        }

        return $.isArray(showOn) ? showOn.indexOf(value) >= 0 : value === showOn;
    };
    var toggleSlave = function ($slaveContainer, $master, showOn) {
        $master.val() && isSlaveVisible($master, showOn) ? $slaveContainer.show() : $slaveContainer.hide();

        if ($slaveContainer.is('option')) {
            var $options = $slaveContainer.closest('select').find('option' + selector);

            if ($options.index($slaveContainer) + 1 === $options.length) {
                $slaveContainer.closest('select').trigger('chosen:updated');
            }
        }
    };

    $(selector).each(function () {
        var $slave = $(this);

        var masterSelector  = $slave.data('master') + ':first',
            showOn          = $slave.data('show-on'),
            $slaveContainer = $slave.is('option') ? $slave : $slave.closest('.table_row');

        showOn = $.isArray(showOn)
            ? showOn.map(function (item) {
                return item.toString();
            })
            : showOn.toString();

        var $context = $slave.closest('[class*="_a2lix_translationsFields-"]');
        var $master = $context.find(masterSelector);

        if (!$master.length) {
            $context = $slave.closest('form');
            $master = $context.find(masterSelector);
        }

        toggleSlave($slaveContainer, $master, showOn);

        $context.on('change', masterSelector, function () {
            toggleSlave($slaveContainer, $(this), showOn);
        });
    });
});

$(document).ready(function () {
    var submitForm = function ($form, reloadPage) {
        if ($form.data('submitted')) {
            return;
        }

        $form
            .data('submitted', true)
            .append(AJAX_LOADER);

        $.ajax({
            async: false,
            data:  $form.serialize(),
            type:  'post',
            url:   $form.attr('action')
        }).done(function (data) {
            var $formReplacement = $(data.form);
            $form.replaceWith($formReplacement);

            toggleButtons($formReplacement.find('.field'));

            $(document).trigger('propertyFormSubmit', $formReplacement);

            notify(data.message, data.success ? 'success' : 'error');

            if (reloadPage && !$formReplacement.closest('.property_forms').parent('.searchable_results').length) {
                $.ajax().done(function (html) {
                    $formReplacement.closest('.section_table').replaceWith($(html).find('.section_table:first'));
                }).fail(onAjaxFail);
            }
        }).fail(onAjaxFail);
    };

    var toggleButtons = function ($field) {
        if ('undefined' === typeof $field.data('original-value')) {
            return;
        }

        var $form = $field.closest('.property_form');
        $form.attr('data-modified', $field.val().toString() !== $field.data('original-value').toString() ? 1 : 0);

        var $forms = $form.closest('.property_forms');

        if (1 != $form.attr('data-modified') && !$forms.find('form.property_form[data-modified="1"]').length) {
            $forms.find('.property_forms_submit').hide();
        } else {
            $forms.find('.property_forms_submit').show();
        }
        if (1 != $form.attr('data-modified')) {
            $form.find('[type="submit"], [type="reset"]').remove();

            return;
        }
        if (!$form.find('[type="submit"]').length) {
            $form.append('<button type="submit">o</button>');
        }
        if (!$form.find('[type="reset"]').length) {
            $form.append('<button type="reset">x</button>');
        }
    };

    var init;
    (init = function (context) {
        var $context = $(context || 'body');

        $context.find('.property_form .field[type!="checkbox"]').each(function () {
            toggleButtons($(this));
        });

        $context
            .on('change', '.property_form .field[type!="checkbox"]', function () {
                toggleButtons($(this));
            })
            .on('keyup', '.property_form input', function () {
                toggleButtons($(this));
            })
            .on('change', '.property_form input[type="checkbox"]', function () {
                var $checkbox = $(this);

                submitForm($checkbox.closest('form.property_form'), $checkbox.data('reload-page'));
            })
            .on('click', '.property_form [type="reset"]', function (e) {
                e.preventDefault();

                var $field = $(this).siblings('.field');

                $field
                    .val($field.data('original-value'))
                    .trigger('change');
            })
            .on('click', '.property_forms .property_forms_submit', function () {
                var $forms     = $(this).closest('.property_forms').find('form.property_form[data-modified="1"]'),
                    reloadPage = false;

                $forms.each(function (i) {
                    var $form = $(this);

                    if (!reloadPage && $form.find('input, select').data('reload-page')) {
                        reloadPage = true;
                    }

                    submitForm($form, i === $forms.length - 1 ? reloadPage : false);
                });
            })
            .on('submit', 'form.property_form', function (e) {
                e.preventDefault();

                var $form = $(this);

                submitForm($form, $form.find('input, select').data('reload-page'));
            });
    })();

    $(document).on('searchComplete', function (e, results) {
        init(results);
    });
});

$(document).ready(function () {
    var $searchables = $('.searchable[data-source]');

    if (!$searchables.length) {
        return;
    }

    var pending = false;

    $searchables.each(function () {
        var $searchable = $(this);
        var $results = $searchable.find('.searchable_results');

        var interval = setInterval(function () {
            if (pending) {
                return;
            }

            pending = true;
            $searchable.show().find('.searchable_title').append(AJAX_LOADER);

            $.ajax({
                url: $searchable.data('source')
            }).done(function (html) {
                var $html = $(html);

                if (!$html.find('tr').length) {
                    $searchable.remove();

                    return;
                }

                $results.html(html);
                $(document).trigger('searchComplete', $results);
            }).always(function () {
                clearInterval(interval);
                pending = false;
            }).fail(onAjaxFail);
        }, 100);
    });
});

$(document).ready(function () {
    var getWidget = function ($child) {
        return $child.closest('.slug_suffix');
    };

    var buildUrlPrefix = function ($widget) {
        var parentSlug = $widget.closest('form').find($widget.data('parent-select')).children('option:selected')
            .data($widget.data('parent-option-data-slug'));

        return $widget.data('base-url') + ('undefined' !== typeof parentSlug ? parentSlug + '/' : '');
    };

    var buildUrl = function ($widget) {
        var slugSuffix = $widget.find('.form_widget input').val();

        return buildUrlPrefix($widget) + (slugSuffix ? slugSuffix : '___') + $widget.data('url-suffix');
    };

    var updateWidget = function ($widget) {
        var $input = $widget.find('.form_widget input');
        var $reset = $widget.find('.reset');
        var slugSuffix = $input.val();
        $input.data('default').toString() !== slugSuffix ? $reset.show() : $reset.hide();

        $widget.find('.url_prefix').text(buildUrlPrefix($widget));

        var url = buildUrl($widget);
        $widget.find('.link_widget a').attr('href', url).text(url);

        if ($widget.data('default-url').toString() !== url) {
            $widget.addClass('changed');

            return;
        }
        if (slugSuffix) {
            $widget.removeClass('changed');
        }
    };

    $('.slug_suffix').each(function () {
        var $widget = $(this);
        $widget.data('base-url', $widget.data('url-prefix'));

        var $form = $widget.closest('form');

        if ($widget.data('parent-select')) {
            var $parent = $form.find($widget.data('parent-select'));

            if ($parent.length) {
                var parentSlug = $parent.find('option:selected').data($widget.data('parent-option-data-slug'));

                if ('undefined' !== typeof parentSlug) {
                    var baseUrl = $widget.data('url-prefix');
                    var index = baseUrl.indexOf(parentSlug);

                    if (-1 !== index) {
                        baseUrl = baseUrl.slice(0, index);
                        $widget.data('base-url', baseUrl);
                    }
                }
            }
        }

        updateWidget($widget);

        // $widget.find('.form_widget input').counter({
        //     count:  'up',
        //     goal:   'sky',
        //     target: $widget.find('.form_widget .input_value')
        // });
        $widget.find('.form_widget input').textcounter({
            countSpaces: true,
            counterText: '%d',
            max:         -1
        });
        $form.on('change', $widget.data('parent-select'), function () {
            updateWidget($widget);
        });
    });

    $('body')
        .on('click', '.slug_suffix .edit', function () {
            var $widget = getWidget($(this));

            $widget.find('.form_widget').show();
            $widget.find('.link_widget').hide();
        })
        .on('click', '.slug_suffix .reset', function () {
            var $widget = getWidget($(this));

            var $input = $widget.find('.form_widget input');
            $input.val($input.data('default')).trigger('change');

            $widget.find('.update').trigger('click');
        })
        .on('click', '.slug_suffix .update', function () {
            var $widget = getWidget($(this));

            updateWidget($widget);

            $widget.find('.form_widget').hide();
            $widget.find('.link_widget').show();
        })
        .on('click', '.slug_suffix.changed .link_widget a', function (e) {
            e.preventDefault();
        });
});

$('.section_table').each(function(){
	var self = $(this);
	var screenHeight = window.innerHeight;
	var tableHeight = $(this).height();
	var head = $(this).find('thead tr').eq(0).clone();
	
	if(tableHeight > screenHeight*1.8){
		var counterHeight = 0;
		var countHead = tableHeight/( screenHeight*0.9);
		var interval = tableHeight / countHead;
		var intervalCurr = 0;
		var rows = self.find('tbody tr');
		
		for(var i = 0; i < rows.length; i++){
			intervalCurr += rows.eq(i).height();
			
			if(intervalCurr >= interval){
				$(head).clone().insertAfter(rows.eq(i));
				intervalCurr = 0;
			}
		}
	} 
	
	setTimeout(function(){
		if(tableHeight > screenHeight*1.2){
			if(self.find('tr:last th')){
				$(this).find('table tbody').append( head.clone() );
			}
		}
	}, 10)
	
});
$(function () {
    $('input[data-max-chars]').each(function () {
        var $input = $(this);

        $input.textcounter({
            countContainerClass: 'input_note',
            countDown:           true,
            countDownText:       Translator.trans('textcounter.count_down_text'),
            countOverflow:       true,
            countOverflowText:   Translator.trans('textcounter.count_overflow_text'),
            countSpaces:         true,
            displayErrorText:    false,
            max:                 $input.data('max-chars'),
            stopInputAtMaximum:  false
        });
    });
});

$(function () {
    var getLocale = function ($tab) {
        var matches = $tab.attr('class').match(/a2lix_translationsfields-([a-z]+)\s*/i);

        return matches[1];
    };

    $('body')
        .on('click', 'form .a2lix_translationsLocales.nav.nav-tabs a', function () {
            $(this).parents('.a2lix_translations').first().find('input[type="text"]').removeData('synced');
        })
        .on('change', 'form .a2lix_translationsFields .tab-pane.active input[type="text"]', function () {
            var $sourceInput = $(this);

            $sourceInput.removeData('synced');

            var $row = $sourceInput.parents('.table_row').first();

            var $sourceTab = $row.parents('.tab-pane').first(),
                rowIndex   = $row.index(),
                sourceText = $sourceInput.val();

            var sourceLocale = getLocale($sourceTab);

            $sourceTab.siblings('.tab-pane').each(function () {
                var $targetTab = $(this);

                var $targetInput = $targetTab.find('.table_row').eq(rowIndex).find('input[type="text"]');

                if ('' !== $targetInput.val() && !$targetInput.data('synced')) {
                    return;
                }
                if ('' === sourceText) {
                    $targetInput.val(sourceText);

                    return;
                }

                YandexTranslator.translate(sourceText, sourceLocale, getLocale($targetTab), function (translated) {
                    $targetInput.val(translated).data('synced', true);
                });
            });
        });
});

$(document).ready(function () {
    var CLASSES = [
        '',
        'checked',
        'unchecked'
    ];

    function checkInput($checkbox, index) {
        if (index < 0 || index > 2) {
            index = 0;
        }

        $checkbox
            .data('index', index).addClass(CLASSES[index])
            .find('input')[index].checked = true;
    }

    function uncheckInput($checkbox, index) {
        $checkbox.removeClass(CLASSES[index])
            .find('input')[index].checked = false;
    }

    (function init() {
        $('.tri_state_checkbox').each(function () {
            var $checkbox = $(this);
            $checkbox.addClass('ready').find(':not(input)').remove();

            checkInput($checkbox, $checkbox.find('input:checked').index());
        });
    })();

    $('body').on('click', '.tri_state_checkbox', function () {
        var $checkbox = $(this);
        var index = $checkbox.data('index');

        uncheckInput($checkbox, index);

        index++;

        checkInput($checkbox, index);
    });
});

/* показать/скрыть сайдбар */
$('#sidebar_switcher').on('mousedown', function(){
	var switch_btn = $('#sidebar_switcher');
	var sidebar_wrap = $('.sidebar_wrap');
	var content_wrap = $('.content_wrap');
	var main_wrap = $('.main_wrap');
	sidebar_wrap.toggleClass('active');
	content_wrap.toggleClass('active');
	main_wrap.toggleClass('active');
	switch_btn.toggleClass('active');
	if(switch_btn.hasClass('active')){
		switch_btn.text(Translator.trans('layout.menu.collapse'));
		sidebar_wrap.removeClass('noactive');
        $.cookie(COOKIE_SIDEBAR, 1, {
            path: '/'
        });
	} else {
		switch_btn.text(Translator.trans('layout.menu.expand'));
		sidebar_wrap.addClass('noactive');
        $.cookie(COOKIE_SIDEBAR, 0, {
            path: '/'
        });
	}
	setTimeout( function(){ $(window).resize();}, 300);
});

/* спойлер */
$('.spoiler_links').on('mousedown', function(){
	var spoiler_container = $(this).parents('.spoiler_container');
    var body = spoiler_container.find('.spoiler_body');
    if (body.css("display")=="none")
	{
		body.hide('normal');
		body.toggle('normal');
        if ('undefined' !== typeof body.data('cookie')) {
            $.cookie(body.data('cookie'), 1, {
                path: '/'
            });
        }

        $(document).trigger('spoilerOpen', body);
	} else {
        body.hide('normal');
        if ('undefined' !== typeof body.data('cookie')) {
            $.cookie(body.data('cookie'), 0, {
                path: '/'
            });
        }
    }
	spoiler_container.toggleClass('noactive');
	return false;
 });
 
 /* клик на пункте меню главной */
 $('.main_menu .item.parent > .name a, .main_menu .item.parent > .img a').on('click', function(){
	var item = $(this).parents('.parent');
	if(item.hasClass('active')){
		item.removeClass('active');
	} else {
		$('.main_menu .item.parent.active').removeClass('active');
		resize();
		item.addClass('active');
		item.find('.main_dropdown_menu').css({'maxHeight' : item.find('.main_dropdown_menu_inner').height()+50});
	}
	resize();
	setTimeout( resize(), 500);
	return false;
});

/* фикс чекбоксов без нужной вёртски*/
var checkboxesInit;
(checkboxesInit = function (context) {
 $(context || 'body').find('.input_value input[type="checkbox"]').each(function(){
	$(this).wrap("<label></label>").wrap("<span class='checkbox'></span>");
	$(this).after("<span></span>")
 });
})();
$(document).on('formCollectionAdd', function (e, form) {
    checkboxesInit(form);
});

 
 jQuery(document).ready(function(){
	resize();
	
	show_menu_function();
	
	$('.content_wrap').css({'minHeight': $('.left_menu').height() });
 });

 function show_menu_function(){
	/*var count = $('.main_menu .item').length;
	console.log(count);
	for (i = 0; i < count; i++) {	
		console.log(i);
		setTimeout( $('.main_menu .item:eq('+i+')').addClass('animate_start'), 700);
	}*/
}

 window.onresize = resize;
 
 function resize(){
	/* меню на главной */
	$('.main_menu .item').height('auto');
	$('.main_menu .item .description').height('auto');
	
	var maxHeightItem = 0;
	var maxHeightItemText = 0;
	var maxHeightDownDrop = 0;
	$('.main_menu .item').each(function(){
		if($(this).height() > maxHeightItem){ maxHeightItem = $(this).height();}
	});
	$('.main_menu .item .description').each(function(){
		if($(this).height() > maxHeightItemText){ maxHeightItemText = $(this).height();}
	});
	$('.main_menu .main_dropdown_menu').each(function(){
		if($(this).height() > maxHeightDownDrop){ maxHeightDownDrop = $(this).height();}
	});
	$('.main_menu .item').height(maxHeightItem);
	$('.main_menu .item .description').height(maxHeightItemText);
	if( $('.main_menu .item.parent.active').length > 0 ){
		$('.main_menu .item.parent.active').css({'marginBottom': maxHeightDownDrop + 5});
	} else {
		$('.main_menu .item.parent').css({'marginBottom': '10px'});
		$('.main_menu .item').height('auto');
		$('.main_menu .item .description').height('auto');
	}
//	console.log('resize')
}


/* скролбар */
/**************************************************************/
// настройки скролбара
var slyOptions = {
    horizontal: 1,
    smart: 1,
    mouseDragging: 1,
    touchDragging: 1,
    releaseSwing: 1,
    scrollBar: $('.scrollbar'),
    speed: 300,
    activatePageOn: 'click',
    scrollBy: 100,
    dragHandle: 1,
    dynamicHandle: 1,
    clickBar: 1,
    scrollSource: ' '
};

// скрывает/показывает скрол бар, если он не нужен
function switchScrollBar() {
	var scrollbar = $('.js-scrollbar');
	var handle = scrollbar.find('.handle');
    var scrollbar_width = scrollbar.eq(0).width();
    var handle_width = scrollbar.eq(0).find('.handle').width();
    var content_width = $('.sly-container .section_table > table').width();

    if(content_width > scrollbar_width){
        if(scrollbar_width <= handle_width + 5 ){ // 5 - магическое число, чтобы нивелировать разницу ширин при ресайзе
            scrollbar.css({'opacity':0});
            handle.css({'display': 'none'});
        } else {
            scrollbar.css({'opacity':1});
            handle.css({'display': 'block'});
        }
	} else {
        scrollbar.css({'opacity':0});
        handle.css({'display': 'none'});
	}
}
// инициализация скролбара
function initSly( container, options ) {
    // для каждого контенера
    $(container).each(function(){
        var $self = $(this);
        var $frame = $self.find('.sly-frame');

        var sly = new Sly( $frame, options, {
            move: function () {
                scrollSync();
            }
        });

        sly.init();
        $('.sly-container .scrollbar').clone(true).appendTo('.sly-container');

        scrollSync();
        switchScrollBar();
        $(window).resize(function() {
            scrollSync();
            switchScrollBar();
            sly.reload();
        });

        function scrollSync() {
            var scrollbar1_handle = $self.find('.scrollbar').eq(0).find('.handle');
            var scrollbar2_handle = $self.find('.scrollbar').eq(1).find('.handle');
            scrollbar2_handle.attr('style', scrollbar1_handle.attr('style'))
        }
    });
}
setTimeout(initSly, 1, $('.sly-container'), slyOptions);

/**************************************************************/
(function () {
    var selector = '.btn_toggle[data-cookie][data-id][data-text-open][data-text-close]';

    var toggle = function ($toggle, $item) {
        $toggle.parent().next().slideToggle(100);
        $toggle.toggleClass('is-open');
        $item.toggleClass('is-open');

        if ($item.hasClass('is-open')) {
            $toggle.text($toggle.attr('data-text-open'));

            return;
        }

        $toggle.text($toggle.attr('data-text-close'));
    };

    $('.main_options_item_container ' + selector).click(function () {
        var $toggle = $(this);
        var $item = $toggle.closest('.main_options_item');

        toggle($toggle, $item);

        var cookie = $.cookie($toggle.data('cookie'));
        var expanded = 'undefined' !== typeof cookie ? cookie.split(',') : [];

        if ($item.hasClass('is-open')) {
            if (-1 === expanded.indexOf($toggle.data('id'))) {
                expanded.push($toggle.data('id'));
            }
        } else {
            expanded.splice(expanded.indexOf($toggle.data('id')), 1);

            $item.find(selector + '[data-id!="' + $toggle.data('id') + '"].is-open').each(function () {
                var $toggle = $(this);

                toggle($toggle, $toggle.closest('.main_options_item'));

                expanded.splice(expanded.indexOf($toggle.data('id')), 1);
            });
        }

        $.cookie($toggle.data('cookie'), expanded.join(','), {
            path: '/'
        });
    })
})();
/**************************************************************/

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImJvb3RzdHJhcC5qcyIsImNob3Nlbi5qcXVlcnkuanMiLCJkcm9wem9uZS5qcyIsImpxdWVyeS5jb2xvcmJveC5qcyIsImpxdWVyeS5tb3VzZXdoZWVsLmpzIiwidGV4dGNvdW50ZXIuanMiLCJqcXVlcnktdWkuanMiLCJkYXRlcGlja2VyLXJ1LmpzIiwianF1ZXJ5LmNvb2tpZS5qcyIsImpxdWVyeS11aS10aW1lcGlja2VyLWFkZG9uLmpzIiwianF1ZXJ5LXVpLXRpbWVwaWNrZXItcnUuanMiLCJub3R5LmpzIiwic2x5LmpzIiwiYTJsaXhfdHJhbnNsYXRpb25fZGVmYXVsdC5qcyIsInRyYW5zbGF0b3IubWluLmpzIiwiZ2xvYmFscy5qcyIsInlhbmRleC10cmFuc2xhdG9yLmpzIiwiYWpheC1mb3JtLmpzIiwiYmF0Y2gtZGVsZXRlLmpzIiwiY2hvc2VuLmpzIiwiY29sb3Jib3guanMiLCJjb25maWd1cmF0aW9uLmpzIiwiZGF0ZS10aW1lLXBpY2tlci5qcyIsImRpc2FibGUtZGVzY2VuZGFudHMuanMiLCJmb3JtLWNvbGxlY3Rpb24uanMiLCJpbWFnZS5qcyIsIm1hc3Rlci1zbGF2ZS5qcyIsInByb3BlcnR5LWZvcm0uanMiLCJzZWFyY2guanMiLCJzbHVnLXN1ZmZpeC5qcyIsInRhYmxlLWhlYWQtY2xvbmUuanMiLCJ0cmFuc2xhdGlvbi1zeW5jLmpzIiwidHJpLXN0YXRlLWNoZWNrYm94LmpzIiwiYXBwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6MEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3eENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0OEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDanhrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNudkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FyQmhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QXNCekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBekIvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EwQmpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJhcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEJvb3RzdHJhcCB2My4zLjcgKGh0dHA6Ly9nZXRib290c3RyYXAuY29tKVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNiBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG5pZiAodHlwZW9mIGpRdWVyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdCb290c3RyYXBcXCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgalF1ZXJ5Jylcbn1cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIHZlcnNpb24gPSAkLmZuLmpxdWVyeS5zcGxpdCgnICcpWzBdLnNwbGl0KCcuJylcbiAgaWYgKCh2ZXJzaW9uWzBdIDwgMiAmJiB2ZXJzaW9uWzFdIDwgOSkgfHwgKHZlcnNpb25bMF0gPT0gMSAmJiB2ZXJzaW9uWzFdID09IDkgJiYgdmVyc2lvblsyXSA8IDEpIHx8ICh2ZXJzaW9uWzBdID4gMykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBqUXVlcnkgdmVyc2lvbiAxLjkuMSBvciBoaWdoZXIsIGJ1dCBsb3dlciB0aGFuIHZlcnNpb24gNCcpXG4gIH1cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHRyYW5zaXRpb24uanMgdjMuMy43XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyN0cmFuc2l0aW9uc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE2IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENTUyBUUkFOU0lUSU9OIFNVUFBPUlQgKFNob3V0b3V0OiBodHRwOi8vd3d3Lm1vZGVybml6ci5jb20vKVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Jvb3RzdHJhcCcpXG5cbiAgICB2YXIgdHJhbnNFbmRFdmVudE5hbWVzID0ge1xuICAgICAgV2Via2l0VHJhbnNpdGlvbiA6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgIE1velRyYW5zaXRpb24gICAgOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgICBPVHJhbnNpdGlvbiAgICAgIDogJ29UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kJyxcbiAgICAgIHRyYW5zaXRpb24gICAgICAgOiAndHJhbnNpdGlvbmVuZCdcbiAgICB9XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHRyYW5zRW5kRXZlbnROYW1lcykge1xuICAgICAgaWYgKGVsLnN0eWxlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgZW5kOiB0cmFuc0VuZEV2ZW50TmFtZXNbbmFtZV0gfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZSAvLyBleHBsaWNpdCBmb3IgaWU4ICggIC5fLilcbiAgfVxuXG4gIC8vIGh0dHA6Ly9ibG9nLmFsZXhtYWNjYXcuY29tL2Nzcy10cmFuc2l0aW9uc1xuICAkLmZuLmVtdWxhdGVUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gICAgdmFyICRlbCA9IHRoaXNcbiAgICAkKHRoaXMpLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlIH0pXG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkgeyBpZiAoIWNhbGxlZCkgJCgkZWwpLnRyaWdnZXIoJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kKSB9XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgZHVyYXRpb24pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gICQoZnVuY3Rpb24gKCkge1xuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkVuZCgpXG5cbiAgICBpZiAoISQuc3VwcG9ydC50cmFuc2l0aW9uKSByZXR1cm5cblxuICAgICQuZXZlbnQuc3BlY2lhbC5ic1RyYW5zaXRpb25FbmQgPSB7XG4gICAgICBiaW5kVHlwZTogJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLFxuICAgICAgZGVsZWdhdGVUeXBlOiAkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsXG4gICAgICBoYW5kbGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcyh0aGlzKSkgcmV0dXJuIGUuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogYWxlcnQuanMgdjMuMy43XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNhbGVydHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNiBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBBTEVSVCBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgZGlzbWlzcyA9ICdbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nXG4gIHZhciBBbGVydCAgID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgJChlbCkub24oJ2NsaWNrJywgZGlzbWlzcywgdGhpcy5jbG9zZSlcbiAgfVxuXG4gIEFsZXJ0LlZFUlNJT04gPSAnMy4zLjcnXG5cbiAgQWxlcnQuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIEFsZXJ0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzICAgID0gJCh0aGlzKVxuICAgIHZhciBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JylcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHNlbGVjdG9yID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yICYmIHNlbGVjdG9yLnJlcGxhY2UoLy4qKD89I1teXFxzXSokKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgfVxuXG4gICAgdmFyICRwYXJlbnQgPSAkKHNlbGVjdG9yID09PSAnIycgPyBbXSA6IHNlbGVjdG9yKVxuXG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgaWYgKCEkcGFyZW50Lmxlbmd0aCkge1xuICAgICAgJHBhcmVudCA9ICR0aGlzLmNsb3Nlc3QoJy5hbGVydCcpXG4gICAgfVxuXG4gICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdjbG9zZS5icy5hbGVydCcpKVxuXG4gICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgJHBhcmVudC5yZW1vdmVDbGFzcygnaW4nKVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudCgpIHtcbiAgICAgIC8vIGRldGFjaCBmcm9tIHBhcmVudCwgZmlyZSBldmVudCB0aGVuIGNsZWFuIHVwIGRhdGFcbiAgICAgICRwYXJlbnQuZGV0YWNoKCkudHJpZ2dlcignY2xvc2VkLmJzLmFsZXJ0JykucmVtb3ZlKClcbiAgICB9XG5cbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiAkcGFyZW50Lmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgJHBhcmVudFxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCByZW1vdmVFbGVtZW50KVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQWxlcnQuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgcmVtb3ZlRWxlbWVudCgpXG4gIH1cblxuXG4gIC8vIEFMRVJUIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgID0gJHRoaXMuZGF0YSgnYnMuYWxlcnQnKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmFsZXJ0JywgKGRhdGEgPSBuZXcgQWxlcnQodGhpcykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXS5jYWxsKCR0aGlzKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5hbGVydFxuXG4gICQuZm4uYWxlcnQgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5hbGVydC5Db25zdHJ1Y3RvciA9IEFsZXJ0XG5cblxuICAvLyBBTEVSVCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uYWxlcnQubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmFsZXJ0ID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQUxFUlQgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KS5vbignY2xpY2suYnMuYWxlcnQuZGF0YS1hcGknLCBkaXNtaXNzLCBBbGVydC5wcm90b3R5cGUuY2xvc2UpXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGJ1dHRvbi5qcyB2My4zLjdcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2J1dHRvbnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNiBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBCVVRUT04gUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIEJ1dHRvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgPSAkLmV4dGVuZCh7fSwgQnV0dG9uLkRFRkFVTFRTLCBvcHRpb25zKVxuICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2VcbiAgfVxuXG4gIEJ1dHRvbi5WRVJTSU9OICA9ICczLjMuNydcblxuICBCdXR0b24uREVGQVVMVFMgPSB7XG4gICAgbG9hZGluZ1RleHQ6ICdsb2FkaW5nLi4uJ1xuICB9XG5cbiAgQnV0dG9uLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHZhciBkICAgID0gJ2Rpc2FibGVkJ1xuICAgIHZhciAkZWwgID0gdGhpcy4kZWxlbWVudFxuICAgIHZhciB2YWwgID0gJGVsLmlzKCdpbnB1dCcpID8gJ3ZhbCcgOiAnaHRtbCdcbiAgICB2YXIgZGF0YSA9ICRlbC5kYXRhKClcblxuICAgIHN0YXRlICs9ICdUZXh0J1xuXG4gICAgaWYgKGRhdGEucmVzZXRUZXh0ID09IG51bGwpICRlbC5kYXRhKCdyZXNldFRleHQnLCAkZWxbdmFsXSgpKVxuXG4gICAgLy8gcHVzaCB0byBldmVudCBsb29wIHRvIGFsbG93IGZvcm1zIHRvIHN1Ym1pdFxuICAgIHNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbiAoKSB7XG4gICAgICAkZWxbdmFsXShkYXRhW3N0YXRlXSA9PSBudWxsID8gdGhpcy5vcHRpb25zW3N0YXRlXSA6IGRhdGFbc3RhdGVdKVxuXG4gICAgICBpZiAoc3RhdGUgPT0gJ2xvYWRpbmdUZXh0Jykge1xuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWVcbiAgICAgICAgJGVsLmFkZENsYXNzKGQpLmF0dHIoZCwgZCkucHJvcChkLCB0cnVlKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTG9hZGluZykge1xuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlXG4gICAgICAgICRlbC5yZW1vdmVDbGFzcyhkKS5yZW1vdmVBdHRyKGQpLnByb3AoZCwgZmFsc2UpXG4gICAgICB9XG4gICAgfSwgdGhpcyksIDApXG4gIH1cblxuICBCdXR0b24ucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2hhbmdlZCA9IHRydWVcbiAgICB2YXIgJHBhcmVudCA9IHRoaXMuJGVsZW1lbnQuY2xvc2VzdCgnW2RhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiXScpXG5cbiAgICBpZiAoJHBhcmVudC5sZW5ndGgpIHtcbiAgICAgIHZhciAkaW5wdXQgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2lucHV0JylcbiAgICAgIGlmICgkaW5wdXQucHJvcCgndHlwZScpID09ICdyYWRpbycpIHtcbiAgICAgICAgaWYgKCRpbnB1dC5wcm9wKCdjaGVja2VkJykpIGNoYW5nZWQgPSBmYWxzZVxuICAgICAgICAkcGFyZW50LmZpbmQoJy5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgIH0gZWxzZSBpZiAoJGlucHV0LnByb3AoJ3R5cGUnKSA9PSAnY2hlY2tib3gnKSB7XG4gICAgICAgIGlmICgoJGlucHV0LnByb3AoJ2NoZWNrZWQnKSkgIT09IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2FjdGl2ZScpKSBjaGFuZ2VkID0gZmFsc2VcbiAgICAgICAgdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcygnYWN0aXZlJylcbiAgICAgIH1cbiAgICAgICRpbnB1dC5wcm9wKCdjaGVja2VkJywgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnYWN0aXZlJykpXG4gICAgICBpZiAoY2hhbmdlZCkgJGlucHV0LnRyaWdnZXIoJ2NoYW5nZScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1wcmVzc2VkJywgIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2FjdGl2ZScpKVxuICAgICAgdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcygnYWN0aXZlJylcbiAgICB9XG4gIH1cblxuXG4gIC8vIEJVVFRPTiBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuYnV0dG9uJylcbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5idXR0b24nLCAoZGF0YSA9IG5ldyBCdXR0b24odGhpcywgb3B0aW9ucykpKVxuXG4gICAgICBpZiAob3B0aW9uID09ICd0b2dnbGUnKSBkYXRhLnRvZ2dsZSgpXG4gICAgICBlbHNlIGlmIChvcHRpb24pIGRhdGEuc2V0U3RhdGUob3B0aW9uKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5idXR0b25cblxuICAkLmZuLmJ1dHRvbiAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmJ1dHRvbi5Db25zdHJ1Y3RvciA9IEJ1dHRvblxuXG5cbiAgLy8gQlVUVE9OIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uYnV0dG9uLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5idXR0b24gPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBCVVRUT04gREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLmJ1dHRvbi5kYXRhLWFwaScsICdbZGF0YS10b2dnbGVePVwiYnV0dG9uXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciAkYnRuID0gJChlLnRhcmdldCkuY2xvc2VzdCgnLmJ0bicpXG4gICAgICBQbHVnaW4uY2FsbCgkYnRuLCAndG9nZ2xlJylcbiAgICAgIGlmICghKCQoZS50YXJnZXQpLmlzKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0sIGlucHV0W3R5cGU9XCJjaGVja2JveFwiXScpKSkge1xuICAgICAgICAvLyBQcmV2ZW50IGRvdWJsZSBjbGljayBvbiByYWRpb3MsIGFuZCB0aGUgZG91YmxlIHNlbGVjdGlvbnMgKHNvIGNhbmNlbGxhdGlvbikgb24gY2hlY2tib3hlc1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgLy8gVGhlIHRhcmdldCBjb21wb25lbnQgc3RpbGwgcmVjZWl2ZSB0aGUgZm9jdXNcbiAgICAgICAgaWYgKCRidG4uaXMoJ2lucHV0LGJ1dHRvbicpKSAkYnRuLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgICAgZWxzZSAkYnRuLmZpbmQoJ2lucHV0OnZpc2libGUsYnV0dG9uOnZpc2libGUnKS5maXJzdCgpLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgIH1cbiAgICB9KVxuICAgIC5vbignZm9jdXMuYnMuYnV0dG9uLmRhdGEtYXBpIGJsdXIuYnMuYnV0dG9uLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgJChlLnRhcmdldCkuY2xvc2VzdCgnLmJ0bicpLnRvZ2dsZUNsYXNzKCdmb2N1cycsIC9eZm9jdXMoaW4pPyQvLnRlc3QoZS50eXBlKSlcbiAgICB9KVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBjYXJvdXNlbC5qcyB2My4zLjdcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2Nhcm91c2VsXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTYgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ0FST1VTRUwgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIENhcm91c2VsID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLiRlbGVtZW50ICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMuJGluZGljYXRvcnMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5jYXJvdXNlbC1pbmRpY2F0b3JzJylcbiAgICB0aGlzLm9wdGlvbnMgICAgID0gb3B0aW9uc1xuICAgIHRoaXMucGF1c2VkICAgICAgPSBudWxsXG4gICAgdGhpcy5zbGlkaW5nICAgICA9IG51bGxcbiAgICB0aGlzLmludGVydmFsICAgID0gbnVsbFxuICAgIHRoaXMuJGFjdGl2ZSAgICAgPSBudWxsXG4gICAgdGhpcy4kaXRlbXMgICAgICA9IG51bGxcblxuICAgIHRoaXMub3B0aW9ucy5rZXlib2FyZCAmJiB0aGlzLiRlbGVtZW50Lm9uKCdrZXlkb3duLmJzLmNhcm91c2VsJywgJC5wcm94eSh0aGlzLmtleWRvd24sIHRoaXMpKVxuXG4gICAgdGhpcy5vcHRpb25zLnBhdXNlID09ICdob3ZlcicgJiYgISgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpICYmIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5vbignbW91c2VlbnRlci5icy5jYXJvdXNlbCcsICQucHJveHkodGhpcy5wYXVzZSwgdGhpcykpXG4gICAgICAub24oJ21vdXNlbGVhdmUuYnMuY2Fyb3VzZWwnLCAkLnByb3h5KHRoaXMuY3ljbGUsIHRoaXMpKVxuICB9XG5cbiAgQ2Fyb3VzZWwuVkVSU0lPTiAgPSAnMy4zLjcnXG5cbiAgQ2Fyb3VzZWwuVFJBTlNJVElPTl9EVVJBVElPTiA9IDYwMFxuXG4gIENhcm91c2VsLkRFRkFVTFRTID0ge1xuICAgIGludGVydmFsOiA1MDAwLFxuICAgIHBhdXNlOiAnaG92ZXInLFxuICAgIHdyYXA6IHRydWUsXG4gICAga2V5Ym9hcmQ6IHRydWVcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5rZXlkb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoL2lucHV0fHRleHRhcmVhL2kudGVzdChlLnRhcmdldC50YWdOYW1lKSkgcmV0dXJuXG4gICAgc3dpdGNoIChlLndoaWNoKSB7XG4gICAgICBjYXNlIDM3OiB0aGlzLnByZXYoKTsgYnJlYWtcbiAgICAgIGNhc2UgMzk6IHRoaXMubmV4dCgpOyBicmVha1xuICAgICAgZGVmYXVsdDogcmV0dXJuXG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuY3ljbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUgfHwgKHRoaXMucGF1c2VkID0gZmFsc2UpXG5cbiAgICB0aGlzLmludGVydmFsICYmIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbClcblxuICAgIHRoaXMub3B0aW9ucy5pbnRlcnZhbFxuICAgICAgJiYgIXRoaXMucGF1c2VkXG4gICAgICAmJiAodGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKCQucHJveHkodGhpcy5uZXh0LCB0aGlzKSwgdGhpcy5vcHRpb25zLmludGVydmFsKSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuZ2V0SXRlbUluZGV4ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB0aGlzLiRpdGVtcyA9IGl0ZW0ucGFyZW50KCkuY2hpbGRyZW4oJy5pdGVtJylcbiAgICByZXR1cm4gdGhpcy4kaXRlbXMuaW5kZXgoaXRlbSB8fCB0aGlzLiRhY3RpdmUpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuZ2V0SXRlbUZvckRpcmVjdGlvbiA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIGFjdGl2ZSkge1xuICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0SXRlbUluZGV4KGFjdGl2ZSlcbiAgICB2YXIgd2lsbFdyYXAgPSAoZGlyZWN0aW9uID09ICdwcmV2JyAmJiBhY3RpdmVJbmRleCA9PT0gMClcbiAgICAgICAgICAgICAgICB8fCAoZGlyZWN0aW9uID09ICduZXh0JyAmJiBhY3RpdmVJbmRleCA9PSAodGhpcy4kaXRlbXMubGVuZ3RoIC0gMSkpXG4gICAgaWYgKHdpbGxXcmFwICYmICF0aGlzLm9wdGlvbnMud3JhcCkgcmV0dXJuIGFjdGl2ZVxuICAgIHZhciBkZWx0YSA9IGRpcmVjdGlvbiA9PSAncHJldicgPyAtMSA6IDFcbiAgICB2YXIgaXRlbUluZGV4ID0gKGFjdGl2ZUluZGV4ICsgZGVsdGEpICUgdGhpcy4kaXRlbXMubGVuZ3RoXG4gICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmVxKGl0ZW1JbmRleClcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICB2YXIgdGhhdCAgICAgICAgPSB0aGlzXG4gICAgdmFyIGFjdGl2ZUluZGV4ID0gdGhpcy5nZXRJdGVtSW5kZXgodGhpcy4kYWN0aXZlID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXRlbS5hY3RpdmUnKSlcblxuICAgIGlmIChwb3MgPiAodGhpcy4kaXRlbXMubGVuZ3RoIC0gMSkgfHwgcG9zIDwgMCkgcmV0dXJuXG5cbiAgICBpZiAodGhpcy5zbGlkaW5nKSAgICAgICByZXR1cm4gdGhpcy4kZWxlbWVudC5vbmUoJ3NsaWQuYnMuY2Fyb3VzZWwnLCBmdW5jdGlvbiAoKSB7IHRoYXQudG8ocG9zKSB9KSAvLyB5ZXMsIFwic2xpZFwiXG4gICAgaWYgKGFjdGl2ZUluZGV4ID09IHBvcykgcmV0dXJuIHRoaXMucGF1c2UoKS5jeWNsZSgpXG5cbiAgICByZXR1cm4gdGhpcy5zbGlkZShwb3MgPiBhY3RpdmVJbmRleCA/ICduZXh0JyA6ICdwcmV2JywgdGhpcy4kaXRlbXMuZXEocG9zKSlcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZSB8fCAodGhpcy5wYXVzZWQgPSB0cnVlKVxuXG4gICAgaWYgKHRoaXMuJGVsZW1lbnQuZmluZCgnLm5leHQsIC5wcmV2JykubGVuZ3RoICYmICQuc3VwcG9ydC50cmFuc2l0aW9uKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kKVxuICAgICAgdGhpcy5jeWNsZSh0cnVlKVxuICAgIH1cblxuICAgIHRoaXMuaW50ZXJ2YWwgPSBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc2xpZGluZykgcmV0dXJuXG4gICAgcmV0dXJuIHRoaXMuc2xpZGUoJ25leHQnKVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc2xpZGluZykgcmV0dXJuXG4gICAgcmV0dXJuIHRoaXMuc2xpZGUoJ3ByZXYnKVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLnNsaWRlID0gZnVuY3Rpb24gKHR5cGUsIG5leHQpIHtcbiAgICB2YXIgJGFjdGl2ZSAgID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXRlbS5hY3RpdmUnKVxuICAgIHZhciAkbmV4dCAgICAgPSBuZXh0IHx8IHRoaXMuZ2V0SXRlbUZvckRpcmVjdGlvbih0eXBlLCAkYWN0aXZlKVxuICAgIHZhciBpc0N5Y2xpbmcgPSB0aGlzLmludGVydmFsXG4gICAgdmFyIGRpcmVjdGlvbiA9IHR5cGUgPT0gJ25leHQnID8gJ2xlZnQnIDogJ3JpZ2h0J1xuICAgIHZhciB0aGF0ICAgICAgPSB0aGlzXG5cbiAgICBpZiAoJG5leHQuaGFzQ2xhc3MoJ2FjdGl2ZScpKSByZXR1cm4gKHRoaXMuc2xpZGluZyA9IGZhbHNlKVxuXG4gICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSAkbmV4dFswXVxuICAgIHZhciBzbGlkZUV2ZW50ID0gJC5FdmVudCgnc2xpZGUuYnMuY2Fyb3VzZWwnLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LFxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICB9KVxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihzbGlkZUV2ZW50KVxuICAgIGlmIChzbGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuc2xpZGluZyA9IHRydWVcblxuICAgIGlzQ3ljbGluZyAmJiB0aGlzLnBhdXNlKClcblxuICAgIGlmICh0aGlzLiRpbmRpY2F0b3JzLmxlbmd0aCkge1xuICAgICAgdGhpcy4kaW5kaWNhdG9ycy5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICB2YXIgJG5leHRJbmRpY2F0b3IgPSAkKHRoaXMuJGluZGljYXRvcnMuY2hpbGRyZW4oKVt0aGlzLmdldEl0ZW1JbmRleCgkbmV4dCldKVxuICAgICAgJG5leHRJbmRpY2F0b3IgJiYgJG5leHRJbmRpY2F0b3IuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgfVxuXG4gICAgdmFyIHNsaWRFdmVudCA9ICQuRXZlbnQoJ3NsaWQuYnMuY2Fyb3VzZWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXQsIGRpcmVjdGlvbjogZGlyZWN0aW9uIH0pIC8vIHllcywgXCJzbGlkXCJcbiAgICBpZiAoJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnc2xpZGUnKSkge1xuICAgICAgJG5leHQuYWRkQ2xhc3ModHlwZSlcbiAgICAgICRuZXh0WzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xuICAgICAgJGFjdGl2ZS5hZGRDbGFzcyhkaXJlY3Rpb24pXG4gICAgICAkbmV4dC5hZGRDbGFzcyhkaXJlY3Rpb24pXG4gICAgICAkYWN0aXZlXG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkbmV4dC5yZW1vdmVDbGFzcyhbdHlwZSwgZGlyZWN0aW9uXS5qb2luKCcgJykpLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgICAgICRhY3RpdmUucmVtb3ZlQ2xhc3MoWydhY3RpdmUnLCBkaXJlY3Rpb25dLmpvaW4oJyAnKSlcbiAgICAgICAgICB0aGF0LnNsaWRpbmcgPSBmYWxzZVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKHNsaWRFdmVudClcbiAgICAgICAgICB9LCAwKVxuICAgICAgICB9KVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQ2Fyb3VzZWwuVFJBTlNJVElPTl9EVVJBVElPTilcbiAgICB9IGVsc2Uge1xuICAgICAgJGFjdGl2ZS5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICAgICRuZXh0LmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgdGhpcy5zbGlkaW5nID0gZmFsc2VcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihzbGlkRXZlbnQpXG4gICAgfVxuXG4gICAgaXNDeWNsaW5nICYmIHRoaXMuY3ljbGUoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQ0FST1VTRUwgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuY2Fyb3VzZWwnKVxuICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQ2Fyb3VzZWwuREVGQVVMVFMsICR0aGlzLmRhdGEoKSwgdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb24pXG4gICAgICB2YXIgYWN0aW9uICA9IHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycgPyBvcHRpb24gOiBvcHRpb25zLnNsaWRlXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuY2Fyb3VzZWwnLCAoZGF0YSA9IG5ldyBDYXJvdXNlbCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnbnVtYmVyJykgZGF0YS50byhvcHRpb24pXG4gICAgICBlbHNlIGlmIChhY3Rpb24pIGRhdGFbYWN0aW9uXSgpXG4gICAgICBlbHNlIGlmIChvcHRpb25zLmludGVydmFsKSBkYXRhLnBhdXNlKCkuY3ljbGUoKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5jYXJvdXNlbFxuXG4gICQuZm4uY2Fyb3VzZWwgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5jYXJvdXNlbC5Db25zdHJ1Y3RvciA9IENhcm91c2VsXG5cblxuICAvLyBDQVJPVVNFTCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uY2Fyb3VzZWwubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmNhcm91c2VsID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQ0FST1VTRUwgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICB2YXIgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgaHJlZlxuICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgIHZhciAkdGFyZ2V0ID0gJCgkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpIHx8IChocmVmID0gJHRoaXMuYXR0cignaHJlZicpKSAmJiBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKSkgLy8gc3RyaXAgZm9yIGllN1xuICAgIGlmICghJHRhcmdldC5oYXNDbGFzcygnY2Fyb3VzZWwnKSkgcmV0dXJuXG4gICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJHRhcmdldC5kYXRhKCksICR0aGlzLmRhdGEoKSlcbiAgICB2YXIgc2xpZGVJbmRleCA9ICR0aGlzLmF0dHIoJ2RhdGEtc2xpZGUtdG8nKVxuICAgIGlmIChzbGlkZUluZGV4KSBvcHRpb25zLmludGVydmFsID0gZmFsc2VcblxuICAgIFBsdWdpbi5jYWxsKCR0YXJnZXQsIG9wdGlvbnMpXG5cbiAgICBpZiAoc2xpZGVJbmRleCkge1xuICAgICAgJHRhcmdldC5kYXRhKCdicy5jYXJvdXNlbCcpLnRvKHNsaWRlSW5kZXgpXG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICAkKGRvY3VtZW50KVxuICAgIC5vbignY2xpY2suYnMuY2Fyb3VzZWwuZGF0YS1hcGknLCAnW2RhdGEtc2xpZGVdJywgY2xpY2tIYW5kbGVyKVxuICAgIC5vbignY2xpY2suYnMuY2Fyb3VzZWwuZGF0YS1hcGknLCAnW2RhdGEtc2xpZGUtdG9dJywgY2xpY2tIYW5kbGVyKVxuXG4gICQod2luZG93KS5vbignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAkKCdbZGF0YS1yaWRlPVwiY2Fyb3VzZWxcIl0nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkY2Fyb3VzZWwgPSAkKHRoaXMpXG4gICAgICBQbHVnaW4uY2FsbCgkY2Fyb3VzZWwsICRjYXJvdXNlbC5kYXRhKCkpXG4gICAgfSlcbiAgfSlcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogY29sbGFwc2UuanMgdjMuMy43XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNjb2xsYXBzZVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE2IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuLyoganNoaW50IGxhdGVkZWY6IGZhbHNlICovXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ09MTEFQU0UgUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgQ29sbGFwc2UgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgICAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLm9wdGlvbnMgICAgICAgPSAkLmV4dGVuZCh7fSwgQ29sbGFwc2UuREVGQVVMVFMsIG9wdGlvbnMpXG4gICAgdGhpcy4kdHJpZ2dlciAgICAgID0gJCgnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1baHJlZj1cIiMnICsgZWxlbWVudC5pZCArICdcIl0sJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS10YXJnZXQ9XCIjJyArIGVsZW1lbnQuaWQgKyAnXCJdJylcbiAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSBudWxsXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnBhcmVudCkge1xuICAgICAgdGhpcy4kcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLiRlbGVtZW50LCB0aGlzLiR0cmlnZ2VyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudG9nZ2xlKSB0aGlzLnRvZ2dsZSgpXG4gIH1cblxuICBDb2xsYXBzZS5WRVJTSU9OICA9ICczLjMuNydcblxuICBDb2xsYXBzZS5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMzUwXG5cbiAgQ29sbGFwc2UuREVGQVVMVFMgPSB7XG4gICAgdG9nZ2xlOiB0cnVlXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNXaWR0aCA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3dpZHRoJylcbiAgICByZXR1cm4gaGFzV2lkdGggPyAnd2lkdGgnIDogJ2hlaWdodCdcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25pbmcgfHwgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaW4nKSkgcmV0dXJuXG5cbiAgICB2YXIgYWN0aXZlc0RhdGFcbiAgICB2YXIgYWN0aXZlcyA9IHRoaXMuJHBhcmVudCAmJiB0aGlzLiRwYXJlbnQuY2hpbGRyZW4oJy5wYW5lbCcpLmNoaWxkcmVuKCcuaW4sIC5jb2xsYXBzaW5nJylcblxuICAgIGlmIChhY3RpdmVzICYmIGFjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICBhY3RpdmVzRGF0YSA9IGFjdGl2ZXMuZGF0YSgnYnMuY29sbGFwc2UnKVxuICAgICAgaWYgKGFjdGl2ZXNEYXRhICYmIGFjdGl2ZXNEYXRhLnRyYW5zaXRpb25pbmcpIHJldHVyblxuICAgIH1cblxuICAgIHZhciBzdGFydEV2ZW50ID0gJC5FdmVudCgnc2hvdy5icy5jb2xsYXBzZScpXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKHN0YXJ0RXZlbnQpXG4gICAgaWYgKHN0YXJ0RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgaWYgKGFjdGl2ZXMgJiYgYWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgIFBsdWdpbi5jYWxsKGFjdGl2ZXMsICdoaWRlJylcbiAgICAgIGFjdGl2ZXNEYXRhIHx8IGFjdGl2ZXMuZGF0YSgnYnMuY29sbGFwc2UnLCBudWxsKVxuICAgIH1cblxuICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmRpbWVuc2lvbigpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlJylcbiAgICAgIC5hZGRDbGFzcygnY29sbGFwc2luZycpW2RpbWVuc2lvbl0oMClcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcblxuICAgIHRoaXMuJHRyaWdnZXJcbiAgICAgIC5yZW1vdmVDbGFzcygnY29sbGFwc2VkJylcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcblxuICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IDFcblxuICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzZSBpbicpW2RpbWVuc2lvbl0oJycpXG4gICAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSAwXG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC50cmlnZ2VyKCdzaG93bi5icy5jb2xsYXBzZScpXG4gICAgfVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuIGNvbXBsZXRlLmNhbGwodGhpcylcblxuICAgIHZhciBzY3JvbGxTaXplID0gJC5jYW1lbENhc2UoWydzY3JvbGwnLCBkaW1lbnNpb25dLmpvaW4oJy0nKSlcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsICQucHJveHkoY29tcGxldGUsIHRoaXMpKVxuICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKENvbGxhcHNlLlRSQU5TSVRJT05fRFVSQVRJT04pW2RpbWVuc2lvbl0odGhpcy4kZWxlbWVudFswXVtzY3JvbGxTaXplXSlcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25pbmcgfHwgIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2luJykpIHJldHVyblxuXG4gICAgdmFyIHN0YXJ0RXZlbnQgPSAkLkV2ZW50KCdoaWRlLmJzLmNvbGxhcHNlJylcbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoc3RhcnRFdmVudClcbiAgICBpZiAoc3RhcnRFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5kaW1lbnNpb24oKVxuXG4gICAgdGhpcy4kZWxlbWVudFtkaW1lbnNpb25dKHRoaXMuJGVsZW1lbnRbZGltZW5zaW9uXSgpKVswXS5vZmZzZXRIZWlnaHRcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5hZGRDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlIGluJylcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpXG5cbiAgICB0aGlzLiR0cmlnZ2VyXG4gICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlZCcpXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuXG4gICAgdGhpcy50cmFuc2l0aW9uaW5nID0gMVxuXG4gICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uaW5nID0gMFxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNpbmcnKVxuICAgICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlJylcbiAgICAgICAgLnRyaWdnZXIoJ2hpZGRlbi5icy5jb2xsYXBzZScpXG4gICAgfVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuIGNvbXBsZXRlLmNhbGwodGhpcylcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIFtkaW1lbnNpb25dKDApXG4gICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCAkLnByb3h5KGNvbXBsZXRlLCB0aGlzKSlcbiAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChDb2xsYXBzZS5UUkFOU0lUSU9OX0RVUkFUSU9OKVxuICB9XG5cbiAgQ29sbGFwc2UucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzW3RoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2luJykgPyAnaGlkZScgOiAnc2hvdyddKClcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICQodGhpcy5vcHRpb25zLnBhcmVudClcbiAgICAgIC5maW5kKCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXBhcmVudD1cIicgKyB0aGlzLm9wdGlvbnMucGFyZW50ICsgJ1wiXScpXG4gICAgICAuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudClcbiAgICAgICAgdGhpcy5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoZ2V0VGFyZ2V0RnJvbVRyaWdnZXIoJGVsZW1lbnQpLCAkZWxlbWVudClcbiAgICAgIH0sIHRoaXMpKVxuICAgICAgLmVuZCgpXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzID0gZnVuY3Rpb24gKCRlbGVtZW50LCAkdHJpZ2dlcikge1xuICAgIHZhciBpc09wZW4gPSAkZWxlbWVudC5oYXNDbGFzcygnaW4nKVxuXG4gICAgJGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsIGlzT3BlbilcbiAgICAkdHJpZ2dlclxuICAgICAgLnRvZ2dsZUNsYXNzKCdjb2xsYXBzZWQnLCAhaXNPcGVuKVxuICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBpc09wZW4pXG4gIH1cblxuICBmdW5jdGlvbiBnZXRUYXJnZXRGcm9tVHJpZ2dlcigkdHJpZ2dlcikge1xuICAgIHZhciBocmVmXG4gICAgdmFyIHRhcmdldCA9ICR0cmlnZ2VyLmF0dHIoJ2RhdGEtdGFyZ2V0JylcbiAgICAgIHx8IChocmVmID0gJHRyaWdnZXIuYXR0cignaHJlZicpKSAmJiBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG5cbiAgICByZXR1cm4gJCh0YXJnZXQpXG4gIH1cblxuXG4gIC8vIENPTExBUFNFIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLmNvbGxhcHNlJylcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIENvbGxhcHNlLkRFRkFVTFRTLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxuXG4gICAgICBpZiAoIWRhdGEgJiYgb3B0aW9ucy50b2dnbGUgJiYgL3Nob3d8aGlkZS8udGVzdChvcHRpb24pKSBvcHRpb25zLnRvZ2dsZSA9IGZhbHNlXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmNvbGxhcHNlJywgKGRhdGEgPSBuZXcgQ29sbGFwc2UodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmNvbGxhcHNlXG5cbiAgJC5mbi5jb2xsYXBzZSAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmNvbGxhcHNlLkNvbnN0cnVjdG9yID0gQ29sbGFwc2VcblxuXG4gIC8vIENPTExBUFNFIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5jb2xsYXBzZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uY29sbGFwc2UgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBDT0xMQVBTRSBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpLm9uKCdjbGljay5icy5jb2xsYXBzZS5kYXRhLWFwaScsICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG5cbiAgICBpZiAoISR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JykpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgdmFyICR0YXJnZXQgPSBnZXRUYXJnZXRGcm9tVHJpZ2dlcigkdGhpcylcbiAgICB2YXIgZGF0YSAgICA9ICR0YXJnZXQuZGF0YSgnYnMuY29sbGFwc2UnKVxuICAgIHZhciBvcHRpb24gID0gZGF0YSA/ICd0b2dnbGUnIDogJHRoaXMuZGF0YSgpXG5cbiAgICBQbHVnaW4uY2FsbCgkdGFyZ2V0LCBvcHRpb24pXG4gIH0pXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IGRyb3Bkb3duLmpzIHYzLjMuN1xuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jZHJvcGRvd25zXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTYgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gRFJPUERPV04gQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIGJhY2tkcm9wID0gJy5kcm9wZG93bi1iYWNrZHJvcCdcbiAgdmFyIHRvZ2dsZSAgID0gJ1tkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCJdJ1xuICB2YXIgRHJvcGRvd24gPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICQoZWxlbWVudCkub24oJ2NsaWNrLmJzLmRyb3Bkb3duJywgdGhpcy50b2dnbGUpXG4gIH1cblxuICBEcm9wZG93bi5WRVJTSU9OID0gJzMuMy43J1xuXG4gIGZ1bmN0aW9uIGdldFBhcmVudCgkdGhpcykge1xuICAgIHZhciBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JylcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHNlbGVjdG9yID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yICYmIC8jW0EtWmEtel0vLnRlc3Qoc2VsZWN0b3IpICYmIHNlbGVjdG9yLnJlcGxhY2UoLy4qKD89I1teXFxzXSokKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgfVxuXG4gICAgdmFyICRwYXJlbnQgPSBzZWxlY3RvciAmJiAkKHNlbGVjdG9yKVxuXG4gICAgcmV0dXJuICRwYXJlbnQgJiYgJHBhcmVudC5sZW5ndGggPyAkcGFyZW50IDogJHRoaXMucGFyZW50KClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyTWVudXMoZSkge1xuICAgIGlmIChlICYmIGUud2hpY2ggPT09IDMpIHJldHVyblxuICAgICQoYmFja2Ryb3ApLnJlbW92ZSgpXG4gICAgJCh0b2dnbGUpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgICAgICAgPSAkKHRoaXMpXG4gICAgICB2YXIgJHBhcmVudCAgICAgICA9IGdldFBhcmVudCgkdGhpcylcbiAgICAgIHZhciByZWxhdGVkVGFyZ2V0ID0geyByZWxhdGVkVGFyZ2V0OiB0aGlzIH1cblxuICAgICAgaWYgKCEkcGFyZW50Lmhhc0NsYXNzKCdvcGVuJykpIHJldHVyblxuXG4gICAgICBpZiAoZSAmJiBlLnR5cGUgPT0gJ2NsaWNrJyAmJiAvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGUudGFyZ2V0LnRhZ05hbWUpICYmICQuY29udGFpbnMoJHBhcmVudFswXSwgZS50YXJnZXQpKSByZXR1cm5cblxuICAgICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdoaWRlLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldCkpXG5cbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICAgJHRoaXMuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpXG4gICAgICAkcGFyZW50LnJlbW92ZUNsYXNzKCdvcGVuJykudHJpZ2dlcigkLkV2ZW50KCdoaWRkZW4uYnMuZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KSlcbiAgICB9KVxuICB9XG5cbiAgRHJvcGRvd24ucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzID0gJCh0aGlzKVxuXG4gICAgaWYgKCR0aGlzLmlzKCcuZGlzYWJsZWQsIDpkaXNhYmxlZCcpKSByZXR1cm5cblxuICAgIHZhciAkcGFyZW50ICA9IGdldFBhcmVudCgkdGhpcylcbiAgICB2YXIgaXNBY3RpdmUgPSAkcGFyZW50Lmhhc0NsYXNzKCdvcGVuJylcblxuICAgIGNsZWFyTWVudXMoKVxuXG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhJHBhcmVudC5jbG9zZXN0KCcubmF2YmFyLW5hdicpLmxlbmd0aCkge1xuICAgICAgICAvLyBpZiBtb2JpbGUgd2UgdXNlIGEgYmFja2Ryb3AgYmVjYXVzZSBjbGljayBldmVudHMgZG9uJ3QgZGVsZWdhdGVcbiAgICAgICAgJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSlcbiAgICAgICAgICAuYWRkQ2xhc3MoJ2Ryb3Bkb3duLWJhY2tkcm9wJylcbiAgICAgICAgICAuaW5zZXJ0QWZ0ZXIoJCh0aGlzKSlcbiAgICAgICAgICAub24oJ2NsaWNrJywgY2xlYXJNZW51cylcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7IHJlbGF0ZWRUYXJnZXQ6IHRoaXMgfVxuICAgICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdzaG93LmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldCkpXG5cbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICAgJHRoaXNcbiAgICAgICAgLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpXG5cbiAgICAgICRwYXJlbnRcbiAgICAgICAgLnRvZ2dsZUNsYXNzKCdvcGVuJylcbiAgICAgICAgLnRyaWdnZXIoJC5FdmVudCgnc2hvd24uYnMuZHJvcGRvd24nLCByZWxhdGVkVGFyZ2V0KSlcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIERyb3Bkb3duLnByb3RvdHlwZS5rZXlkb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIS8oMzh8NDB8Mjd8MzIpLy50ZXN0KGUud2hpY2gpIHx8IC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZS50YXJnZXQudGFnTmFtZSkpIHJldHVyblxuXG4gICAgdmFyICR0aGlzID0gJCh0aGlzKVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgaWYgKCR0aGlzLmlzKCcuZGlzYWJsZWQsIDpkaXNhYmxlZCcpKSByZXR1cm5cblxuICAgIHZhciAkcGFyZW50ICA9IGdldFBhcmVudCgkdGhpcylcbiAgICB2YXIgaXNBY3RpdmUgPSAkcGFyZW50Lmhhc0NsYXNzKCdvcGVuJylcblxuICAgIGlmICghaXNBY3RpdmUgJiYgZS53aGljaCAhPSAyNyB8fCBpc0FjdGl2ZSAmJiBlLndoaWNoID09IDI3KSB7XG4gICAgICBpZiAoZS53aGljaCA9PSAyNykgJHBhcmVudC5maW5kKHRvZ2dsZSkudHJpZ2dlcignZm9jdXMnKVxuICAgICAgcmV0dXJuICR0aGlzLnRyaWdnZXIoJ2NsaWNrJylcbiAgICB9XG5cbiAgICB2YXIgZGVzYyA9ICcgbGk6bm90KC5kaXNhYmxlZCk6dmlzaWJsZSBhJ1xuICAgIHZhciAkaXRlbXMgPSAkcGFyZW50LmZpbmQoJy5kcm9wZG93bi1tZW51JyArIGRlc2MpXG5cbiAgICBpZiAoISRpdGVtcy5sZW5ndGgpIHJldHVyblxuXG4gICAgdmFyIGluZGV4ID0gJGl0ZW1zLmluZGV4KGUudGFyZ2V0KVxuXG4gICAgaWYgKGUud2hpY2ggPT0gMzggJiYgaW5kZXggPiAwKSAgICAgICAgICAgICAgICAgaW5kZXgtLSAgICAgICAgIC8vIHVwXG4gICAgaWYgKGUud2hpY2ggPT0gNDAgJiYgaW5kZXggPCAkaXRlbXMubGVuZ3RoIC0gMSkgaW5kZXgrKyAgICAgICAgIC8vIGRvd25cbiAgICBpZiAoIX5pbmRleCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDBcblxuICAgICRpdGVtcy5lcShpbmRleCkudHJpZ2dlcignZm9jdXMnKVxuICB9XG5cblxuICAvLyBEUk9QRE9XTiBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICA9ICR0aGlzLmRhdGEoJ2JzLmRyb3Bkb3duJylcblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5kcm9wZG93bicsIChkYXRhID0gbmV3IERyb3Bkb3duKHRoaXMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0uY2FsbCgkdGhpcylcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uZHJvcGRvd25cblxuICAkLmZuLmRyb3Bkb3duICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uZHJvcGRvd24uQ29uc3RydWN0b3IgPSBEcm9wZG93blxuXG5cbiAgLy8gRFJPUERPV04gTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmRyb3Bkb3duLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5kcm9wZG93biA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIEFQUExZIFRPIFNUQU5EQVJEIERST1BET1dOIEVMRU1FTlRTXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgY2xlYXJNZW51cylcbiAgICAub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgJy5kcm9wZG93biBmb3JtJywgZnVuY3Rpb24gKGUpIHsgZS5zdG9wUHJvcGFnYXRpb24oKSB9KVxuICAgIC5vbignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGknLCB0b2dnbGUsIERyb3Bkb3duLnByb3RvdHlwZS50b2dnbGUpXG4gICAgLm9uKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgdG9nZ2xlLCBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93bilcbiAgICAub24oJ2tleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGknLCAnLmRyb3Bkb3duLW1lbnUnLCBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93bilcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogbW9kYWwuanMgdjMuMy43XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNtb2RhbHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNiBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBNT0RBTCBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgTW9kYWwgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyAgICAgICAgICAgICA9IG9wdGlvbnNcbiAgICB0aGlzLiRib2R5ICAgICAgICAgICAgICAgPSAkKGRvY3VtZW50LmJvZHkpXG4gICAgdGhpcy4kZWxlbWVudCAgICAgICAgICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMuJGRpYWxvZyAgICAgICAgICAgICA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLm1vZGFsLWRpYWxvZycpXG4gICAgdGhpcy4kYmFja2Ryb3AgICAgICAgICAgID0gbnVsbFxuICAgIHRoaXMuaXNTaG93biAgICAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLm9yaWdpbmFsQm9keVBhZCAgICAgPSBudWxsXG4gICAgdGhpcy5zY3JvbGxiYXJXaWR0aCAgICAgID0gMFxuICAgIHRoaXMuaWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJlbW90ZSkge1xuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAuZmluZCgnLm1vZGFsLWNvbnRlbnQnKVxuICAgICAgICAubG9hZCh0aGlzLm9wdGlvbnMucmVtb3RlLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2xvYWRlZC5icy5tb2RhbCcpXG4gICAgICAgIH0sIHRoaXMpKVxuICAgIH1cbiAgfVxuXG4gIE1vZGFsLlZFUlNJT04gID0gJzMuMy43J1xuXG4gIE1vZGFsLlRSQU5TSVRJT05fRFVSQVRJT04gPSAzMDBcbiAgTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIE1vZGFsLkRFRkFVTFRTID0ge1xuICAgIGJhY2tkcm9wOiB0cnVlLFxuICAgIGtleWJvYXJkOiB0cnVlLFxuICAgIHNob3c6IHRydWVcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coX3JlbGF0ZWRUYXJnZXQpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChfcmVsYXRlZFRhcmdldCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHZhciBlICAgID0gJC5FdmVudCgnc2hvdy5icy5tb2RhbCcsIHsgcmVsYXRlZFRhcmdldDogX3JlbGF0ZWRUYXJnZXQgfSlcblxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgaWYgKHRoaXMuaXNTaG93biB8fCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuaXNTaG93biA9IHRydWVcblxuICAgIHRoaXMuY2hlY2tTY3JvbGxiYXIoKVxuICAgIHRoaXMuc2V0U2Nyb2xsYmFyKClcbiAgICB0aGlzLiRib2R5LmFkZENsYXNzKCdtb2RhbC1vcGVuJylcblxuICAgIHRoaXMuZXNjYXBlKClcbiAgICB0aGlzLnJlc2l6ZSgpXG5cbiAgICB0aGlzLiRlbGVtZW50Lm9uKCdjbGljay5kaXNtaXNzLmJzLm1vZGFsJywgJ1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXScsICQucHJveHkodGhpcy5oaWRlLCB0aGlzKSlcblxuICAgIHRoaXMuJGRpYWxvZy5vbignbW91c2Vkb3duLmRpc21pc3MuYnMubW9kYWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LiRlbGVtZW50Lm9uZSgnbW91c2V1cC5kaXNtaXNzLmJzLm1vZGFsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCQoZS50YXJnZXQpLmlzKHRoYXQuJGVsZW1lbnQpKSB0aGF0Lmlnbm9yZUJhY2tkcm9wQ2xpY2sgPSB0cnVlXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhhdC4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpXG5cbiAgICAgIGlmICghdGhhdC4kZWxlbWVudC5wYXJlbnQoKS5sZW5ndGgpIHtcbiAgICAgICAgdGhhdC4kZWxlbWVudC5hcHBlbmRUbyh0aGF0LiRib2R5KSAvLyBkb24ndCBtb3ZlIG1vZGFscyBkb20gcG9zaXRpb25cbiAgICAgIH1cblxuICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAuc2hvdygpXG4gICAgICAgIC5zY3JvbGxUb3AoMClcblxuICAgICAgdGhhdC5hZGp1c3REaWFsb2coKVxuXG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICB0aGF0LiRlbGVtZW50WzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xuICAgICAgfVxuXG4gICAgICB0aGF0LiRlbGVtZW50LmFkZENsYXNzKCdpbicpXG5cbiAgICAgIHRoYXQuZW5mb3JjZUZvY3VzKClcblxuICAgICAgdmFyIGUgPSAkLkV2ZW50KCdzaG93bi5icy5tb2RhbCcsIHsgcmVsYXRlZFRhcmdldDogX3JlbGF0ZWRUYXJnZXQgfSlcblxuICAgICAgdHJhbnNpdGlvbiA/XG4gICAgICAgIHRoYXQuJGRpYWxvZyAvLyB3YWl0IGZvciBtb2RhbCB0byBzbGlkZSBpblxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKS50cmlnZ2VyKGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJykudHJpZ2dlcihlKVxuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgZSA9ICQuRXZlbnQoJ2hpZGUuYnMubW9kYWwnKVxuXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICBpZiAoIXRoaXMuaXNTaG93biB8fCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHRoaXMuaXNTaG93biA9IGZhbHNlXG5cbiAgICB0aGlzLmVzY2FwZSgpXG4gICAgdGhpcy5yZXNpemUoKVxuXG4gICAgJChkb2N1bWVudCkub2ZmKCdmb2N1c2luLmJzLm1vZGFsJylcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5yZW1vdmVDbGFzcygnaW4nKVxuICAgICAgLm9mZignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcpXG4gICAgICAub2ZmKCdtb3VzZXVwLmRpc21pc3MuYnMubW9kYWwnKVxuXG4gICAgdGhpcy4kZGlhbG9nLm9mZignbW91c2Vkb3duLmRpc21pc3MuYnMubW9kYWwnKVxuXG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgJC5wcm94eSh0aGlzLmhpZGVNb2RhbCwgdGhpcykpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChNb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICB0aGlzLmhpZGVNb2RhbCgpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuZW5mb3JjZUZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICQoZG9jdW1lbnQpXG4gICAgICAub2ZmKCdmb2N1c2luLmJzLm1vZGFsJykgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXG4gICAgICAub24oJ2ZvY3VzaW4uYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChkb2N1bWVudCAhPT0gZS50YXJnZXQgJiZcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnRbMF0gIT09IGUudGFyZ2V0ICYmXG4gICAgICAgICAgICAhdGhpcy4kZWxlbWVudC5oYXMoZS50YXJnZXQpLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5lc2NhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNTaG93biAmJiB0aGlzLm9wdGlvbnMua2V5Ym9hcmQpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2tleWRvd24uZGlzbWlzcy5icy5tb2RhbCcsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS53aGljaCA9PSAyNyAmJiB0aGlzLmhpZGUoKVxuICAgICAgfSwgdGhpcykpXG4gICAgfSBlbHNlIGlmICghdGhpcy5pc1Nob3duKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigna2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsJylcbiAgICB9XG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzU2hvd24pIHtcbiAgICAgICQod2luZG93KS5vbigncmVzaXplLmJzLm1vZGFsJywgJC5wcm94eSh0aGlzLmhhbmRsZVVwZGF0ZSwgdGhpcykpXG4gICAgfSBlbHNlIHtcbiAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS5icy5tb2RhbCcpXG4gICAgfVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmhpZGVNb2RhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB0aGlzLiRlbGVtZW50LmhpZGUoKVxuICAgIHRoaXMuYmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC4kYm9keS5yZW1vdmVDbGFzcygnbW9kYWwtb3BlbicpXG4gICAgICB0aGF0LnJlc2V0QWRqdXN0bWVudHMoKVxuICAgICAgdGhhdC5yZXNldFNjcm9sbGJhcigpXG4gICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2hpZGRlbi5icy5tb2RhbCcpXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZW1vdmVCYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRiYWNrZHJvcCAmJiB0aGlzLiRiYWNrZHJvcC5yZW1vdmUoKVxuICAgIHRoaXMuJGJhY2tkcm9wID0gbnVsbFxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmJhY2tkcm9wID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdmFyIGFuaW1hdGUgPSB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJykgPyAnZmFkZScgOiAnJ1xuXG4gICAgaWYgKHRoaXMuaXNTaG93biAmJiB0aGlzLm9wdGlvbnMuYmFja2Ryb3ApIHtcbiAgICAgIHZhciBkb0FuaW1hdGUgPSAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiBhbmltYXRlXG5cbiAgICAgIHRoaXMuJGJhY2tkcm9wID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSlcbiAgICAgICAgLmFkZENsYXNzKCdtb2RhbC1iYWNrZHJvcCAnICsgYW5pbWF0ZSlcbiAgICAgICAgLmFwcGVuZFRvKHRoaXMuJGJvZHkpXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2sgPSBmYWxzZVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0KSByZXR1cm5cbiAgICAgICAgdGhpcy5vcHRpb25zLmJhY2tkcm9wID09ICdzdGF0aWMnXG4gICAgICAgICAgPyB0aGlzLiRlbGVtZW50WzBdLmZvY3VzKClcbiAgICAgICAgICA6IHRoaXMuaGlkZSgpXG4gICAgICB9LCB0aGlzKSlcblxuICAgICAgaWYgKGRvQW5pbWF0ZSkgdGhpcy4kYmFja2Ryb3BbMF0ub2Zmc2V0V2lkdGggLy8gZm9yY2UgcmVmbG93XG5cbiAgICAgIHRoaXMuJGJhY2tkcm9wLmFkZENsYXNzKCdpbicpXG5cbiAgICAgIGlmICghY2FsbGJhY2spIHJldHVyblxuXG4gICAgICBkb0FuaW1hdGUgP1xuICAgICAgICB0aGlzLiRiYWNrZHJvcFxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNhbGxiYWNrKVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChNb2RhbC5CQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICAgIGNhbGxiYWNrKClcblxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNTaG93biAmJiB0aGlzLiRiYWNrZHJvcCkge1xuICAgICAgdGhpcy4kYmFja2Ryb3AucmVtb3ZlQ2xhc3MoJ2luJylcblxuICAgICAgdmFyIGNhbGxiYWNrUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGF0LnJlbW92ZUJhY2tkcm9wKClcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgICAgfVxuICAgICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICAgdGhpcy4kYmFja2Ryb3BcbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBjYWxsYmFja1JlbW92ZSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgICBjYWxsYmFja1JlbW92ZSgpXG5cbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgLy8gdGhlc2UgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xuXG4gIE1vZGFsLnByb3RvdHlwZS5oYW5kbGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hZGp1c3REaWFsb2coKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmFkanVzdERpYWxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kYWxJc092ZXJmbG93aW5nID0gdGhpcy4kZWxlbWVudFswXS5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG5cbiAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICBwYWRkaW5nTGVmdDogICF0aGlzLmJvZHlJc092ZXJmbG93aW5nICYmIG1vZGFsSXNPdmVyZmxvd2luZyA/IHRoaXMuc2Nyb2xsYmFyV2lkdGggOiAnJyxcbiAgICAgIHBhZGRpbmdSaWdodDogdGhpcy5ib2R5SXNPdmVyZmxvd2luZyAmJiAhbW9kYWxJc092ZXJmbG93aW5nID8gdGhpcy5zY3JvbGxiYXJXaWR0aCA6ICcnXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZXNldEFkanVzdG1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcbiAgICAgIHBhZGRpbmdMZWZ0OiAnJyxcbiAgICAgIHBhZGRpbmdSaWdodDogJydcbiAgICB9KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmNoZWNrU2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmdWxsV2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIGlmICghZnVsbFdpbmRvd1dpZHRoKSB7IC8vIHdvcmthcm91bmQgZm9yIG1pc3Npbmcgd2luZG93LmlubmVyV2lkdGggaW4gSUU4XG4gICAgICB2YXIgZG9jdW1lbnRFbGVtZW50UmVjdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgZnVsbFdpbmRvd1dpZHRoID0gZG9jdW1lbnRFbGVtZW50UmVjdC5yaWdodCAtIE1hdGguYWJzKGRvY3VtZW50RWxlbWVudFJlY3QubGVmdClcbiAgICB9XG4gICAgdGhpcy5ib2R5SXNPdmVyZmxvd2luZyA9IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGggPCBmdWxsV2luZG93V2lkdGhcbiAgICB0aGlzLnNjcm9sbGJhcldpZHRoID0gdGhpcy5tZWFzdXJlU2Nyb2xsYmFyKClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5zZXRTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJvZHlQYWQgPSBwYXJzZUludCgodGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnKSB8fCAwKSwgMTApXG4gICAgdGhpcy5vcmlnaW5hbEJvZHlQYWQgPSBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCB8fCAnJ1xuICAgIGlmICh0aGlzLmJvZHlJc092ZXJmbG93aW5nKSB0aGlzLiRib2R5LmNzcygncGFkZGluZy1yaWdodCcsIGJvZHlQYWQgKyB0aGlzLnNjcm9sbGJhcldpZHRoKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnJlc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JywgdGhpcy5vcmlnaW5hbEJvZHlQYWQpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUubWVhc3VyZVNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHsgLy8gdGh4IHdhbHNoXG4gICAgdmFyIHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgc2Nyb2xsRGl2LmNsYXNzTmFtZSA9ICdtb2RhbC1zY3JvbGxiYXItbWVhc3VyZSdcbiAgICB0aGlzLiRib2R5LmFwcGVuZChzY3JvbGxEaXYpXG4gICAgdmFyIHNjcm9sbGJhcldpZHRoID0gc2Nyb2xsRGl2Lm9mZnNldFdpZHRoIC0gc2Nyb2xsRGl2LmNsaWVudFdpZHRoXG4gICAgdGhpcy4kYm9keVswXS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpXG4gICAgcmV0dXJuIHNjcm9sbGJhcldpZHRoXG4gIH1cblxuXG4gIC8vIE1PREFMIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbiwgX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5tb2RhbCcpXG4gICAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBNb2RhbC5ERUZBVUxUUywgJHRoaXMuZGF0YSgpLCB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvbilcblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5tb2RhbCcsIChkYXRhID0gbmV3IE1vZGFsKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oX3JlbGF0ZWRUYXJnZXQpXG4gICAgICBlbHNlIGlmIChvcHRpb25zLnNob3cpIGRhdGEuc2hvdyhfcmVsYXRlZFRhcmdldClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4ubW9kYWxcblxuICAkLmZuLm1vZGFsICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4ubW9kYWwuQ29uc3RydWN0b3IgPSBNb2RhbFxuXG5cbiAgLy8gTU9EQUwgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT1cblxuICAkLmZuLm1vZGFsLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5tb2RhbCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIE1PREFMIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudCkub24oJ2NsaWNrLmJzLm1vZGFsLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cIm1vZGFsXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICB2YXIgaHJlZiAgICA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgIHZhciAkdGFyZ2V0ID0gJCgkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpIHx8IChocmVmICYmIGhyZWYucmVwbGFjZSgvLiooPz0jW15cXHNdKyQpLywgJycpKSkgLy8gc3RyaXAgZm9yIGllN1xuICAgIHZhciBvcHRpb24gID0gJHRhcmdldC5kYXRhKCdicy5tb2RhbCcpID8gJ3RvZ2dsZScgOiAkLmV4dGVuZCh7IHJlbW90ZTogIS8jLy50ZXN0KGhyZWYpICYmIGhyZWYgfSwgJHRhcmdldC5kYXRhKCksICR0aGlzLmRhdGEoKSlcblxuICAgIGlmICgkdGhpcy5pcygnYScpKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgICR0YXJnZXQub25lKCdzaG93LmJzLm1vZGFsJywgZnVuY3Rpb24gKHNob3dFdmVudCkge1xuICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cbiAgICAgICR0YXJnZXQub25lKCdoaWRkZW4uYnMubW9kYWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICR0aGlzLmlzKCc6dmlzaWJsZScpICYmICR0aGlzLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgIH0pXG4gICAgfSlcbiAgICBQbHVnaW4uY2FsbCgkdGFyZ2V0LCBvcHRpb24sIHRoaXMpXG4gIH0pXG5cbn0oalF1ZXJ5KTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHRvb2x0aXAuanMgdjMuMy43XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyN0b29sdGlwXG4gKiBJbnNwaXJlZCBieSB0aGUgb3JpZ2luYWwgalF1ZXJ5LnRpcHN5IGJ5IEphc29uIEZyYW1lXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTYgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVE9PTFRJUCBQVUJMSUMgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIFRvb2x0aXAgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSAgICAgICA9IG51bGxcbiAgICB0aGlzLm9wdGlvbnMgICAgPSBudWxsXG4gICAgdGhpcy5lbmFibGVkICAgID0gbnVsbFxuICAgIHRoaXMudGltZW91dCAgICA9IG51bGxcbiAgICB0aGlzLmhvdmVyU3RhdGUgPSBudWxsXG4gICAgdGhpcy4kZWxlbWVudCAgID0gbnVsbFxuICAgIHRoaXMuaW5TdGF0ZSAgICA9IG51bGxcblxuICAgIHRoaXMuaW5pdCgndG9vbHRpcCcsIGVsZW1lbnQsIG9wdGlvbnMpXG4gIH1cblxuICBUb29sdGlwLlZFUlNJT04gID0gJzMuMy43J1xuXG4gIFRvb2x0aXAuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIFRvb2x0aXAuREVGQVVMVFMgPSB7XG4gICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgc2VsZWN0b3I6IGZhbHNlLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLFxuICAgIHRyaWdnZXI6ICdob3ZlciBmb2N1cycsXG4gICAgdGl0bGU6ICcnLFxuICAgIGRlbGF5OiAwLFxuICAgIGh0bWw6IGZhbHNlLFxuICAgIGNvbnRhaW5lcjogZmFsc2UsXG4gICAgdmlld3BvcnQ6IHtcbiAgICAgIHNlbGVjdG9yOiAnYm9keScsXG4gICAgICBwYWRkaW5nOiAwXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh0eXBlLCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5lbmFibGVkICAgPSB0cnVlXG4gICAgdGhpcy50eXBlICAgICAgPSB0eXBlXG4gICAgdGhpcy4kZWxlbWVudCAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgPSB0aGlzLmdldE9wdGlvbnMob3B0aW9ucylcbiAgICB0aGlzLiR2aWV3cG9ydCA9IHRoaXMub3B0aW9ucy52aWV3cG9ydCAmJiAkKCQuaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMudmlld3BvcnQpID8gdGhpcy5vcHRpb25zLnZpZXdwb3J0LmNhbGwodGhpcywgdGhpcy4kZWxlbWVudCkgOiAodGhpcy5vcHRpb25zLnZpZXdwb3J0LnNlbGVjdG9yIHx8IHRoaXMub3B0aW9ucy52aWV3cG9ydCkpXG4gICAgdGhpcy5pblN0YXRlICAgPSB7IGNsaWNrOiBmYWxzZSwgaG92ZXI6IGZhbHNlLCBmb2N1czogZmFsc2UgfVxuXG4gICAgaWYgKHRoaXMuJGVsZW1lbnRbMF0gaW5zdGFuY2VvZiBkb2N1bWVudC5jb25zdHJ1Y3RvciAmJiAhdGhpcy5vcHRpb25zLnNlbGVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BzZWxlY3RvcmAgb3B0aW9uIG11c3QgYmUgc3BlY2lmaWVkIHdoZW4gaW5pdGlhbGl6aW5nICcgKyB0aGlzLnR5cGUgKyAnIG9uIHRoZSB3aW5kb3cuZG9jdW1lbnQgb2JqZWN0IScpXG4gICAgfVxuXG4gICAgdmFyIHRyaWdnZXJzID0gdGhpcy5vcHRpb25zLnRyaWdnZXIuc3BsaXQoJyAnKVxuXG4gICAgZm9yICh2YXIgaSA9IHRyaWdnZXJzLmxlbmd0aDsgaS0tOykge1xuICAgICAgdmFyIHRyaWdnZXIgPSB0cmlnZ2Vyc1tpXVxuXG4gICAgICBpZiAodHJpZ2dlciA9PSAnY2xpY2snKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLicgKyB0aGlzLnR5cGUsIHRoaXMub3B0aW9ucy5zZWxlY3RvciwgJC5wcm94eSh0aGlzLnRvZ2dsZSwgdGhpcykpXG4gICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgIT0gJ21hbnVhbCcpIHtcbiAgICAgICAgdmFyIGV2ZW50SW4gID0gdHJpZ2dlciA9PSAnaG92ZXInID8gJ21vdXNlZW50ZXInIDogJ2ZvY3VzaW4nXG4gICAgICAgIHZhciBldmVudE91dCA9IHRyaWdnZXIgPT0gJ2hvdmVyJyA/ICdtb3VzZWxlYXZlJyA6ICdmb2N1c291dCdcblxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKGV2ZW50SW4gICsgJy4nICsgdGhpcy50eXBlLCB0aGlzLm9wdGlvbnMuc2VsZWN0b3IsICQucHJveHkodGhpcy5lbnRlciwgdGhpcykpXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oZXZlbnRPdXQgKyAnLicgKyB0aGlzLnR5cGUsIHRoaXMub3B0aW9ucy5zZWxlY3RvciwgJC5wcm94eSh0aGlzLmxlYXZlLCB0aGlzKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMuc2VsZWN0b3IgP1xuICAgICAgKHRoaXMuX29wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB7IHRyaWdnZXI6ICdtYW51YWwnLCBzZWxlY3RvcjogJycgfSkpIDpcbiAgICAgIHRoaXMuZml4VGl0bGUoKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0RGVmYXVsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRvb2x0aXAuREVGQVVMVFNcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5nZXREZWZhdWx0cygpLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucylcblxuICAgIGlmIChvcHRpb25zLmRlbGF5ICYmIHR5cGVvZiBvcHRpb25zLmRlbGF5ID09ICdudW1iZXInKSB7XG4gICAgICBvcHRpb25zLmRlbGF5ID0ge1xuICAgICAgICBzaG93OiBvcHRpb25zLmRlbGF5LFxuICAgICAgICBoaWRlOiBvcHRpb25zLmRlbGF5XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldERlbGVnYXRlT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyAgPSB7fVxuICAgIHZhciBkZWZhdWx0cyA9IHRoaXMuZ2V0RGVmYXVsdHMoKVxuXG4gICAgdGhpcy5fb3B0aW9ucyAmJiAkLmVhY2godGhpcy5fb3B0aW9ucywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChkZWZhdWx0c1trZXldICE9IHZhbHVlKSBvcHRpb25zW2tleV0gPSB2YWx1ZVxuICAgIH0pXG5cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHNlbGYgPSBvYmogaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yID9cbiAgICAgIG9iaiA6ICQob2JqLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUpXG5cbiAgICBpZiAoIXNlbGYpIHtcbiAgICAgIHNlbGYgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihvYmouY3VycmVudFRhcmdldCwgdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSlcbiAgICAgICQob2JqLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUsIHNlbGYpXG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mICQuRXZlbnQpIHtcbiAgICAgIHNlbGYuaW5TdGF0ZVtvYmoudHlwZSA9PSAnZm9jdXNpbicgPyAnZm9jdXMnIDogJ2hvdmVyJ10gPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHNlbGYudGlwKCkuaGFzQ2xhc3MoJ2luJykgfHwgc2VsZi5ob3ZlclN0YXRlID09ICdpbicpIHtcbiAgICAgIHNlbGYuaG92ZXJTdGF0ZSA9ICdpbidcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNsZWFyVGltZW91dChzZWxmLnRpbWVvdXQpXG5cbiAgICBzZWxmLmhvdmVyU3RhdGUgPSAnaW4nXG5cbiAgICBpZiAoIXNlbGYub3B0aW9ucy5kZWxheSB8fCAhc2VsZi5vcHRpb25zLmRlbGF5LnNob3cpIHJldHVybiBzZWxmLnNob3coKVxuXG4gICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5ob3ZlclN0YXRlID09ICdpbicpIHNlbGYuc2hvdygpXG4gICAgfSwgc2VsZi5vcHRpb25zLmRlbGF5LnNob3cpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5pc0luU3RhdGVUcnVlID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmluU3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLmluU3RhdGVba2V5XSkgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBzZWxmID0gb2JqIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvciA/XG4gICAgICBvYmogOiAkKG9iai5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlKVxuXG4gICAgaWYgKCFzZWxmKSB7XG4gICAgICBzZWxmID0gbmV3IHRoaXMuY29uc3RydWN0b3Iob2JqLmN1cnJlbnRUYXJnZXQsIHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpXG4gICAgICAkKG9iai5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlLCBzZWxmKVxuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiAkLkV2ZW50KSB7XG4gICAgICBzZWxmLmluU3RhdGVbb2JqLnR5cGUgPT0gJ2ZvY3Vzb3V0JyA/ICdmb2N1cycgOiAnaG92ZXInXSA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHNlbGYuaXNJblN0YXRlVHJ1ZSgpKSByZXR1cm5cblxuICAgIGNsZWFyVGltZW91dChzZWxmLnRpbWVvdXQpXG5cbiAgICBzZWxmLmhvdmVyU3RhdGUgPSAnb3V0J1xuXG4gICAgaWYgKCFzZWxmLm9wdGlvbnMuZGVsYXkgfHwgIXNlbGYub3B0aW9ucy5kZWxheS5oaWRlKSByZXR1cm4gc2VsZi5oaWRlKClcblxuICAgIHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaG92ZXJTdGF0ZSA9PSAnb3V0Jykgc2VsZi5oaWRlKClcbiAgICB9LCBzZWxmLm9wdGlvbnMuZGVsYXkuaGlkZSlcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUgPSAkLkV2ZW50KCdzaG93LmJzLicgKyB0aGlzLnR5cGUpXG5cbiAgICBpZiAodGhpcy5oYXNDb250ZW50KCkgJiYgdGhpcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgICAgdmFyIGluRG9tID0gJC5jb250YWlucyh0aGlzLiRlbGVtZW50WzBdLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLiRlbGVtZW50WzBdKVxuICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgIWluRG9tKSByZXR1cm5cbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuXG4gICAgICB2YXIgJHRpcCA9IHRoaXMudGlwKClcblxuICAgICAgdmFyIHRpcElkID0gdGhpcy5nZXRVSUQodGhpcy50eXBlKVxuXG4gICAgICB0aGlzLnNldENvbnRlbnQoKVxuICAgICAgJHRpcC5hdHRyKCdpZCcsIHRpcElkKVxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGlwSWQpXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSAkdGlwLmFkZENsYXNzKCdmYWRlJylcblxuICAgICAgdmFyIHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID09ICdmdW5jdGlvbicgP1xuICAgICAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50LmNhbGwodGhpcywgJHRpcFswXSwgdGhpcy4kZWxlbWVudFswXSkgOlxuICAgICAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50XG5cbiAgICAgIHZhciBhdXRvVG9rZW4gPSAvXFxzP2F1dG8/XFxzPy9pXG4gICAgICB2YXIgYXV0b1BsYWNlID0gYXV0b1Rva2VuLnRlc3QocGxhY2VtZW50KVxuICAgICAgaWYgKGF1dG9QbGFjZSkgcGxhY2VtZW50ID0gcGxhY2VtZW50LnJlcGxhY2UoYXV0b1Rva2VuLCAnJykgfHwgJ3RvcCdcblxuICAgICAgJHRpcFxuICAgICAgICAuZGV0YWNoKClcbiAgICAgICAgLmNzcyh7IHRvcDogMCwgbGVmdDogMCwgZGlzcGxheTogJ2Jsb2NrJyB9KVxuICAgICAgICAuYWRkQ2xhc3MocGxhY2VtZW50KVxuICAgICAgICAuZGF0YSgnYnMuJyArIHRoaXMudHlwZSwgdGhpcylcblxuICAgICAgdGhpcy5vcHRpb25zLmNvbnRhaW5lciA/ICR0aXAuYXBwZW5kVG8odGhpcy5vcHRpb25zLmNvbnRhaW5lcikgOiAkdGlwLmluc2VydEFmdGVyKHRoaXMuJGVsZW1lbnQpXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2luc2VydGVkLmJzLicgKyB0aGlzLnR5cGUpXG5cbiAgICAgIHZhciBwb3MgICAgICAgICAgPSB0aGlzLmdldFBvc2l0aW9uKClcbiAgICAgIHZhciBhY3R1YWxXaWR0aCAgPSAkdGlwWzBdLm9mZnNldFdpZHRoXG4gICAgICB2YXIgYWN0dWFsSGVpZ2h0ID0gJHRpcFswXS5vZmZzZXRIZWlnaHRcblxuICAgICAgaWYgKGF1dG9QbGFjZSkge1xuICAgICAgICB2YXIgb3JnUGxhY2VtZW50ID0gcGxhY2VtZW50XG4gICAgICAgIHZhciB2aWV3cG9ydERpbSA9IHRoaXMuZ2V0UG9zaXRpb24odGhpcy4kdmlld3BvcnQpXG5cbiAgICAgICAgcGxhY2VtZW50ID0gcGxhY2VtZW50ID09ICdib3R0b20nICYmIHBvcy5ib3R0b20gKyBhY3R1YWxIZWlnaHQgPiB2aWV3cG9ydERpbS5ib3R0b20gPyAndG9wJyAgICA6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PSAndG9wJyAgICAmJiBwb3MudG9wICAgIC0gYWN0dWFsSGVpZ2h0IDwgdmlld3BvcnREaW0udG9wICAgID8gJ2JvdHRvbScgOlxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ3JpZ2h0JyAgJiYgcG9zLnJpZ2h0ICArIGFjdHVhbFdpZHRoICA+IHZpZXdwb3J0RGltLndpZHRoICA/ICdsZWZ0JyAgIDpcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09ICdsZWZ0JyAgICYmIHBvcy5sZWZ0ICAgLSBhY3R1YWxXaWR0aCAgPCB2aWV3cG9ydERpbS5sZWZ0ICAgPyAncmlnaHQnICA6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudFxuXG4gICAgICAgICR0aXBcbiAgICAgICAgICAucmVtb3ZlQ2xhc3Mob3JnUGxhY2VtZW50KVxuICAgICAgICAgIC5hZGRDbGFzcyhwbGFjZW1lbnQpXG4gICAgICB9XG5cbiAgICAgIHZhciBjYWxjdWxhdGVkT2Zmc2V0ID0gdGhpcy5nZXRDYWxjdWxhdGVkT2Zmc2V0KHBsYWNlbWVudCwgcG9zLCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KVxuXG4gICAgICB0aGlzLmFwcGx5UGxhY2VtZW50KGNhbGN1bGF0ZWRPZmZzZXQsIHBsYWNlbWVudClcblxuICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJldkhvdmVyU3RhdGUgPSB0aGF0LmhvdmVyU3RhdGVcbiAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdzaG93bi5icy4nICsgdGhhdC50eXBlKVxuICAgICAgICB0aGF0LmhvdmVyU3RhdGUgPSBudWxsXG5cbiAgICAgICAgaWYgKHByZXZIb3ZlclN0YXRlID09ICdvdXQnKSB0aGF0LmxlYXZlKHRoYXQpXG4gICAgICB9XG5cbiAgICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJHRpcC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICAgJHRpcFxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNvbXBsZXRlKVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChUb29sdGlwLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY29tcGxldGUoKVxuICAgIH1cbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmFwcGx5UGxhY2VtZW50ID0gZnVuY3Rpb24gKG9mZnNldCwgcGxhY2VtZW50KSB7XG4gICAgdmFyICR0aXAgICA9IHRoaXMudGlwKClcbiAgICB2YXIgd2lkdGggID0gJHRpcFswXS5vZmZzZXRXaWR0aFxuICAgIHZhciBoZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodFxuXG4gICAgLy8gbWFudWFsbHkgcmVhZCBtYXJnaW5zIGJlY2F1c2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGluY2x1ZGVzIGRpZmZlcmVuY2VcbiAgICB2YXIgbWFyZ2luVG9wID0gcGFyc2VJbnQoJHRpcC5jc3MoJ21hcmdpbi10b3AnKSwgMTApXG4gICAgdmFyIG1hcmdpbkxlZnQgPSBwYXJzZUludCgkdGlwLmNzcygnbWFyZ2luLWxlZnQnKSwgMTApXG5cbiAgICAvLyB3ZSBtdXN0IGNoZWNrIGZvciBOYU4gZm9yIGllIDgvOVxuICAgIGlmIChpc05hTihtYXJnaW5Ub3ApKSAgbWFyZ2luVG9wICA9IDBcbiAgICBpZiAoaXNOYU4obWFyZ2luTGVmdCkpIG1hcmdpbkxlZnQgPSAwXG5cbiAgICBvZmZzZXQudG9wICArPSBtYXJnaW5Ub3BcbiAgICBvZmZzZXQubGVmdCArPSBtYXJnaW5MZWZ0XG5cbiAgICAvLyAkLmZuLm9mZnNldCBkb2Vzbid0IHJvdW5kIHBpeGVsIHZhbHVlc1xuICAgIC8vIHNvIHdlIHVzZSBzZXRPZmZzZXQgZGlyZWN0bHkgd2l0aCBvdXIgb3duIGZ1bmN0aW9uIEItMFxuICAgICQub2Zmc2V0LnNldE9mZnNldCgkdGlwWzBdLCAkLmV4dGVuZCh7XG4gICAgICB1c2luZzogZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICR0aXAuY3NzKHtcbiAgICAgICAgICB0b3A6IE1hdGgucm91bmQocHJvcHMudG9wKSxcbiAgICAgICAgICBsZWZ0OiBNYXRoLnJvdW5kKHByb3BzLmxlZnQpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSwgb2Zmc2V0KSwgMClcblxuICAgICR0aXAuYWRkQ2xhc3MoJ2luJylcblxuICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBwbGFjaW5nIHRpcCBpbiBuZXcgb2Zmc2V0IGNhdXNlZCB0aGUgdGlwIHRvIHJlc2l6ZSBpdHNlbGZcbiAgICB2YXIgYWN0dWFsV2lkdGggID0gJHRpcFswXS5vZmZzZXRXaWR0aFxuICAgIHZhciBhY3R1YWxIZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodFxuXG4gICAgaWYgKHBsYWNlbWVudCA9PSAndG9wJyAmJiBhY3R1YWxIZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICBvZmZzZXQudG9wID0gb2Zmc2V0LnRvcCArIGhlaWdodCAtIGFjdHVhbEhlaWdodFxuICAgIH1cblxuICAgIHZhciBkZWx0YSA9IHRoaXMuZ2V0Vmlld3BvcnRBZGp1c3RlZERlbHRhKHBsYWNlbWVudCwgb2Zmc2V0LCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KVxuXG4gICAgaWYgKGRlbHRhLmxlZnQpIG9mZnNldC5sZWZ0ICs9IGRlbHRhLmxlZnRcbiAgICBlbHNlIG9mZnNldC50b3AgKz0gZGVsdGEudG9wXG5cbiAgICB2YXIgaXNWZXJ0aWNhbCAgICAgICAgICA9IC90b3B8Ym90dG9tLy50ZXN0KHBsYWNlbWVudClcbiAgICB2YXIgYXJyb3dEZWx0YSAgICAgICAgICA9IGlzVmVydGljYWwgPyBkZWx0YS5sZWZ0ICogMiAtIHdpZHRoICsgYWN0dWFsV2lkdGggOiBkZWx0YS50b3AgKiAyIC0gaGVpZ2h0ICsgYWN0dWFsSGVpZ2h0XG4gICAgdmFyIGFycm93T2Zmc2V0UG9zaXRpb24gPSBpc1ZlcnRpY2FsID8gJ29mZnNldFdpZHRoJyA6ICdvZmZzZXRIZWlnaHQnXG5cbiAgICAkdGlwLm9mZnNldChvZmZzZXQpXG4gICAgdGhpcy5yZXBsYWNlQXJyb3coYXJyb3dEZWx0YSwgJHRpcFswXVthcnJvd09mZnNldFBvc2l0aW9uXSwgaXNWZXJ0aWNhbClcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnJlcGxhY2VBcnJvdyA9IGZ1bmN0aW9uIChkZWx0YSwgZGltZW5zaW9uLCBpc1ZlcnRpY2FsKSB7XG4gICAgdGhpcy5hcnJvdygpXG4gICAgICAuY3NzKGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJywgNTAgKiAoMSAtIGRlbHRhIC8gZGltZW5zaW9uKSArICclJylcbiAgICAgIC5jc3MoaXNWZXJ0aWNhbCA/ICd0b3AnIDogJ2xlZnQnLCAnJylcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICR0aXAgID0gdGhpcy50aXAoKVxuICAgIHZhciB0aXRsZSA9IHRoaXMuZ2V0VGl0bGUoKVxuXG4gICAgJHRpcC5maW5kKCcudG9vbHRpcC1pbm5lcicpW3RoaXMub3B0aW9ucy5odG1sID8gJ2h0bWwnIDogJ3RleHQnXSh0aXRsZSlcbiAgICAkdGlwLnJlbW92ZUNsYXNzKCdmYWRlIGluIHRvcCBib3R0b20gbGVmdCByaWdodCcpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdmFyICR0aXAgPSAkKHRoaXMuJHRpcClcbiAgICB2YXIgZSAgICA9ICQuRXZlbnQoJ2hpZGUuYnMuJyArIHRoaXMudHlwZSlcblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgaWYgKHRoYXQuaG92ZXJTdGF0ZSAhPSAnaW4nKSAkdGlwLmRldGFjaCgpXG4gICAgICBpZiAodGhhdC4kZWxlbWVudCkgeyAvLyBUT0RPOiBDaGVjayB3aGV0aGVyIGd1YXJkaW5nIHRoaXMgY29kZSB3aXRoIHRoaXMgYGlmYCBpcyByZWFsbHkgbmVjZXNzYXJ5LlxuICAgICAgICB0aGF0LiRlbGVtZW50XG4gICAgICAgICAgLnJlbW92ZUF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknKVxuICAgICAgICAgIC50cmlnZ2VyKCdoaWRkZW4uYnMuJyArIHRoYXQudHlwZSlcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICR0aXAucmVtb3ZlQ2xhc3MoJ2luJylcblxuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmICR0aXAuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAkdGlwXG4gICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNvbXBsZXRlKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoVG9vbHRpcC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICBjb21wbGV0ZSgpXG5cbiAgICB0aGlzLmhvdmVyU3RhdGUgPSBudWxsXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZml4VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIGlmICgkZS5hdHRyKCd0aXRsZScpIHx8IHR5cGVvZiAkZS5hdHRyKCdkYXRhLW9yaWdpbmFsLXRpdGxlJykgIT0gJ3N0cmluZycpIHtcbiAgICAgICRlLmF0dHIoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnLCAkZS5hdHRyKCd0aXRsZScpIHx8ICcnKS5hdHRyKCd0aXRsZScsICcnKVxuICAgIH1cbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmhhc0NvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoJGVsZW1lbnQpIHtcbiAgICAkZWxlbWVudCAgID0gJGVsZW1lbnQgfHwgdGhpcy4kZWxlbWVudFxuXG4gICAgdmFyIGVsICAgICA9ICRlbGVtZW50WzBdXG4gICAgdmFyIGlzQm9keSA9IGVsLnRhZ05hbWUgPT0gJ0JPRFknXG5cbiAgICB2YXIgZWxSZWN0ICAgID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBpZiAoZWxSZWN0LndpZHRoID09IG51bGwpIHtcbiAgICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgYXJlIG1pc3NpbmcgaW4gSUU4LCBzbyBjb21wdXRlIHRoZW0gbWFudWFsbHk7IHNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvaXNzdWVzLzE0MDkzXG4gICAgICBlbFJlY3QgPSAkLmV4dGVuZCh7fSwgZWxSZWN0LCB7IHdpZHRoOiBlbFJlY3QucmlnaHQgLSBlbFJlY3QubGVmdCwgaGVpZ2h0OiBlbFJlY3QuYm90dG9tIC0gZWxSZWN0LnRvcCB9KVxuICAgIH1cbiAgICB2YXIgaXNTdmcgPSB3aW5kb3cuU1ZHRWxlbWVudCAmJiBlbCBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50XG4gICAgLy8gQXZvaWQgdXNpbmcgJC5vZmZzZXQoKSBvbiBTVkdzIHNpbmNlIGl0IGdpdmVzIGluY29ycmVjdCByZXN1bHRzIGluIGpRdWVyeSAzLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvaXNzdWVzLzIwMjgwXG4gICAgdmFyIGVsT2Zmc2V0ICA9IGlzQm9keSA/IHsgdG9wOiAwLCBsZWZ0OiAwIH0gOiAoaXNTdmcgPyBudWxsIDogJGVsZW1lbnQub2Zmc2V0KCkpXG4gICAgdmFyIHNjcm9sbCAgICA9IHsgc2Nyb2xsOiBpc0JvZHkgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIDogJGVsZW1lbnQuc2Nyb2xsVG9wKCkgfVxuICAgIHZhciBvdXRlckRpbXMgPSBpc0JvZHkgPyB7IHdpZHRoOiAkKHdpbmRvdykud2lkdGgoKSwgaGVpZ2h0OiAkKHdpbmRvdykuaGVpZ2h0KCkgfSA6IG51bGxcblxuICAgIHJldHVybiAkLmV4dGVuZCh7fSwgZWxSZWN0LCBzY3JvbGwsIG91dGVyRGltcywgZWxPZmZzZXQpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRDYWxjdWxhdGVkT2Zmc2V0ID0gZnVuY3Rpb24gKHBsYWNlbWVudCwgcG9zLCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudCA9PSAnYm90dG9tJyA/IHsgdG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCwgICBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCAvIDIgLSBhY3R1YWxXaWR0aCAvIDIgfSA6XG4gICAgICAgICAgIHBsYWNlbWVudCA9PSAndG9wJyAgICA/IHsgdG9wOiBwb3MudG9wIC0gYWN0dWFsSGVpZ2h0LCBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCAvIDIgLSBhY3R1YWxXaWR0aCAvIDIgfSA6XG4gICAgICAgICAgIHBsYWNlbWVudCA9PSAnbGVmdCcgICA/IHsgdG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCAvIDIgLSBhY3R1YWxIZWlnaHQgLyAyLCBsZWZ0OiBwb3MubGVmdCAtIGFjdHVhbFdpZHRoIH0gOlxuICAgICAgICAvKiBwbGFjZW1lbnQgPT0gJ3JpZ2h0JyAqLyB7IHRvcDogcG9zLnRvcCArIHBvcy5oZWlnaHQgLyAyIC0gYWN0dWFsSGVpZ2h0IC8gMiwgbGVmdDogcG9zLmxlZnQgKyBwb3Mud2lkdGggfVxuXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRWaWV3cG9ydEFkanVzdGVkRGVsdGEgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpIHtcbiAgICB2YXIgZGVsdGEgPSB7IHRvcDogMCwgbGVmdDogMCB9XG4gICAgaWYgKCF0aGlzLiR2aWV3cG9ydCkgcmV0dXJuIGRlbHRhXG5cbiAgICB2YXIgdmlld3BvcnRQYWRkaW5nID0gdGhpcy5vcHRpb25zLnZpZXdwb3J0ICYmIHRoaXMub3B0aW9ucy52aWV3cG9ydC5wYWRkaW5nIHx8IDBcbiAgICB2YXIgdmlld3BvcnREaW1lbnNpb25zID0gdGhpcy5nZXRQb3NpdGlvbih0aGlzLiR2aWV3cG9ydClcblxuICAgIGlmICgvcmlnaHR8bGVmdC8udGVzdChwbGFjZW1lbnQpKSB7XG4gICAgICB2YXIgdG9wRWRnZU9mZnNldCAgICA9IHBvcy50b3AgLSB2aWV3cG9ydFBhZGRpbmcgLSB2aWV3cG9ydERpbWVuc2lvbnMuc2Nyb2xsXG4gICAgICB2YXIgYm90dG9tRWRnZU9mZnNldCA9IHBvcy50b3AgKyB2aWV3cG9ydFBhZGRpbmcgLSB2aWV3cG9ydERpbWVuc2lvbnMuc2Nyb2xsICsgYWN0dWFsSGVpZ2h0XG4gICAgICBpZiAodG9wRWRnZU9mZnNldCA8IHZpZXdwb3J0RGltZW5zaW9ucy50b3ApIHsgLy8gdG9wIG92ZXJmbG93XG4gICAgICAgIGRlbHRhLnRvcCA9IHZpZXdwb3J0RGltZW5zaW9ucy50b3AgLSB0b3BFZGdlT2Zmc2V0XG4gICAgICB9IGVsc2UgaWYgKGJvdHRvbUVkZ2VPZmZzZXQgPiB2aWV3cG9ydERpbWVuc2lvbnMudG9wICsgdmlld3BvcnREaW1lbnNpb25zLmhlaWdodCkgeyAvLyBib3R0b20gb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEudG9wID0gdmlld3BvcnREaW1lbnNpb25zLnRvcCArIHZpZXdwb3J0RGltZW5zaW9ucy5oZWlnaHQgLSBib3R0b21FZGdlT2Zmc2V0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZWZ0RWRnZU9mZnNldCAgPSBwb3MubGVmdCAtIHZpZXdwb3J0UGFkZGluZ1xuICAgICAgdmFyIHJpZ2h0RWRnZU9mZnNldCA9IHBvcy5sZWZ0ICsgdmlld3BvcnRQYWRkaW5nICsgYWN0dWFsV2lkdGhcbiAgICAgIGlmIChsZWZ0RWRnZU9mZnNldCA8IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0KSB7IC8vIGxlZnQgb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEubGVmdCA9IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0IC0gbGVmdEVkZ2VPZmZzZXRcbiAgICAgIH0gZWxzZSBpZiAocmlnaHRFZGdlT2Zmc2V0ID4gdmlld3BvcnREaW1lbnNpb25zLnJpZ2h0KSB7IC8vIHJpZ2h0IG92ZXJmbG93XG4gICAgICAgIGRlbHRhLmxlZnQgPSB2aWV3cG9ydERpbWVuc2lvbnMubGVmdCArIHZpZXdwb3J0RGltZW5zaW9ucy53aWR0aCAtIHJpZ2h0RWRnZU9mZnNldFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWx0YVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRpdGxlXG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIHZhciBvICA9IHRoaXMub3B0aW9uc1xuXG4gICAgdGl0bGUgPSAkZS5hdHRyKCdkYXRhLW9yaWdpbmFsLXRpdGxlJylcbiAgICAgIHx8ICh0eXBlb2Ygby50aXRsZSA9PSAnZnVuY3Rpb24nID8gby50aXRsZS5jYWxsKCRlWzBdKSA6ICBvLnRpdGxlKVxuXG4gICAgcmV0dXJuIHRpdGxlXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRVSUQgPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgZG8gcHJlZml4ICs9IH5+KE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKVxuICAgIHdoaWxlIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwcmVmaXgpKVxuICAgIHJldHVybiBwcmVmaXhcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuJHRpcCkge1xuICAgICAgdGhpcy4kdGlwID0gJCh0aGlzLm9wdGlvbnMudGVtcGxhdGUpXG4gICAgICBpZiAodGhpcy4kdGlwLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLnR5cGUgKyAnIGB0ZW1wbGF0ZWAgb3B0aW9uIG11c3QgY29uc2lzdCBvZiBleGFjdGx5IDEgdG9wLWxldmVsIGVsZW1lbnQhJylcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJHRpcFxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuYXJyb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLiRhcnJvdyA9IHRoaXMuJGFycm93IHx8IHRoaXMudGlwKCkuZmluZCgnLnRvb2x0aXAtYXJyb3cnKSlcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS50b2dnbGVFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9ICF0aGlzLmVuYWJsZWRcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgaWYgKGUpIHtcbiAgICAgIHNlbGYgPSAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSlcbiAgICAgIGlmICghc2VsZikge1xuICAgICAgICBzZWxmID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZS5jdXJyZW50VGFyZ2V0LCB0aGlzLmdldERlbGVnYXRlT3B0aW9ucygpKVxuICAgICAgICAkKGUuY3VycmVudFRhcmdldCkuZGF0YSgnYnMuJyArIHRoaXMudHlwZSwgc2VsZilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZSkge1xuICAgICAgc2VsZi5pblN0YXRlLmNsaWNrID0gIXNlbGYuaW5TdGF0ZS5jbGlja1xuICAgICAgaWYgKHNlbGYuaXNJblN0YXRlVHJ1ZSgpKSBzZWxmLmVudGVyKHNlbGYpXG4gICAgICBlbHNlIHNlbGYubGVhdmUoc2VsZilcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi50aXAoKS5oYXNDbGFzcygnaW4nKSA/IHNlbGYubGVhdmUoc2VsZikgOiBzZWxmLmVudGVyKHNlbGYpXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KVxuICAgIHRoaXMuaGlkZShmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LiRlbGVtZW50Lm9mZignLicgKyB0aGF0LnR5cGUpLnJlbW92ZURhdGEoJ2JzLicgKyB0aGF0LnR5cGUpXG4gICAgICBpZiAodGhhdC4kdGlwKSB7XG4gICAgICAgIHRoYXQuJHRpcC5kZXRhY2goKVxuICAgICAgfVxuICAgICAgdGhhdC4kdGlwID0gbnVsbFxuICAgICAgdGhhdC4kYXJyb3cgPSBudWxsXG4gICAgICB0aGF0LiR2aWV3cG9ydCA9IG51bGxcbiAgICAgIHRoYXQuJGVsZW1lbnQgPSBudWxsXG4gICAgfSlcbiAgfVxuXG5cbiAgLy8gVE9PTFRJUCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLnRvb2x0aXAnKVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgICBpZiAoIWRhdGEgJiYgL2Rlc3Ryb3l8aGlkZS8udGVzdChvcHRpb24pKSByZXR1cm5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMudG9vbHRpcCcsIChkYXRhID0gbmV3IFRvb2x0aXAodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLnRvb2x0aXBcblxuICAkLmZuLnRvb2x0aXAgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi50b29sdGlwLkNvbnN0cnVjdG9yID0gVG9vbHRpcFxuXG5cbiAgLy8gVE9PTFRJUCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi50b29sdGlwLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi50b29sdGlwID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBwb3BvdmVyLmpzIHYzLjMuN1xuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jcG9wb3ZlcnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNiBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBQT1BPVkVSIFBVQkxJQyBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgUG9wb3ZlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5pbml0KCdwb3BvdmVyJywgZWxlbWVudCwgb3B0aW9ucylcbiAgfVxuXG4gIGlmICghJC5mbi50b29sdGlwKSB0aHJvdyBuZXcgRXJyb3IoJ1BvcG92ZXIgcmVxdWlyZXMgdG9vbHRpcC5qcycpXG5cbiAgUG9wb3Zlci5WRVJTSU9OICA9ICczLjMuNydcblxuICBQb3BvdmVyLkRFRkFVTFRTID0gJC5leHRlbmQoe30sICQuZm4udG9vbHRpcC5Db25zdHJ1Y3Rvci5ERUZBVUxUUywge1xuICAgIHBsYWNlbWVudDogJ3JpZ2h0JyxcbiAgICB0cmlnZ2VyOiAnY2xpY2snLFxuICAgIGNvbnRlbnQ6ICcnLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInBvcG92ZXJcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PjxoMyBjbGFzcz1cInBvcG92ZXItdGl0bGVcIj48L2gzPjxkaXYgY2xhc3M9XCJwb3BvdmVyLWNvbnRlbnRcIj48L2Rpdj48L2Rpdj4nXG4gIH0pXG5cblxuICAvLyBOT1RFOiBQT1BPVkVSIEVYVEVORFMgdG9vbHRpcC5qc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIFBvcG92ZXIucHJvdG90eXBlID0gJC5leHRlbmQoe30sICQuZm4udG9vbHRpcC5Db25zdHJ1Y3Rvci5wcm90b3R5cGUpXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb3BvdmVyXG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuZ2V0RGVmYXVsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFBvcG92ZXIuREVGQVVMVFNcbiAgfVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICR0aXAgICAgPSB0aGlzLnRpcCgpXG4gICAgdmFyIHRpdGxlICAgPSB0aGlzLmdldFRpdGxlKClcbiAgICB2YXIgY29udGVudCA9IHRoaXMuZ2V0Q29udGVudCgpXG5cbiAgICAkdGlwLmZpbmQoJy5wb3BvdmVyLXRpdGxlJylbdGhpcy5vcHRpb25zLmh0bWwgPyAnaHRtbCcgOiAndGV4dCddKHRpdGxlKVxuICAgICR0aXAuZmluZCgnLnBvcG92ZXItY29udGVudCcpLmNoaWxkcmVuKCkuZGV0YWNoKCkuZW5kKClbIC8vIHdlIHVzZSBhcHBlbmQgZm9yIGh0bWwgb2JqZWN0cyB0byBtYWludGFpbiBqcyBldmVudHNcbiAgICAgIHRoaXMub3B0aW9ucy5odG1sID8gKHR5cGVvZiBjb250ZW50ID09ICdzdHJpbmcnID8gJ2h0bWwnIDogJ2FwcGVuZCcpIDogJ3RleHQnXG4gICAgXShjb250ZW50KVxuXG4gICAgJHRpcC5yZW1vdmVDbGFzcygnZmFkZSB0b3AgYm90dG9tIGxlZnQgcmlnaHQgaW4nKVxuXG4gICAgLy8gSUU4IGRvZXNuJ3QgYWNjZXB0IGhpZGluZyB2aWEgdGhlIGA6ZW1wdHlgIHBzZXVkbyBzZWxlY3Rvciwgd2UgaGF2ZSB0byBkb1xuICAgIC8vIHRoaXMgbWFudWFsbHkgYnkgY2hlY2tpbmcgdGhlIGNvbnRlbnRzLlxuICAgIGlmICghJHRpcC5maW5kKCcucG9wb3Zlci10aXRsZScpLmh0bWwoKSkgJHRpcC5maW5kKCcucG9wb3Zlci10aXRsZScpLmhpZGUoKVxuICB9XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuaGFzQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpIHx8IHRoaXMuZ2V0Q29udGVudCgpXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5nZXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciAkZSA9IHRoaXMuJGVsZW1lbnRcbiAgICB2YXIgbyAgPSB0aGlzLm9wdGlvbnNcblxuICAgIHJldHVybiAkZS5hdHRyKCdkYXRhLWNvbnRlbnQnKVxuICAgICAgfHwgKHR5cGVvZiBvLmNvbnRlbnQgPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICBvLmNvbnRlbnQuY2FsbCgkZVswXSkgOlxuICAgICAgICAgICAgby5jb250ZW50KVxuICB9XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuYXJyb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLiRhcnJvdyA9IHRoaXMuJGFycm93IHx8IHRoaXMudGlwKCkuZmluZCgnLmFycm93JykpXG4gIH1cblxuXG4gIC8vIFBPUE9WRVIgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5wb3BvdmVyJylcbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cblxuICAgICAgaWYgKCFkYXRhICYmIC9kZXN0cm95fGhpZGUvLnRlc3Qob3B0aW9uKSkgcmV0dXJuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnBvcG92ZXInLCAoZGF0YSA9IG5ldyBQb3BvdmVyKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5wb3BvdmVyXG5cbiAgJC5mbi5wb3BvdmVyICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4ucG9wb3Zlci5Db25zdHJ1Y3RvciA9IFBvcG92ZXJcblxuXG4gIC8vIFBPUE9WRVIgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4ucG9wb3Zlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4ucG9wb3ZlciA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogc2Nyb2xsc3B5LmpzIHYzLjMuN1xuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jc2Nyb2xsc3B5XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTYgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gU0NST0xMU1BZIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBTY3JvbGxTcHkoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGJvZHkgICAgICAgICAgPSAkKGRvY3VtZW50LmJvZHkpXG4gICAgdGhpcy4kc2Nyb2xsRWxlbWVudCA9ICQoZWxlbWVudCkuaXMoZG9jdW1lbnQuYm9keSkgPyAkKHdpbmRvdykgOiAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgICAgICA9ICQuZXh0ZW5kKHt9LCBTY3JvbGxTcHkuREVGQVVMVFMsIG9wdGlvbnMpXG4gICAgdGhpcy5zZWxlY3RvciAgICAgICA9ICh0aGlzLm9wdGlvbnMudGFyZ2V0IHx8ICcnKSArICcgLm5hdiBsaSA+IGEnXG4gICAgdGhpcy5vZmZzZXRzICAgICAgICA9IFtdXG4gICAgdGhpcy50YXJnZXRzICAgICAgICA9IFtdXG4gICAgdGhpcy5hY3RpdmVUYXJnZXQgICA9IG51bGxcbiAgICB0aGlzLnNjcm9sbEhlaWdodCAgID0gMFxuXG4gICAgdGhpcy4kc2Nyb2xsRWxlbWVudC5vbignc2Nyb2xsLmJzLnNjcm9sbHNweScsICQucHJveHkodGhpcy5wcm9jZXNzLCB0aGlzKSlcbiAgICB0aGlzLnJlZnJlc2goKVxuICAgIHRoaXMucHJvY2VzcygpXG4gIH1cblxuICBTY3JvbGxTcHkuVkVSU0lPTiAgPSAnMy4zLjcnXG5cbiAgU2Nyb2xsU3B5LkRFRkFVTFRTID0ge1xuICAgIG9mZnNldDogMTBcbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUuZ2V0U2Nyb2xsSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLiRzY3JvbGxFbGVtZW50WzBdLnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heCh0aGlzLiRib2R5WzBdLnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodClcbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCAgICAgICAgICA9IHRoaXNcbiAgICB2YXIgb2Zmc2V0TWV0aG9kICA9ICdvZmZzZXQnXG4gICAgdmFyIG9mZnNldEJhc2UgICAgPSAwXG5cbiAgICB0aGlzLm9mZnNldHMgICAgICA9IFtdXG4gICAgdGhpcy50YXJnZXRzICAgICAgPSBbXVxuICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gdGhpcy5nZXRTY3JvbGxIZWlnaHQoKVxuXG4gICAgaWYgKCEkLmlzV2luZG93KHRoaXMuJHNjcm9sbEVsZW1lbnRbMF0pKSB7XG4gICAgICBvZmZzZXRNZXRob2QgPSAncG9zaXRpb24nXG4gICAgICBvZmZzZXRCYXNlICAgPSB0aGlzLiRzY3JvbGxFbGVtZW50LnNjcm9sbFRvcCgpXG4gICAgfVxuXG4gICAgdGhpcy4kYm9keVxuICAgICAgLmZpbmQodGhpcy5zZWxlY3RvcilcbiAgICAgIC5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGVsICAgPSAkKHRoaXMpXG4gICAgICAgIHZhciBocmVmICA9ICRlbC5kYXRhKCd0YXJnZXQnKSB8fCAkZWwuYXR0cignaHJlZicpXG4gICAgICAgIHZhciAkaHJlZiA9IC9eIy4vLnRlc3QoaHJlZikgJiYgJChocmVmKVxuXG4gICAgICAgIHJldHVybiAoJGhyZWZcbiAgICAgICAgICAmJiAkaHJlZi5sZW5ndGhcbiAgICAgICAgICAmJiAkaHJlZi5pcygnOnZpc2libGUnKVxuICAgICAgICAgICYmIFtbJGhyZWZbb2Zmc2V0TWV0aG9kXSgpLnRvcCArIG9mZnNldEJhc2UsIGhyZWZdXSkgfHwgbnVsbFxuICAgICAgfSlcbiAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdIC0gYlswXSB9KVxuICAgICAgLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGF0Lm9mZnNldHMucHVzaCh0aGlzWzBdKVxuICAgICAgICB0aGF0LnRhcmdldHMucHVzaCh0aGlzWzFdKVxuICAgICAgfSlcbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2Nyb2xsVG9wICAgID0gdGhpcy4kc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3AoKSArIHRoaXMub3B0aW9ucy5vZmZzZXRcbiAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gdGhpcy5nZXRTY3JvbGxIZWlnaHQoKVxuICAgIHZhciBtYXhTY3JvbGwgICAgPSB0aGlzLm9wdGlvbnMub2Zmc2V0ICsgc2Nyb2xsSGVpZ2h0IC0gdGhpcy4kc2Nyb2xsRWxlbWVudC5oZWlnaHQoKVxuICAgIHZhciBvZmZzZXRzICAgICAgPSB0aGlzLm9mZnNldHNcbiAgICB2YXIgdGFyZ2V0cyAgICAgID0gdGhpcy50YXJnZXRzXG4gICAgdmFyIGFjdGl2ZVRhcmdldCA9IHRoaXMuYWN0aXZlVGFyZ2V0XG4gICAgdmFyIGlcblxuICAgIGlmICh0aGlzLnNjcm9sbEhlaWdodCAhPSBzY3JvbGxIZWlnaHQpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpXG4gICAgfVxuXG4gICAgaWYgKHNjcm9sbFRvcCA+PSBtYXhTY3JvbGwpIHtcbiAgICAgIHJldHVybiBhY3RpdmVUYXJnZXQgIT0gKGkgPSB0YXJnZXRzW3RhcmdldHMubGVuZ3RoIC0gMV0pICYmIHRoaXMuYWN0aXZhdGUoaSlcbiAgICB9XG5cbiAgICBpZiAoYWN0aXZlVGFyZ2V0ICYmIHNjcm9sbFRvcCA8IG9mZnNldHNbMF0pIHtcbiAgICAgIHRoaXMuYWN0aXZlVGFyZ2V0ID0gbnVsbFxuICAgICAgcmV0dXJuIHRoaXMuY2xlYXIoKVxuICAgIH1cblxuICAgIGZvciAoaSA9IG9mZnNldHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBhY3RpdmVUYXJnZXQgIT0gdGFyZ2V0c1tpXVxuICAgICAgICAmJiBzY3JvbGxUb3AgPj0gb2Zmc2V0c1tpXVxuICAgICAgICAmJiAob2Zmc2V0c1tpICsgMV0gPT09IHVuZGVmaW5lZCB8fCBzY3JvbGxUb3AgPCBvZmZzZXRzW2kgKyAxXSlcbiAgICAgICAgJiYgdGhpcy5hY3RpdmF0ZSh0YXJnZXRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGhpcy5hY3RpdmVUYXJnZXQgPSB0YXJnZXRcblxuICAgIHRoaXMuY2xlYXIoKVxuXG4gICAgdmFyIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciArXG4gICAgICAnW2RhdGEtdGFyZ2V0PVwiJyArIHRhcmdldCArICdcIl0sJyArXG4gICAgICB0aGlzLnNlbGVjdG9yICsgJ1tocmVmPVwiJyArIHRhcmdldCArICdcIl0nXG5cbiAgICB2YXIgYWN0aXZlID0gJChzZWxlY3RvcilcbiAgICAgIC5wYXJlbnRzKCdsaScpXG4gICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZScpXG5cbiAgICBpZiAoYWN0aXZlLnBhcmVudCgnLmRyb3Bkb3duLW1lbnUnKS5sZW5ndGgpIHtcbiAgICAgIGFjdGl2ZSA9IGFjdGl2ZVxuICAgICAgICAuY2xvc2VzdCgnbGkuZHJvcGRvd24nKVxuICAgICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgfVxuXG4gICAgYWN0aXZlLnRyaWdnZXIoJ2FjdGl2YXRlLmJzLnNjcm9sbHNweScpXG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICQodGhpcy5zZWxlY3RvcilcbiAgICAgIC5wYXJlbnRzVW50aWwodGhpcy5vcHRpb25zLnRhcmdldCwgJy5hY3RpdmUnKVxuICAgICAgLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICB9XG5cblxuICAvLyBTQ1JPTExTUFkgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLnNjcm9sbHNweScpXG4gICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuc2Nyb2xsc3B5JywgKGRhdGEgPSBuZXcgU2Nyb2xsU3B5KHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5zY3JvbGxzcHlcblxuICAkLmZuLnNjcm9sbHNweSAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLnNjcm9sbHNweS5Db25zdHJ1Y3RvciA9IFNjcm9sbFNweVxuXG5cbiAgLy8gU0NST0xMU1BZIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uc2Nyb2xsc3B5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5zY3JvbGxzcHkgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBTQ1JPTExTUFkgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT09PT09XG5cbiAgJCh3aW5kb3cpLm9uKCdsb2FkLmJzLnNjcm9sbHNweS5kYXRhLWFwaScsIGZ1bmN0aW9uICgpIHtcbiAgICAkKCdbZGF0YS1zcHk9XCJzY3JvbGxcIl0nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkc3B5ID0gJCh0aGlzKVxuICAgICAgUGx1Z2luLmNhbGwoJHNweSwgJHNweS5kYXRhKCkpXG4gICAgfSlcbiAgfSlcblxufShqUXVlcnkpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogdGFiLmpzIHYzLjMuN1xuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jdGFic1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE2IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFRBQiBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIFRhYiA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgLy8ganNjczpkaXNhYmxlIHJlcXVpcmVEb2xsYXJCZWZvcmVqUXVlcnlBc3NpZ25tZW50XG4gICAgdGhpcy5lbGVtZW50ID0gJChlbGVtZW50KVxuICAgIC8vIGpzY3M6ZW5hYmxlIHJlcXVpcmVEb2xsYXJCZWZvcmVqUXVlcnlBc3NpZ25tZW50XG4gIH1cblxuICBUYWIuVkVSU0lPTiA9ICczLjMuNydcblxuICBUYWIuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIFRhYi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHRoaXMgICAgPSB0aGlzLmVsZW1lbnRcbiAgICB2YXIgJHVsICAgICAgPSAkdGhpcy5jbG9zZXN0KCd1bDpub3QoLmRyb3Bkb3duLW1lbnUpJylcbiAgICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5kYXRhKCd0YXJnZXQnKVxuXG4gICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IgJiYgc2VsZWN0b3IucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLywgJycpIC8vIHN0cmlwIGZvciBpZTdcbiAgICB9XG5cbiAgICBpZiAoJHRoaXMucGFyZW50KCdsaScpLmhhc0NsYXNzKCdhY3RpdmUnKSkgcmV0dXJuXG5cbiAgICB2YXIgJHByZXZpb3VzID0gJHVsLmZpbmQoJy5hY3RpdmU6bGFzdCBhJylcbiAgICB2YXIgaGlkZUV2ZW50ID0gJC5FdmVudCgnaGlkZS5icy50YWInLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiAkdGhpc1swXVxuICAgIH0pXG4gICAgdmFyIHNob3dFdmVudCA9ICQuRXZlbnQoJ3Nob3cuYnMudGFiJywge1xuICAgICAgcmVsYXRlZFRhcmdldDogJHByZXZpb3VzWzBdXG4gICAgfSlcblxuICAgICRwcmV2aW91cy50cmlnZ2VyKGhpZGVFdmVudClcbiAgICAkdGhpcy50cmlnZ2VyKHNob3dFdmVudClcblxuICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgIHZhciAkdGFyZ2V0ID0gJChzZWxlY3RvcilcblxuICAgIHRoaXMuYWN0aXZhdGUoJHRoaXMuY2xvc2VzdCgnbGknKSwgJHVsKVxuICAgIHRoaXMuYWN0aXZhdGUoJHRhcmdldCwgJHRhcmdldC5wYXJlbnQoKSwgZnVuY3Rpb24gKCkge1xuICAgICAgJHByZXZpb3VzLnRyaWdnZXIoe1xuICAgICAgICB0eXBlOiAnaGlkZGVuLmJzLnRhYicsXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6ICR0aGlzWzBdXG4gICAgICB9KVxuICAgICAgJHRoaXMudHJpZ2dlcih7XG4gICAgICAgIHR5cGU6ICdzaG93bi5icy50YWInLFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiAkcHJldmlvdXNbMF1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIFRhYi5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIHZhciAkYWN0aXZlICAgID0gY29udGFpbmVyLmZpbmQoJz4gLmFjdGl2ZScpXG4gICAgdmFyIHRyYW5zaXRpb24gPSBjYWxsYmFja1xuICAgICAgJiYgJC5zdXBwb3J0LnRyYW5zaXRpb25cbiAgICAgICYmICgkYWN0aXZlLmxlbmd0aCAmJiAkYWN0aXZlLmhhc0NsYXNzKCdmYWRlJykgfHwgISFjb250YWluZXIuZmluZCgnPiAuZmFkZScpLmxlbmd0aClcblxuICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAkYWN0aXZlXG4gICAgICAgIC5yZW1vdmVDbGFzcygnYWN0aXZlJylcbiAgICAgICAgLmZpbmQoJz4gLmRyb3Bkb3duLW1lbnUgPiAuYWN0aXZlJylcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAgIC5lbmQoKVxuICAgICAgICAuZmluZCgnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJylcbiAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuXG4gICAgICBlbGVtZW50XG4gICAgICAgIC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgICAgLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScpXG4gICAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKVxuXG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICBlbGVtZW50WzBdLm9mZnNldFdpZHRoIC8vIHJlZmxvdyBmb3IgdHJhbnNpdGlvblxuICAgICAgICBlbGVtZW50LmFkZENsYXNzKCdpbicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKCdmYWRlJylcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQucGFyZW50KCcuZHJvcGRvd24tbWVudScpLmxlbmd0aCkge1xuICAgICAgICBlbGVtZW50XG4gICAgICAgICAgLmNsb3Nlc3QoJ2xpLmRyb3Bkb3duJylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgICAgICAuZW5kKClcbiAgICAgICAgICAuZmluZCgnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJylcbiAgICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgIH1cblxuICAgICRhY3RpdmUubGVuZ3RoICYmIHRyYW5zaXRpb24gP1xuICAgICAgJGFjdGl2ZVxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBuZXh0KVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoVGFiLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgIG5leHQoKVxuXG4gICAgJGFjdGl2ZS5yZW1vdmVDbGFzcygnaW4nKVxuICB9XG5cblxuICAvLyBUQUIgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgID0gJHRoaXMuZGF0YSgnYnMudGFiJylcblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy50YWInLCAoZGF0YSA9IG5ldyBUYWIodGhpcykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLnRhYlxuXG4gICQuZm4udGFiICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4udGFiLkNvbnN0cnVjdG9yID0gVGFiXG5cblxuICAvLyBUQUIgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09XG5cbiAgJC5mbi50YWIubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLnRhYiA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIFRBQiBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT1cblxuICB2YXIgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBQbHVnaW4uY2FsbCgkKHRoaXMpLCAnc2hvdycpXG4gIH1cblxuICAkKGRvY3VtZW50KVxuICAgIC5vbignY2xpY2suYnMudGFiLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScsIGNsaWNrSGFuZGxlcilcbiAgICAub24oJ2NsaWNrLmJzLnRhYi5kYXRhLWFwaScsICdbZGF0YS10b2dnbGU9XCJwaWxsXCJdJywgY2xpY2tIYW5kbGVyKVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBhZmZpeC5qcyB2My4zLjdcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2FmZml4XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTYgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQUZGSVggQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIEFmZml4ID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQWZmaXguREVGQVVMVFMsIG9wdGlvbnMpXG5cbiAgICB0aGlzLiR0YXJnZXQgPSAkKHRoaXMub3B0aW9ucy50YXJnZXQpXG4gICAgICAub24oJ3Njcm9sbC5icy5hZmZpeC5kYXRhLWFwaScsICQucHJveHkodGhpcy5jaGVja1Bvc2l0aW9uLCB0aGlzKSlcbiAgICAgIC5vbignY2xpY2suYnMuYWZmaXguZGF0YS1hcGknLCAgJC5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wLCB0aGlzKSlcblxuICAgIHRoaXMuJGVsZW1lbnQgICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMuYWZmaXhlZCAgICAgID0gbnVsbFxuICAgIHRoaXMudW5waW4gICAgICAgID0gbnVsbFxuICAgIHRoaXMucGlubmVkT2Zmc2V0ID0gbnVsbFxuXG4gICAgdGhpcy5jaGVja1Bvc2l0aW9uKClcbiAgfVxuXG4gIEFmZml4LlZFUlNJT04gID0gJzMuMy43J1xuXG4gIEFmZml4LlJFU0VUICAgID0gJ2FmZml4IGFmZml4LXRvcCBhZmZpeC1ib3R0b20nXG5cbiAgQWZmaXguREVGQVVMVFMgPSB7XG4gICAgb2Zmc2V0OiAwLFxuICAgIHRhcmdldDogd2luZG93XG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoc2Nyb2xsSGVpZ2h0LCBoZWlnaHQsIG9mZnNldFRvcCwgb2Zmc2V0Qm90dG9tKSB7XG4gICAgdmFyIHNjcm9sbFRvcCAgICA9IHRoaXMuJHRhcmdldC5zY3JvbGxUb3AoKVxuICAgIHZhciBwb3NpdGlvbiAgICAgPSB0aGlzLiRlbGVtZW50Lm9mZnNldCgpXG4gICAgdmFyIHRhcmdldEhlaWdodCA9IHRoaXMuJHRhcmdldC5oZWlnaHQoKVxuXG4gICAgaWYgKG9mZnNldFRvcCAhPSBudWxsICYmIHRoaXMuYWZmaXhlZCA9PSAndG9wJykgcmV0dXJuIHNjcm9sbFRvcCA8IG9mZnNldFRvcCA/ICd0b3AnIDogZmFsc2VcblxuICAgIGlmICh0aGlzLmFmZml4ZWQgPT0gJ2JvdHRvbScpIHtcbiAgICAgIGlmIChvZmZzZXRUb3AgIT0gbnVsbCkgcmV0dXJuIChzY3JvbGxUb3AgKyB0aGlzLnVucGluIDw9IHBvc2l0aW9uLnRvcCkgPyBmYWxzZSA6ICdib3R0b20nXG4gICAgICByZXR1cm4gKHNjcm9sbFRvcCArIHRhcmdldEhlaWdodCA8PSBzY3JvbGxIZWlnaHQgLSBvZmZzZXRCb3R0b20pID8gZmFsc2UgOiAnYm90dG9tJ1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsaXppbmcgICA9IHRoaXMuYWZmaXhlZCA9PSBudWxsXG4gICAgdmFyIGNvbGxpZGVyVG9wICAgID0gaW5pdGlhbGl6aW5nID8gc2Nyb2xsVG9wIDogcG9zaXRpb24udG9wXG4gICAgdmFyIGNvbGxpZGVySGVpZ2h0ID0gaW5pdGlhbGl6aW5nID8gdGFyZ2V0SGVpZ2h0IDogaGVpZ2h0XG5cbiAgICBpZiAob2Zmc2V0VG9wICE9IG51bGwgJiYgc2Nyb2xsVG9wIDw9IG9mZnNldFRvcCkgcmV0dXJuICd0b3AnXG4gICAgaWYgKG9mZnNldEJvdHRvbSAhPSBudWxsICYmIChjb2xsaWRlclRvcCArIGNvbGxpZGVySGVpZ2h0ID49IHNjcm9sbEhlaWdodCAtIG9mZnNldEJvdHRvbSkpIHJldHVybiAnYm90dG9tJ1xuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuZ2V0UGlubmVkT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBpbm5lZE9mZnNldCkgcmV0dXJuIHRoaXMucGlubmVkT2Zmc2V0XG4gICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhBZmZpeC5SRVNFVCkuYWRkQ2xhc3MoJ2FmZml4JylcbiAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy4kdGFyZ2V0LnNjcm9sbFRvcCgpXG4gICAgdmFyIHBvc2l0aW9uICA9IHRoaXMuJGVsZW1lbnQub2Zmc2V0KClcbiAgICByZXR1cm4gKHRoaXMucGlubmVkT2Zmc2V0ID0gcG9zaXRpb24udG9wIC0gc2Nyb2xsVG9wKVxuICB9XG5cbiAgQWZmaXgucHJvdG90eXBlLmNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoJC5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb24sIHRoaXMpLCAxKVxuICB9XG5cbiAgQWZmaXgucHJvdG90eXBlLmNoZWNrUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLiRlbGVtZW50LmlzKCc6dmlzaWJsZScpKSByZXR1cm5cblxuICAgIHZhciBoZWlnaHQgICAgICAgPSB0aGlzLiRlbGVtZW50LmhlaWdodCgpXG4gICAgdmFyIG9mZnNldCAgICAgICA9IHRoaXMub3B0aW9ucy5vZmZzZXRcbiAgICB2YXIgb2Zmc2V0VG9wICAgID0gb2Zmc2V0LnRvcFxuICAgIHZhciBvZmZzZXRCb3R0b20gPSBvZmZzZXQuYm90dG9tXG4gICAgdmFyIHNjcm9sbEhlaWdodCA9IE1hdGgubWF4KCQoZG9jdW1lbnQpLmhlaWdodCgpLCAkKGRvY3VtZW50LmJvZHkpLmhlaWdodCgpKVxuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgIT0gJ29iamVjdCcpICAgICAgICAgb2Zmc2V0Qm90dG9tID0gb2Zmc2V0VG9wID0gb2Zmc2V0XG4gICAgaWYgKHR5cGVvZiBvZmZzZXRUb3AgPT0gJ2Z1bmN0aW9uJykgICAgb2Zmc2V0VG9wICAgID0gb2Zmc2V0LnRvcCh0aGlzLiRlbGVtZW50KVxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0Qm90dG9tID09ICdmdW5jdGlvbicpIG9mZnNldEJvdHRvbSA9IG9mZnNldC5ib3R0b20odGhpcy4kZWxlbWVudClcblxuICAgIHZhciBhZmZpeCA9IHRoaXMuZ2V0U3RhdGUoc2Nyb2xsSGVpZ2h0LCBoZWlnaHQsIG9mZnNldFRvcCwgb2Zmc2V0Qm90dG9tKVxuXG4gICAgaWYgKHRoaXMuYWZmaXhlZCAhPSBhZmZpeCkge1xuICAgICAgaWYgKHRoaXMudW5waW4gIT0gbnVsbCkgdGhpcy4kZWxlbWVudC5jc3MoJ3RvcCcsICcnKVxuXG4gICAgICB2YXIgYWZmaXhUeXBlID0gJ2FmZml4JyArIChhZmZpeCA/ICctJyArIGFmZml4IDogJycpXG4gICAgICB2YXIgZSAgICAgICAgID0gJC5FdmVudChhZmZpeFR5cGUgKyAnLmJzLmFmZml4JylcblxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICAgdGhpcy5hZmZpeGVkID0gYWZmaXhcbiAgICAgIHRoaXMudW5waW4gPSBhZmZpeCA9PSAnYm90dG9tJyA/IHRoaXMuZ2V0UGlubmVkT2Zmc2V0KCkgOiBudWxsXG5cbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUNsYXNzKEFmZml4LlJFU0VUKVxuICAgICAgICAuYWRkQ2xhc3MoYWZmaXhUeXBlKVxuICAgICAgICAudHJpZ2dlcihhZmZpeFR5cGUucmVwbGFjZSgnYWZmaXgnLCAnYWZmaXhlZCcpICsgJy5icy5hZmZpeCcpXG4gICAgfVxuXG4gICAgaWYgKGFmZml4ID09ICdib3R0b20nKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZnNldCh7XG4gICAgICAgIHRvcDogc2Nyb2xsSGVpZ2h0IC0gaGVpZ2h0IC0gb2Zmc2V0Qm90dG9tXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gQUZGSVggUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuYWZmaXgnKVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmFmZml4JywgKGRhdGEgPSBuZXcgQWZmaXgodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmFmZml4XG5cbiAgJC5mbi5hZmZpeCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmFmZml4LkNvbnN0cnVjdG9yID0gQWZmaXhcblxuXG4gIC8vIEFGRklYIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5hZmZpeC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uYWZmaXggPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBBRkZJWCBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PVxuXG4gICQod2luZG93KS5vbignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAkKCdbZGF0YS1zcHk9XCJhZmZpeFwiXScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRzcHkgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSA9ICRzcHkuZGF0YSgpXG5cbiAgICAgIGRhdGEub2Zmc2V0ID0gZGF0YS5vZmZzZXQgfHwge31cblxuICAgICAgaWYgKGRhdGEub2Zmc2V0Qm90dG9tICE9IG51bGwpIGRhdGEub2Zmc2V0LmJvdHRvbSA9IGRhdGEub2Zmc2V0Qm90dG9tXG4gICAgICBpZiAoZGF0YS5vZmZzZXRUb3AgICAgIT0gbnVsbCkgZGF0YS5vZmZzZXQudG9wICAgID0gZGF0YS5vZmZzZXRUb3BcblxuICAgICAgUGx1Z2luLmNhbGwoJHNweSwgZGF0YSlcbiAgICB9KVxuICB9KVxuXG59KGpRdWVyeSk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciAkLCBBYnN0cmFjdENob3NlbiwgQ2hvc2VuLCBTZWxlY3RQYXJzZXIsIF9yZWYsXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuICBTZWxlY3RQYXJzZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU2VsZWN0UGFyc2VyKCkge1xuICAgICAgdGhpcy5vcHRpb25zX2luZGV4ID0gMDtcbiAgICAgIHRoaXMucGFyc2VkID0gW107XG4gICAgfVxuXG4gICAgU2VsZWN0UGFyc2VyLnByb3RvdHlwZS5hZGRfbm9kZSA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJPUFRHUk9VUFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZF9ncm91cChjaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRfb3B0aW9uKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU2VsZWN0UGFyc2VyLnByb3RvdHlwZS5hZGRfZ3JvdXAgPSBmdW5jdGlvbihncm91cCkge1xuICAgICAgdmFyIGdyb3VwX3Bvc2l0aW9uLCBvcHRpb24sIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgIGdyb3VwX3Bvc2l0aW9uID0gdGhpcy5wYXJzZWQubGVuZ3RoO1xuICAgICAgdGhpcy5wYXJzZWQucHVzaCh7XG4gICAgICAgIGFycmF5X2luZGV4OiBncm91cF9wb3NpdGlvbixcbiAgICAgICAgZ3JvdXA6IHRydWUsXG4gICAgICAgIGxhYmVsOiB0aGlzLmVzY2FwZUV4cHJlc3Npb24oZ3JvdXAubGFiZWwpLFxuICAgICAgICB0aXRsZTogZ3JvdXAudGl0bGUgPyBncm91cC50aXRsZSA6IHZvaWQgMCxcbiAgICAgICAgY2hpbGRyZW46IDAsXG4gICAgICAgIGRpc2FibGVkOiBncm91cC5kaXNhYmxlZCxcbiAgICAgICAgY2xhc3NlczogZ3JvdXAuY2xhc3NOYW1lXG4gICAgICB9KTtcbiAgICAgIF9yZWYgPSBncm91cC5jaGlsZE5vZGVzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBvcHRpb24gPSBfcmVmW19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLmFkZF9vcHRpb24ob3B0aW9uLCBncm91cF9wb3NpdGlvbiwgZ3JvdXAuZGlzYWJsZWQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgU2VsZWN0UGFyc2VyLnByb3RvdHlwZS5hZGRfb3B0aW9uID0gZnVuY3Rpb24ob3B0aW9uLCBncm91cF9wb3NpdGlvbiwgZ3JvdXBfZGlzYWJsZWQpIHtcbiAgICAgIGlmIChvcHRpb24ubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJPUFRJT05cIikge1xuICAgICAgICBpZiAob3B0aW9uLnRleHQgIT09IFwiXCIpIHtcbiAgICAgICAgICBpZiAoZ3JvdXBfcG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRbZ3JvdXBfcG9zaXRpb25dLmNoaWxkcmVuICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucGFyc2VkLnB1c2goe1xuICAgICAgICAgICAgYXJyYXlfaW5kZXg6IHRoaXMucGFyc2VkLmxlbmd0aCxcbiAgICAgICAgICAgIG9wdGlvbnNfaW5kZXg6IHRoaXMub3B0aW9uc19pbmRleCxcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb24udmFsdWUsXG4gICAgICAgICAgICB0ZXh0OiBvcHRpb24udGV4dCxcbiAgICAgICAgICAgIGh0bWw6IG9wdGlvbi5pbm5lckhUTUwsXG4gICAgICAgICAgICB0aXRsZTogb3B0aW9uLnRpdGxlID8gb3B0aW9uLnRpdGxlIDogdm9pZCAwLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IG9wdGlvbi5zZWxlY3RlZCxcbiAgICAgICAgICAgIGRpc2FibGVkOiBncm91cF9kaXNhYmxlZCA9PT0gdHJ1ZSA/IGdyb3VwX2Rpc2FibGVkIDogb3B0aW9uLmRpc2FibGVkLFxuICAgICAgICAgICAgZ3JvdXBfYXJyYXlfaW5kZXg6IGdyb3VwX3Bvc2l0aW9uLFxuICAgICAgICAgICAgZ3JvdXBfbGFiZWw6IGdyb3VwX3Bvc2l0aW9uICE9IG51bGwgPyB0aGlzLnBhcnNlZFtncm91cF9wb3NpdGlvbl0ubGFiZWwgOiBudWxsLFxuICAgICAgICAgICAgY2xhc3Nlczogb3B0aW9uLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHN0eWxlOiBvcHRpb24uc3R5bGUuY3NzVGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFyc2VkLnB1c2goe1xuICAgICAgICAgICAgYXJyYXlfaW5kZXg6IHRoaXMucGFyc2VkLmxlbmd0aCxcbiAgICAgICAgICAgIG9wdGlvbnNfaW5kZXg6IHRoaXMub3B0aW9uc19pbmRleCxcbiAgICAgICAgICAgIGVtcHR5OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc19pbmRleCArPSAxO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3RQYXJzZXIucHJvdG90eXBlLmVzY2FwZUV4cHJlc3Npb24gPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB2YXIgbWFwLCB1bnNhZmVfY2hhcnM7XG4gICAgICBpZiAoKHRleHQgPT0gbnVsbCkgfHwgdGV4dCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAoIS9bXFwmXFw8XFw+XFxcIlxcJ1xcYF0vLnRlc3QodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9XG4gICAgICBtYXAgPSB7XG4gICAgICAgIFwiPFwiOiBcIiZsdDtcIixcbiAgICAgICAgXCI+XCI6IFwiJmd0O1wiLFxuICAgICAgICAnXCInOiBcIiZxdW90O1wiLFxuICAgICAgICBcIidcIjogXCImI3gyNztcIixcbiAgICAgICAgXCJgXCI6IFwiJiN4NjA7XCJcbiAgICAgIH07XG4gICAgICB1bnNhZmVfY2hhcnMgPSAvJig/IVxcdys7KXxbXFw8XFw+XFxcIlxcJ1xcYF0vZztcbiAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UodW5zYWZlX2NoYXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgICAgcmV0dXJuIG1hcFtjaHJdIHx8IFwiJmFtcDtcIjtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2VsZWN0UGFyc2VyO1xuXG4gIH0pKCk7XG5cbiAgU2VsZWN0UGFyc2VyLnNlbGVjdF90b19hcnJheSA9IGZ1bmN0aW9uKHNlbGVjdCkge1xuICAgIHZhciBjaGlsZCwgcGFyc2VyLCBfaSwgX2xlbiwgX3JlZjtcbiAgICBwYXJzZXIgPSBuZXcgU2VsZWN0UGFyc2VyKCk7XG4gICAgX3JlZiA9IHNlbGVjdC5jaGlsZE5vZGVzO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgY2hpbGQgPSBfcmVmW19pXTtcbiAgICAgIHBhcnNlci5hZGRfbm9kZShjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIucGFyc2VkO1xuICB9O1xuXG4gIEFic3RyYWN0Q2hvc2VuID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0Q2hvc2VuKGZvcm1fZmllbGQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZm9ybV9maWVsZCA9IGZvcm1fZmllbGQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge307XG4gICAgICB0aGlzLmxhYmVsX2NsaWNrX2hhbmRsZXIgPSBfX2JpbmQodGhpcy5sYWJlbF9jbGlja19oYW5kbGVyLCB0aGlzKTtcbiAgICAgIGlmICghQWJzdHJhY3RDaG9zZW4uYnJvd3Nlcl9pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmlzX211bHRpcGxlID0gdGhpcy5mb3JtX2ZpZWxkLm11bHRpcGxlO1xuICAgICAgdGhpcy5zZXRfZGVmYXVsdF90ZXh0KCk7XG4gICAgICB0aGlzLnNldF9kZWZhdWx0X3ZhbHVlcygpO1xuICAgICAgdGhpcy5zZXR1cCgpO1xuICAgICAgdGhpcy5zZXRfdXBfaHRtbCgpO1xuICAgICAgdGhpcy5yZWdpc3Rlcl9vYnNlcnZlcnMoKTtcbiAgICAgIHRoaXMub25fcmVhZHkoKTtcbiAgICB9XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuc2V0X2RlZmF1bHRfdmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5jbGlja190ZXN0X2FjdGlvbiA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMudGVzdF9hY3RpdmVfY2xpY2soZXZ0KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFjdGl2YXRlX2FjdGlvbiA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuYWN0aXZhdGVfZmllbGQoZXZ0KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFjdGl2ZV9maWVsZCA9IGZhbHNlO1xuICAgICAgdGhpcy5tb3VzZV9vbl9jb250YWluZXIgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVzdWx0c19zaG93aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnJlc3VsdF9oaWdobGlnaHRlZCA9IG51bGw7XG4gICAgICB0aGlzLmlzX3J0bCA9IHRoaXMub3B0aW9ucy5ydGwgfHwgL1xcYmNob3Nlbi1ydGxcXGIvLnRlc3QodGhpcy5mb3JtX2ZpZWxkLmNsYXNzTmFtZSk7XG4gICAgICB0aGlzLmFsbG93X3NpbmdsZV9kZXNlbGVjdCA9ICh0aGlzLm9wdGlvbnMuYWxsb3dfc2luZ2xlX2Rlc2VsZWN0ICE9IG51bGwpICYmICh0aGlzLmZvcm1fZmllbGQub3B0aW9uc1swXSAhPSBudWxsKSAmJiB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1swXS50ZXh0ID09PSBcIlwiID8gdGhpcy5vcHRpb25zLmFsbG93X3NpbmdsZV9kZXNlbGVjdCA6IGZhbHNlO1xuICAgICAgdGhpcy5kaXNhYmxlX3NlYXJjaF90aHJlc2hvbGQgPSB0aGlzLm9wdGlvbnMuZGlzYWJsZV9zZWFyY2hfdGhyZXNob2xkIHx8IDA7XG4gICAgICB0aGlzLmRpc2FibGVfc2VhcmNoID0gdGhpcy5vcHRpb25zLmRpc2FibGVfc2VhcmNoIHx8IGZhbHNlO1xuICAgICAgdGhpcy5lbmFibGVfc3BsaXRfd29yZF9zZWFyY2ggPSB0aGlzLm9wdGlvbnMuZW5hYmxlX3NwbGl0X3dvcmRfc2VhcmNoICE9IG51bGwgPyB0aGlzLm9wdGlvbnMuZW5hYmxlX3NwbGl0X3dvcmRfc2VhcmNoIDogdHJ1ZTtcbiAgICAgIHRoaXMuZ3JvdXBfc2VhcmNoID0gdGhpcy5vcHRpb25zLmdyb3VwX3NlYXJjaCAhPSBudWxsID8gdGhpcy5vcHRpb25zLmdyb3VwX3NlYXJjaCA6IHRydWU7XG4gICAgICB0aGlzLnNlYXJjaF9jb250YWlucyA9IHRoaXMub3B0aW9ucy5zZWFyY2hfY29udGFpbnMgfHwgZmFsc2U7XG4gICAgICB0aGlzLnNpbmdsZV9iYWNrc3Ryb2tlX2RlbGV0ZSA9IHRoaXMub3B0aW9ucy5zaW5nbGVfYmFja3N0cm9rZV9kZWxldGUgIT0gbnVsbCA/IHRoaXMub3B0aW9ucy5zaW5nbGVfYmFja3N0cm9rZV9kZWxldGUgOiB0cnVlO1xuICAgICAgdGhpcy5tYXhfc2VsZWN0ZWRfb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5tYXhfc2VsZWN0ZWRfb3B0aW9ucyB8fCBJbmZpbml0eTtcbiAgICAgIHRoaXMuaW5oZXJpdF9zZWxlY3RfY2xhc3NlcyA9IHRoaXMub3B0aW9ucy5pbmhlcml0X3NlbGVjdF9jbGFzc2VzIHx8IGZhbHNlO1xuICAgICAgdGhpcy5kaXNwbGF5X3NlbGVjdGVkX29wdGlvbnMgPSB0aGlzLm9wdGlvbnMuZGlzcGxheV9zZWxlY3RlZF9vcHRpb25zICE9IG51bGwgPyB0aGlzLm9wdGlvbnMuZGlzcGxheV9zZWxlY3RlZF9vcHRpb25zIDogdHJ1ZTtcbiAgICAgIHRoaXMuZGlzcGxheV9kaXNhYmxlZF9vcHRpb25zID0gdGhpcy5vcHRpb25zLmRpc3BsYXlfZGlzYWJsZWRfb3B0aW9ucyAhPSBudWxsID8gdGhpcy5vcHRpb25zLmRpc3BsYXlfZGlzYWJsZWRfb3B0aW9ucyA6IHRydWU7XG4gICAgICB0aGlzLmluY2x1ZGVfZ3JvdXBfbGFiZWxfaW5fc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbnMuaW5jbHVkZV9ncm91cF9sYWJlbF9pbl9zZWxlY3RlZCB8fCBmYWxzZTtcbiAgICAgIHRoaXMubWF4X3Nob3duX3Jlc3VsdHMgPSB0aGlzLm9wdGlvbnMubWF4X3Nob3duX3Jlc3VsdHMgfHwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgdGhpcy5jYXNlX3NlbnNpdGl2ZV9zZWFyY2ggPSB0aGlzLm9wdGlvbnMuY2FzZV9zZW5zaXRpdmVfc2VhcmNoIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMuaGlkZV9yZXN1bHRzX29uX3NlbGVjdCA9IHRoaXMub3B0aW9ucy5oaWRlX3Jlc3VsdHNfb25fc2VsZWN0ICE9IG51bGwgPyB0aGlzLm9wdGlvbnMuaGlkZV9yZXN1bHRzX29uX3NlbGVjdCA6IHRydWU7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5zZXRfZGVmYXVsdF90ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5mb3JtX2ZpZWxkLmdldEF0dHJpYnV0ZShcImRhdGEtcGxhY2Vob2xkZXJcIikpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0X3RleHQgPSB0aGlzLmZvcm1fZmllbGQuZ2V0QXR0cmlidXRlKFwiZGF0YS1wbGFjZWhvbGRlclwiKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICB0aGlzLmRlZmF1bHRfdGV4dCA9IHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcl90ZXh0X211bHRpcGxlIHx8IHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcl90ZXh0IHx8IEFic3RyYWN0Q2hvc2VuLmRlZmF1bHRfbXVsdGlwbGVfdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdF90ZXh0ID0gdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyX3RleHRfc2luZ2xlIHx8IHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcl90ZXh0IHx8IEFic3RyYWN0Q2hvc2VuLmRlZmF1bHRfc2luZ2xlX3RleHQ7XG4gICAgICB9XG4gICAgICB0aGlzLmRlZmF1bHRfdGV4dCA9IHRoaXMuZXNjYXBlX2h0bWwodGhpcy5kZWZhdWx0X3RleHQpO1xuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19ub25lX2ZvdW5kID0gdGhpcy5mb3JtX2ZpZWxkLmdldEF0dHJpYnV0ZShcImRhdGEtbm9fcmVzdWx0c190ZXh0XCIpIHx8IHRoaXMub3B0aW9ucy5ub19yZXN1bHRzX3RleHQgfHwgQWJzdHJhY3RDaG9zZW4uZGVmYXVsdF9ub19yZXN1bHRfdGV4dDtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmNob2ljZV9sYWJlbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGlmICh0aGlzLmluY2x1ZGVfZ3JvdXBfbGFiZWxfaW5fc2VsZWN0ZWQgJiYgKGl0ZW0uZ3JvdXBfbGFiZWwgIT0gbnVsbCkpIHtcbiAgICAgICAgcmV0dXJuIFwiPGIgY2xhc3M9J2dyb3VwLW5hbWUnPlwiICsgaXRlbS5ncm91cF9sYWJlbCArIFwiPC9iPlwiICsgaXRlbS5odG1sO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uaHRtbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLm1vdXNlX2VudGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb3VzZV9vbl9jb250YWluZXIgPSB0cnVlO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUubW91c2VfbGVhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vdXNlX29uX2NvbnRhaW5lciA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuaW5wdXRfZm9jdXMgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlX2ZpZWxkKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbnRhaW5lcl9tb3VzZWRvd24oKTtcbiAgICAgICAgICB9KSwgNTApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlX2ZpZWxkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVfZmllbGQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuaW5wdXRfYmx1ciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5tb3VzZV9vbl9jb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVfZmllbGQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5ibHVyX3Rlc3QoKTtcbiAgICAgICAgfSksIDEwMCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5sYWJlbF9jbGlja19oYW5kbGVyID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXJfbW91c2Vkb3duKGV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZV9maWVsZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19vcHRpb25fYnVpbGQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY29udGVudCwgZGF0YSwgZGF0YV9jb250ZW50LCBzaG93bl9yZXN1bHRzLCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIGNvbnRlbnQgPSAnJztcbiAgICAgIHNob3duX3Jlc3VsdHMgPSAwO1xuICAgICAgX3JlZiA9IHRoaXMucmVzdWx0c19kYXRhO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGRhdGEgPSBfcmVmW19pXTtcbiAgICAgICAgZGF0YV9jb250ZW50ID0gJyc7XG4gICAgICAgIGlmIChkYXRhLmdyb3VwKSB7XG4gICAgICAgICAgZGF0YV9jb250ZW50ID0gdGhpcy5yZXN1bHRfYWRkX2dyb3VwKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFfY29udGVudCA9IHRoaXMucmVzdWx0X2FkZF9vcHRpb24oZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFfY29udGVudCAhPT0gJycpIHtcbiAgICAgICAgICBzaG93bl9yZXN1bHRzKys7XG4gICAgICAgICAgY29udGVudCArPSBkYXRhX2NvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuZmlyc3QgOiB2b2lkIDApIHtcbiAgICAgICAgICBpZiAoZGF0YS5zZWxlY3RlZCAmJiB0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLmNob2ljZV9idWlsZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEuc2VsZWN0ZWQgJiYgIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2luZ2xlX3NldF9zZWxlY3RlZF90ZXh0KHRoaXMuY2hvaWNlX2xhYmVsKGRhdGEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3duX3Jlc3VsdHMgPj0gdGhpcy5tYXhfc2hvd25fcmVzdWx0cykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9hZGRfb3B0aW9uID0gZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICB2YXIgY2xhc3Nlcywgb3B0aW9uX2VsO1xuICAgICAgaWYgKCFvcHRpb24uc2VhcmNoX21hdGNoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5pbmNsdWRlX29wdGlvbl9pbl9yZXN1bHRzKG9wdGlvbikpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgY2xhc3NlcyA9IFtdO1xuICAgICAgaWYgKCFvcHRpb24uZGlzYWJsZWQgJiYgIShvcHRpb24uc2VsZWN0ZWQgJiYgdGhpcy5pc19tdWx0aXBsZSkpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKFwiYWN0aXZlLXJlc3VsdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb24uZGlzYWJsZWQgJiYgIShvcHRpb24uc2VsZWN0ZWQgJiYgdGhpcy5pc19tdWx0aXBsZSkpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKFwiZGlzYWJsZWQtcmVzdWx0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICBjbGFzc2VzLnB1c2goXCJyZXN1bHQtc2VsZWN0ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uLmdyb3VwX2FycmF5X2luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKFwiZ3JvdXAtb3B0aW9uXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbi5jbGFzc2VzICE9PSBcIlwiKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChvcHRpb24uY2xhc3Nlcyk7XG4gICAgICB9XG4gICAgICBvcHRpb25fZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XG4gICAgICBvcHRpb25fZWwuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICAgIG9wdGlvbl9lbC5zdHlsZS5jc3NUZXh0ID0gb3B0aW9uLnN0eWxlO1xuICAgICAgb3B0aW9uX2VsLnNldEF0dHJpYnV0ZShcImRhdGEtb3B0aW9uLWFycmF5LWluZGV4XCIsIG9wdGlvbi5hcnJheV9pbmRleCk7XG4gICAgICBvcHRpb25fZWwuaW5uZXJIVE1MID0gb3B0aW9uLnNlYXJjaF90ZXh0O1xuICAgICAgaWYgKG9wdGlvbi50aXRsZSkge1xuICAgICAgICBvcHRpb25fZWwudGl0bGUgPSBvcHRpb24udGl0bGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5vdXRlckhUTUwob3B0aW9uX2VsKTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9hZGRfZ3JvdXAgPSBmdW5jdGlvbihncm91cCkge1xuICAgICAgdmFyIGNsYXNzZXMsIGdyb3VwX2VsO1xuICAgICAgaWYgKCEoZ3JvdXAuc2VhcmNoX21hdGNoIHx8IGdyb3VwLmdyb3VwX21hdGNoKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBpZiAoIShncm91cC5hY3RpdmVfb3B0aW9ucyA+IDApKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGNsYXNzZXMgPSBbXTtcbiAgICAgIGNsYXNzZXMucHVzaChcImdyb3VwLXJlc3VsdFwiKTtcbiAgICAgIGlmIChncm91cC5jbGFzc2VzKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChncm91cC5jbGFzc2VzKTtcbiAgICAgIH1cbiAgICAgIGdyb3VwX2VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuICAgICAgZ3JvdXBfZWwuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICAgIGdyb3VwX2VsLmlubmVySFRNTCA9IGdyb3VwLnNlYXJjaF90ZXh0O1xuICAgICAgaWYgKGdyb3VwLnRpdGxlKSB7XG4gICAgICAgIGdyb3VwX2VsLnRpdGxlID0gZ3JvdXAudGl0bGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5vdXRlckhUTUwoZ3JvdXBfZWwpO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUucmVzdWx0c191cGRhdGVfZmllbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0X2RlZmF1bHRfdGV4dCgpO1xuICAgICAgaWYgKCF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMucmVzdWx0c19yZXNldF9jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc3VsdF9jbGVhcl9oaWdobGlnaHQoKTtcbiAgICAgIHRoaXMucmVzdWx0c19idWlsZCgpO1xuICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpbm5vd19yZXN1bHRzKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5yZXNldF9zaW5nbGVfc2VsZWN0X29wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQsIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgIF9yZWYgPSB0aGlzLnJlc3VsdHNfZGF0YTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcmVzdWx0ID0gX3JlZltfaV07XG4gICAgICAgIGlmIChyZXN1bHQuc2VsZWN0ZWQpIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHJlc3VsdC5zZWxlY3RlZCA9IGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfdG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3Nob3coKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfc2VhcmNoID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lubm93X3Jlc3VsdHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHNfc2hvdygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUud2lubm93X3Jlc3VsdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlc2NhcGVkU2VhcmNoVGV4dCwgaGlnaGxpZ2h0UmVnZXgsIG9wdGlvbiwgcmVnZXgsIHJlc3VsdHMsIHJlc3VsdHNfZ3JvdXAsIHNlYXJjaFRleHQsIHN0YXJ0cG9zLCB0ZXh0LCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIHRoaXMubm9fcmVzdWx0c19jbGVhcigpO1xuICAgICAgcmVzdWx0cyA9IDA7XG4gICAgICBzZWFyY2hUZXh0ID0gdGhpcy5nZXRfc2VhcmNoX3RleHQoKTtcbiAgICAgIGVzY2FwZWRTZWFyY2hUZXh0ID0gc2VhcmNoVGV4dC5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgXCJcXFxcJCZcIik7XG4gICAgICByZWdleCA9IHRoaXMuZ2V0X3NlYXJjaF9yZWdleChlc2NhcGVkU2VhcmNoVGV4dCk7XG4gICAgICBoaWdobGlnaHRSZWdleCA9IHRoaXMuZ2V0X2hpZ2hsaWdodF9yZWdleChlc2NhcGVkU2VhcmNoVGV4dCk7XG4gICAgICBfcmVmID0gdGhpcy5yZXN1bHRzX2RhdGE7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgb3B0aW9uID0gX3JlZltfaV07XG4gICAgICAgIG9wdGlvbi5zZWFyY2hfbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgcmVzdWx0c19ncm91cCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVfb3B0aW9uX2luX3Jlc3VsdHMob3B0aW9uKSkge1xuICAgICAgICAgIGlmIChvcHRpb24uZ3JvdXApIHtcbiAgICAgICAgICAgIG9wdGlvbi5ncm91cF9tYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgb3B0aW9uLmFjdGl2ZV9vcHRpb25zID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChvcHRpb24uZ3JvdXBfYXJyYXlfaW5kZXggIT0gbnVsbCkgJiYgdGhpcy5yZXN1bHRzX2RhdGFbb3B0aW9uLmdyb3VwX2FycmF5X2luZGV4XSkge1xuICAgICAgICAgICAgcmVzdWx0c19ncm91cCA9IHRoaXMucmVzdWx0c19kYXRhW29wdGlvbi5ncm91cF9hcnJheV9pbmRleF07XG4gICAgICAgICAgICBpZiAocmVzdWx0c19ncm91cC5hY3RpdmVfb3B0aW9ucyA9PT0gMCAmJiByZXN1bHRzX2dyb3VwLnNlYXJjaF9tYXRjaCkge1xuICAgICAgICAgICAgICByZXN1bHRzICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzX2dyb3VwLmFjdGl2ZV9vcHRpb25zICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdGlvbi5zZWFyY2hfdGV4dCA9IG9wdGlvbi5ncm91cCA/IG9wdGlvbi5sYWJlbCA6IG9wdGlvbi5odG1sO1xuICAgICAgICAgIGlmICghKG9wdGlvbi5ncm91cCAmJiAhdGhpcy5ncm91cF9zZWFyY2gpKSB7XG4gICAgICAgICAgICBvcHRpb24uc2VhcmNoX21hdGNoID0gdGhpcy5zZWFyY2hfc3RyaW5nX21hdGNoKG9wdGlvbi5zZWFyY2hfdGV4dCwgcmVnZXgpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWFyY2hfbWF0Y2ggJiYgIW9wdGlvbi5ncm91cCkge1xuICAgICAgICAgICAgICByZXN1bHRzICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9uLnNlYXJjaF9tYXRjaCkge1xuICAgICAgICAgICAgICBpZiAoc2VhcmNoVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzdGFydHBvcyA9IG9wdGlvbi5zZWFyY2hfdGV4dC5zZWFyY2goaGlnaGxpZ2h0UmVnZXgpO1xuICAgICAgICAgICAgICAgIHRleHQgPSBvcHRpb24uc2VhcmNoX3RleHQuc3Vic3RyKDAsIHN0YXJ0cG9zICsgc2VhcmNoVGV4dC5sZW5ndGgpICsgJzwvZW0+JyArIG9wdGlvbi5zZWFyY2hfdGV4dC5zdWJzdHIoc3RhcnRwb3MgKyBzZWFyY2hUZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlYXJjaF90ZXh0ID0gdGV4dC5zdWJzdHIoMCwgc3RhcnRwb3MpICsgJzxlbT4nICsgdGV4dC5zdWJzdHIoc3RhcnRwb3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHRzX2dyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzX2dyb3VwLmdyb3VwX21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICgob3B0aW9uLmdyb3VwX2FycmF5X2luZGV4ICE9IG51bGwpICYmIHRoaXMucmVzdWx0c19kYXRhW29wdGlvbi5ncm91cF9hcnJheV9pbmRleF0uc2VhcmNoX21hdGNoKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5zZWFyY2hfbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0KCk7XG4gICAgICBpZiAocmVzdWx0cyA8IDEgJiYgc2VhcmNoVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVfcmVzdWx0c19jb250ZW50KFwiXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub19yZXN1bHRzKHNlYXJjaFRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cGRhdGVfcmVzdWx0c19jb250ZW50KHRoaXMucmVzdWx0c19vcHRpb25fYnVpbGQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLndpbm5vd19yZXN1bHRzX3NldF9oaWdobGlnaHQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmdldF9zZWFyY2hfcmVnZXggPSBmdW5jdGlvbihlc2NhcGVkX3NlYXJjaF9zdHJpbmcpIHtcbiAgICAgIHZhciByZWdleF9hbmNob3IsIHJlZ2V4X2ZsYWc7XG4gICAgICByZWdleF9hbmNob3IgPSB0aGlzLnNlYXJjaF9jb250YWlucyA/IFwiXCIgOiBcIl5cIjtcbiAgICAgIHJlZ2V4X2ZsYWcgPSB0aGlzLmNhc2Vfc2Vuc2l0aXZlX3NlYXJjaCA/IFwiXCIgOiBcImlcIjtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4X2FuY2hvciArIGVzY2FwZWRfc2VhcmNoX3N0cmluZywgcmVnZXhfZmxhZyk7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5nZXRfaGlnaGxpZ2h0X3JlZ2V4ID0gZnVuY3Rpb24oZXNjYXBlZF9zZWFyY2hfc3RyaW5nKSB7XG4gICAgICB2YXIgcmVnZXhfYW5jaG9yLCByZWdleF9mbGFnO1xuICAgICAgcmVnZXhfYW5jaG9yID0gdGhpcy5zZWFyY2hfY29udGFpbnMgPyBcIlwiIDogXCJcXFxcYlwiO1xuICAgICAgcmVnZXhfZmxhZyA9IHRoaXMuY2FzZV9zZW5zaXRpdmVfc2VhcmNoID8gXCJcIiA6IFwiaVwiO1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhfYW5jaG9yICsgZXNjYXBlZF9zZWFyY2hfc3RyaW5nLCByZWdleF9mbGFnKTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnNlYXJjaF9zdHJpbmdfbWF0Y2ggPSBmdW5jdGlvbihzZWFyY2hfc3RyaW5nLCByZWdleCkge1xuICAgICAgdmFyIHBhcnQsIHBhcnRzLCBfaSwgX2xlbjtcbiAgICAgIGlmIChyZWdleC50ZXN0KHNlYXJjaF9zdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmVuYWJsZV9zcGxpdF93b3JkX3NlYXJjaCAmJiAoc2VhcmNoX3N0cmluZy5pbmRleE9mKFwiIFwiKSA+PSAwIHx8IHNlYXJjaF9zdHJpbmcuaW5kZXhPZihcIltcIikgPT09IDApKSB7XG4gICAgICAgIHBhcnRzID0gc2VhcmNoX3N0cmluZy5yZXBsYWNlKC9cXFt8XFxdL2csIFwiXCIpLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gcGFydHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgIHBhcnQgPSBwYXJ0c1tfaV07XG4gICAgICAgICAgICBpZiAocmVnZXgudGVzdChwYXJ0KSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmNob2ljZXNfY291bnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcHRpb24sIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRfb3B0aW9uX2NvdW50ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRfb3B0aW9uX2NvdW50O1xuICAgICAgfVxuICAgICAgdGhpcy5zZWxlY3RlZF9vcHRpb25fY291bnQgPSAwO1xuICAgICAgX3JlZiA9IHRoaXMuZm9ybV9maWVsZC5vcHRpb25zO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIG9wdGlvbiA9IF9yZWZbX2ldO1xuICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZF9vcHRpb25fY291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRfb3B0aW9uX2NvdW50O1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuY2hvaWNlc19jbGljayA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLmFjdGl2YXRlX2ZpZWxkKCk7XG4gICAgICBpZiAoISh0aGlzLnJlc3VsdHNfc2hvd2luZyB8fCB0aGlzLmlzX2Rpc2FibGVkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3Nob3coKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmtleWRvd25fY2hlY2tlciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIHN0cm9rZSwgX3JlZjtcbiAgICAgIHN0cm9rZSA9IChfcmVmID0gZXZ0LndoaWNoKSAhPSBudWxsID8gX3JlZiA6IGV2dC5rZXlDb2RlO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGRfc2NhbGUoKTtcbiAgICAgIGlmIChzdHJva2UgIT09IDggJiYgdGhpcy5wZW5kaW5nX2JhY2tzdHJva2UpIHtcbiAgICAgICAgdGhpcy5jbGVhcl9iYWNrc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHN0cm9rZSkge1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgdGhpcy5iYWNrc3Ryb2tlX2xlbmd0aCA9IHRoaXMuZ2V0X3NlYXJjaF9maWVsZF92YWx1ZSgpLmxlbmd0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGlmICh0aGlzLnJlc3VsdHNfc2hvd2luZyAmJiAhdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRfc2VsZWN0KGV2dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubW91c2Vfb25fY29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZV9zZWFyY2gpIHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmtleXVwX2Fycm93KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5rZXlkb3duX2Fycm93KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5rZXl1cF9jaGVja2VyID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgc3Ryb2tlLCBfcmVmO1xuICAgICAgc3Ryb2tlID0gKF9yZWYgPSBldnQud2hpY2gpICE9IG51bGwgPyBfcmVmIDogZXZ0LmtleUNvZGU7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZF9zY2FsZSgpO1xuICAgICAgc3dpdGNoIChzdHJva2UpIHtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlICYmIHRoaXMuYmFja3N0cm9rZV9sZW5ndGggPCAxICYmIHRoaXMuY2hvaWNlc19jb3VudCgpID4gMCkge1xuICAgICAgICAgICAgdGhpcy5rZXlkb3duX2JhY2tzdHJva2UoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnBlbmRpbmdfYmFja3N0cm9rZSkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdHNfc2VhcmNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGlmICh0aGlzLnJlc3VsdHNfc2hvd2luZykge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRfc2VsZWN0KGV2dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIGlmICh0aGlzLnJlc3VsdHNfc2hvd2luZykge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgY2FzZSAxODpcbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLnJlc3VsdHNfc2VhcmNoKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5jbGlwYm9hcmRfZXZlbnRfY2hlY2tlciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLmlzX2Rpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnJlc3VsdHNfc2VhcmNoKCk7XG4gICAgICB9KSwgNTApO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuY29udGFpbmVyX3dpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLndpZHRoICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgdGhpcy5mb3JtX2ZpZWxkLm9mZnNldFdpZHRoICsgXCJweFwiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuaW5jbHVkZV9vcHRpb25faW5fcmVzdWx0cyA9IGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUgJiYgKCF0aGlzLmRpc3BsYXlfc2VsZWN0ZWRfb3B0aW9ucyAmJiBvcHRpb24uc2VsZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5kaXNwbGF5X2Rpc2FibGVkX29wdGlvbnMgJiYgb3B0aW9uLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb24uZW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5zZWFyY2hfcmVzdWx0c190b3VjaHN0YXJ0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB0aGlzLnRvdWNoX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX3Jlc3VsdHNfbW91c2VvdmVyKGV2dCk7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5zZWFyY2hfcmVzdWx0c190b3VjaG1vdmUgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHRoaXMudG91Y2hfc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX3Jlc3VsdHNfbW91c2VvdXQoZXZ0KTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnNlYXJjaF9yZXN1bHRzX3RvdWNoZW5kID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAodGhpcy50b3VjaF9zdGFydGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzX21vdXNldXAoZXZ0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLm91dGVySFRNTCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciB0bXA7XG4gICAgICBpZiAoZWxlbWVudC5vdXRlckhUTUwpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgfVxuICAgICAgdG1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRtcC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgIHJldHVybiB0bXAuaW5uZXJIVE1MO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuZ2V0X3NpbmdsZV9odG1sID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCI8YSBjbGFzcz1cXFwiY2hvc2VuLXNpbmdsZSBjaG9zZW4tZGVmYXVsdFxcXCI+XFxuICA8c3Bhbj5cIiArIHRoaXMuZGVmYXVsdF90ZXh0ICsgXCI8L3NwYW4+XFxuICA8ZGl2PjxiPjwvYj48L2Rpdj5cXG48L2E+XFxuPGRpdiBjbGFzcz1cXFwiY2hvc2VuLWRyb3BcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY2hvc2VuLXNlYXJjaFxcXCI+XFxuICAgIDxpbnB1dCBjbGFzcz1cXFwiY2hvc2VuLXNlYXJjaC1pbnB1dFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgYXV0b2NvbXBsZXRlPVxcXCJvZmZcXFwiIC8+XFxuICA8L2Rpdj5cXG4gIDx1bCBjbGFzcz1cXFwiY2hvc2VuLXJlc3VsdHNcXFwiPjwvdWw+XFxuPC9kaXY+XCI7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5nZXRfbXVsdGlfaHRtbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwiPHVsIGNsYXNzPVxcXCJjaG9zZW4tY2hvaWNlc1xcXCI+XFxuICA8bGkgY2xhc3M9XFxcInNlYXJjaC1maWVsZFxcXCI+XFxuICAgIDxpbnB1dCBjbGFzcz1cXFwiY2hvc2VuLXNlYXJjaC1pbnB1dFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgYXV0b2NvbXBsZXRlPVxcXCJvZmZcXFwiIHZhbHVlPVxcXCJcIiArIHRoaXMuZGVmYXVsdF90ZXh0ICsgXCJcXFwiIC8+XFxuICA8L2xpPlxcbjwvdWw+XFxuPGRpdiBjbGFzcz1cXFwiY2hvc2VuLWRyb3BcXFwiPlxcbiAgPHVsIGNsYXNzPVxcXCJjaG9zZW4tcmVzdWx0c1xcXCI+PC91bD5cXG48L2Rpdj5cIjtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmdldF9ub19yZXN1bHRzX2h0bWwgPSBmdW5jdGlvbih0ZXJtcykge1xuICAgICAgcmV0dXJuIFwiPGxpIGNsYXNzPVxcXCJuby1yZXN1bHRzXFxcIj5cXG4gIFwiICsgdGhpcy5yZXN1bHRzX25vbmVfZm91bmQgKyBcIiA8c3Bhbj5cIiArIHRlcm1zICsgXCI8L3NwYW4+XFxuPC9saT5cIjtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4uYnJvd3Nlcl9pc19zdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChcIk1pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlclwiID09PSB3aW5kb3cubmF2aWdhdG9yLmFwcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50TW9kZSA+PSA4O1xuICAgICAgfVxuICAgICAgaWYgKC9pUChvZHxob25lKS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8IC9JRU1vYmlsZS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8IC9XaW5kb3dzIFBob25lL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL0JsYWNrQmVycnkvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSB8fCAvQkIxMC9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8IC9BbmRyb2lkLipNb2JpbGUvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4uZGVmYXVsdF9tdWx0aXBsZV90ZXh0ID0gXCJTZWxlY3QgU29tZSBPcHRpb25zXCI7XG5cbiAgICBBYnN0cmFjdENob3Nlbi5kZWZhdWx0X3NpbmdsZV90ZXh0ID0gXCJTZWxlY3QgYW4gT3B0aW9uXCI7XG5cbiAgICBBYnN0cmFjdENob3Nlbi5kZWZhdWx0X25vX3Jlc3VsdF90ZXh0ID0gXCJObyByZXN1bHRzIG1hdGNoXCI7XG5cbiAgICByZXR1cm4gQWJzdHJhY3RDaG9zZW47XG5cbiAgfSkoKTtcblxuICAkID0galF1ZXJ5O1xuXG4gICQuZm4uZXh0ZW5kKHtcbiAgICBjaG9zZW46IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghQWJzdHJhY3RDaG9zZW4uYnJvd3Nlcl9pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5wdXRfZmllbGQpIHtcbiAgICAgICAgdmFyICR0aGlzLCBjaG9zZW47XG4gICAgICAgICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgY2hvc2VuID0gJHRoaXMuZGF0YSgnY2hvc2VuJyk7XG4gICAgICAgIGlmIChvcHRpb25zID09PSAnZGVzdHJveScpIHtcbiAgICAgICAgICBpZiAoY2hvc2VuIGluc3RhbmNlb2YgQ2hvc2VuKSB7XG4gICAgICAgICAgICBjaG9zZW4uZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoY2hvc2VuIGluc3RhbmNlb2YgQ2hvc2VuKSkge1xuICAgICAgICAgICR0aGlzLmRhdGEoJ2Nob3NlbicsIG5ldyBDaG9zZW4odGhpcywgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIENob3NlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hvc2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQ2hvc2VuKCkge1xuICAgICAgX3JlZiA9IENob3Nlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZm9ybV9maWVsZF9qcSA9ICQodGhpcy5mb3JtX2ZpZWxkKTtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRfc2VsZWN0ZWRJbmRleCA9IHRoaXMuZm9ybV9maWVsZC5zZWxlY3RlZEluZGV4O1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNldF91cF9odG1sID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29udGFpbmVyX2NsYXNzZXMsIGNvbnRhaW5lcl9wcm9wcztcbiAgICAgIGNvbnRhaW5lcl9jbGFzc2VzID0gW1wiY2hvc2VuLWNvbnRhaW5lclwiXTtcbiAgICAgIGNvbnRhaW5lcl9jbGFzc2VzLnB1c2goXCJjaG9zZW4tY29udGFpbmVyLVwiICsgKHRoaXMuaXNfbXVsdGlwbGUgPyBcIm11bHRpXCIgOiBcInNpbmdsZVwiKSk7XG4gICAgICBpZiAodGhpcy5pbmhlcml0X3NlbGVjdF9jbGFzc2VzICYmIHRoaXMuZm9ybV9maWVsZC5jbGFzc05hbWUpIHtcbiAgICAgICAgY29udGFpbmVyX2NsYXNzZXMucHVzaCh0aGlzLmZvcm1fZmllbGQuY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzX3J0bCkge1xuICAgICAgICBjb250YWluZXJfY2xhc3Nlcy5wdXNoKFwiY2hvc2VuLXJ0bFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnRhaW5lcl9wcm9wcyA9IHtcbiAgICAgICAgJ2NsYXNzJzogY29udGFpbmVyX2NsYXNzZXMuam9pbignICcpLFxuICAgICAgICAndGl0bGUnOiB0aGlzLmZvcm1fZmllbGQudGl0bGVcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5mb3JtX2ZpZWxkLmlkLmxlbmd0aCkge1xuICAgICAgICBjb250YWluZXJfcHJvcHMuaWQgPSB0aGlzLmZvcm1fZmllbGQuaWQucmVwbGFjZSgvW15cXHddL2csICdfJykgKyBcIl9jaG9zZW5cIjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyID0gJChcIjxkaXYgLz5cIiwgY29udGFpbmVyX3Byb3BzKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLndpZHRoKHRoaXMuY29udGFpbmVyX3dpZHRoKCkpO1xuICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuaHRtbCh0aGlzLmdldF9tdWx0aV9odG1sKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuaHRtbCh0aGlzLmdldF9zaW5nbGVfaHRtbCgpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS5oaWRlKCkuYWZ0ZXIodGhpcy5jb250YWluZXIpO1xuICAgICAgdGhpcy5kcm9wZG93biA9IHRoaXMuY29udGFpbmVyLmZpbmQoJ2Rpdi5jaG9zZW4tZHJvcCcpLmZpcnN0KCk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZCA9IHRoaXMuY29udGFpbmVyLmZpbmQoJ2lucHV0JykuZmlyc3QoKTtcbiAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMgPSB0aGlzLmNvbnRhaW5lci5maW5kKCd1bC5jaG9zZW4tcmVzdWx0cycpLmZpcnN0KCk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZF9zY2FsZSgpO1xuICAgICAgdGhpcy5zZWFyY2hfbm9fcmVzdWx0cyA9IHRoaXMuY29udGFpbmVyLmZpbmQoJ2xpLm5vLXJlc3VsdHMnKS5maXJzdCgpO1xuICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hfY2hvaWNlcyA9IHRoaXMuY29udGFpbmVyLmZpbmQoJ3VsLmNob3Nlbi1jaG9pY2VzJykuZmlyc3QoKTtcbiAgICAgICAgdGhpcy5zZWFyY2hfY29udGFpbmVyID0gdGhpcy5jb250YWluZXIuZmluZCgnbGkuc2VhcmNoLWZpZWxkJykuZmlyc3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VhcmNoX2NvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLmZpbmQoJ2Rpdi5jaG9zZW4tc2VhcmNoJykuZmlyc3QoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZF9pdGVtID0gdGhpcy5jb250YWluZXIuZmluZCgnLmNob3Nlbi1zaW5nbGUnKS5maXJzdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXN1bHRzX2J1aWxkKCk7XG4gICAgICB0aGlzLnNldF90YWJfaW5kZXgoKTtcbiAgICAgIHJldHVybiB0aGlzLnNldF9sYWJlbF9iZWhhdmlvcigpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLm9uX3JlYWR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtX2ZpZWxkX2pxLnRyaWdnZXIoXCJjaG9zZW46cmVhZHlcIiwge1xuICAgICAgICBjaG9zZW46IHRoaXNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlZ2lzdGVyX29ic2VydmVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMuY29udGFpbmVyLmJpbmQoJ3RvdWNoc3RhcnQuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmNvbnRhaW5lcl9tb3VzZWRvd24oZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250YWluZXIuYmluZCgndG91Y2hlbmQuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmNvbnRhaW5lcl9tb3VzZXVwKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmJpbmQoJ21vdXNlZG93bi5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMuY29udGFpbmVyX21vdXNlZG93bihldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5iaW5kKCdtb3VzZXVwLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5jb250YWluZXJfbW91c2V1cChldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5iaW5kKCdtb3VzZWVudGVyLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5tb3VzZV9lbnRlcihldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5iaW5kKCdtb3VzZWxlYXZlLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5tb3VzZV9sZWF2ZShldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzLmJpbmQoJ21vdXNldXAuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLnNlYXJjaF9yZXN1bHRzX21vdXNldXAoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfcmVzdWx0cy5iaW5kKCdtb3VzZW92ZXIuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLnNlYXJjaF9yZXN1bHRzX21vdXNlb3ZlcihldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzLmJpbmQoJ21vdXNlb3V0LmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5zZWFyY2hfcmVzdWx0c19tb3VzZW91dChldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzLmJpbmQoJ21vdXNld2hlZWwuY2hvc2VuIERPTU1vdXNlU2Nyb2xsLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5zZWFyY2hfcmVzdWx0c19tb3VzZXdoZWVsKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMuYmluZCgndG91Y2hzdGFydC5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMuc2VhcmNoX3Jlc3VsdHNfdG91Y2hzdGFydChldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzLmJpbmQoJ3RvdWNobW92ZS5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMuc2VhcmNoX3Jlc3VsdHNfdG91Y2htb3ZlKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMuYmluZCgndG91Y2hlbmQuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLnNlYXJjaF9yZXN1bHRzX3RvdWNoZW5kKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS5iaW5kKFwiY2hvc2VuOnVwZGF0ZWQuY2hvc2VuXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5yZXN1bHRzX3VwZGF0ZV9maWVsZChldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmZvcm1fZmllbGRfanEuYmluZChcImNob3NlbjphY3RpdmF0ZS5jaG9zZW5cIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmFjdGl2YXRlX2ZpZWxkKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS5iaW5kKFwiY2hvc2VuOm9wZW4uY2hvc2VuXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5jb250YWluZXJfbW91c2Vkb3duKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS5iaW5kKFwiY2hvc2VuOmNsb3NlLmNob3NlblwiLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMuY2xvc2VfZmllbGQoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQuYmluZCgnYmx1ci5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMuaW5wdXRfYmx1cihldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZC5iaW5kKCdrZXl1cC5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMua2V5dXBfY2hlY2tlcihldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZC5iaW5kKCdrZXlkb3duLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5rZXlkb3duX2NoZWNrZXIoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQuYmluZCgnZm9jdXMuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmlucHV0X2ZvY3VzKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLmJpbmQoJ2N1dC5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMuY2xpcGJvYXJkX2V2ZW50X2NoZWNrZXIoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQuYmluZCgncGFzdGUuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmNsaXBib2FyZF9ldmVudF9jaGVja2VyKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9jaG9pY2VzLmJpbmQoJ2NsaWNrLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIF90aGlzLmNob2ljZXNfY2xpY2soZXZ0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIuYmluZCgnY2xpY2suY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICQodGhpcy5jb250YWluZXJbMF0ub3duZXJEb2N1bWVudCkudW5iaW5kKCdjbGljay5jaG9zZW4nLCB0aGlzLmNsaWNrX3Rlc3RfYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLmZvcm1fZmllbGRfbGFiZWwubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmZvcm1fZmllbGRfbGFiZWwudW5iaW5kKCdjbGljay5jaG9zZW4nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlYXJjaF9maWVsZFswXS50YWJJbmRleCkge1xuICAgICAgICB0aGlzLmZvcm1fZmllbGRfanFbMF0udGFiSW5kZXggPSB0aGlzLnNlYXJjaF9maWVsZFswXS50YWJJbmRleDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLnJlbW92ZURhdGEoJ2Nob3NlbicpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybV9maWVsZF9qcS5zaG93KCk7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX2ZpZWxkX2Rpc2FibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzX2Rpc2FibGVkID0gdGhpcy5mb3JtX2ZpZWxkLmRpc2FibGVkIHx8IHRoaXMuZm9ybV9maWVsZF9qcS5wYXJlbnRzKCdmaWVsZHNldCcpLmlzKCc6ZGlzYWJsZWQnKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLnRvZ2dsZUNsYXNzKCdjaG9zZW4tZGlzYWJsZWQnLCB0aGlzLmlzX2Rpc2FibGVkKTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkWzBdLmRpc2FibGVkID0gdGhpcy5pc19kaXNhYmxlZDtcbiAgICAgIGlmICghdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkX2l0ZW0udW5iaW5kKCdmb2N1cy5jaG9zZW4nLCB0aGlzLmFjdGl2YXRlX2ZpZWxkKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzX2Rpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlX2ZpZWxkKCk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkX2l0ZW0uYmluZCgnZm9jdXMuY2hvc2VuJywgdGhpcy5hY3RpdmF0ZV9maWVsZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY29udGFpbmVyX21vdXNlZG93biA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIF9yZWYxO1xuICAgICAgaWYgKHRoaXMuaXNfZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2dCAmJiAoKF9yZWYxID0gZXZ0LnR5cGUpID09PSAnbW91c2Vkb3duJyB8fCBfcmVmMSA9PT0gJ3RvdWNoc3RhcnQnKSAmJiAhdGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBpZiAoISgoZXZ0ICE9IG51bGwpICYmICgkKGV2dC50YXJnZXQpKS5oYXNDbGFzcyhcInNlYXJjaC1jaG9pY2UtY2xvc2VcIikpKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVfZmllbGQpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hfZmllbGQudmFsKFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkKHRoaXMuY29udGFpbmVyWzBdLm93bmVyRG9jdW1lbnQpLmJpbmQoJ2NsaWNrLmNob3NlbicsIHRoaXMuY2xpY2tfdGVzdF9hY3Rpb24pO1xuICAgICAgICAgIHRoaXMucmVzdWx0c19zaG93KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNfbXVsdGlwbGUgJiYgZXZ0ICYmICgoJChldnQudGFyZ2V0KVswXSA9PT0gdGhpcy5zZWxlY3RlZF9pdGVtWzBdKSB8fCAkKGV2dC50YXJnZXQpLnBhcmVudHMoXCJhLmNob3Nlbi1zaW5nbGVcIikubGVuZ3RoKSkge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMucmVzdWx0c190b2dnbGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZV9maWVsZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmNvbnRhaW5lcl9tb3VzZXVwID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAoZXZ0LnRhcmdldC5ub2RlTmFtZSA9PT0gXCJBQkJSXCIgJiYgIXRoaXMuaXNfZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19yZXNldChldnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNlYXJjaF9yZXN1bHRzX21vdXNld2hlZWwgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBkZWx0YTtcbiAgICAgIGlmIChldnQub3JpZ2luYWxFdmVudCkge1xuICAgICAgICBkZWx0YSA9IGV2dC5vcmlnaW5hbEV2ZW50LmRlbHRhWSB8fCAtZXZ0Lm9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YSB8fCBldnQub3JpZ2luYWxFdmVudC5kZXRhaWw7XG4gICAgICB9XG4gICAgICBpZiAoZGVsdGEgIT0gbnVsbCkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKGV2dC50eXBlID09PSAnRE9NTW91c2VTY3JvbGwnKSB7XG4gICAgICAgICAgZGVsdGEgPSBkZWx0YSAqIDQwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLnNjcm9sbFRvcChkZWx0YSArIHRoaXMuc2VhcmNoX3Jlc3VsdHMuc2Nyb2xsVG9wKCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmJsdXJfdGVzdCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKCF0aGlzLmFjdGl2ZV9maWVsZCAmJiB0aGlzLmNvbnRhaW5lci5oYXNDbGFzcyhcImNob3Nlbi1jb250YWluZXItYWN0aXZlXCIpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlX2ZpZWxkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2xvc2VfZmllbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICQodGhpcy5jb250YWluZXJbMF0ub3duZXJEb2N1bWVudCkudW5iaW5kKFwiY2xpY2suY2hvc2VuXCIsIHRoaXMuY2xpY2tfdGVzdF9hY3Rpb24pO1xuICAgICAgdGhpcy5hY3RpdmVfZmllbGQgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVzdWx0c19oaWRlKCk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImNob3Nlbi1jb250YWluZXItYWN0aXZlXCIpO1xuICAgICAgdGhpcy5jbGVhcl9iYWNrc3Ryb2tlKCk7XG4gICAgICB0aGlzLnNob3dfc2VhcmNoX2ZpZWxkX2RlZmF1bHQoKTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkX3NjYWxlKCk7XG4gICAgICByZXR1cm4gdGhpcy5zZWFyY2hfZmllbGQuYmx1cigpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmFjdGl2YXRlX2ZpZWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc19kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyhcImNob3Nlbi1jb250YWluZXItYWN0aXZlXCIpO1xuICAgICAgdGhpcy5hY3RpdmVfZmllbGQgPSB0cnVlO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQudmFsKHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCgpKTtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5mb2N1cygpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnRlc3RfYWN0aXZlX2NsaWNrID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgYWN0aXZlX2NvbnRhaW5lcjtcbiAgICAgIGFjdGl2ZV9jb250YWluZXIgPSAkKGV2dC50YXJnZXQpLmNsb3Nlc3QoJy5jaG9zZW4tY29udGFpbmVyJyk7XG4gICAgICBpZiAoYWN0aXZlX2NvbnRhaW5lci5sZW5ndGggJiYgdGhpcy5jb250YWluZXJbMF0gPT09IGFjdGl2ZV9jb250YWluZXJbMF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlX2ZpZWxkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlX2ZpZWxkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19idWlsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wYXJzaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2VsZWN0ZWRfb3B0aW9uX2NvdW50ID0gbnVsbDtcbiAgICAgIHRoaXMucmVzdWx0c19kYXRhID0gU2VsZWN0UGFyc2VyLnNlbGVjdF90b19hcnJheSh0aGlzLmZvcm1fZmllbGQpO1xuICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hfY2hvaWNlcy5maW5kKFwibGkuc2VhcmNoLWNob2ljZVwiKS5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5zaW5nbGVfc2V0X3NlbGVjdGVkX3RleHQoKTtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZV9zZWFyY2ggfHwgdGhpcy5mb3JtX2ZpZWxkLm9wdGlvbnMubGVuZ3RoIDw9IHRoaXMuZGlzYWJsZV9zZWFyY2hfdGhyZXNob2xkKSB7XG4gICAgICAgICAgdGhpcy5zZWFyY2hfZmllbGRbMF0ucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKFwiY2hvc2VuLWNvbnRhaW5lci1zaW5nbGUtbm9zZWFyY2hcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWFyY2hfZmllbGRbMF0ucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImNob3Nlbi1jb250YWluZXItc2luZ2xlLW5vc2VhcmNoXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZV9yZXN1bHRzX2NvbnRlbnQodGhpcy5yZXN1bHRzX29wdGlvbl9idWlsZCh7XG4gICAgICAgIGZpcnN0OiB0cnVlXG4gICAgICB9KSk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZF9kaXNhYmxlZCgpO1xuICAgICAgdGhpcy5zaG93X3NlYXJjaF9maWVsZF9kZWZhdWx0KCk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZF9zY2FsZSgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2luZyA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9kb19oaWdobGlnaHQgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGhpZ2hfYm90dG9tLCBoaWdoX3RvcCwgbWF4SGVpZ2h0LCB2aXNpYmxlX2JvdHRvbSwgdmlzaWJsZV90b3A7XG4gICAgICBpZiAoZWwubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICB0aGlzLnJlc3VsdF9oaWdobGlnaHQgPSBlbDtcbiAgICAgICAgdGhpcy5yZXN1bHRfaGlnaGxpZ2h0LmFkZENsYXNzKFwiaGlnaGxpZ2h0ZWRcIik7XG4gICAgICAgIG1heEhlaWdodCA9IHBhcnNlSW50KHRoaXMuc2VhcmNoX3Jlc3VsdHMuY3NzKFwibWF4SGVpZ2h0XCIpLCAxMCk7XG4gICAgICAgIHZpc2libGVfdG9wID0gdGhpcy5zZWFyY2hfcmVzdWx0cy5zY3JvbGxUb3AoKTtcbiAgICAgICAgdmlzaWJsZV9ib3R0b20gPSBtYXhIZWlnaHQgKyB2aXNpYmxlX3RvcDtcbiAgICAgICAgaGlnaF90b3AgPSB0aGlzLnJlc3VsdF9oaWdobGlnaHQucG9zaXRpb24oKS50b3AgKyB0aGlzLnNlYXJjaF9yZXN1bHRzLnNjcm9sbFRvcCgpO1xuICAgICAgICBoaWdoX2JvdHRvbSA9IGhpZ2hfdG9wICsgdGhpcy5yZXN1bHRfaGlnaGxpZ2h0Lm91dGVySGVpZ2h0KCk7XG4gICAgICAgIGlmIChoaWdoX2JvdHRvbSA+PSB2aXNpYmxlX2JvdHRvbSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLnNjcm9sbFRvcCgoaGlnaF9ib3R0b20gLSBtYXhIZWlnaHQpID4gMCA/IGhpZ2hfYm90dG9tIC0gbWF4SGVpZ2h0IDogMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGlnaF90b3AgPCB2aXNpYmxlX3RvcCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLnNjcm9sbFRvcChoaWdoX3RvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRfaGlnaGxpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVzdWx0X2hpZ2hsaWdodC5yZW1vdmVDbGFzcyhcImhpZ2hsaWdodGVkXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0X2hpZ2hsaWdodCA9IG51bGw7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSAmJiB0aGlzLm1heF9zZWxlY3RlZF9vcHRpb25zIDw9IHRoaXMuY2hvaWNlc19jb3VudCgpKSB7XG4gICAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hvc2VuOm1heHNlbGVjdGVkXCIsIHtcbiAgICAgICAgICBjaG9zZW46IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKFwiY2hvc2VuLXdpdGgtZHJvcFwiKTtcbiAgICAgIHRoaXMucmVzdWx0c19zaG93aW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLmZvY3VzKCk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZC52YWwodGhpcy5nZXRfc2VhcmNoX2ZpZWxkX3ZhbHVlKCkpO1xuICAgICAgdGhpcy53aW5ub3dfcmVzdWx0cygpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hvc2VuOnNob3dpbmdfZHJvcGRvd25cIiwge1xuICAgICAgICBjaG9zZW46IHRoaXNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnVwZGF0ZV9yZXN1bHRzX2NvbnRlbnQgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWFyY2hfcmVzdWx0cy5odG1sKGNvbnRlbnQpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImNob3Nlbi13aXRoLWRyb3BcIik7XG4gICAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hvc2VuOmhpZGluZ19kcm9wZG93blwiLCB7XG4gICAgICAgICAgY2hvc2VuOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zaG93aW5nID0gZmFsc2U7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2V0X3RhYl9pbmRleCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgdGk7XG4gICAgICBpZiAodGhpcy5mb3JtX2ZpZWxkLnRhYkluZGV4KSB7XG4gICAgICAgIHRpID0gdGhpcy5mb3JtX2ZpZWxkLnRhYkluZGV4O1xuICAgICAgICB0aGlzLmZvcm1fZmllbGQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX2ZpZWxkWzBdLnRhYkluZGV4ID0gdGk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2V0X2xhYmVsX2JlaGF2aW9yID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmZvcm1fZmllbGRfbGFiZWwgPSB0aGlzLmZvcm1fZmllbGRfanEucGFyZW50cyhcImxhYmVsXCIpO1xuICAgICAgaWYgKCF0aGlzLmZvcm1fZmllbGRfbGFiZWwubGVuZ3RoICYmIHRoaXMuZm9ybV9maWVsZC5pZC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5mb3JtX2ZpZWxkX2xhYmVsID0gJChcImxhYmVsW2Zvcj0nXCIgKyB0aGlzLmZvcm1fZmllbGQuaWQgKyBcIiddXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZm9ybV9maWVsZF9sYWJlbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1fZmllbGRfbGFiZWwuYmluZCgnY2xpY2suY2hvc2VuJywgdGhpcy5sYWJlbF9jbGlja19oYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5zaG93X3NlYXJjaF9maWVsZF9kZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSAmJiB0aGlzLmNob2ljZXNfY291bnQoKSA8IDEgJiYgIXRoaXMuYWN0aXZlX2ZpZWxkKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCh0aGlzLmRlZmF1bHRfdGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5hZGRDbGFzcyhcImRlZmF1bHRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlYXJjaF9maWVsZC52YWwoXCJcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5yZW1vdmVDbGFzcyhcImRlZmF1bHRcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX3Jlc3VsdHNfbW91c2V1cCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIHRhcmdldDtcbiAgICAgIHRhcmdldCA9ICQoZXZ0LnRhcmdldCkuaGFzQ2xhc3MoXCJhY3RpdmUtcmVzdWx0XCIpID8gJChldnQudGFyZ2V0KSA6ICQoZXZ0LnRhcmdldCkucGFyZW50cyhcIi5hY3RpdmUtcmVzdWx0XCIpLmZpcnN0KCk7XG4gICAgICBpZiAodGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLnJlc3VsdF9oaWdobGlnaHQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucmVzdWx0X3NlbGVjdChldnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfZmllbGQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5zZWFyY2hfcmVzdWx0c19tb3VzZW92ZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSAkKGV2dC50YXJnZXQpLmhhc0NsYXNzKFwiYWN0aXZlLXJlc3VsdFwiKSA/ICQoZXZ0LnRhcmdldCkgOiAkKGV2dC50YXJnZXQpLnBhcmVudHMoXCIuYWN0aXZlLXJlc3VsdFwiKS5maXJzdCgpO1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfZG9faGlnaGxpZ2h0KHRhcmdldCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX3Jlc3VsdHNfbW91c2VvdXQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmICgkKGV2dC50YXJnZXQpLmhhc0NsYXNzKFwiYWN0aXZlLXJlc3VsdFwiIHx8ICQoZXZ0LnRhcmdldCkucGFyZW50cygnLmFjdGl2ZS1yZXN1bHQnKS5maXJzdCgpKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2hvaWNlX2J1aWxkID0gZnVuY3Rpb24oaXRlbSkge1xuICAgICAgdmFyIGNob2ljZSwgY2xvc2VfbGluayxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgY2hvaWNlID0gJCgnPGxpIC8+Jywge1xuICAgICAgICBcImNsYXNzXCI6IFwic2VhcmNoLWNob2ljZVwiXG4gICAgICB9KS5odG1sKFwiPHNwYW4+XCIgKyAodGhpcy5jaG9pY2VfbGFiZWwoaXRlbSkpICsgXCI8L3NwYW4+XCIpO1xuICAgICAgaWYgKGl0ZW0uZGlzYWJsZWQpIHtcbiAgICAgICAgY2hvaWNlLmFkZENsYXNzKCdzZWFyY2gtY2hvaWNlLWRpc2FibGVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9zZV9saW5rID0gJCgnPGEgLz4nLCB7XG4gICAgICAgICAgXCJjbGFzc1wiOiAnc2VhcmNoLWNob2ljZS1jbG9zZScsXG4gICAgICAgICAgJ2RhdGEtb3B0aW9uLWFycmF5LWluZGV4JzogaXRlbS5hcnJheV9pbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgY2xvc2VfbGluay5iaW5kKCdjbGljay5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY2hvaWNlX2Rlc3Ryb3lfbGlua19jbGljayhldnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hvaWNlLmFwcGVuZChjbG9zZV9saW5rKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9jb250YWluZXIuYmVmb3JlKGNob2ljZSk7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2hvaWNlX2Rlc3Ryb3lfbGlua19jbGljayA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBpZiAoIXRoaXMuaXNfZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hvaWNlX2Rlc3Ryb3koJChldnQudGFyZ2V0KSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2hvaWNlX2Rlc3Ryb3kgPSBmdW5jdGlvbihsaW5rKSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRfZGVzZWxlY3QobGlua1swXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW9wdGlvbi1hcnJheS1pbmRleFwiKSkpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlX2ZpZWxkKSB7XG4gICAgICAgICAgdGhpcy5zZWFyY2hfZmllbGQuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNob3dfc2VhcmNoX2ZpZWxkX2RlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSAmJiB0aGlzLmNob2ljZXNfY291bnQoKSA+IDAgJiYgdGhpcy5nZXRfc2VhcmNoX2ZpZWxkX3ZhbHVlKCkubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRoaXMucmVzdWx0c19oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGluay5wYXJlbnRzKCdsaScpLmZpcnN0KCkucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZF9zY2FsZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfcmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVzZXRfc2luZ2xlX3NlbGVjdF9vcHRpb25zKCk7XG4gICAgICB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICB0aGlzLnNpbmdsZV9zZXRfc2VsZWN0ZWRfdGV4dCgpO1xuICAgICAgdGhpcy5zaG93X3NlYXJjaF9maWVsZF9kZWZhdWx0KCk7XG4gICAgICB0aGlzLnJlc3VsdHNfcmVzZXRfY2xlYW51cCgpO1xuICAgICAgdGhpcy50cmlnZ2VyX2Zvcm1fZmllbGRfY2hhbmdlKCk7XG4gICAgICBpZiAodGhpcy5hY3RpdmVfZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19oaWRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19yZXNldF9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmN1cnJlbnRfc2VsZWN0ZWRJbmRleCA9IHRoaXMuZm9ybV9maWVsZC5zZWxlY3RlZEluZGV4O1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRfaXRlbS5maW5kKFwiYWJiclwiKS5yZW1vdmUoKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRfc2VsZWN0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgaGlnaCwgaXRlbTtcbiAgICAgIGlmICh0aGlzLnJlc3VsdF9oaWdobGlnaHQpIHtcbiAgICAgICAgaGlnaCA9IHRoaXMucmVzdWx0X2hpZ2hsaWdodDtcbiAgICAgICAgdGhpcy5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0KCk7XG4gICAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlICYmIHRoaXMubWF4X3NlbGVjdGVkX29wdGlvbnMgPD0gdGhpcy5jaG9pY2VzX2NvdW50KCkpIHtcbiAgICAgICAgICB0aGlzLmZvcm1fZmllbGRfanEudHJpZ2dlcihcImNob3NlbjptYXhzZWxlY3RlZFwiLCB7XG4gICAgICAgICAgICBjaG9zZW46IHRoaXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICBoaWdoLnJlbW92ZUNsYXNzKFwiYWN0aXZlLXJlc3VsdFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlc2V0X3NpbmdsZV9zZWxlY3Rfb3B0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIGhpZ2guYWRkQ2xhc3MoXCJyZXN1bHQtc2VsZWN0ZWRcIik7XG4gICAgICAgIGl0ZW0gPSB0aGlzLnJlc3VsdHNfZGF0YVtoaWdoWzBdLmdldEF0dHJpYnV0ZShcImRhdGEtb3B0aW9uLWFycmF5LWluZGV4XCIpXTtcbiAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZm9ybV9maWVsZC5vcHRpb25zW2l0ZW0ub3B0aW9uc19pbmRleF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkX29wdGlvbl9jb3VudCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgICAgdGhpcy5jaG9pY2VfYnVpbGQoaXRlbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zaW5nbGVfc2V0X3NlbGVjdGVkX3RleHQodGhpcy5jaG9pY2VfbGFiZWwoaXRlbSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHRoaXMuaXNfbXVsdGlwbGUgJiYgKCF0aGlzLmhpZGVfcmVzdWx0c19vbl9zZWxlY3QgfHwgKGV2dC5tZXRhS2V5IHx8IGV2dC5jdHJsS2V5KSkpKSB7XG4gICAgICAgICAgdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgICAgICB0aGlzLnNob3dfc2VhcmNoX2ZpZWxkX2RlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSB8fCB0aGlzLmZvcm1fZmllbGQuc2VsZWN0ZWRJbmRleCAhPT0gdGhpcy5jdXJyZW50X3NlbGVjdGVkSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXJfZm9ybV9maWVsZF9jaGFuZ2Uoe1xuICAgICAgICAgICAgc2VsZWN0ZWQ6IHRoaXMuZm9ybV9maWVsZC5vcHRpb25zW2l0ZW0ub3B0aW9uc19pbmRleF0udmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRfc2VsZWN0ZWRJbmRleCA9IHRoaXMuZm9ybV9maWVsZC5zZWxlY3RlZEluZGV4O1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX2ZpZWxkX3NjYWxlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2luZ2xlX3NldF9zZWxlY3RlZF90ZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgaWYgKHRleHQgPT0gbnVsbCkge1xuICAgICAgICB0ZXh0ID0gdGhpcy5kZWZhdWx0X3RleHQ7XG4gICAgICB9XG4gICAgICBpZiAodGV4dCA9PT0gdGhpcy5kZWZhdWx0X3RleHQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZF9pdGVtLmFkZENsYXNzKFwiY2hvc2VuLWRlZmF1bHRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNpbmdsZV9kZXNlbGVjdF9jb250cm9sX2J1aWxkKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbS5yZW1vdmVDbGFzcyhcImNob3Nlbi1kZWZhdWx0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRfaXRlbS5maW5kKFwic3BhblwiKS5odG1sKHRleHQpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9kZXNlbGVjdCA9IGZ1bmN0aW9uKHBvcykge1xuICAgICAgdmFyIHJlc3VsdF9kYXRhO1xuICAgICAgcmVzdWx0X2RhdGEgPSB0aGlzLnJlc3VsdHNfZGF0YVtwb3NdO1xuICAgICAgaWYgKCF0aGlzLmZvcm1fZmllbGQub3B0aW9uc1tyZXN1bHRfZGF0YS5vcHRpb25zX2luZGV4XS5kaXNhYmxlZCkge1xuICAgICAgICByZXN1bHRfZGF0YS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1tyZXN1bHRfZGF0YS5vcHRpb25zX2luZGV4XS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkX29wdGlvbl9jb3VudCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgICB0aGlzLndpbm5vd19yZXN1bHRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmlnZ2VyX2Zvcm1fZmllbGRfY2hhbmdlKHtcbiAgICAgICAgICBkZXNlbGVjdGVkOiB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1tyZXN1bHRfZGF0YS5vcHRpb25zX2luZGV4XS52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZWFyY2hfZmllbGRfc2NhbGUoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2luZ2xlX2Rlc2VsZWN0X2NvbnRyb2xfYnVpbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5hbGxvd19zaW5nbGVfZGVzZWxlY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnNlbGVjdGVkX2l0ZW0uZmluZChcImFiYnJcIikubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbS5maW5kKFwic3BhblwiKS5maXJzdCgpLmFmdGVyKFwiPGFiYnIgY2xhc3M9XFxcInNlYXJjaC1jaG9pY2UtY2xvc2VcXFwiPjwvYWJicj5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZF9pdGVtLmFkZENsYXNzKFwiY2hvc2VuLXNpbmdsZS13aXRoLWRlc2VsZWN0XCIpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmdldF9zZWFyY2hfZmllbGRfdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC52YWwoKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5nZXRfc2VhcmNoX3RleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVzY2FwZV9odG1sKCQudHJpbSh0aGlzLmdldF9zZWFyY2hfZmllbGRfdmFsdWUoKSkpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmVzY2FwZV9odG1sID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgcmV0dXJuICQoJzxkaXYvPicpLnRleHQodGV4dCkuaHRtbCgpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLndpbm5vd19yZXN1bHRzX3NldF9oaWdobGlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkb19oaWdoLCBzZWxlY3RlZF9yZXN1bHRzO1xuICAgICAgc2VsZWN0ZWRfcmVzdWx0cyA9ICF0aGlzLmlzX211bHRpcGxlID8gdGhpcy5zZWFyY2hfcmVzdWx0cy5maW5kKFwiLnJlc3VsdC1zZWxlY3RlZC5hY3RpdmUtcmVzdWx0XCIpIDogW107XG4gICAgICBkb19oaWdoID0gc2VsZWN0ZWRfcmVzdWx0cy5sZW5ndGggPyBzZWxlY3RlZF9yZXN1bHRzLmZpcnN0KCkgOiB0aGlzLnNlYXJjaF9yZXN1bHRzLmZpbmQoXCIuYWN0aXZlLXJlc3VsdFwiKS5maXJzdCgpO1xuICAgICAgaWYgKGRvX2hpZ2ggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfZG9faGlnaGxpZ2h0KGRvX2hpZ2gpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLm5vX3Jlc3VsdHMgPSBmdW5jdGlvbih0ZXJtcykge1xuICAgICAgdmFyIG5vX3Jlc3VsdHNfaHRtbDtcbiAgICAgIG5vX3Jlc3VsdHNfaHRtbCA9IHRoaXMuZ2V0X25vX3Jlc3VsdHNfaHRtbCh0ZXJtcyk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzLmFwcGVuZChub19yZXN1bHRzX2h0bWwpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hvc2VuOm5vX3Jlc3VsdHNcIiwge1xuICAgICAgICBjaG9zZW46IHRoaXNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLm5vX3Jlc3VsdHNfY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLmZpbmQoXCIubm8tcmVzdWx0c1wiKS5yZW1vdmUoKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5rZXlkb3duX2Fycm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV4dF9zaWI7XG4gICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcgJiYgdGhpcy5yZXN1bHRfaGlnaGxpZ2h0KSB7XG4gICAgICAgIG5leHRfc2liID0gdGhpcy5yZXN1bHRfaGlnaGxpZ2h0Lm5leHRBbGwoXCJsaS5hY3RpdmUtcmVzdWx0XCIpLmZpcnN0KCk7XG4gICAgICAgIGlmIChuZXh0X3NpYikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdF9kb19oaWdobGlnaHQobmV4dF9zaWIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3Nob3coKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5rZXl1cF9hcnJvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHByZXZfc2licztcbiAgICAgIGlmICghdGhpcy5yZXN1bHRzX3Nob3dpbmcgJiYgIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zaG93KCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVzdWx0X2hpZ2hsaWdodCkge1xuICAgICAgICBwcmV2X3NpYnMgPSB0aGlzLnJlc3VsdF9oaWdobGlnaHQucHJldkFsbChcImxpLmFjdGl2ZS1yZXN1bHRcIik7XG4gICAgICAgIGlmIChwcmV2X3NpYnMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0X2RvX2hpZ2hsaWdodChwcmV2X3NpYnMuZmlyc3QoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2hvaWNlc19jb3VudCgpID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUua2V5ZG93bl9iYWNrc3Ryb2tlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV4dF9hdmFpbGFibGVfZGVzdHJveTtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdfYmFja3N0cm9rZSkge1xuICAgICAgICB0aGlzLmNob2ljZV9kZXN0cm95KHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlLmZpbmQoXCJhXCIpLmZpcnN0KCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jbGVhcl9iYWNrc3Ryb2tlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0X2F2YWlsYWJsZV9kZXN0cm95ID0gdGhpcy5zZWFyY2hfY29udGFpbmVyLnNpYmxpbmdzKFwibGkuc2VhcmNoLWNob2ljZVwiKS5sYXN0KCk7XG4gICAgICAgIGlmIChuZXh0X2F2YWlsYWJsZV9kZXN0cm95Lmxlbmd0aCAmJiAhbmV4dF9hdmFpbGFibGVfZGVzdHJveS5oYXNDbGFzcyhcInNlYXJjaC1jaG9pY2UtZGlzYWJsZWRcIikpIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdfYmFja3N0cm9rZSA9IG5leHRfYXZhaWxhYmxlX2Rlc3Ryb3k7XG4gICAgICAgICAgaWYgKHRoaXMuc2luZ2xlX2JhY2tzdHJva2VfZGVsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlkb3duX2JhY2tzdHJva2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlLmFkZENsYXNzKFwic2VhcmNoLWNob2ljZS1mb2N1c1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5jbGVhcl9iYWNrc3Ryb2tlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nX2JhY2tzdHJva2UpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nX2JhY2tzdHJva2UucmVtb3ZlQ2xhc3MoXCJzZWFyY2gtY2hvaWNlLWZvY3VzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5zZWFyY2hfZmllbGRfc2NhbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb250YWluZXJfd2lkdGgsIGRpdiwgc3R5bGUsIHN0eWxlX2Jsb2NrLCBzdHlsZXMsIHdpZHRoLCBfaSwgX2xlbjtcbiAgICAgIGlmICghdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdHlsZV9ibG9jayA9IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIGxlZnQ6ICctMTAwMHB4JyxcbiAgICAgICAgdG9wOiAnLTEwMDBweCcsXG4gICAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgICAgd2hpdGVTcGFjZTogJ3ByZSdcbiAgICAgIH07XG4gICAgICBzdHlsZXMgPSBbJ2ZvbnRTaXplJywgJ2ZvbnRTdHlsZScsICdmb250V2VpZ2h0JywgJ2ZvbnRGYW1pbHknLCAnbGluZUhlaWdodCcsICd0ZXh0VHJhbnNmb3JtJywgJ2xldHRlclNwYWNpbmcnXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gc3R5bGVzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHN0eWxlID0gc3R5bGVzW19pXTtcbiAgICAgICAgc3R5bGVfYmxvY2tbc3R5bGVdID0gdGhpcy5zZWFyY2hfZmllbGQuY3NzKHN0eWxlKTtcbiAgICAgIH1cbiAgICAgIGRpdiA9ICQoJzxkaXYgLz4nKS5jc3Moc3R5bGVfYmxvY2spO1xuICAgICAgZGl2LnRleHQodGhpcy5nZXRfc2VhcmNoX2ZpZWxkX3ZhbHVlKCkpO1xuICAgICAgJCgnYm9keScpLmFwcGVuZChkaXYpO1xuICAgICAgd2lkdGggPSBkaXYud2lkdGgoKSArIDI1O1xuICAgICAgZGl2LnJlbW92ZSgpO1xuICAgICAgY29udGFpbmVyX3dpZHRoID0gdGhpcy5jb250YWluZXIub3V0ZXJXaWR0aCgpO1xuICAgICAgd2lkdGggPSBNYXRoLm1pbihjb250YWluZXJfd2lkdGggLSAxMCwgd2lkdGgpO1xuICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX2ZpZWxkLndpZHRoKHdpZHRoKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS50cmlnZ2VyX2Zvcm1fZmllbGRfY2hhbmdlID0gZnVuY3Rpb24oZXh0cmEpIHtcbiAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiaW5wdXRcIiwgZXh0cmEpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hhbmdlXCIsIGV4dHJhKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENob3NlbjtcblxuICB9KShBYnN0cmFjdENob3Nlbik7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCJEcm9wem9uZS5hdXRvRGlzY292ZXIgPSBmYWxzZTtcblxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICQoJy5kcm9wem9uZVtkYXRhLWZpbGVzXVtkYXRhLXVybF0nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRkcm9wem9uZSA9ICQodGhpcyk7XG5cbiAgICAgICAgdmFyICRmaWxlcyA9ICRkcm9wem9uZS5wYXJlbnRzKCdmb3JtJykuZmlyc3QoKS5maW5kKCRkcm9wem9uZS5kYXRhKCdmaWxlcycpICsgJ1tkYXRhLXByb3RvdHlwZV0nKTtcbiAgICAgICAgdmFyIGZpbGVQcm90b3R5cGUgPSAkZmlsZXMuZGF0YSgncHJvdG90eXBlJyk7XG5cbiAgICAgICAgdmFyIGRlZmF1bHRNZXNzYWdlID0gVHJhbnNsYXRvci50cmFucygnZHJvcHpvbmUuZGVmYXVsdF9tZXNzYWdlJyk7XG5cbiAgICAgICAgaWYgKCRkcm9wem9uZS5kYXRhKCdkZXNjcmlwdGlvbicpKSB7XG4gICAgICAgICAgICBkZWZhdWx0TWVzc2FnZSArPSAnPGJyPjxicj48Yj4nICsgVHJhbnNsYXRvci50cmFucygkZHJvcHpvbmUuZGF0YSgnZGVzY3JpcHRpb24nKSkgKyAnPC9iPic7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHJvcHpvbmUgPSBuZXcgRHJvcHpvbmUoJyMnICsgJGRyb3B6b25lLmF0dHIoJ2lkJyksIHtcbiAgICAgICAgICAgIGFjY2VwdGVkRmlsZXM6ICAgICAgICRkcm9wem9uZS5kYXRhKCdhY2NlcHRlZC1maWxlcycpLFxuICAgICAgICAgICAgYWRkUmVtb3ZlTGlua3M6ICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIGRpY3REZWZhdWx0TWVzc2FnZTogIGRlZmF1bHRNZXNzYWdlLFxuICAgICAgICAgICAgZGljdEZpbGVUb29CaWc6ICAgICAgVHJhbnNsYXRvci50cmFucygnZHJvcHpvbmUuZmlsZV90b29fYmlnJyksXG4gICAgICAgICAgICBkaWN0SW52YWxpZEZpbGVUeXBlOiBUcmFuc2xhdG9yLnRyYW5zKCdkcm9wem9uZS5pbnZhbGlkX2ZpbGVfdHlwZScpLFxuICAgICAgICAgICAgZGljdFJlbW92ZUZpbGU6ICAgICAgVHJhbnNsYXRvci50cmFucygnZHJvcHpvbmUucmVtb3ZlX2ZpbGUnKSxcbiAgICAgICAgICAgIGZpbGVzaXplQmFzZTogICAgICAgIDEwMjQsXG4gICAgICAgICAgICBtYXhGaWxlc2l6ZTogICAgICAgICAkZHJvcHpvbmUuZGF0YSgnbWF4LWZpbGVzaXplJyksXG4gICAgICAgICAgICB1cmw6ICAgICAgICAgICAgICAgICAkZHJvcHpvbmUuZGF0YSgndXJsJylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZHJvcHpvbmVcbiAgICAgICAgICAgIC5vbignc3VjY2VzcycsIGZ1bmN0aW9uIChmaWxlLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHZhciAkZmlsZSA9ICQoZmlsZVByb3RvdHlwZS5yZXBsYWNlKC9fX25hbWVfXy9nLCAkZmlsZXMuY2hpbGRyZW4oKS5sZW5ndGgpKTtcblxuICAgICAgICAgICAgICAgICRmaWxlLmZpbmQoJy5maWxlbmFtZScpLnZhbChyZXNwb25zZVswXSk7XG4gICAgICAgICAgICAgICAgJGZpbGUuZmluZCgnLm9yaWdpbmFsX2ZpbGVuYW1lJykudmFsKGZpbGUubmFtZSk7XG5cbiAgICAgICAgICAgICAgICAkZmlsZXMuYXBwZW5kKCRmaWxlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ3JlbW92ZWRmaWxlJywgZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAkZmlsZXMuZmluZCgnLm9yaWdpbmFsX2ZpbGVuYW1lW3ZhbHVlPVwiJyArIGZpbGUubmFtZSArICdcIl0nKS5wYXJlbnRzKCcudGFibGVfcm93OmZpcnN0JykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuIiwiLyohXG5cdENvbG9yYm94IDEuNi40XG5cdGxpY2Vuc2U6IE1JVFxuXHRodHRwOi8vd3d3LmphY2tsbW9vcmUuY29tL2NvbG9yYm94XG4qL1xuKGZ1bmN0aW9uICgkLCBkb2N1bWVudCwgd2luZG93KSB7XG5cdHZhclxuXHQvLyBEZWZhdWx0IHNldHRpbmdzIG9iamVjdC5cblx0Ly8gU2VlIGh0dHA6Ly9qYWNrbG1vb3JlLmNvbS9jb2xvcmJveCBmb3IgZGV0YWlscy5cblx0ZGVmYXVsdHMgPSB7XG5cdFx0Ly8gZGF0YSBzb3VyY2VzXG5cdFx0aHRtbDogZmFsc2UsXG5cdFx0cGhvdG86IGZhbHNlLFxuXHRcdGlmcmFtZTogZmFsc2UsXG5cdFx0aW5saW5lOiBmYWxzZSxcblxuXHRcdC8vIGJlaGF2aW9yIGFuZCBhcHBlYXJhbmNlXG5cdFx0dHJhbnNpdGlvbjogXCJlbGFzdGljXCIsXG5cdFx0c3BlZWQ6IDMwMCxcblx0XHRmYWRlT3V0OiAzMDAsXG5cdFx0d2lkdGg6IGZhbHNlLFxuXHRcdGluaXRpYWxXaWR0aDogXCI2MDBcIixcblx0XHRpbm5lcldpZHRoOiBmYWxzZSxcblx0XHRtYXhXaWR0aDogZmFsc2UsXG5cdFx0aGVpZ2h0OiBmYWxzZSxcblx0XHRpbml0aWFsSGVpZ2h0OiBcIjQ1MFwiLFxuXHRcdGlubmVySGVpZ2h0OiBmYWxzZSxcblx0XHRtYXhIZWlnaHQ6IGZhbHNlLFxuXHRcdHNjYWxlUGhvdG9zOiB0cnVlLFxuXHRcdHNjcm9sbGluZzogdHJ1ZSxcblx0XHRvcGFjaXR5OiAwLjksXG5cdFx0cHJlbG9hZGluZzogdHJ1ZSxcblx0XHRjbGFzc05hbWU6IGZhbHNlLFxuXHRcdG92ZXJsYXlDbG9zZTogdHJ1ZSxcblx0XHRlc2NLZXk6IHRydWUsXG5cdFx0YXJyb3dLZXk6IHRydWUsXG5cdFx0dG9wOiBmYWxzZSxcblx0XHRib3R0b206IGZhbHNlLFxuXHRcdGxlZnQ6IGZhbHNlLFxuXHRcdHJpZ2h0OiBmYWxzZSxcblx0XHRmaXhlZDogZmFsc2UsXG5cdFx0ZGF0YTogdW5kZWZpbmVkLFxuXHRcdGNsb3NlQnV0dG9uOiB0cnVlLFxuXHRcdGZhc3RJZnJhbWU6IHRydWUsXG5cdFx0b3BlbjogZmFsc2UsXG5cdFx0cmVwb3NpdGlvbjogdHJ1ZSxcblx0XHRsb29wOiB0cnVlLFxuXHRcdHNsaWRlc2hvdzogZmFsc2UsXG5cdFx0c2xpZGVzaG93QXV0bzogdHJ1ZSxcblx0XHRzbGlkZXNob3dTcGVlZDogMjUwMCxcblx0XHRzbGlkZXNob3dTdGFydDogXCJzdGFydCBzbGlkZXNob3dcIixcblx0XHRzbGlkZXNob3dTdG9wOiBcInN0b3Agc2xpZGVzaG93XCIsXG5cdFx0cGhvdG9SZWdleDogL1xcLihnaWZ8cG5nfGpwKGV8Z3xlZyl8Ym1wfGljb3x3ZWJwfGp4cnxzdmcpKCgjfFxcPykuKik/JC9pLFxuXG5cdFx0Ly8gYWx0ZXJuYXRlIGltYWdlIHBhdGhzIGZvciBoaWdoLXJlcyBkaXNwbGF5c1xuXHRcdHJldGluYUltYWdlOiBmYWxzZSxcblx0XHRyZXRpbmFVcmw6IGZhbHNlLFxuXHRcdHJldGluYVN1ZmZpeDogJ0AyeC4kMScsXG5cblx0XHQvLyBpbnRlcm5hdGlvbmFsaXphdGlvblxuXHRcdGN1cnJlbnQ6IFwiaW1hZ2Uge2N1cnJlbnR9IG9mIHt0b3RhbH1cIixcblx0XHRwcmV2aW91czogXCJwcmV2aW91c1wiLFxuXHRcdG5leHQ6IFwibmV4dFwiLFxuXHRcdGNsb3NlOiBcImNsb3NlXCIsXG5cdFx0eGhyRXJyb3I6IFwiVGhpcyBjb250ZW50IGZhaWxlZCB0byBsb2FkLlwiLFxuXHRcdGltZ0Vycm9yOiBcIlRoaXMgaW1hZ2UgZmFpbGVkIHRvIGxvYWQuXCIsXG5cblx0XHQvLyBhY2Nlc3NiaWxpdHlcblx0XHRyZXR1cm5Gb2N1czogdHJ1ZSxcblx0XHR0cmFwRm9jdXM6IHRydWUsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRvbk9wZW46IGZhbHNlLFxuXHRcdG9uTG9hZDogZmFsc2UsXG5cdFx0b25Db21wbGV0ZTogZmFsc2UsXG5cdFx0b25DbGVhbnVwOiBmYWxzZSxcblx0XHRvbkNsb3NlZDogZmFsc2UsXG5cblx0XHRyZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVsO1xuXHRcdH0sXG5cdFx0aHJlZjogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyB1c2luZyB0aGlzLmhyZWYgd291bGQgZ2l2ZSB0aGUgYWJzb2x1dGUgdXJsLCB3aGVuIHRoZSBocmVmIG1heSBoYXZlIGJlZW4gaW50ZWRlZCBhcyBhIHNlbGVjdG9yIChlLmcuICcjY29udGFpbmVyJylcblx0XHRcdHJldHVybiAkKHRoaXMpLmF0dHIoJ2hyZWYnKTtcblx0XHR9LFxuXHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnRpdGxlO1xuXHRcdH0sXG5cdFx0Y3JlYXRlSW1nOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcblx0XHRcdHZhciBhdHRycyA9ICQodGhpcykuZGF0YSgnY2JveC1pbWctYXR0cnMnKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhdHRycyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0JC5lYWNoKGF0dHJzLCBmdW5jdGlvbihrZXksIHZhbCl7XG5cdFx0XHRcdFx0aW1nW2tleV0gPSB2YWw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW1nO1xuXHRcdH0sXG5cdFx0Y3JlYXRlSWZyYW1lOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblx0XHRcdHZhciBhdHRycyA9ICQodGhpcykuZGF0YSgnY2JveC1pZnJhbWUtYXR0cnMnKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhdHRycyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0JC5lYWNoKGF0dHJzLCBmdW5jdGlvbihrZXksIHZhbCl7XG5cdFx0XHRcdFx0aWZyYW1lW2tleV0gPSB2YWw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoJ2ZyYW1lQm9yZGVyJyBpbiBpZnJhbWUpIHtcblx0XHRcdFx0aWZyYW1lLmZyYW1lQm9yZGVyID0gMDtcblx0XHRcdH1cblx0XHRcdGlmICgnYWxsb3dUcmFuc3BhcmVuY3knIGluIGlmcmFtZSkge1xuXHRcdFx0XHRpZnJhbWUuYWxsb3dUcmFuc3BhcmVuY3kgPSBcInRydWVcIjtcblx0XHRcdH1cblx0XHRcdGlmcmFtZS5uYW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTsgLy8gZ2l2ZSB0aGUgaWZyYW1lIGEgdW5pcXVlIG5hbWUgdG8gcHJldmVudCBjYWNoaW5nXG5cdFx0XHRpZnJhbWUuYWxsb3dGdWxsc2NyZWVuID0gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIGlmcmFtZTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQWJzdHJhY3RpbmcgdGhlIEhUTUwgYW5kIGV2ZW50IGlkZW50aWZpZXJzIGZvciBlYXN5IHJlYnJhbmRpbmdcblx0Y29sb3Jib3ggPSAnY29sb3Jib3gnLFxuXHRwcmVmaXggPSAnY2JveCcsXG5cdGJveEVsZW1lbnQgPSBwcmVmaXggKyAnRWxlbWVudCcsXG5cblx0Ly8gRXZlbnRzXG5cdGV2ZW50X29wZW4gPSBwcmVmaXggKyAnX29wZW4nLFxuXHRldmVudF9sb2FkID0gcHJlZml4ICsgJ19sb2FkJyxcblx0ZXZlbnRfY29tcGxldGUgPSBwcmVmaXggKyAnX2NvbXBsZXRlJyxcblx0ZXZlbnRfY2xlYW51cCA9IHByZWZpeCArICdfY2xlYW51cCcsXG5cdGV2ZW50X2Nsb3NlZCA9IHByZWZpeCArICdfY2xvc2VkJyxcblx0ZXZlbnRfcHVyZ2UgPSBwcmVmaXggKyAnX3B1cmdlJyxcblxuXHQvLyBDYWNoZWQgalF1ZXJ5IE9iamVjdCBWYXJpYWJsZXNcblx0JG92ZXJsYXksXG5cdCRib3gsXG5cdCR3cmFwLFxuXHQkY29udGVudCxcblx0JHRvcEJvcmRlcixcblx0JGxlZnRCb3JkZXIsXG5cdCRyaWdodEJvcmRlcixcblx0JGJvdHRvbUJvcmRlcixcblx0JHJlbGF0ZWQsXG5cdCR3aW5kb3csXG5cdCRsb2FkZWQsXG5cdCRsb2FkaW5nQmF5LFxuXHQkbG9hZGluZ092ZXJsYXksXG5cdCR0aXRsZSxcblx0JGN1cnJlbnQsXG5cdCRzbGlkZXNob3csXG5cdCRuZXh0LFxuXHQkcHJldixcblx0JGNsb3NlLFxuXHQkZ3JvdXBDb250cm9scyxcblx0JGV2ZW50cyA9ICQoJzxhLz4nKSwgLy8gJCh7fSkgd291bGQgYmUgcHJlZmVyZWQsIGJ1dCB0aGVyZSBpcyBhbiBpc3N1ZSB3aXRoIGpRdWVyeSAxLjQuMlxuXG5cdC8vIFZhcmlhYmxlcyBmb3IgY2FjaGVkIHZhbHVlcyBvciB1c2UgYWNyb3NzIG11bHRpcGxlIGZ1bmN0aW9uc1xuXHRzZXR0aW5ncyxcblx0aW50ZXJmYWNlSGVpZ2h0LFxuXHRpbnRlcmZhY2VXaWR0aCxcblx0bG9hZGVkSGVpZ2h0LFxuXHRsb2FkZWRXaWR0aCxcblx0aW5kZXgsXG5cdHBob3RvLFxuXHRvcGVuLFxuXHRhY3RpdmUsXG5cdGNsb3NpbmcsXG5cdGxvYWRpbmdUaW1lcixcblx0cHVibGljTWV0aG9kLFxuXHRkaXYgPSBcImRpdlwiLFxuXHRyZXF1ZXN0cyA9IDAsXG5cdHByZXZpb3VzQ1NTID0ge30sXG5cdGluaXQ7XG5cblx0Ly8gKioqKioqKioqKioqKioqKlxuXHQvLyBIRUxQRVIgRlVOQ1RJT05TXG5cdC8vICoqKioqKioqKioqKioqKipcblxuXHQvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgbmV3IGpRdWVyeSBvYmplY3RzXG5cdGZ1bmN0aW9uICR0YWcodGFnLCBpZCwgY3NzKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG5cblx0XHRpZiAoaWQpIHtcblx0XHRcdGVsZW1lbnQuaWQgPSBwcmVmaXggKyBpZDtcblx0XHR9XG5cblx0XHRpZiAoY3NzKSB7XG5cdFx0XHRlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBjc3M7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICQoZWxlbWVudCk7XG5cdH1cblxuXHQvLyBHZXQgdGhlIHdpbmRvdyBoZWlnaHQgdXNpbmcgaW5uZXJIZWlnaHQgd2hlbiBhdmFpbGFibGUgdG8gYXZvaWQgYW4gaXNzdWUgd2l0aCBpT1Ncblx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNjcyNFxuXHRmdW5jdGlvbiB3aW5oZWlnaHQoKSB7XG5cdFx0cmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCA/IHdpbmRvdy5pbm5lckhlaWdodCA6ICQod2luZG93KS5oZWlnaHQoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIFNldHRpbmdzKGVsZW1lbnQsIG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucyAhPT0gT2JqZWN0KG9wdGlvbnMpKSB7XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0fVxuXG5cdFx0dGhpcy5jYWNoZSA9IHt9O1xuXHRcdHRoaXMuZWwgPSBlbGVtZW50O1xuXG5cdFx0dGhpcy52YWx1ZSA9IGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0dmFyIGRhdGFBdHRyO1xuXG5cdFx0XHRpZiAodGhpcy5jYWNoZVtrZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZGF0YUF0dHIgPSAkKHRoaXMuZWwpLmF0dHIoJ2RhdGEtY2JveC0nK2tleSk7XG5cblx0XHRcdFx0aWYgKGRhdGFBdHRyICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aGlzLmNhY2hlW2tleV0gPSBkYXRhQXR0cjtcblx0XHRcdFx0fSBlbHNlIGlmIChvcHRpb25zW2tleV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRoaXMuY2FjaGVba2V5XSA9IG9wdGlvbnNba2V5XTtcblx0XHRcdFx0fSBlbHNlIGlmIChkZWZhdWx0c1trZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aGlzLmNhY2hlW2tleV0gPSBkZWZhdWx0c1trZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmNhY2hlW2tleV07XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlKGtleSk7XG5cdFx0XHRyZXR1cm4gJC5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwodGhpcy5lbCwgdGhpcykgOiB2YWx1ZTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBuZXh0IGFuZCBwcmV2aW91cyBtZW1iZXJzIGluIGEgZ3JvdXAuXG5cdGZ1bmN0aW9uIGdldEluZGV4KGluY3JlbWVudCkge1xuXHRcdHZhclxuXHRcdG1heCA9ICRyZWxhdGVkLmxlbmd0aCxcblx0XHRuZXdJbmRleCA9IChpbmRleCArIGluY3JlbWVudCkgJSBtYXg7XG5cblx0XHRyZXR1cm4gKG5ld0luZGV4IDwgMCkgPyBtYXggKyBuZXdJbmRleCA6IG5ld0luZGV4O1xuXHR9XG5cblx0Ly8gQ29udmVydCAnJScgYW5kICdweCcgdmFsdWVzIHRvIGludGVnZXJzXG5cdGZ1bmN0aW9uIHNldFNpemUoc2l6ZSwgZGltZW5zaW9uKSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoKC8lLy50ZXN0KHNpemUpID8gKChkaW1lbnNpb24gPT09ICd4JyA/ICR3aW5kb3cud2lkdGgoKSA6IHdpbmhlaWdodCgpKSAvIDEwMCkgOiAxKSAqIHBhcnNlSW50KHNpemUsIDEwKSk7XG5cdH1cblxuXHQvLyBDaGVja3MgYW4gaHJlZiB0byBzZWUgaWYgaXQgaXMgYSBwaG90by5cblx0Ly8gVGhlcmUgaXMgYSBmb3JjZSBwaG90byBvcHRpb24gKHBob3RvOiB0cnVlKSBmb3IgaHJlZnMgdGhhdCBjYW5ub3QgYmUgbWF0Y2hlZCBieSB0aGUgcmVnZXguXG5cdGZ1bmN0aW9uIGlzSW1hZ2Uoc2V0dGluZ3MsIHVybCkge1xuXHRcdHJldHVybiBzZXR0aW5ncy5nZXQoJ3Bob3RvJykgfHwgc2V0dGluZ3MuZ2V0KCdwaG90b1JlZ2V4JykudGVzdCh1cmwpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmV0aW5hVXJsKHNldHRpbmdzLCB1cmwpIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MuZ2V0KCdyZXRpbmFVcmwnKSAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDEgPyB1cmwucmVwbGFjZShzZXR0aW5ncy5nZXQoJ3Bob3RvUmVnZXgnKSwgc2V0dGluZ3MuZ2V0KCdyZXRpbmFTdWZmaXgnKSkgOiB1cmw7XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFwRm9jdXMoZSkge1xuXHRcdGlmICgnY29udGFpbnMnIGluICRib3hbMF0gJiYgISRib3hbMF0uY29udGFpbnMoZS50YXJnZXQpICYmIGUudGFyZ2V0ICE9PSAkb3ZlcmxheVswXSkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdCRib3guZm9jdXMoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRDbGFzcyhzdHIpIHtcblx0XHRpZiAoc2V0Q2xhc3Muc3RyICE9PSBzdHIpIHtcblx0XHRcdCRib3guYWRkKCRvdmVybGF5KS5yZW1vdmVDbGFzcyhzZXRDbGFzcy5zdHIpLmFkZENsYXNzKHN0cik7XG5cdFx0XHRzZXRDbGFzcy5zdHIgPSBzdHI7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UmVsYXRlZChyZWwpIHtcblx0XHRpbmRleCA9IDA7XG5cblx0XHRpZiAocmVsICYmIHJlbCAhPT0gZmFsc2UgJiYgcmVsICE9PSAnbm9mb2xsb3cnKSB7XG5cdFx0XHQkcmVsYXRlZCA9ICQoJy4nICsgYm94RWxlbWVudCkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIG9wdGlvbnMgPSAkLmRhdGEodGhpcywgY29sb3Jib3gpO1xuXHRcdFx0XHR2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3ModGhpcywgb3B0aW9ucyk7XG5cdFx0XHRcdHJldHVybiAoc2V0dGluZ3MuZ2V0KCdyZWwnKSA9PT0gcmVsKTtcblx0XHRcdH0pO1xuXHRcdFx0aW5kZXggPSAkcmVsYXRlZC5pbmRleChzZXR0aW5ncy5lbCk7XG5cblx0XHRcdC8vIENoZWNrIGRpcmVjdCBjYWxscyB0byBDb2xvcmJveC5cblx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0JHJlbGF0ZWQgPSAkcmVsYXRlZC5hZGQoc2V0dGluZ3MuZWwpO1xuXHRcdFx0XHRpbmRleCA9ICRyZWxhdGVkLmxlbmd0aCAtIDE7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdCRyZWxhdGVkID0gJChzZXR0aW5ncy5lbCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gdHJpZ2dlcihldmVudCkge1xuXHRcdC8vIGZvciBleHRlcm5hbCB1c2Vcblx0XHQkKGRvY3VtZW50KS50cmlnZ2VyKGV2ZW50KTtcblx0XHQvLyBmb3IgaW50ZXJuYWwgdXNlXG5cdFx0JGV2ZW50cy50cmlnZ2VySGFuZGxlcihldmVudCk7XG5cdH1cblxuXHR2YXIgc2xpZGVzaG93ID0gKGZ1bmN0aW9uKCl7XG5cdFx0dmFyIGFjdGl2ZSxcblx0XHRcdGNsYXNzTmFtZSA9IHByZWZpeCArIFwiU2xpZGVzaG93X1wiLFxuXHRcdFx0Y2xpY2sgPSBcImNsaWNrLlwiICsgcHJlZml4LFxuXHRcdFx0dGltZU91dDtcblxuXHRcdGZ1bmN0aW9uIGNsZWFyICgpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lT3V0KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXQoKSB7XG5cdFx0XHRpZiAoc2V0dGluZ3MuZ2V0KCdsb29wJykgfHwgJHJlbGF0ZWRbaW5kZXggKyAxXSkge1xuXHRcdFx0XHRjbGVhcigpO1xuXHRcdFx0XHR0aW1lT3V0ID0gc2V0VGltZW91dChwdWJsaWNNZXRob2QubmV4dCwgc2V0dGluZ3MuZ2V0KCdzbGlkZXNob3dTcGVlZCcpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzdGFydCgpIHtcblx0XHRcdCRzbGlkZXNob3dcblx0XHRcdFx0Lmh0bWwoc2V0dGluZ3MuZ2V0KCdzbGlkZXNob3dTdG9wJykpXG5cdFx0XHRcdC51bmJpbmQoY2xpY2spXG5cdFx0XHRcdC5vbmUoY2xpY2ssIHN0b3ApO1xuXG5cdFx0XHQkZXZlbnRzXG5cdFx0XHRcdC5iaW5kKGV2ZW50X2NvbXBsZXRlLCBzZXQpXG5cdFx0XHRcdC5iaW5kKGV2ZW50X2xvYWQsIGNsZWFyKTtcblxuXHRcdFx0JGJveC5yZW1vdmVDbGFzcyhjbGFzc05hbWUgKyBcIm9mZlwiKS5hZGRDbGFzcyhjbGFzc05hbWUgKyBcIm9uXCIpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHN0b3AoKSB7XG5cdFx0XHRjbGVhcigpO1xuXG5cdFx0XHQkZXZlbnRzXG5cdFx0XHRcdC51bmJpbmQoZXZlbnRfY29tcGxldGUsIHNldClcblx0XHRcdFx0LnVuYmluZChldmVudF9sb2FkLCBjbGVhcik7XG5cblx0XHRcdCRzbGlkZXNob3dcblx0XHRcdFx0Lmh0bWwoc2V0dGluZ3MuZ2V0KCdzbGlkZXNob3dTdGFydCcpKVxuXHRcdFx0XHQudW5iaW5kKGNsaWNrKVxuXHRcdFx0XHQub25lKGNsaWNrLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cHVibGljTWV0aG9kLm5leHQoKTtcblx0XHRcdFx0XHRzdGFydCgpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0JGJveC5yZW1vdmVDbGFzcyhjbGFzc05hbWUgKyBcIm9uXCIpLmFkZENsYXNzKGNsYXNzTmFtZSArIFwib2ZmXCIpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc2V0KCkge1xuXHRcdFx0YWN0aXZlID0gZmFsc2U7XG5cdFx0XHQkc2xpZGVzaG93LmhpZGUoKTtcblx0XHRcdGNsZWFyKCk7XG5cdFx0XHQkZXZlbnRzXG5cdFx0XHRcdC51bmJpbmQoZXZlbnRfY29tcGxldGUsIHNldClcblx0XHRcdFx0LnVuYmluZChldmVudF9sb2FkLCBjbGVhcik7XG5cdFx0XHQkYm94LnJlbW92ZUNsYXNzKGNsYXNzTmFtZSArIFwib2ZmIFwiICsgY2xhc3NOYW1lICsgXCJvblwiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdGlmIChhY3RpdmUpIHtcblx0XHRcdFx0aWYgKCFzZXR0aW5ncy5nZXQoJ3NsaWRlc2hvdycpKSB7XG5cdFx0XHRcdFx0JGV2ZW50cy51bmJpbmQoZXZlbnRfY2xlYW51cCwgcmVzZXQpO1xuXHRcdFx0XHRcdHJlc2V0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChzZXR0aW5ncy5nZXQoJ3NsaWRlc2hvdycpICYmICRyZWxhdGVkWzFdKSB7XG5cdFx0XHRcdFx0YWN0aXZlID0gdHJ1ZTtcblx0XHRcdFx0XHQkZXZlbnRzLm9uZShldmVudF9jbGVhbnVwLCByZXNldCk7XG5cdFx0XHRcdFx0aWYgKHNldHRpbmdzLmdldCgnc2xpZGVzaG93QXV0bycpKSB7XG5cdFx0XHRcdFx0XHRzdGFydCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdG9wKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCRzbGlkZXNob3cuc2hvdygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHR9KCkpO1xuXG5cblx0ZnVuY3Rpb24gbGF1bmNoKGVsZW1lbnQpIHtcblx0XHR2YXIgb3B0aW9ucztcblxuXHRcdGlmICghY2xvc2luZykge1xuXG5cdFx0XHRvcHRpb25zID0gJChlbGVtZW50KS5kYXRhKGNvbG9yYm94KTtcblxuXHRcdFx0c2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoZWxlbWVudCwgb3B0aW9ucyk7XG5cblx0XHRcdGdldFJlbGF0ZWQoc2V0dGluZ3MuZ2V0KCdyZWwnKSk7XG5cblx0XHRcdGlmICghb3Blbikge1xuXHRcdFx0XHRvcGVuID0gYWN0aXZlID0gdHJ1ZTsgLy8gUHJldmVudHMgdGhlIHBhZ2UtY2hhbmdlIGFjdGlvbiBmcm9tIHF1ZXVpbmcgdXAgaWYgdGhlIHZpc2l0b3IgaG9sZHMgZG93biB0aGUgbGVmdCBvciByaWdodCBrZXlzLlxuXG5cdFx0XHRcdHNldENsYXNzKHNldHRpbmdzLmdldCgnY2xhc3NOYW1lJykpO1xuXG5cdFx0XHRcdC8vIFNob3cgY29sb3Jib3ggc28gdGhlIHNpemVzIGNhbiBiZSBjYWxjdWxhdGVkIGluIG9sZGVyIHZlcnNpb25zIG9mIGpRdWVyeVxuXHRcdFx0XHQkYm94LmNzcyh7dmlzaWJpbGl0eTonaGlkZGVuJywgZGlzcGxheTonYmxvY2snLCBvcGFjaXR5OicnfSk7XG5cblx0XHRcdFx0JGxvYWRlZCA9ICR0YWcoZGl2LCAnTG9hZGVkQ29udGVudCcsICd3aWR0aDowOyBoZWlnaHQ6MDsgb3ZlcmZsb3c6aGlkZGVuOyB2aXNpYmlsaXR5OmhpZGRlbicpO1xuXHRcdFx0XHQkY29udGVudC5jc3Moe3dpZHRoOicnLCBoZWlnaHQ6Jyd9KS5hcHBlbmQoJGxvYWRlZCk7XG5cblx0XHRcdFx0Ly8gQ2FjaGUgdmFsdWVzIG5lZWRlZCBmb3Igc2l6ZSBjYWxjdWxhdGlvbnNcblx0XHRcdFx0aW50ZXJmYWNlSGVpZ2h0ID0gJHRvcEJvcmRlci5oZWlnaHQoKSArICRib3R0b21Cb3JkZXIuaGVpZ2h0KCkgKyAkY29udGVudC5vdXRlckhlaWdodCh0cnVlKSAtICRjb250ZW50LmhlaWdodCgpO1xuXHRcdFx0XHRpbnRlcmZhY2VXaWR0aCA9ICRsZWZ0Qm9yZGVyLndpZHRoKCkgKyAkcmlnaHRCb3JkZXIud2lkdGgoKSArICRjb250ZW50Lm91dGVyV2lkdGgodHJ1ZSkgLSAkY29udGVudC53aWR0aCgpO1xuXHRcdFx0XHRsb2FkZWRIZWlnaHQgPSAkbG9hZGVkLm91dGVySGVpZ2h0KHRydWUpO1xuXHRcdFx0XHRsb2FkZWRXaWR0aCA9ICRsb2FkZWQub3V0ZXJXaWR0aCh0cnVlKTtcblxuXHRcdFx0XHQvLyBPcGVucyBpbml0YWwgZW1wdHkgQ29sb3Jib3ggcHJpb3IgdG8gY29udGVudCBiZWluZyBsb2FkZWQuXG5cdFx0XHRcdHZhciBpbml0aWFsV2lkdGggPSBzZXRTaXplKHNldHRpbmdzLmdldCgnaW5pdGlhbFdpZHRoJyksICd4Jyk7XG5cdFx0XHRcdHZhciBpbml0aWFsSGVpZ2h0ID0gc2V0U2l6ZShzZXR0aW5ncy5nZXQoJ2luaXRpYWxIZWlnaHQnKSwgJ3knKTtcblx0XHRcdFx0dmFyIG1heFdpZHRoID0gc2V0dGluZ3MuZ2V0KCdtYXhXaWR0aCcpO1xuXHRcdFx0XHR2YXIgbWF4SGVpZ2h0ID0gc2V0dGluZ3MuZ2V0KCdtYXhIZWlnaHQnKTtcblxuXHRcdFx0XHRzZXR0aW5ncy53ID0gTWF0aC5tYXgoKG1heFdpZHRoICE9PSBmYWxzZSA/IE1hdGgubWluKGluaXRpYWxXaWR0aCwgc2V0U2l6ZShtYXhXaWR0aCwgJ3gnKSkgOiBpbml0aWFsV2lkdGgpIC0gbG9hZGVkV2lkdGggLSBpbnRlcmZhY2VXaWR0aCwgMCk7XG5cdFx0XHRcdHNldHRpbmdzLmggPSBNYXRoLm1heCgobWF4SGVpZ2h0ICE9PSBmYWxzZSA/IE1hdGgubWluKGluaXRpYWxIZWlnaHQsIHNldFNpemUobWF4SGVpZ2h0LCAneScpKSA6IGluaXRpYWxIZWlnaHQpIC0gbG9hZGVkSGVpZ2h0IC0gaW50ZXJmYWNlSGVpZ2h0LCAwKTtcblxuXHRcdFx0XHQkbG9hZGVkLmNzcyh7d2lkdGg6JycsIGhlaWdodDpzZXR0aW5ncy5ofSk7XG5cdFx0XHRcdHB1YmxpY01ldGhvZC5wb3NpdGlvbigpO1xuXG5cdFx0XHRcdHRyaWdnZXIoZXZlbnRfb3Blbik7XG5cdFx0XHRcdHNldHRpbmdzLmdldCgnb25PcGVuJyk7XG5cblx0XHRcdFx0JGdyb3VwQ29udHJvbHMuYWRkKCR0aXRsZSkuaGlkZSgpO1xuXG5cdFx0XHRcdCRib3guZm9jdXMoKTtcblxuXHRcdFx0XHRpZiAoc2V0dGluZ3MuZ2V0KCd0cmFwRm9jdXMnKSkge1xuXHRcdFx0XHRcdC8vIENvbmZpbmUgZm9jdXMgdG8gdGhlIG1vZGFsXG5cdFx0XHRcdFx0Ly8gVXNlcyBldmVudCBjYXB0dXJpbmcgdGhhdCBpcyBub3Qgc3VwcG9ydGVkIGluIElFOC1cblx0XHRcdFx0XHRpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuXG5cdFx0XHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRyYXBGb2N1cywgdHJ1ZSk7XG5cblx0XHRcdFx0XHRcdCRldmVudHMub25lKGV2ZW50X2Nsb3NlZCwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRyYXBGb2N1cywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZm9jdXMgb24gY2xvc2luZ1xuXHRcdFx0XHRpZiAoc2V0dGluZ3MuZ2V0KCdyZXR1cm5Gb2N1cycpKSB7XG5cdFx0XHRcdFx0JGV2ZW50cy5vbmUoZXZlbnRfY2xvc2VkLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHQkKHNldHRpbmdzLmVsKS5mb2N1cygpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBvcGFjaXR5ID0gcGFyc2VGbG9hdChzZXR0aW5ncy5nZXQoJ29wYWNpdHknKSk7XG5cdFx0XHQkb3ZlcmxheS5jc3Moe1xuXHRcdFx0XHRvcGFjaXR5OiBvcGFjaXR5ID09PSBvcGFjaXR5ID8gb3BhY2l0eSA6ICcnLFxuXHRcdFx0XHRjdXJzb3I6IHNldHRpbmdzLmdldCgnb3ZlcmxheUNsb3NlJykgPyAncG9pbnRlcicgOiAnJyxcblx0XHRcdFx0dmlzaWJpbGl0eTogJ3Zpc2libGUnXG5cdFx0XHR9KS5zaG93KCk7XG5cblx0XHRcdGlmIChzZXR0aW5ncy5nZXQoJ2Nsb3NlQnV0dG9uJykpIHtcblx0XHRcdFx0JGNsb3NlLmh0bWwoc2V0dGluZ3MuZ2V0KCdjbG9zZScpKS5hcHBlbmRUbygkY29udGVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkY2xvc2UuYXBwZW5kVG8oJzxkaXYvPicpOyAvLyByZXBsYWNlIHdpdGggLmRldGFjaCgpIHdoZW4gZHJvcHBpbmcgalF1ZXJ5IDwgMS40XG5cdFx0XHR9XG5cblx0XHRcdGxvYWQoKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDb2xvcmJveCdzIG1hcmt1cCBuZWVkcyB0byBiZSBhZGRlZCB0byB0aGUgRE9NIHByaW9yIHRvIGJlaW5nIGNhbGxlZFxuXHQvLyBzbyB0aGF0IHRoZSBicm93c2VyIHdpbGwgZ28gYWhlYWQgYW5kIGxvYWQgdGhlIENTUyBiYWNrZ3JvdW5kIGltYWdlcy5cblx0ZnVuY3Rpb24gYXBwZW5kSFRNTCgpIHtcblx0XHRpZiAoISRib3gpIHtcblx0XHRcdGluaXQgPSBmYWxzZTtcblx0XHRcdCR3aW5kb3cgPSAkKHdpbmRvdyk7XG5cdFx0XHQkYm94ID0gJHRhZyhkaXYpLmF0dHIoe1xuXHRcdFx0XHRpZDogY29sb3Jib3gsXG5cdFx0XHRcdCdjbGFzcyc6ICQuc3VwcG9ydC5vcGFjaXR5ID09PSBmYWxzZSA/IHByZWZpeCArICdJRScgOiAnJywgLy8gY2xhc3MgZm9yIG9wdGlvbmFsIElFOCAmIGxvd2VyIHRhcmdldGVkIENTUy5cblx0XHRcdFx0cm9sZTogJ2RpYWxvZycsXG5cdFx0XHRcdHRhYmluZGV4OiAnLTEnXG5cdFx0XHR9KS5oaWRlKCk7XG5cdFx0XHQkb3ZlcmxheSA9ICR0YWcoZGl2LCBcIk92ZXJsYXlcIikuaGlkZSgpO1xuXHRcdFx0JGxvYWRpbmdPdmVybGF5ID0gJChbJHRhZyhkaXYsIFwiTG9hZGluZ092ZXJsYXlcIilbMF0sJHRhZyhkaXYsIFwiTG9hZGluZ0dyYXBoaWNcIilbMF1dKTtcblx0XHRcdCR3cmFwID0gJHRhZyhkaXYsIFwiV3JhcHBlclwiKTtcblx0XHRcdCRjb250ZW50ID0gJHRhZyhkaXYsIFwiQ29udGVudFwiKS5hcHBlbmQoXG5cdFx0XHRcdCR0aXRsZSA9ICR0YWcoZGl2LCBcIlRpdGxlXCIpLFxuXHRcdFx0XHQkY3VycmVudCA9ICR0YWcoZGl2LCBcIkN1cnJlbnRcIiksXG5cdFx0XHRcdCRwcmV2ID0gJCgnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIvPicpLmF0dHIoe2lkOnByZWZpeCsnUHJldmlvdXMnfSksXG5cdFx0XHRcdCRuZXh0ID0gJCgnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIvPicpLmF0dHIoe2lkOnByZWZpeCsnTmV4dCd9KSxcblx0XHRcdFx0JHNsaWRlc2hvdyA9ICQoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiLz4nKS5hdHRyKHtpZDpwcmVmaXgrJ1NsaWRlc2hvdyd9KSxcblx0XHRcdFx0JGxvYWRpbmdPdmVybGF5XG5cdFx0XHQpO1xuXG5cdFx0XHQkY2xvc2UgPSAkKCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIi8+JykuYXR0cih7aWQ6cHJlZml4KydDbG9zZSd9KTtcblxuXHRcdFx0JHdyYXAuYXBwZW5kKCAvLyBUaGUgM3gzIEdyaWQgdGhhdCBtYWtlcyB1cCBDb2xvcmJveFxuXHRcdFx0XHQkdGFnKGRpdikuYXBwZW5kKFxuXHRcdFx0XHRcdCR0YWcoZGl2LCBcIlRvcExlZnRcIiksXG5cdFx0XHRcdFx0JHRvcEJvcmRlciA9ICR0YWcoZGl2LCBcIlRvcENlbnRlclwiKSxcblx0XHRcdFx0XHQkdGFnKGRpdiwgXCJUb3BSaWdodFwiKVxuXHRcdFx0XHQpLFxuXHRcdFx0XHQkdGFnKGRpdiwgZmFsc2UsICdjbGVhcjpsZWZ0JykuYXBwZW5kKFxuXHRcdFx0XHRcdCRsZWZ0Qm9yZGVyID0gJHRhZyhkaXYsIFwiTWlkZGxlTGVmdFwiKSxcblx0XHRcdFx0XHQkY29udGVudCxcblx0XHRcdFx0XHQkcmlnaHRCb3JkZXIgPSAkdGFnKGRpdiwgXCJNaWRkbGVSaWdodFwiKVxuXHRcdFx0XHQpLFxuXHRcdFx0XHQkdGFnKGRpdiwgZmFsc2UsICdjbGVhcjpsZWZ0JykuYXBwZW5kKFxuXHRcdFx0XHRcdCR0YWcoZGl2LCBcIkJvdHRvbUxlZnRcIiksXG5cdFx0XHRcdFx0JGJvdHRvbUJvcmRlciA9ICR0YWcoZGl2LCBcIkJvdHRvbUNlbnRlclwiKSxcblx0XHRcdFx0XHQkdGFnKGRpdiwgXCJCb3R0b21SaWdodFwiKVxuXHRcdFx0XHQpXG5cdFx0XHQpLmZpbmQoJ2RpdiBkaXYnKS5jc3MoeydmbG9hdCc6ICdsZWZ0J30pO1xuXG5cdFx0XHQkbG9hZGluZ0JheSA9ICR0YWcoZGl2LCBmYWxzZSwgJ3Bvc2l0aW9uOmFic29sdXRlOyB3aWR0aDo5OTk5cHg7IHZpc2liaWxpdHk6aGlkZGVuOyBkaXNwbGF5Om5vbmU7IG1heC13aWR0aDpub25lOycpO1xuXG5cdFx0XHQkZ3JvdXBDb250cm9scyA9ICRuZXh0LmFkZCgkcHJldikuYWRkKCRjdXJyZW50KS5hZGQoJHNsaWRlc2hvdyk7XG5cdFx0fVxuXHRcdGlmIChkb2N1bWVudC5ib2R5ICYmICEkYm94LnBhcmVudCgpLmxlbmd0aCkge1xuXHRcdFx0JChkb2N1bWVudC5ib2R5KS5hcHBlbmQoJG92ZXJsYXksICRib3guYXBwZW5kKCR3cmFwLCAkbG9hZGluZ0JheSkpO1xuXHRcdH1cblx0fVxuXG5cdC8vIEFkZCBDb2xvcmJveCdzIGV2ZW50IGJpbmRpbmdzXG5cdGZ1bmN0aW9uIGFkZEJpbmRpbmdzKCkge1xuXHRcdGZ1bmN0aW9uIGNsaWNrSGFuZGxlcihlKSB7XG5cdFx0XHQvLyBpZ25vcmUgbm9uLWxlZnQtbW91c2UtY2xpY2tzIGFuZCBjbGlja3MgbW9kaWZpZWQgd2l0aCBjdHJsIC8gY29tbWFuZCwgc2hpZnQsIG9yIGFsdC5cblx0XHRcdC8vIFNlZTogaHR0cDovL2phY2tsbW9vcmUuY29tL25vdGVzL2NsaWNrLWV2ZW50cy9cblx0XHRcdGlmICghKGUud2hpY2ggPiAxIHx8IGUuc2hpZnRLZXkgfHwgZS5hbHRLZXkgfHwgZS5tZXRhS2V5IHx8IGUuY3RybEtleSkpIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRsYXVuY2godGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCRib3gpIHtcblx0XHRcdGlmICghaW5pdCkge1xuXHRcdFx0XHRpbml0ID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBBbm9ueW1vdXMgZnVuY3Rpb25zIGhlcmUga2VlcCB0aGUgcHVibGljIG1ldGhvZCBmcm9tIGJlaW5nIGNhY2hlZCwgdGhlcmVieSBhbGxvd2luZyB0aGVtIHRvIGJlIHJlZGVmaW5lZCBvbiB0aGUgZmx5LlxuXHRcdFx0XHQkbmV4dC5jbGljayhmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cHVibGljTWV0aG9kLm5leHQoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdCRwcmV2LmNsaWNrKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRwdWJsaWNNZXRob2QucHJldigpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0JGNsb3NlLmNsaWNrKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRwdWJsaWNNZXRob2QuY2xvc2UoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdCRvdmVybGF5LmNsaWNrKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoc2V0dGluZ3MuZ2V0KCdvdmVybGF5Q2xvc2UnKSkge1xuXHRcdFx0XHRcdFx0cHVibGljTWV0aG9kLmNsb3NlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBLZXkgQmluZGluZ3Ncblx0XHRcdFx0JChkb2N1bWVudCkuYmluZCgna2V5ZG93bi4nICsgcHJlZml4LCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdHZhciBrZXkgPSBlLmtleUNvZGU7XG5cdFx0XHRcdFx0aWYgKG9wZW4gJiYgc2V0dGluZ3MuZ2V0KCdlc2NLZXknKSAmJiBrZXkgPT09IDI3KSB7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRwdWJsaWNNZXRob2QuY2xvc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG9wZW4gJiYgc2V0dGluZ3MuZ2V0KCdhcnJvd0tleScpICYmICRyZWxhdGVkWzFdICYmICFlLmFsdEtleSkge1xuXHRcdFx0XHRcdFx0aWYgKGtleSA9PT0gMzcpIHtcblx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHQkcHJldi5jbGljaygpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChrZXkgPT09IDM5KSB7XG5cdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0JG5leHQuY2xpY2soKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmICgkLmlzRnVuY3Rpb24oJC5mbi5vbikpIHtcblx0XHRcdFx0XHQvLyBGb3IgalF1ZXJ5IDEuNytcblx0XHRcdFx0XHQkKGRvY3VtZW50KS5vbignY2xpY2suJytwcmVmaXgsICcuJytib3hFbGVtZW50LCBjbGlja0hhbmRsZXIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEZvciBqUXVlcnkgMS4zLnggLT4gMS42Lnhcblx0XHRcdFx0XHQvLyBUaGlzIGNvZGUgaXMgbmV2ZXIgcmVhY2hlZCBpbiBqUXVlcnkgMS45LCBzbyBkbyBub3QgY29udGFjdCBtZSBhYm91dCAnbGl2ZScgYmVpbmcgcmVtb3ZlZC5cblx0XHRcdFx0XHQvLyBUaGlzIGlzIG5vdCBoZXJlIGZvciBqUXVlcnkgMS45LCBpdCdzIGhlcmUgZm9yIGxlZ2FjeSB1c2Vycy5cblx0XHRcdFx0XHQkKCcuJytib3hFbGVtZW50KS5saXZlKCdjbGljay4nK3ByZWZpeCwgY2xpY2tIYW5kbGVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIERvbid0IGRvIGFueXRoaW5nIGlmIENvbG9yYm94IGFscmVhZHkgZXhpc3RzLlxuXHRpZiAoJFtjb2xvcmJveF0pIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBBcHBlbmQgdGhlIEhUTUwgd2hlbiB0aGUgRE9NIGxvYWRzXG5cdCQoYXBwZW5kSFRNTCk7XG5cblxuXHQvLyAqKioqKioqKioqKioqKioqXG5cdC8vIFBVQkxJQyBGVU5DVElPTlNcblx0Ly8gVXNhZ2UgZm9ybWF0OiAkLmNvbG9yYm94LmNsb3NlKCk7XG5cdC8vIFVzYWdlIGZyb20gd2l0aGluIGFuIGlmcmFtZTogcGFyZW50LmpRdWVyeS5jb2xvcmJveC5jbG9zZSgpO1xuXHQvLyAqKioqKioqKioqKioqKioqXG5cblx0cHVibGljTWV0aG9kID0gJC5mbltjb2xvcmJveF0gPSAkW2NvbG9yYm94XSA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuXHRcdHZhciBzZXR0aW5ncztcblx0XHR2YXIgJG9iaiA9IHRoaXM7XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdGlmICgkLmlzRnVuY3Rpb24oJG9iaikpIHsgLy8gYXNzdW1lIGEgY2FsbCB0byAkLmNvbG9yYm94XG5cdFx0XHQkb2JqID0gJCgnPGEvPicpO1xuXHRcdFx0b3B0aW9ucy5vcGVuID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoISRvYmpbMF0pIHsgLy8gY29sb3Jib3ggYmVpbmcgYXBwbGllZCB0byBlbXB0eSBjb2xsZWN0aW9uXG5cdFx0XHRyZXR1cm4gJG9iajtcblx0XHR9XG5cblx0XHRhcHBlbmRIVE1MKCk7XG5cblx0XHRpZiAoYWRkQmluZGluZ3MoKSkge1xuXG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0b3B0aW9ucy5vbkNvbXBsZXRlID0gY2FsbGJhY2s7XG5cdFx0XHR9XG5cblx0XHRcdCRvYmouZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBvbGQgPSAkLmRhdGEodGhpcywgY29sb3Jib3gpIHx8IHt9O1xuXHRcdFx0XHQkLmRhdGEodGhpcywgY29sb3Jib3gsICQuZXh0ZW5kKG9sZCwgb3B0aW9ucykpO1xuXHRcdFx0fSkuYWRkQ2xhc3MoYm94RWxlbWVudCk7XG5cblx0XHRcdHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCRvYmpbMF0sIG9wdGlvbnMpO1xuXG5cdFx0XHRpZiAoc2V0dGluZ3MuZ2V0KCdvcGVuJykpIHtcblx0XHRcdFx0bGF1bmNoKCRvYmpbMF0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAkb2JqO1xuXHR9O1xuXG5cdHB1YmxpY01ldGhvZC5wb3NpdGlvbiA9IGZ1bmN0aW9uIChzcGVlZCwgbG9hZGVkQ2FsbGJhY2spIHtcblx0XHR2YXJcblx0XHRjc3MsXG5cdFx0dG9wID0gMCxcblx0XHRsZWZ0ID0gMCxcblx0XHRvZmZzZXQgPSAkYm94Lm9mZnNldCgpLFxuXHRcdHNjcm9sbFRvcCxcblx0XHRzY3JvbGxMZWZ0O1xuXG5cdFx0JHdpbmRvdy51bmJpbmQoJ3Jlc2l6ZS4nICsgcHJlZml4KTtcblxuXHRcdC8vIHJlbW92ZSB0aGUgbW9kYWwgc28gdGhhdCBpdCBkb2Vzbid0IGluZmx1ZW5jZSB0aGUgZG9jdW1lbnQgd2lkdGgvaGVpZ2h0XG5cdFx0JGJveC5jc3Moe3RvcDogLTllNCwgbGVmdDogLTllNH0pO1xuXG5cdFx0c2Nyb2xsVG9wID0gJHdpbmRvdy5zY3JvbGxUb3AoKTtcblx0XHRzY3JvbGxMZWZ0ID0gJHdpbmRvdy5zY3JvbGxMZWZ0KCk7XG5cblx0XHRpZiAoc2V0dGluZ3MuZ2V0KCdmaXhlZCcpKSB7XG5cdFx0XHRvZmZzZXQudG9wIC09IHNjcm9sbFRvcDtcblx0XHRcdG9mZnNldC5sZWZ0IC09IHNjcm9sbExlZnQ7XG5cdFx0XHQkYm94LmNzcyh7cG9zaXRpb246ICdmaXhlZCd9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dG9wID0gc2Nyb2xsVG9wO1xuXHRcdFx0bGVmdCA9IHNjcm9sbExlZnQ7XG5cdFx0XHQkYm94LmNzcyh7cG9zaXRpb246ICdhYnNvbHV0ZSd9KTtcblx0XHR9XG5cblx0XHQvLyBrZWVwcyB0aGUgdG9wIGFuZCBsZWZ0IHBvc2l0aW9ucyB3aXRoaW4gdGhlIGJyb3dzZXIncyB2aWV3cG9ydC5cblx0XHRpZiAoc2V0dGluZ3MuZ2V0KCdyaWdodCcpICE9PSBmYWxzZSkge1xuXHRcdFx0bGVmdCArPSBNYXRoLm1heCgkd2luZG93LndpZHRoKCkgLSBzZXR0aW5ncy53IC0gbG9hZGVkV2lkdGggLSBpbnRlcmZhY2VXaWR0aCAtIHNldFNpemUoc2V0dGluZ3MuZ2V0KCdyaWdodCcpLCAneCcpLCAwKTtcblx0XHR9IGVsc2UgaWYgKHNldHRpbmdzLmdldCgnbGVmdCcpICE9PSBmYWxzZSkge1xuXHRcdFx0bGVmdCArPSBzZXRTaXplKHNldHRpbmdzLmdldCgnbGVmdCcpLCAneCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZWZ0ICs9IE1hdGgucm91bmQoTWF0aC5tYXgoJHdpbmRvdy53aWR0aCgpIC0gc2V0dGluZ3MudyAtIGxvYWRlZFdpZHRoIC0gaW50ZXJmYWNlV2lkdGgsIDApIC8gMik7XG5cdFx0fVxuXG5cdFx0aWYgKHNldHRpbmdzLmdldCgnYm90dG9tJykgIT09IGZhbHNlKSB7XG5cdFx0XHR0b3AgKz0gTWF0aC5tYXgod2luaGVpZ2h0KCkgLSBzZXR0aW5ncy5oIC0gbG9hZGVkSGVpZ2h0IC0gaW50ZXJmYWNlSGVpZ2h0IC0gc2V0U2l6ZShzZXR0aW5ncy5nZXQoJ2JvdHRvbScpLCAneScpLCAwKTtcblx0XHR9IGVsc2UgaWYgKHNldHRpbmdzLmdldCgndG9wJykgIT09IGZhbHNlKSB7XG5cdFx0XHR0b3AgKz0gc2V0U2l6ZShzZXR0aW5ncy5nZXQoJ3RvcCcpLCAneScpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0b3AgKz0gTWF0aC5yb3VuZChNYXRoLm1heCh3aW5oZWlnaHQoKSAtIHNldHRpbmdzLmggLSBsb2FkZWRIZWlnaHQgLSBpbnRlcmZhY2VIZWlnaHQsIDApIC8gMik7XG5cdFx0fVxuXG5cdFx0JGJveC5jc3Moe3RvcDogb2Zmc2V0LnRvcCwgbGVmdDogb2Zmc2V0LmxlZnQsIHZpc2liaWxpdHk6J3Zpc2libGUnfSk7XG5cblx0XHQvLyB0aGlzIGdpdmVzIHRoZSB3cmFwcGVyIHBsZW50eSBvZiBicmVhdGhpbmcgcm9vbSBzbyBpdCdzIGZsb2F0ZWQgY29udGVudHMgY2FuIG1vdmUgYXJvdW5kIHNtb290aGx5LFxuXHRcdC8vIGJ1dCBpdCBoYXMgdG8gYmUgc2hyYW5rIGRvd24gYXJvdW5kIHRoZSBzaXplIG9mIGRpdiNjb2xvcmJveCB3aGVuIGl0J3MgZG9uZS4gIElmIG5vdCxcblx0XHQvLyBpdCBjYW4gaW52b2tlIGFuIG9ic2N1cmUgSUUgYnVnIHdoZW4gdXNpbmcgaWZyYW1lcy5cblx0XHQkd3JhcFswXS5zdHlsZS53aWR0aCA9ICR3cmFwWzBdLnN0eWxlLmhlaWdodCA9IFwiOTk5OXB4XCI7XG5cblx0XHRmdW5jdGlvbiBtb2RhbERpbWVuc2lvbnMoKSB7XG5cdFx0XHQkdG9wQm9yZGVyWzBdLnN0eWxlLndpZHRoID0gJGJvdHRvbUJvcmRlclswXS5zdHlsZS53aWR0aCA9ICRjb250ZW50WzBdLnN0eWxlLndpZHRoID0gKHBhcnNlSW50KCRib3hbMF0uc3R5bGUud2lkdGgsMTApIC0gaW50ZXJmYWNlV2lkdGgpKydweCc7XG5cdFx0XHQkY29udGVudFswXS5zdHlsZS5oZWlnaHQgPSAkbGVmdEJvcmRlclswXS5zdHlsZS5oZWlnaHQgPSAkcmlnaHRCb3JkZXJbMF0uc3R5bGUuaGVpZ2h0ID0gKHBhcnNlSW50KCRib3hbMF0uc3R5bGUuaGVpZ2h0LDEwKSAtIGludGVyZmFjZUhlaWdodCkrJ3B4Jztcblx0XHR9XG5cblx0XHRjc3MgPSB7d2lkdGg6IHNldHRpbmdzLncgKyBsb2FkZWRXaWR0aCArIGludGVyZmFjZVdpZHRoLCBoZWlnaHQ6IHNldHRpbmdzLmggKyBsb2FkZWRIZWlnaHQgKyBpbnRlcmZhY2VIZWlnaHQsIHRvcDogdG9wLCBsZWZ0OiBsZWZ0fTtcblxuXHRcdC8vIHNldHRpbmcgdGhlIHNwZWVkIHRvIDAgaWYgdGhlIGNvbnRlbnQgaGFzbid0IGNoYW5nZWQgc2l6ZSBvciBwb3NpdGlvblxuXHRcdGlmIChzcGVlZCkge1xuXHRcdFx0dmFyIHRlbXBTcGVlZCA9IDA7XG5cdFx0XHQkLmVhY2goY3NzLCBmdW5jdGlvbihpKXtcblx0XHRcdFx0aWYgKGNzc1tpXSAhPT0gcHJldmlvdXNDU1NbaV0pIHtcblx0XHRcdFx0XHR0ZW1wU3BlZWQgPSBzcGVlZDtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0c3BlZWQgPSB0ZW1wU3BlZWQ7XG5cdFx0fVxuXG5cdFx0cHJldmlvdXNDU1MgPSBjc3M7XG5cblx0XHRpZiAoIXNwZWVkKSB7XG5cdFx0XHQkYm94LmNzcyhjc3MpO1xuXHRcdH1cblxuXHRcdCRib3guZGVxdWV1ZSgpLmFuaW1hdGUoY3NzLCB7XG5cdFx0XHRkdXJhdGlvbjogc3BlZWQgfHwgMCxcblx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdG1vZGFsRGltZW5zaW9ucygpO1xuXG5cdFx0XHRcdGFjdGl2ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIHNocmluayB0aGUgd3JhcHBlciBkb3duIHRvIGV4YWN0bHkgdGhlIHNpemUgb2YgY29sb3Jib3ggdG8gYXZvaWQgYSBidWcgaW4gSUUncyBpZnJhbWUgaW1wbGVtZW50YXRpb24uXG5cdFx0XHRcdCR3cmFwWzBdLnN0eWxlLndpZHRoID0gKHNldHRpbmdzLncgKyBsb2FkZWRXaWR0aCArIGludGVyZmFjZVdpZHRoKSArIFwicHhcIjtcblx0XHRcdFx0JHdyYXBbMF0uc3R5bGUuaGVpZ2h0ID0gKHNldHRpbmdzLmggKyBsb2FkZWRIZWlnaHQgKyBpbnRlcmZhY2VIZWlnaHQpICsgXCJweFwiO1xuXG5cdFx0XHRcdGlmIChzZXR0aW5ncy5nZXQoJ3JlcG9zaXRpb24nKSkge1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyAgLy8gc21hbGwgZGVsYXkgYmVmb3JlIGJpbmRpbmcgb25yZXNpemUgZHVlIHRvIGFuIElFOCBidWcuXG5cdFx0XHRcdFx0XHQkd2luZG93LmJpbmQoJ3Jlc2l6ZS4nICsgcHJlZml4LCBwdWJsaWNNZXRob2QucG9zaXRpb24pO1xuXHRcdFx0XHRcdH0sIDEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCQuaXNGdW5jdGlvbihsb2FkZWRDYWxsYmFjaykpIHtcblx0XHRcdFx0XHRsb2FkZWRDYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c3RlcDogbW9kYWxEaW1lbnNpb25zXG5cdFx0fSk7XG5cdH07XG5cblx0cHVibGljTWV0aG9kLnJlc2l6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0dmFyIHNjcm9sbHRvcDtcblxuXHRcdGlmIChvcGVuKSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdFx0aWYgKG9wdGlvbnMud2lkdGgpIHtcblx0XHRcdFx0c2V0dGluZ3MudyA9IHNldFNpemUob3B0aW9ucy53aWR0aCwgJ3gnKSAtIGxvYWRlZFdpZHRoIC0gaW50ZXJmYWNlV2lkdGg7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zLmlubmVyV2lkdGgpIHtcblx0XHRcdFx0c2V0dGluZ3MudyA9IHNldFNpemUob3B0aW9ucy5pbm5lcldpZHRoLCAneCcpO1xuXHRcdFx0fVxuXG5cdFx0XHQkbG9hZGVkLmNzcyh7d2lkdGg6IHNldHRpbmdzLnd9KTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuaGVpZ2h0KSB7XG5cdFx0XHRcdHNldHRpbmdzLmggPSBzZXRTaXplKG9wdGlvbnMuaGVpZ2h0LCAneScpIC0gbG9hZGVkSGVpZ2h0IC0gaW50ZXJmYWNlSGVpZ2h0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0aW9ucy5pbm5lckhlaWdodCkge1xuXHRcdFx0XHRzZXR0aW5ncy5oID0gc2V0U2l6ZShvcHRpb25zLmlubmVySGVpZ2h0LCAneScpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIW9wdGlvbnMuaW5uZXJIZWlnaHQgJiYgIW9wdGlvbnMuaGVpZ2h0KSB7XG5cdFx0XHRcdHNjcm9sbHRvcCA9ICRsb2FkZWQuc2Nyb2xsVG9wKCk7XG5cdFx0XHRcdCRsb2FkZWQuY3NzKHtoZWlnaHQ6IFwiYXV0b1wifSk7XG5cdFx0XHRcdHNldHRpbmdzLmggPSAkbG9hZGVkLmhlaWdodCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQkbG9hZGVkLmNzcyh7aGVpZ2h0OiBzZXR0aW5ncy5ofSk7XG5cblx0XHRcdGlmKHNjcm9sbHRvcCkge1xuXHRcdFx0XHQkbG9hZGVkLnNjcm9sbFRvcChzY3JvbGx0b3ApO1xuXHRcdFx0fVxuXG5cdFx0XHRwdWJsaWNNZXRob2QucG9zaXRpb24oc2V0dGluZ3MuZ2V0KCd0cmFuc2l0aW9uJykgPT09IFwibm9uZVwiID8gMCA6IHNldHRpbmdzLmdldCgnc3BlZWQnKSk7XG5cdFx0fVxuXHR9O1xuXG5cdHB1YmxpY01ldGhvZC5wcmVwID0gZnVuY3Rpb24gKG9iamVjdCkge1xuXHRcdGlmICghb3Blbikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjYWxsYmFjaywgc3BlZWQgPSBzZXR0aW5ncy5nZXQoJ3RyYW5zaXRpb24nKSA9PT0gXCJub25lXCIgPyAwIDogc2V0dGluZ3MuZ2V0KCdzcGVlZCcpO1xuXG5cdFx0JGxvYWRlZC5yZW1vdmUoKTtcblxuXHRcdCRsb2FkZWQgPSAkdGFnKGRpdiwgJ0xvYWRlZENvbnRlbnQnKS5hcHBlbmQob2JqZWN0KTtcblxuXHRcdGZ1bmN0aW9uIGdldFdpZHRoKCkge1xuXHRcdFx0c2V0dGluZ3MudyA9IHNldHRpbmdzLncgfHwgJGxvYWRlZC53aWR0aCgpO1xuXHRcdFx0c2V0dGluZ3MudyA9IHNldHRpbmdzLm13ICYmIHNldHRpbmdzLm13IDwgc2V0dGluZ3MudyA/IHNldHRpbmdzLm13IDogc2V0dGluZ3Mudztcblx0XHRcdHJldHVybiBzZXR0aW5ncy53O1xuXHRcdH1cblx0XHRmdW5jdGlvbiBnZXRIZWlnaHQoKSB7XG5cdFx0XHRzZXR0aW5ncy5oID0gc2V0dGluZ3MuaCB8fCAkbG9hZGVkLmhlaWdodCgpO1xuXHRcdFx0c2V0dGluZ3MuaCA9IHNldHRpbmdzLm1oICYmIHNldHRpbmdzLm1oIDwgc2V0dGluZ3MuaCA/IHNldHRpbmdzLm1oIDogc2V0dGluZ3MuaDtcblx0XHRcdHJldHVybiBzZXR0aW5ncy5oO1xuXHRcdH1cblxuXHRcdCRsb2FkZWQuaGlkZSgpXG5cdFx0LmFwcGVuZFRvKCRsb2FkaW5nQmF5LnNob3coKSkvLyBjb250ZW50IGhhcyB0byBiZSBhcHBlbmRlZCB0byB0aGUgRE9NIGZvciBhY2N1cmF0ZSBzaXplIGNhbGN1bGF0aW9ucy5cblx0XHQuY3NzKHt3aWR0aDogZ2V0V2lkdGgoKSwgb3ZlcmZsb3c6IHNldHRpbmdzLmdldCgnc2Nyb2xsaW5nJykgPyAnYXV0bycgOiAnaGlkZGVuJ30pXG5cdFx0LmNzcyh7aGVpZ2h0OiBnZXRIZWlnaHQoKX0pLy8gc2V0cyB0aGUgaGVpZ2h0IGluZGVwZW5kZW50bHkgZnJvbSB0aGUgd2lkdGggaW4gY2FzZSB0aGUgbmV3IHdpZHRoIGluZmx1ZW5jZXMgdGhlIHZhbHVlIG9mIGhlaWdodC5cblx0XHQucHJlcGVuZFRvKCRjb250ZW50KTtcblxuXHRcdCRsb2FkaW5nQmF5LmhpZGUoKTtcblxuXHRcdC8vIGZsb2F0aW5nIHRoZSBJTUcgcmVtb3ZlcyB0aGUgYm90dG9tIGxpbmUtaGVpZ2h0IGFuZCBmaXhlZCBhIHByb2JsZW0gd2hlcmUgSUUgbWlzY2FsY3VsYXRlcyB0aGUgd2lkdGggb2YgdGhlIHBhcmVudCBlbGVtZW50IGFzIDEwMCUgb2YgdGhlIGRvY3VtZW50IHdpZHRoLlxuXG5cdFx0JChwaG90bykuY3NzKHsnZmxvYXQnOiAnbm9uZSd9KTtcblxuXHRcdHNldENsYXNzKHNldHRpbmdzLmdldCgnY2xhc3NOYW1lJykpO1xuXG5cdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgdG90YWwgPSAkcmVsYXRlZC5sZW5ndGgsXG5cdFx0XHRcdGlmcmFtZSxcblx0XHRcdFx0Y29tcGxldGU7XG5cblx0XHRcdGlmICghb3Blbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHJlbW92ZUZpbHRlcigpIHsgLy8gTmVlZGVkIGZvciBJRTggaW4gdmVyc2lvbnMgb2YgalF1ZXJ5IHByaW9yIHRvIDEuNy4yXG5cdFx0XHRcdGlmICgkLnN1cHBvcnQub3BhY2l0eSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHQkYm94WzBdLnN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnZmlsdGVyJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dChsb2FkaW5nVGltZXIpO1xuXHRcdFx0XHQkbG9hZGluZ092ZXJsYXkuaGlkZSgpO1xuXHRcdFx0XHR0cmlnZ2VyKGV2ZW50X2NvbXBsZXRlKTtcblx0XHRcdFx0c2V0dGluZ3MuZ2V0KCdvbkNvbXBsZXRlJyk7XG5cdFx0XHR9O1xuXG5cblx0XHRcdCR0aXRsZS5odG1sKHNldHRpbmdzLmdldCgndGl0bGUnKSkuc2hvdygpO1xuXHRcdFx0JGxvYWRlZC5zaG93KCk7XG5cblx0XHRcdGlmICh0b3RhbCA+IDEpIHsgLy8gaGFuZGxlIGdyb3VwaW5nXG5cdFx0XHRcdGlmICh0eXBlb2Ygc2V0dGluZ3MuZ2V0KCdjdXJyZW50JykgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHQkY3VycmVudC5odG1sKHNldHRpbmdzLmdldCgnY3VycmVudCcpLnJlcGxhY2UoJ3tjdXJyZW50fScsIGluZGV4ICsgMSkucmVwbGFjZSgne3RvdGFsfScsIHRvdGFsKSkuc2hvdygpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0JG5leHRbKHNldHRpbmdzLmdldCgnbG9vcCcpIHx8IGluZGV4IDwgdG90YWwgLSAxKSA/IFwic2hvd1wiIDogXCJoaWRlXCJdKCkuaHRtbChzZXR0aW5ncy5nZXQoJ25leHQnKSk7XG5cdFx0XHRcdCRwcmV2WyhzZXR0aW5ncy5nZXQoJ2xvb3AnKSB8fCBpbmRleCkgPyBcInNob3dcIiA6IFwiaGlkZVwiXSgpLmh0bWwoc2V0dGluZ3MuZ2V0KCdwcmV2aW91cycpKTtcblxuXHRcdFx0XHRzbGlkZXNob3coKTtcblxuXHRcdFx0XHQvLyBQcmVsb2FkcyBpbWFnZXMgd2l0aGluIGEgcmVsIGdyb3VwXG5cdFx0XHRcdGlmIChzZXR0aW5ncy5nZXQoJ3ByZWxvYWRpbmcnKSkge1xuXHRcdFx0XHRcdCQuZWFjaChbZ2V0SW5kZXgoLTEpLCBnZXRJbmRleCgxKV0sIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHR2YXIgaW1nLFxuXHRcdFx0XHRcdFx0XHRpID0gJHJlbGF0ZWRbdGhpc10sXG5cdFx0XHRcdFx0XHRcdHNldHRpbmdzID0gbmV3IFNldHRpbmdzKGksICQuZGF0YShpLCBjb2xvcmJveCkpLFxuXHRcdFx0XHRcdFx0XHRzcmMgPSBzZXR0aW5ncy5nZXQoJ2hyZWYnKTtcblxuXHRcdFx0XHRcdFx0aWYgKHNyYyAmJiBpc0ltYWdlKHNldHRpbmdzLCBzcmMpKSB7XG5cdFx0XHRcdFx0XHRcdHNyYyA9IHJldGluYVVybChzZXR0aW5ncywgc3JjKTtcblx0XHRcdFx0XHRcdFx0aW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cdFx0XHRcdFx0XHRcdGltZy5zcmMgPSBzcmM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCRncm91cENvbnRyb2xzLmhpZGUoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHNldHRpbmdzLmdldCgnaWZyYW1lJykpIHtcblxuXHRcdFx0XHRpZnJhbWUgPSBzZXR0aW5ncy5nZXQoJ2NyZWF0ZUlmcmFtZScpO1xuXG5cdFx0XHRcdGlmICghc2V0dGluZ3MuZ2V0KCdzY3JvbGxpbmcnKSkge1xuXHRcdFx0XHRcdGlmcmFtZS5zY3JvbGxpbmcgPSBcIm5vXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQkKGlmcmFtZSlcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRzcmM6IHNldHRpbmdzLmdldCgnaHJlZicpLFxuXHRcdFx0XHRcdFx0J2NsYXNzJzogcHJlZml4ICsgJ0lmcmFtZSdcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5vbmUoJ2xvYWQnLCBjb21wbGV0ZSlcblx0XHRcdFx0XHQuYXBwZW5kVG8oJGxvYWRlZCk7XG5cblx0XHRcdFx0JGV2ZW50cy5vbmUoZXZlbnRfcHVyZ2UsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZnJhbWUuc3JjID0gXCIvL2Fib3V0OmJsYW5rXCI7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChzZXR0aW5ncy5nZXQoJ2Zhc3RJZnJhbWUnKSkge1xuXHRcdFx0XHRcdCQoaWZyYW1lKS50cmlnZ2VyKCdsb2FkJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbXBsZXRlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzZXR0aW5ncy5nZXQoJ3RyYW5zaXRpb24nKSA9PT0gJ2ZhZGUnKSB7XG5cdFx0XHRcdCRib3guZmFkZVRvKHNwZWVkLCAxLCByZW1vdmVGaWx0ZXIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVtb3ZlRmlsdGVyKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGlmIChzZXR0aW5ncy5nZXQoJ3RyYW5zaXRpb24nKSA9PT0gJ2ZhZGUnKSB7XG5cdFx0XHQkYm94LmZhZGVUbyhzcGVlZCwgMCwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRwdWJsaWNNZXRob2QucG9zaXRpb24oMCwgY2FsbGJhY2spO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHB1YmxpY01ldGhvZC5wb3NpdGlvbihzcGVlZCwgY2FsbGJhY2spO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBsb2FkICgpIHtcblx0XHR2YXIgaHJlZiwgc2V0UmVzaXplLCBwcmVwID0gcHVibGljTWV0aG9kLnByZXAsICRpbmxpbmUsIHJlcXVlc3QgPSArK3JlcXVlc3RzO1xuXG5cdFx0YWN0aXZlID0gdHJ1ZTtcblxuXHRcdHBob3RvID0gZmFsc2U7XG5cblx0XHR0cmlnZ2VyKGV2ZW50X3B1cmdlKTtcblx0XHR0cmlnZ2VyKGV2ZW50X2xvYWQpO1xuXHRcdHNldHRpbmdzLmdldCgnb25Mb2FkJyk7XG5cblx0XHRzZXR0aW5ncy5oID0gc2V0dGluZ3MuZ2V0KCdoZWlnaHQnKSA/XG5cdFx0XHRcdHNldFNpemUoc2V0dGluZ3MuZ2V0KCdoZWlnaHQnKSwgJ3knKSAtIGxvYWRlZEhlaWdodCAtIGludGVyZmFjZUhlaWdodCA6XG5cdFx0XHRcdHNldHRpbmdzLmdldCgnaW5uZXJIZWlnaHQnKSAmJiBzZXRTaXplKHNldHRpbmdzLmdldCgnaW5uZXJIZWlnaHQnKSwgJ3knKTtcblxuXHRcdHNldHRpbmdzLncgPSBzZXR0aW5ncy5nZXQoJ3dpZHRoJykgP1xuXHRcdFx0XHRzZXRTaXplKHNldHRpbmdzLmdldCgnd2lkdGgnKSwgJ3gnKSAtIGxvYWRlZFdpZHRoIC0gaW50ZXJmYWNlV2lkdGggOlxuXHRcdFx0XHRzZXR0aW5ncy5nZXQoJ2lubmVyV2lkdGgnKSAmJiBzZXRTaXplKHNldHRpbmdzLmdldCgnaW5uZXJXaWR0aCcpLCAneCcpO1xuXG5cdFx0Ly8gU2V0cyB0aGUgbWluaW11bSBkaW1lbnNpb25zIGZvciB1c2UgaW4gaW1hZ2Ugc2NhbGluZ1xuXHRcdHNldHRpbmdzLm13ID0gc2V0dGluZ3Mudztcblx0XHRzZXR0aW5ncy5taCA9IHNldHRpbmdzLmg7XG5cblx0XHQvLyBSZS1ldmFsdWF0ZSB0aGUgbWluaW11bSB3aWR0aCBhbmQgaGVpZ2h0IGJhc2VkIG9uIG1heFdpZHRoIGFuZCBtYXhIZWlnaHQgdmFsdWVzLlxuXHRcdC8vIElmIHRoZSB3aWR0aCBvciBoZWlnaHQgZXhjZWVkIHRoZSBtYXhXaWR0aCBvciBtYXhIZWlnaHQsIHVzZSB0aGUgbWF4aW11bSB2YWx1ZXMgaW5zdGVhZC5cblx0XHRpZiAoc2V0dGluZ3MuZ2V0KCdtYXhXaWR0aCcpKSB7XG5cdFx0XHRzZXR0aW5ncy5tdyA9IHNldFNpemUoc2V0dGluZ3MuZ2V0KCdtYXhXaWR0aCcpLCAneCcpIC0gbG9hZGVkV2lkdGggLSBpbnRlcmZhY2VXaWR0aDtcblx0XHRcdHNldHRpbmdzLm13ID0gc2V0dGluZ3MudyAmJiBzZXR0aW5ncy53IDwgc2V0dGluZ3MubXcgPyBzZXR0aW5ncy53IDogc2V0dGluZ3MubXc7XG5cdFx0fVxuXHRcdGlmIChzZXR0aW5ncy5nZXQoJ21heEhlaWdodCcpKSB7XG5cdFx0XHRzZXR0aW5ncy5taCA9IHNldFNpemUoc2V0dGluZ3MuZ2V0KCdtYXhIZWlnaHQnKSwgJ3knKSAtIGxvYWRlZEhlaWdodCAtIGludGVyZmFjZUhlaWdodDtcblx0XHRcdHNldHRpbmdzLm1oID0gc2V0dGluZ3MuaCAmJiBzZXR0aW5ncy5oIDwgc2V0dGluZ3MubWggPyBzZXR0aW5ncy5oIDogc2V0dGluZ3MubWg7XG5cdFx0fVxuXG5cdFx0aHJlZiA9IHNldHRpbmdzLmdldCgnaHJlZicpO1xuXG5cdFx0bG9hZGluZ1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHQkbG9hZGluZ092ZXJsYXkuc2hvdygpO1xuXHRcdH0sIDEwMCk7XG5cblx0XHRpZiAoc2V0dGluZ3MuZ2V0KCdpbmxpbmUnKSkge1xuXHRcdFx0dmFyICR0YXJnZXQgPSAkKGhyZWYpLmVxKDApO1xuXHRcdFx0Ly8gSW5zZXJ0cyBhbiBlbXB0eSBwbGFjZWhvbGRlciB3aGVyZSBpbmxpbmUgY29udGVudCBpcyBiZWluZyBwdWxsZWQgZnJvbS5cblx0XHRcdC8vIEFuIGV2ZW50IGlzIGJvdW5kIHRvIHB1dCBpbmxpbmUgY29udGVudCBiYWNrIHdoZW4gQ29sb3Jib3ggY2xvc2VzIG9yIGxvYWRzIG5ldyBjb250ZW50LlxuXHRcdFx0JGlubGluZSA9ICQoJzxkaXY+JykuaGlkZSgpLmluc2VydEJlZm9yZSgkdGFyZ2V0KTtcblxuXHRcdFx0JGV2ZW50cy5vbmUoZXZlbnRfcHVyZ2UsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0JGlubGluZS5yZXBsYWNlV2l0aCgkdGFyZ2V0KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRwcmVwKCR0YXJnZXQpO1xuXHRcdH0gZWxzZSBpZiAoc2V0dGluZ3MuZ2V0KCdpZnJhbWUnKSkge1xuXHRcdFx0Ly8gSUZyYW1lIGVsZW1lbnQgd29uJ3QgYmUgYWRkZWQgdG8gdGhlIERPTSB1bnRpbCBpdCBpcyByZWFkeSB0byBiZSBkaXNwbGF5ZWQsXG5cdFx0XHQvLyB0byBhdm9pZCBwcm9ibGVtcyB3aXRoIERPTS1yZWFkeSBKUyB0aGF0IG1pZ2h0IGJlIHRyeWluZyB0byBydW4gaW4gdGhhdCBpZnJhbWUuXG5cdFx0XHRwcmVwKFwiIFwiKTtcblx0XHR9IGVsc2UgaWYgKHNldHRpbmdzLmdldCgnaHRtbCcpKSB7XG5cdFx0XHRwcmVwKHNldHRpbmdzLmdldCgnaHRtbCcpKTtcblx0XHR9IGVsc2UgaWYgKGlzSW1hZ2Uoc2V0dGluZ3MsIGhyZWYpKSB7XG5cblx0XHRcdGhyZWYgPSByZXRpbmFVcmwoc2V0dGluZ3MsIGhyZWYpO1xuXG5cdFx0XHRwaG90byA9IHNldHRpbmdzLmdldCgnY3JlYXRlSW1nJyk7XG5cblx0XHRcdCQocGhvdG8pXG5cdFx0XHQuYWRkQ2xhc3MocHJlZml4ICsgJ1Bob3RvJylcblx0XHRcdC5iaW5kKCdlcnJvci4nK3ByZWZpeCxmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHByZXAoJHRhZyhkaXYsICdFcnJvcicpLmh0bWwoc2V0dGluZ3MuZ2V0KCdpbWdFcnJvcicpKSk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uZSgnbG9hZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHJlcXVlc3QgIT09IHJlcXVlc3RzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQSBzbWFsbCBwYXVzZSBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgd2lsbCBvY2Nhc3Npb25hbHkgcmVwb3J0IGFcblx0XHRcdFx0Ly8gaW1nLndpZHRoIGFuZCBpbWcuaGVpZ2h0IG9mIHplcm8gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGltZy5vbmxvYWQgZmlyZXNcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHZhciBwZXJjZW50O1xuXG5cdFx0XHRcdFx0aWYgKHNldHRpbmdzLmdldCgncmV0aW5hSW1hZ2UnKSAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDEpIHtcblx0XHRcdFx0XHRcdHBob3RvLmhlaWdodCA9IHBob3RvLmhlaWdodCAvIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuXHRcdFx0XHRcdFx0cGhvdG8ud2lkdGggPSBwaG90by53aWR0aCAvIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChzZXR0aW5ncy5nZXQoJ3NjYWxlUGhvdG9zJykpIHtcblx0XHRcdFx0XHRcdHNldFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0cGhvdG8uaGVpZ2h0IC09IHBob3RvLmhlaWdodCAqIHBlcmNlbnQ7XG5cdFx0XHRcdFx0XHRcdHBob3RvLndpZHRoIC09IHBob3RvLndpZHRoICogcGVyY2VudDtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRpZiAoc2V0dGluZ3MubXcgJiYgcGhvdG8ud2lkdGggPiBzZXR0aW5ncy5tdykge1xuXHRcdFx0XHRcdFx0XHRwZXJjZW50ID0gKHBob3RvLndpZHRoIC0gc2V0dGluZ3MubXcpIC8gcGhvdG8ud2lkdGg7XG5cdFx0XHRcdFx0XHRcdHNldFJlc2l6ZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHNldHRpbmdzLm1oICYmIHBob3RvLmhlaWdodCA+IHNldHRpbmdzLm1oKSB7XG5cdFx0XHRcdFx0XHRcdHBlcmNlbnQgPSAocGhvdG8uaGVpZ2h0IC0gc2V0dGluZ3MubWgpIC8gcGhvdG8uaGVpZ2h0O1xuXHRcdFx0XHRcdFx0XHRzZXRSZXNpemUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoc2V0dGluZ3MuaCkge1xuXHRcdFx0XHRcdFx0cGhvdG8uc3R5bGUubWFyZ2luVG9wID0gTWF0aC5tYXgoc2V0dGluZ3MubWggLSBwaG90by5oZWlnaHQsIDApIC8gMiArICdweCc7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCRyZWxhdGVkWzFdICYmIChzZXR0aW5ncy5nZXQoJ2xvb3AnKSB8fCAkcmVsYXRlZFtpbmRleCArIDFdKSkge1xuXHRcdFx0XHRcdFx0cGhvdG8uc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuXG5cdFx0XHRcdFx0XHQkKHBob3RvKS5iaW5kKCdjbGljay4nK3ByZWZpeCwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRwdWJsaWNNZXRob2QubmV4dCgpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cGhvdG8uc3R5bGUud2lkdGggPSBwaG90by53aWR0aCArICdweCc7XG5cdFx0XHRcdFx0cGhvdG8uc3R5bGUuaGVpZ2h0ID0gcGhvdG8uaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdFx0XHRwcmVwKHBob3RvKTtcblx0XHRcdFx0fSwgMSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cGhvdG8uc3JjID0gaHJlZjtcblxuXHRcdH0gZWxzZSBpZiAoaHJlZikge1xuXHRcdFx0JGxvYWRpbmdCYXkubG9hZChocmVmLCBzZXR0aW5ncy5nZXQoJ2RhdGEnKSwgZnVuY3Rpb24gKGRhdGEsIHN0YXR1cykge1xuXHRcdFx0XHRpZiAocmVxdWVzdCA9PT0gcmVxdWVzdHMpIHtcblx0XHRcdFx0XHRwcmVwKHN0YXR1cyA9PT0gJ2Vycm9yJyA/ICR0YWcoZGl2LCAnRXJyb3InKS5odG1sKHNldHRpbmdzLmdldCgneGhyRXJyb3InKSkgOiAkKHRoaXMpLmNvbnRlbnRzKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvLyBOYXZpZ2F0ZXMgdG8gdGhlIG5leHQgcGFnZS9pbWFnZSBpbiBhIHNldC5cblx0cHVibGljTWV0aG9kLm5leHQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCFhY3RpdmUgJiYgJHJlbGF0ZWRbMV0gJiYgKHNldHRpbmdzLmdldCgnbG9vcCcpIHx8ICRyZWxhdGVkW2luZGV4ICsgMV0pKSB7XG5cdFx0XHRpbmRleCA9IGdldEluZGV4KDEpO1xuXHRcdFx0bGF1bmNoKCRyZWxhdGVkW2luZGV4XSk7XG5cdFx0fVxuXHR9O1xuXG5cdHB1YmxpY01ldGhvZC5wcmV2ID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICghYWN0aXZlICYmICRyZWxhdGVkWzFdICYmIChzZXR0aW5ncy5nZXQoJ2xvb3AnKSB8fCBpbmRleCkpIHtcblx0XHRcdGluZGV4ID0gZ2V0SW5kZXgoLTEpO1xuXHRcdFx0bGF1bmNoKCRyZWxhdGVkW2luZGV4XSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIE5vdGU6IHRvIHVzZSB0aGlzIHdpdGhpbiBhbiBpZnJhbWUgdXNlIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBwYXJlbnQualF1ZXJ5LmNvbG9yYm94LmNsb3NlKCk7XG5cdHB1YmxpY01ldGhvZC5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAob3BlbiAmJiAhY2xvc2luZykge1xuXG5cdFx0XHRjbG9zaW5nID0gdHJ1ZTtcblx0XHRcdG9wZW4gPSBmYWxzZTtcblx0XHRcdHRyaWdnZXIoZXZlbnRfY2xlYW51cCk7XG5cdFx0XHRzZXR0aW5ncy5nZXQoJ29uQ2xlYW51cCcpO1xuXHRcdFx0JHdpbmRvdy51bmJpbmQoJy4nICsgcHJlZml4KTtcblx0XHRcdCRvdmVybGF5LmZhZGVUbyhzZXR0aW5ncy5nZXQoJ2ZhZGVPdXQnKSB8fCAwLCAwKTtcblxuXHRcdFx0JGJveC5zdG9wKCkuZmFkZVRvKHNldHRpbmdzLmdldCgnZmFkZU91dCcpIHx8IDAsIDAsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0JGJveC5oaWRlKCk7XG5cdFx0XHRcdCRvdmVybGF5LmhpZGUoKTtcblx0XHRcdFx0dHJpZ2dlcihldmVudF9wdXJnZSk7XG5cdFx0XHRcdCRsb2FkZWQucmVtb3ZlKCk7XG5cblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Y2xvc2luZyA9IGZhbHNlO1xuXHRcdFx0XHRcdHRyaWdnZXIoZXZlbnRfY2xvc2VkKTtcblx0XHRcdFx0XHRzZXR0aW5ncy5nZXQoJ29uQ2xvc2VkJyk7XG5cdFx0XHRcdH0sIDEpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIFJlbW92ZXMgY2hhbmdlcyBDb2xvcmJveCBtYWRlIHRvIHRoZSBkb2N1bWVudCwgYnV0IGRvZXMgbm90IHJlbW92ZSB0aGUgcGx1Z2luLlxuXHRwdWJsaWNNZXRob2QucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICghJGJveCkgeyByZXR1cm47IH1cblxuXHRcdCRib3guc3RvcCgpO1xuXHRcdCRbY29sb3Jib3hdLmNsb3NlKCk7XG5cdFx0JGJveC5zdG9wKGZhbHNlLCB0cnVlKS5yZW1vdmUoKTtcblx0XHQkb3ZlcmxheS5yZW1vdmUoKTtcblx0XHRjbG9zaW5nID0gZmFsc2U7XG5cdFx0JGJveCA9IG51bGw7XG5cdFx0JCgnLicgKyBib3hFbGVtZW50KVxuXHRcdFx0LnJlbW92ZURhdGEoY29sb3Jib3gpXG5cdFx0XHQucmVtb3ZlQ2xhc3MoYm94RWxlbWVudCk7XG5cblx0XHQkKGRvY3VtZW50KS51bmJpbmQoJ2NsaWNrLicrcHJlZml4KS51bmJpbmQoJ2tleWRvd24uJytwcmVmaXgpO1xuXHR9O1xuXG5cdC8vIEEgbWV0aG9kIGZvciBmZXRjaGluZyB0aGUgY3VycmVudCBlbGVtZW50IENvbG9yYm94IGlzIHJlZmVyZW5jaW5nLlxuXHQvLyByZXR1cm5zIGEgalF1ZXJ5IG9iamVjdC5cblx0cHVibGljTWV0aG9kLmVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICQoc2V0dGluZ3MuZWwpO1xuXHR9O1xuXG5cdHB1YmxpY01ldGhvZC5zZXR0aW5ncyA9IGRlZmF1bHRzO1xuXG59KGpRdWVyeSwgZG9jdW1lbnQsIHdpbmRvdykpO1xuIiwiLyohXG4gKiBqUXVlcnkgTW91c2V3aGVlbCAzLjEuMTNcbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgaWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUvQ29tbW9uSlMgc3R5bGUgZm9yIEJyb3dzZXJpZnlcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgICAgICBmYWN0b3J5KGpRdWVyeSk7XG4gICAgfVxufShmdW5jdGlvbiAoJCkge1xuXG4gICAgdmFyIHRvRml4ICA9IFsnd2hlZWwnLCAnbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJ10sXG4gICAgICAgIHRvQmluZCA9ICggJ29ud2hlZWwnIGluIGRvY3VtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+PSA5ICkgP1xuICAgICAgICAgICAgICAgICAgICBbJ3doZWVsJ10gOiBbJ21vdXNld2hlZWwnLCAnRG9tTW91c2VTY3JvbGwnLCAnTW96TW91c2VQaXhlbFNjcm9sbCddLFxuICAgICAgICBzbGljZSAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG4gICAgICAgIG51bGxMb3dlc3REZWx0YVRpbWVvdXQsIGxvd2VzdERlbHRhO1xuXG4gICAgaWYgKCAkLmV2ZW50LmZpeEhvb2tzICkge1xuICAgICAgICBmb3IgKCB2YXIgaSA9IHRvRml4Lmxlbmd0aDsgaTsgKSB7XG4gICAgICAgICAgICAkLmV2ZW50LmZpeEhvb2tzWyB0b0ZpeFstLWldIF0gPSAkLmV2ZW50Lm1vdXNlSG9va3M7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3BlY2lhbCA9ICQuZXZlbnQuc3BlY2lhbC5tb3VzZXdoZWVsID0ge1xuICAgICAgICB2ZXJzaW9uOiAnMy4xLjEyJyxcblxuICAgICAgICBzZXR1cDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciApIHtcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaSA9IHRvQmluZC5sZW5ndGg7IGk7ICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoIHRvQmluZFstLWldLCBoYW5kbGVyLCBmYWxzZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbm1vdXNld2hlZWwgPSBoYW5kbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGxpbmUgaGVpZ2h0IGFuZCBwYWdlIGhlaWdodCBmb3IgdGhpcyBwYXJ0aWN1bGFyIGVsZW1lbnRcbiAgICAgICAgICAgICQuZGF0YSh0aGlzLCAnbW91c2V3aGVlbC1saW5lLWhlaWdodCcsIHNwZWNpYWwuZ2V0TGluZUhlaWdodCh0aGlzKSk7XG4gICAgICAgICAgICAkLmRhdGEodGhpcywgJ21vdXNld2hlZWwtcGFnZS1oZWlnaHQnLCBzcGVjaWFsLmdldFBhZ2VIZWlnaHQodGhpcykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRlYXJkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICggdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuICAgICAgICAgICAgICAgIGZvciAoIHZhciBpID0gdG9CaW5kLmxlbmd0aDsgaTsgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggdG9CaW5kWy0taV0sIGhhbmRsZXIsIGZhbHNlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ubW91c2V3aGVlbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgZGF0YSB3ZSBhZGRlZCB0byB0aGUgZWxlbWVudFxuICAgICAgICAgICAgJC5yZW1vdmVEYXRhKHRoaXMsICdtb3VzZXdoZWVsLWxpbmUtaGVpZ2h0Jyk7XG4gICAgICAgICAgICAkLnJlbW92ZURhdGEodGhpcywgJ21vdXNld2hlZWwtcGFnZS1oZWlnaHQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRMaW5lSGVpZ2h0OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICB2YXIgJGVsZW0gPSAkKGVsZW0pLFxuICAgICAgICAgICAgICAgICRwYXJlbnQgPSAkZWxlbVsnb2Zmc2V0UGFyZW50JyBpbiAkLmZuID8gJ29mZnNldFBhcmVudCcgOiAncGFyZW50J10oKTtcbiAgICAgICAgICAgIGlmICghJHBhcmVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAkcGFyZW50ID0gJCgnYm9keScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KCRwYXJlbnQuY3NzKCdmb250U2l6ZScpLCAxMCkgfHwgcGFyc2VJbnQoJGVsZW0uY3NzKCdmb250U2l6ZScpLCAxMCkgfHwgMTY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0UGFnZUhlaWdodDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuICQoZWxlbSkuaGVpZ2h0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGFkanVzdE9sZERlbHRhczogdHJ1ZSwgLy8gc2VlIHNob3VsZEFkanVzdE9sZERlbHRhcygpIGJlbG93XG4gICAgICAgICAgICBub3JtYWxpemVPZmZzZXQ6IHRydWUgIC8vIGNhbGxzIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmb3IgZWFjaCBldmVudFxuICAgICAgICB9XG4gICAgfTtcblxuICAgICQuZm4uZXh0ZW5kKHtcbiAgICAgICAgbW91c2V3aGVlbDogZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmbiA/IHRoaXMuYmluZCgnbW91c2V3aGVlbCcsIGZuKSA6IHRoaXMudHJpZ2dlcignbW91c2V3aGVlbCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVubW91c2V3aGVlbDogZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuYmluZCgnbW91c2V3aGVlbCcsIGZuKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIHZhciBvcmdFdmVudCAgID0gZXZlbnQgfHwgd2luZG93LmV2ZW50LFxuICAgICAgICAgICAgYXJncyAgICAgICA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIGRlbHRhICAgICAgPSAwLFxuICAgICAgICAgICAgZGVsdGFYICAgICA9IDAsXG4gICAgICAgICAgICBkZWx0YVkgICAgID0gMCxcbiAgICAgICAgICAgIGFic0RlbHRhICAgPSAwLFxuICAgICAgICAgICAgb2Zmc2V0WCAgICA9IDAsXG4gICAgICAgICAgICBvZmZzZXRZICAgID0gMDtcbiAgICAgICAgZXZlbnQgPSAkLmV2ZW50LmZpeChvcmdFdmVudCk7XG4gICAgICAgIGV2ZW50LnR5cGUgPSAnbW91c2V3aGVlbCc7XG5cbiAgICAgICAgLy8gT2xkIHNjaG9vbCBzY3JvbGx3aGVlbCBkZWx0YVxuICAgICAgICBpZiAoICdkZXRhaWwnICAgICAgaW4gb3JnRXZlbnQgKSB7IGRlbHRhWSA9IG9yZ0V2ZW50LmRldGFpbCAqIC0xOyAgICAgIH1cbiAgICAgICAgaWYgKCAnd2hlZWxEZWx0YScgIGluIG9yZ0V2ZW50ICkgeyBkZWx0YVkgPSBvcmdFdmVudC53aGVlbERlbHRhOyAgICAgICB9XG4gICAgICAgIGlmICggJ3doZWVsRGVsdGFZJyBpbiBvcmdFdmVudCApIHsgZGVsdGFZID0gb3JnRXZlbnQud2hlZWxEZWx0YVk7ICAgICAgfVxuICAgICAgICBpZiAoICd3aGVlbERlbHRhWCcgaW4gb3JnRXZlbnQgKSB7IGRlbHRhWCA9IG9yZ0V2ZW50LndoZWVsRGVsdGFYICogLTE7IH1cblxuICAgICAgICAvLyBGaXJlZm94IDwgMTcgaG9yaXpvbnRhbCBzY3JvbGxpbmcgcmVsYXRlZCB0byBET01Nb3VzZVNjcm9sbCBldmVudFxuICAgICAgICBpZiAoICdheGlzJyBpbiBvcmdFdmVudCAmJiBvcmdFdmVudC5heGlzID09PSBvcmdFdmVudC5IT1JJWk9OVEFMX0FYSVMgKSB7XG4gICAgICAgICAgICBkZWx0YVggPSBkZWx0YVkgKiAtMTtcbiAgICAgICAgICAgIGRlbHRhWSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgZGVsdGEgdG8gYmUgZGVsdGFZIG9yIGRlbHRhWCBpZiBkZWx0YVkgaXMgMCBmb3IgYmFja3dhcmRzIGNvbXBhdGFiaWxpdGl5XG4gICAgICAgIGRlbHRhID0gZGVsdGFZID09PSAwID8gZGVsdGFYIDogZGVsdGFZO1xuXG4gICAgICAgIC8vIE5ldyBzY2hvb2wgd2hlZWwgZGVsdGEgKHdoZWVsIGV2ZW50KVxuICAgICAgICBpZiAoICdkZWx0YVknIGluIG9yZ0V2ZW50ICkge1xuICAgICAgICAgICAgZGVsdGFZID0gb3JnRXZlbnQuZGVsdGFZICogLTE7XG4gICAgICAgICAgICBkZWx0YSAgPSBkZWx0YVk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAnZGVsdGFYJyBpbiBvcmdFdmVudCApIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IG9yZ0V2ZW50LmRlbHRhWDtcbiAgICAgICAgICAgIGlmICggZGVsdGFZID09PSAwICkgeyBkZWx0YSAgPSBkZWx0YVggKiAtMTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm8gY2hhbmdlIGFjdHVhbGx5IGhhcHBlbmVkLCBubyByZWFzb24gdG8gZ28gYW55IGZ1cnRoZXJcbiAgICAgICAgaWYgKCBkZWx0YVkgPT09IDAgJiYgZGVsdGFYID09PSAwICkgeyByZXR1cm47IH1cblxuICAgICAgICAvLyBOZWVkIHRvIGNvbnZlcnQgbGluZXMgYW5kIHBhZ2VzIHRvIHBpeGVscyBpZiB3ZSBhcmVuJ3QgYWxyZWFkeSBpbiBwaXhlbHNcbiAgICAgICAgLy8gVGhlcmUgYXJlIHRocmVlIGRlbHRhIG1vZGVzOlxuICAgICAgICAvLyAgICogZGVsdGFNb2RlIDAgaXMgYnkgcGl4ZWxzLCBub3RoaW5nIHRvIGRvXG4gICAgICAgIC8vICAgKiBkZWx0YU1vZGUgMSBpcyBieSBsaW5lc1xuICAgICAgICAvLyAgICogZGVsdGFNb2RlIDIgaXMgYnkgcGFnZXNcbiAgICAgICAgaWYgKCBvcmdFdmVudC5kZWx0YU1vZGUgPT09IDEgKSB7XG4gICAgICAgICAgICB2YXIgbGluZUhlaWdodCA9ICQuZGF0YSh0aGlzLCAnbW91c2V3aGVlbC1saW5lLWhlaWdodCcpO1xuICAgICAgICAgICAgZGVsdGEgICo9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBkZWx0YVkgKj0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIGRlbHRhWCAqPSBsaW5lSGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKCBvcmdFdmVudC5kZWx0YU1vZGUgPT09IDIgKSB7XG4gICAgICAgICAgICB2YXIgcGFnZUhlaWdodCA9ICQuZGF0YSh0aGlzLCAnbW91c2V3aGVlbC1wYWdlLWhlaWdodCcpO1xuICAgICAgICAgICAgZGVsdGEgICo9IHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBkZWx0YVkgKj0gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIGRlbHRhWCAqPSBwYWdlSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RvcmUgbG93ZXN0IGFic29sdXRlIGRlbHRhIHRvIG5vcm1hbGl6ZSB0aGUgZGVsdGEgdmFsdWVzXG4gICAgICAgIGFic0RlbHRhID0gTWF0aC5tYXgoIE1hdGguYWJzKGRlbHRhWSksIE1hdGguYWJzKGRlbHRhWCkgKTtcblxuICAgICAgICBpZiAoICFsb3dlc3REZWx0YSB8fCBhYnNEZWx0YSA8IGxvd2VzdERlbHRhICkge1xuICAgICAgICAgICAgbG93ZXN0RGVsdGEgPSBhYnNEZWx0YTtcblxuICAgICAgICAgICAgLy8gQWRqdXN0IG9sZGVyIGRlbHRhcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIGlmICggc2hvdWxkQWRqdXN0T2xkRGVsdGFzKG9yZ0V2ZW50LCBhYnNEZWx0YSkgKSB7XG4gICAgICAgICAgICAgICAgbG93ZXN0RGVsdGEgLz0gNDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGp1c3Qgb2xkZXIgZGVsdGFzIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAoIHNob3VsZEFkanVzdE9sZERlbHRhcyhvcmdFdmVudCwgYWJzRGVsdGEpICkge1xuICAgICAgICAgICAgLy8gRGl2aWRlIGFsbCB0aGUgdGhpbmdzIGJ5IDQwIVxuICAgICAgICAgICAgZGVsdGEgIC89IDQwO1xuICAgICAgICAgICAgZGVsdGFYIC89IDQwO1xuICAgICAgICAgICAgZGVsdGFZIC89IDQwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGEgd2hvbGUsIG5vcm1hbGl6ZWQgdmFsdWUgZm9yIHRoZSBkZWx0YXNcbiAgICAgICAgZGVsdGEgID0gTWF0aFsgZGVsdGEgID49IDEgPyAnZmxvb3InIDogJ2NlaWwnIF0oZGVsdGEgIC8gbG93ZXN0RGVsdGEpO1xuICAgICAgICBkZWx0YVggPSBNYXRoWyBkZWx0YVggPj0gMSA/ICdmbG9vcicgOiAnY2VpbCcgXShkZWx0YVggLyBsb3dlc3REZWx0YSk7XG4gICAgICAgIGRlbHRhWSA9IE1hdGhbIGRlbHRhWSA+PSAxID8gJ2Zsb29yJyA6ICdjZWlsJyBdKGRlbHRhWSAvIGxvd2VzdERlbHRhKTtcblxuICAgICAgICAvLyBOb3JtYWxpc2Ugb2Zmc2V0WCBhbmQgb2Zmc2V0WSBwcm9wZXJ0aWVzXG4gICAgICAgIGlmICggc3BlY2lhbC5zZXR0aW5ncy5ub3JtYWxpemVPZmZzZXQgJiYgdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QgKSB7XG4gICAgICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIG9mZnNldFggPSBldmVudC5jbGllbnRYIC0gYm91bmRpbmdSZWN0LmxlZnQ7XG4gICAgICAgICAgICBvZmZzZXRZID0gZXZlbnQuY2xpZW50WSAtIGJvdW5kaW5nUmVjdC50b3A7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgaW5mb3JtYXRpb24gdG8gdGhlIGV2ZW50IG9iamVjdFxuICAgICAgICBldmVudC5kZWx0YVggPSBkZWx0YVg7XG4gICAgICAgIGV2ZW50LmRlbHRhWSA9IGRlbHRhWTtcbiAgICAgICAgZXZlbnQuZGVsdGFGYWN0b3IgPSBsb3dlc3REZWx0YTtcbiAgICAgICAgZXZlbnQub2Zmc2V0WCA9IG9mZnNldFg7XG4gICAgICAgIGV2ZW50Lm9mZnNldFkgPSBvZmZzZXRZO1xuICAgICAgICAvLyBHbyBhaGVhZCBhbmQgc2V0IGRlbHRhTW9kZSB0byAwIHNpbmNlIHdlIGNvbnZlcnRlZCB0byBwaXhlbHNcbiAgICAgICAgLy8gQWx0aG91Z2ggdGhpcyBpcyBhIGxpdHRsZSBvZGQgc2luY2Ugd2Ugb3ZlcndyaXRlIHRoZSBkZWx0YVgvWVxuICAgICAgICAvLyBwcm9wZXJ0aWVzIHdpdGggbm9ybWFsaXplZCBkZWx0YXMuXG4gICAgICAgIGV2ZW50LmRlbHRhTW9kZSA9IDA7XG5cbiAgICAgICAgLy8gQWRkIGV2ZW50IGFuZCBkZWx0YSB0byB0aGUgZnJvbnQgb2YgdGhlIGFyZ3VtZW50c1xuICAgICAgICBhcmdzLnVuc2hpZnQoZXZlbnQsIGRlbHRhLCBkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICAgICAgLy8gQ2xlYXJvdXQgbG93ZXN0RGVsdGEgYWZ0ZXIgc29tZXRpbWUgdG8gYmV0dGVyXG4gICAgICAgIC8vIGhhbmRsZSBtdWx0aXBsZSBkZXZpY2UgdHlwZXMgdGhhdCBnaXZlIGRpZmZlcmVudFxuICAgICAgICAvLyBhIGRpZmZlcmVudCBsb3dlc3REZWx0YVxuICAgICAgICAvLyBFeDogdHJhY2twYWQgPSAzIGFuZCBtb3VzZSB3aGVlbCA9IDEyMFxuICAgICAgICBpZiAobnVsbExvd2VzdERlbHRhVGltZW91dCkgeyBjbGVhclRpbWVvdXQobnVsbExvd2VzdERlbHRhVGltZW91dCk7IH1cbiAgICAgICAgbnVsbExvd2VzdERlbHRhVGltZW91dCA9IHNldFRpbWVvdXQobnVsbExvd2VzdERlbHRhLCAyMDApO1xuXG4gICAgICAgIHJldHVybiAoJC5ldmVudC5kaXNwYXRjaCB8fCAkLmV2ZW50LmhhbmRsZSkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbnVsbExvd2VzdERlbHRhKCkge1xuICAgICAgICBsb3dlc3REZWx0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvdWxkQWRqdXN0T2xkRGVsdGFzKG9yZ0V2ZW50LCBhYnNEZWx0YSkge1xuICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIG9sZGVyIGV2ZW50IGFuZCB0aGUgZGVsdGEgaXMgZGl2aXNhYmxlIGJ5IDEyMCxcbiAgICAgICAgLy8gdGhlbiB3ZSBhcmUgYXNzdW1pbmcgdGhhdCB0aGUgYnJvd3NlciBpcyB0cmVhdGluZyB0aGlzIGFzIGFuXG4gICAgICAgIC8vIG9sZGVyIG1vdXNlIHdoZWVsIGV2ZW50IGFuZCB0aGF0IHdlIHNob3VsZCBkaXZpZGUgdGhlIGRlbHRhc1xuICAgICAgICAvLyBieSA0MCB0byB0cnkgYW5kIGdldCBhIG1vcmUgdXNhYmxlIGRlbHRhRmFjdG9yLlxuICAgICAgICAvLyBTaWRlIG5vdGUsIHRoaXMgYWN0dWFsbHkgaW1wYWN0cyB0aGUgcmVwb3J0ZWQgc2Nyb2xsIGRpc3RhbmNlXG4gICAgICAgIC8vIGluIG9sZGVyIGJyb3dzZXJzIGFuZCBjYW4gY2F1c2Ugc2Nyb2xsaW5nIHRvIGJlIHNsb3dlciB0aGFuIG5hdGl2ZS5cbiAgICAgICAgLy8gVHVybiB0aGlzIG9mZiBieSBzZXR0aW5nICQuZXZlbnQuc3BlY2lhbC5tb3VzZXdoZWVsLnNldHRpbmdzLmFkanVzdE9sZERlbHRhcyB0byBmYWxzZS5cbiAgICAgICAgcmV0dXJuIHNwZWNpYWwuc2V0dGluZ3MuYWRqdXN0T2xkRGVsdGFzICYmIG9yZ0V2ZW50LnR5cGUgPT09ICdtb3VzZXdoZWVsJyAmJiBhYnNEZWx0YSAlIDEyMCA9PT0gMDtcbiAgICB9XG5cbn0pKTtcbiIsIiQoZnVuY3Rpb24gKCkge1xuICAgICQoJ2lucHV0W2RhdGEtbWF4LWNoYXJzXScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGlucHV0ID0gJCh0aGlzKTtcblxuICAgICAgICAkaW5wdXQudGV4dGNvdW50ZXIoe1xuICAgICAgICAgICAgY291bnRDb250YWluZXJDbGFzczogJ2lucHV0X25vdGUnLFxuICAgICAgICAgICAgY291bnREb3duOiAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIGNvdW50RG93blRleHQ6ICAgICAgIFRyYW5zbGF0b3IudHJhbnMoJ3RleHRjb3VudGVyLmNvdW50X2Rvd25fdGV4dCcpLFxuICAgICAgICAgICAgY291bnRPdmVyZmxvdzogICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIGNvdW50T3ZlcmZsb3dUZXh0OiAgIFRyYW5zbGF0b3IudHJhbnMoJ3RleHRjb3VudGVyLmNvdW50X292ZXJmbG93X3RleHQnKSxcbiAgICAgICAgICAgIGNvdW50U3BhY2VzOiAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBkaXNwbGF5RXJyb3JUZXh0OiAgICBmYWxzZSxcbiAgICAgICAgICAgIG1heDogICAgICAgICAgICAgICAgICRpbnB1dC5kYXRhKCdtYXgtY2hhcnMnKSxcbiAgICAgICAgICAgIHN0b3BJbnB1dEF0TWF4aW11bTogIGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH0pO1xufSk7XG4iLCIvKiEgalF1ZXJ5IFVJIC0gdjEuMTIuMSAtIDIwMTYtMDktMTRcbiogaHR0cDovL2pxdWVyeXVpLmNvbVxuKiBJbmNsdWRlczogd2lkZ2V0LmpzLCBwb3NpdGlvbi5qcywgZGF0YS5qcywgZGlzYWJsZS1zZWxlY3Rpb24uanMsIGVmZmVjdC5qcywgZWZmZWN0cy9lZmZlY3QtYmxpbmQuanMsIGVmZmVjdHMvZWZmZWN0LWJvdW5jZS5qcywgZWZmZWN0cy9lZmZlY3QtY2xpcC5qcywgZWZmZWN0cy9lZmZlY3QtZHJvcC5qcywgZWZmZWN0cy9lZmZlY3QtZXhwbG9kZS5qcywgZWZmZWN0cy9lZmZlY3QtZmFkZS5qcywgZWZmZWN0cy9lZmZlY3QtZm9sZC5qcywgZWZmZWN0cy9lZmZlY3QtaGlnaGxpZ2h0LmpzLCBlZmZlY3RzL2VmZmVjdC1wdWZmLmpzLCBlZmZlY3RzL2VmZmVjdC1wdWxzYXRlLmpzLCBlZmZlY3RzL2VmZmVjdC1zY2FsZS5qcywgZWZmZWN0cy9lZmZlY3Qtc2hha2UuanMsIGVmZmVjdHMvZWZmZWN0LXNpemUuanMsIGVmZmVjdHMvZWZmZWN0LXNsaWRlLmpzLCBlZmZlY3RzL2VmZmVjdC10cmFuc2Zlci5qcywgZm9jdXNhYmxlLmpzLCBmb3JtLXJlc2V0LW1peGluLmpzLCBqcXVlcnktMS03LmpzLCBrZXljb2RlLmpzLCBsYWJlbHMuanMsIHNjcm9sbC1wYXJlbnQuanMsIHRhYmJhYmxlLmpzLCB1bmlxdWUtaWQuanMsIHdpZGdldHMvYWNjb3JkaW9uLmpzLCB3aWRnZXRzL2F1dG9jb21wbGV0ZS5qcywgd2lkZ2V0cy9idXR0b24uanMsIHdpZGdldHMvY2hlY2tib3hyYWRpby5qcywgd2lkZ2V0cy9jb250cm9sZ3JvdXAuanMsIHdpZGdldHMvZGF0ZXBpY2tlci5qcywgd2lkZ2V0cy9kaWFsb2cuanMsIHdpZGdldHMvZHJhZ2dhYmxlLmpzLCB3aWRnZXRzL2Ryb3BwYWJsZS5qcywgd2lkZ2V0cy9tZW51LmpzLCB3aWRnZXRzL21vdXNlLmpzLCB3aWRnZXRzL3Byb2dyZXNzYmFyLmpzLCB3aWRnZXRzL3Jlc2l6YWJsZS5qcywgd2lkZ2V0cy9zZWxlY3RhYmxlLmpzLCB3aWRnZXRzL3NlbGVjdG1lbnUuanMsIHdpZGdldHMvc2xpZGVyLmpzLCB3aWRnZXRzL3NvcnRhYmxlLmpzLCB3aWRnZXRzL3NwaW5uZXIuanMsIHdpZGdldHMvdGFicy5qcywgd2lkZ2V0cy90b29sdGlwLmpzXG4qIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzOyBMaWNlbnNlZCBNSVQgKi9cblxuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZShbIFwianF1ZXJ5XCIgXSwgZmFjdG9yeSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeSggalF1ZXJ5ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQgKSB7XG5cbiQudWkgPSAkLnVpIHx8IHt9O1xuXG52YXIgdmVyc2lvbiA9ICQudWkudmVyc2lvbiA9IFwiMS4xMi4xXCI7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgV2lkZ2V0IDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBXaWRnZXRcbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBQcm92aWRlcyBhIGZhY3RvcnkgZm9yIGNyZWF0aW5nIHN0YXRlZnVsIHdpZGdldHMgd2l0aCBhIGNvbW1vbiBBUEkuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20valF1ZXJ5LndpZGdldC9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS93aWRnZXQvXG5cblxuXG52YXIgd2lkZ2V0VXVpZCA9IDA7XG52YXIgd2lkZ2V0U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiQuY2xlYW5EYXRhID0gKCBmdW5jdGlvbiggb3JpZyApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZXZlbnRzLCBlbGVtLCBpO1xuXHRcdGZvciAoIGkgPSAwOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHQvLyBPbmx5IHRyaWdnZXIgcmVtb3ZlIHdoZW4gbmVjZXNzYXJ5IHRvIHNhdmUgdGltZVxuXHRcdFx0XHRldmVudHMgPSAkLl9kYXRhKCBlbGVtLCBcImV2ZW50c1wiICk7XG5cdFx0XHRcdGlmICggZXZlbnRzICYmIGV2ZW50cy5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0JCggZWxlbSApLnRyaWdnZXJIYW5kbGVyKCBcInJlbW92ZVwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvODIzNVxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdH1cblx0XHRvcmlnKCBlbGVtcyApO1xuXHR9O1xufSApKCAkLmNsZWFuRGF0YSApO1xuXG4kLndpZGdldCA9IGZ1bmN0aW9uKCBuYW1lLCBiYXNlLCBwcm90b3R5cGUgKSB7XG5cdHZhciBleGlzdGluZ0NvbnN0cnVjdG9yLCBjb25zdHJ1Y3RvciwgYmFzZVByb3RvdHlwZTtcblxuXHQvLyBQcm94aWVkUHJvdG90eXBlIGFsbG93cyB0aGUgcHJvdmlkZWQgcHJvdG90eXBlIHRvIHJlbWFpbiB1bm1vZGlmaWVkXG5cdC8vIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgYXMgYSBtaXhpbiBmb3IgbXVsdGlwbGUgd2lkZ2V0cyAoIzg4NzYpXG5cdHZhciBwcm94aWVkUHJvdG90eXBlID0ge307XG5cblx0dmFyIG5hbWVzcGFjZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDAgXTtcblx0bmFtZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDEgXTtcblx0dmFyIGZ1bGxOYW1lID0gbmFtZXNwYWNlICsgXCItXCIgKyBuYW1lO1xuXG5cdGlmICggIXByb3RvdHlwZSApIHtcblx0XHRwcm90b3R5cGUgPSBiYXNlO1xuXHRcdGJhc2UgPSAkLldpZGdldDtcblx0fVxuXG5cdGlmICggJC5pc0FycmF5KCBwcm90b3R5cGUgKSApIHtcblx0XHRwcm90b3R5cGUgPSAkLmV4dGVuZC5hcHBseSggbnVsbCwgWyB7fSBdLmNvbmNhdCggcHJvdG90eXBlICkgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBzZWxlY3RvciBmb3IgcGx1Z2luXG5cdCQuZXhwclsgXCI6XCIgXVsgZnVsbE5hbWUudG9Mb3dlckNhc2UoKSBdID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICEhJC5kYXRhKCBlbGVtLCBmdWxsTmFtZSApO1xuXHR9O1xuXG5cdCRbIG5hbWVzcGFjZSBdID0gJFsgbmFtZXNwYWNlIF0gfHwge307XG5cdGV4aXN0aW5nQ29uc3RydWN0b3IgPSAkWyBuYW1lc3BhY2UgXVsgbmFtZSBdO1xuXHRjb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF0gPSBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblxuXHRcdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCBcIm5ld1wiIGtleXdvcmRcblx0XHRpZiAoICF0aGlzLl9jcmVhdGVXaWRnZXQgKSB7XG5cdFx0XHRyZXR1cm4gbmV3IGNvbnN0cnVjdG9yKCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IGluaXRpYWxpemluZyBmb3Igc2ltcGxlIGluaGVyaXRhbmNlXG5cdFx0Ly8gbXVzdCB1c2UgXCJuZXdcIiBrZXl3b3JkICh0aGUgY29kZSBhYm92ZSBhbHdheXMgcGFzc2VzIGFyZ3MpXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5fY3JlYXRlV2lkZ2V0KCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEV4dGVuZCB3aXRoIHRoZSBleGlzdGluZyBjb25zdHJ1Y3RvciB0byBjYXJyeSBvdmVyIGFueSBzdGF0aWMgcHJvcGVydGllc1xuXHQkLmV4dGVuZCggY29uc3RydWN0b3IsIGV4aXN0aW5nQ29uc3RydWN0b3IsIHtcblx0XHR2ZXJzaW9uOiBwcm90b3R5cGUudmVyc2lvbixcblxuXHRcdC8vIENvcHkgdGhlIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGUgcHJvdG90eXBlIGluIGNhc2Ugd2UgbmVlZCB0b1xuXHRcdC8vIHJlZGVmaW5lIHRoZSB3aWRnZXQgbGF0ZXJcblx0XHRfcHJvdG86ICQuZXh0ZW5kKCB7fSwgcHJvdG90eXBlICksXG5cblx0XHQvLyBUcmFjayB3aWRnZXRzIHRoYXQgaW5oZXJpdCBmcm9tIHRoaXMgd2lkZ2V0IGluIGNhc2UgdGhpcyB3aWRnZXQgaXNcblx0XHQvLyByZWRlZmluZWQgYWZ0ZXIgYSB3aWRnZXQgaW5oZXJpdHMgZnJvbSBpdFxuXHRcdF9jaGlsZENvbnN0cnVjdG9yczogW11cblx0fSApO1xuXG5cdGJhc2VQcm90b3R5cGUgPSBuZXcgYmFzZSgpO1xuXG5cdC8vIFdlIG5lZWQgdG8gbWFrZSB0aGUgb3B0aW9ucyBoYXNoIGEgcHJvcGVydHkgZGlyZWN0bHkgb24gdGhlIG5ldyBpbnN0YW5jZVxuXHQvLyBvdGhlcndpc2Ugd2UnbGwgbW9kaWZ5IHRoZSBvcHRpb25zIGhhc2ggb24gdGhlIHByb3RvdHlwZSB0aGF0IHdlJ3JlXG5cdC8vIGluaGVyaXRpbmcgZnJvbVxuXHRiYXNlUHJvdG90eXBlLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LCBiYXNlUHJvdG90eXBlLm9wdGlvbnMgKTtcblx0JC5lYWNoKCBwcm90b3R5cGUsIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRpZiAoICEkLmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSB2YWx1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cHJveGllZFByb3RvdHlwZVsgcHJvcCBdID0gKCBmdW5jdGlvbigpIHtcblx0XHRcdGZ1bmN0aW9uIF9zdXBlcigpIHtcblx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBfc3VwZXJBcHBseSggYXJncyApIHtcblx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgX19zdXBlciA9IHRoaXMuX3N1cGVyO1xuXHRcdFx0XHR2YXIgX19zdXBlckFwcGx5ID0gdGhpcy5fc3VwZXJBcHBseTtcblx0XHRcdFx0dmFyIHJldHVyblZhbHVlO1xuXG5cdFx0XHRcdHRoaXMuX3N1cGVyID0gX3N1cGVyO1xuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuVmFsdWUgPSB2YWx1ZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfX3N1cGVyO1xuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX19zdXBlckFwcGx5O1xuXG5cdFx0XHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0XHRcdH07XG5cdFx0fSApKCk7XG5cdH0gKTtcblx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gJC53aWRnZXQuZXh0ZW5kKCBiYXNlUHJvdG90eXBlLCB7XG5cblx0XHQvLyBUT0RPOiByZW1vdmUgc3VwcG9ydCBmb3Igd2lkZ2V0RXZlbnRQcmVmaXhcblx0XHQvLyBhbHdheXMgdXNlIHRoZSBuYW1lICsgYSBjb2xvbiBhcyB0aGUgcHJlZml4LCBlLmcuLCBkcmFnZ2FibGU6c3RhcnRcblx0XHQvLyBkb24ndCBwcmVmaXggZm9yIHdpZGdldHMgdGhhdCBhcmVuJ3QgRE9NLWJhc2VkXG5cdFx0d2lkZ2V0RXZlbnRQcmVmaXg6IGV4aXN0aW5nQ29uc3RydWN0b3IgPyAoIGJhc2VQcm90b3R5cGUud2lkZ2V0RXZlbnRQcmVmaXggfHwgbmFtZSApIDogbmFtZVxuXHR9LCBwcm94aWVkUHJvdG90eXBlLCB7XG5cdFx0Y29uc3RydWN0b3I6IGNvbnN0cnVjdG9yLFxuXHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuXHRcdHdpZGdldE5hbWU6IG5hbWUsXG5cdFx0d2lkZ2V0RnVsbE5hbWU6IGZ1bGxOYW1lXG5cdH0gKTtcblxuXHQvLyBJZiB0aGlzIHdpZGdldCBpcyBiZWluZyByZWRlZmluZWQgdGhlbiB3ZSBuZWVkIHRvIGZpbmQgYWxsIHdpZGdldHMgdGhhdFxuXHQvLyBhcmUgaW5oZXJpdGluZyBmcm9tIGl0IGFuZCByZWRlZmluZSBhbGwgb2YgdGhlbSBzbyB0aGF0IHRoZXkgaW5oZXJpdCBmcm9tXG5cdC8vIHRoZSBuZXcgdmVyc2lvbiBvZiB0aGlzIHdpZGdldC4gV2UncmUgZXNzZW50aWFsbHkgdHJ5aW5nIHRvIHJlcGxhY2Ugb25lXG5cdC8vIGxldmVsIGluIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5cdGlmICggZXhpc3RpbmdDb25zdHJ1Y3RvciApIHtcblx0XHQkLmVhY2goIGV4aXN0aW5nQ29uc3RydWN0b3IuX2NoaWxkQ29uc3RydWN0b3JzLCBmdW5jdGlvbiggaSwgY2hpbGQgKSB7XG5cdFx0XHR2YXIgY2hpbGRQcm90b3R5cGUgPSBjaGlsZC5wcm90b3R5cGU7XG5cblx0XHRcdC8vIFJlZGVmaW5lIHRoZSBjaGlsZCB3aWRnZXQgdXNpbmcgdGhlIHNhbWUgcHJvdG90eXBlIHRoYXQgd2FzXG5cdFx0XHQvLyBvcmlnaW5hbGx5IHVzZWQsIGJ1dCBpbmhlcml0IGZyb20gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoZSBiYXNlXG5cdFx0XHQkLndpZGdldCggY2hpbGRQcm90b3R5cGUubmFtZXNwYWNlICsgXCIuXCIgKyBjaGlsZFByb3RvdHlwZS53aWRnZXROYW1lLCBjb25zdHJ1Y3Rvcixcblx0XHRcdFx0Y2hpbGQuX3Byb3RvICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBsaXN0IG9mIGV4aXN0aW5nIGNoaWxkIGNvbnN0cnVjdG9ycyBmcm9tIHRoZSBvbGQgY29uc3RydWN0b3Jcblx0XHQvLyBzbyB0aGUgb2xkIGNoaWxkIGNvbnN0cnVjdG9ycyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcblx0XHRkZWxldGUgZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnM7XG5cdH0gZWxzZSB7XG5cdFx0YmFzZS5fY2hpbGRDb25zdHJ1Y3RvcnMucHVzaCggY29uc3RydWN0b3IgKTtcblx0fVxuXG5cdCQud2lkZ2V0LmJyaWRnZSggbmFtZSwgY29uc3RydWN0b3IgKTtcblxuXHRyZXR1cm4gY29uc3RydWN0b3I7XG59O1xuXG4kLndpZGdldC5leHRlbmQgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHR2YXIgaW5wdXQgPSB3aWRnZXRTbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblx0dmFyIGlucHV0SW5kZXggPSAwO1xuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdHZhciBrZXk7XG5cdHZhciB2YWx1ZTtcblxuXHRmb3IgKCA7IGlucHV0SW5kZXggPCBpbnB1dExlbmd0aDsgaW5wdXRJbmRleCsrICkge1xuXHRcdGZvciAoIGtleSBpbiBpbnB1dFsgaW5wdXRJbmRleCBdICkge1xuXHRcdFx0dmFsdWUgPSBpbnB1dFsgaW5wdXRJbmRleCBdWyBrZXkgXTtcblx0XHRcdGlmICggaW5wdXRbIGlucHV0SW5kZXggXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBDbG9uZSBvYmplY3RzXG5cdFx0XHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHRcdHRhcmdldFsga2V5IF0gPSAkLmlzUGxhaW5PYmplY3QoIHRhcmdldFsga2V5IF0gKSA/XG5cdFx0XHRcdFx0XHQkLndpZGdldC5leHRlbmQoIHt9LCB0YXJnZXRbIGtleSBdLCB2YWx1ZSApIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgZXh0ZW5kIHN0cmluZ3MsIGFycmF5cywgZXRjLiB3aXRoIG9iamVjdHNcblx0XHRcdFx0XHRcdCQud2lkZ2V0LmV4dGVuZCgge30sIHZhbHVlICk7XG5cblx0XHRcdFx0Ly8gQ29weSBldmVyeXRoaW5nIGVsc2UgYnkgcmVmZXJlbmNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG4kLndpZGdldC5icmlkZ2UgPSBmdW5jdGlvbiggbmFtZSwgb2JqZWN0ICkge1xuXHR2YXIgZnVsbE5hbWUgPSBvYmplY3QucHJvdG90eXBlLndpZGdldEZ1bGxOYW1lIHx8IG5hbWU7XG5cdCQuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBpc01ldGhvZENhbGwgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIjtcblx0XHR2YXIgYXJncyA9IHdpZGdldFNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHRcdHZhciByZXR1cm5WYWx1ZSA9IHRoaXM7XG5cblx0XHRpZiAoIGlzTWV0aG9kQ2FsbCApIHtcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBlbXB0eSBjb2xsZWN0aW9uLCB3ZSBuZWVkIHRvIGhhdmUgdGhlIGluc3RhbmNlIG1ldGhvZFxuXHRcdFx0Ly8gcmV0dXJuIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHRoZSBqUXVlcnkgaW5zdGFuY2Vcblx0XHRcdGlmICggIXRoaXMubGVuZ3RoICYmIG9wdGlvbnMgPT09IFwiaW5zdGFuY2VcIiApIHtcblx0XHRcdFx0cmV0dXJuVmFsdWUgPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBtZXRob2RWYWx1ZTtcblx0XHRcdFx0XHR2YXIgaW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbnMgPT09IFwiaW5zdGFuY2VcIiApIHtcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlID0gaW5zdGFuY2U7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJjYW5ub3QgY2FsbCBtZXRob2RzIG9uIFwiICsgbmFtZSArXG5cdFx0XHRcdFx0XHRcdFwiIHByaW9yIHRvIGluaXRpYWxpemF0aW9uOyBcIiArXG5cdFx0XHRcdFx0XHRcdFwiYXR0ZW1wdGVkIHRvIGNhbGwgbWV0aG9kICdcIiArIG9wdGlvbnMgKyBcIidcIiApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggISQuaXNGdW5jdGlvbiggaW5zdGFuY2VbIG9wdGlvbnMgXSApIHx8IG9wdGlvbnMuY2hhckF0KCAwICkgPT09IFwiX1wiICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuICQuZXJyb3IoIFwibm8gc3VjaCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJyBmb3IgXCIgKyBuYW1lICtcblx0XHRcdFx0XHRcdFx0XCIgd2lkZ2V0IGluc3RhbmNlXCIgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtZXRob2RWYWx1ZSA9IGluc3RhbmNlWyBvcHRpb25zIF0uYXBwbHkoIGluc3RhbmNlLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1ldGhvZFZhbHVlICE9PSBpbnN0YW5jZSAmJiBtZXRob2RWYWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBtZXRob2RWYWx1ZSAmJiBtZXRob2RWYWx1ZS5qcXVlcnkgP1xuXHRcdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZS5wdXNoU3RhY2soIG1ldGhvZFZhbHVlLmdldCgpICkgOlxuXHRcdFx0XHRcdFx0XHRtZXRob2RWYWx1ZTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBBbGxvdyBtdWx0aXBsZSBoYXNoZXMgdG8gYmUgcGFzc2VkIG9uIGluaXRcblx0XHRcdGlmICggYXJncy5sZW5ndGggKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQuYXBwbHkoIG51bGwsIFsgb3B0aW9ucyBdLmNvbmNhdCggYXJncyApICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblx0XHRcdFx0aWYgKCBpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRpbnN0YW5jZS5vcHRpb24oIG9wdGlvbnMgfHwge30gKTtcblx0XHRcdFx0XHRpZiAoIGluc3RhbmNlLl9pbml0ICkge1xuXHRcdFx0XHRcdFx0aW5zdGFuY2UuX2luaXQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5kYXRhKCB0aGlzLCBmdWxsTmFtZSwgbmV3IG9iamVjdCggb3B0aW9ucywgdGhpcyApICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdH07XG59O1xuXG4kLldpZGdldCA9IGZ1bmN0aW9uKCAvKiBvcHRpb25zLCBlbGVtZW50ICovICkge307XG4kLldpZGdldC5fY2hpbGRDb25zdHJ1Y3RvcnMgPSBbXTtcblxuJC5XaWRnZXQucHJvdG90eXBlID0ge1xuXHR3aWRnZXROYW1lOiBcIndpZGdldFwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJcIixcblx0ZGVmYXVsdEVsZW1lbnQ6IFwiPGRpdj5cIixcblxuXHRvcHRpb25zOiB7XG5cdFx0Y2xhc3Nlczoge30sXG5cdFx0ZGlzYWJsZWQ6IGZhbHNlLFxuXG5cdFx0Ly8gQ2FsbGJhY2tzXG5cdFx0Y3JlYXRlOiBudWxsXG5cdH0sXG5cblx0X2NyZWF0ZVdpZGdldDogZnVuY3Rpb24oIG9wdGlvbnMsIGVsZW1lbnQgKSB7XG5cdFx0ZWxlbWVudCA9ICQoIGVsZW1lbnQgfHwgdGhpcy5kZWZhdWx0RWxlbWVudCB8fCB0aGlzIClbIDAgXTtcblx0XHR0aGlzLmVsZW1lbnQgPSAkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy51dWlkID0gd2lkZ2V0VXVpZCsrO1xuXHRcdHRoaXMuZXZlbnROYW1lc3BhY2UgPSBcIi5cIiArIHRoaXMud2lkZ2V0TmFtZSArIHRoaXMudXVpZDtcblxuXHRcdHRoaXMuYmluZGluZ3MgPSAkKCk7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSAkKCk7XG5cdFx0dGhpcy5mb2N1c2FibGUgPSAkKCk7XG5cdFx0dGhpcy5jbGFzc2VzRWxlbWVudExvb2t1cCA9IHt9O1xuXG5cdFx0aWYgKCBlbGVtZW50ICE9PSB0aGlzICkge1xuXHRcdFx0JC5kYXRhKCBlbGVtZW50LCB0aGlzLndpZGdldEZ1bGxOYW1lLCB0aGlzICk7XG5cdFx0XHR0aGlzLl9vbiggdHJ1ZSwgdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdGlmICggZXZlbnQudGFyZ2V0ID09PSBlbGVtZW50ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLmRvY3VtZW50ID0gJCggZWxlbWVudC5zdHlsZSA/XG5cblx0XHRcdFx0Ly8gRWxlbWVudCB3aXRoaW4gdGhlIGRvY3VtZW50XG5cdFx0XHRcdGVsZW1lbnQub3duZXJEb2N1bWVudCA6XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyB3aW5kb3cgb3IgZG9jdW1lbnRcblx0XHRcdFx0ZWxlbWVudC5kb2N1bWVudCB8fCBlbGVtZW50ICk7XG5cdFx0XHR0aGlzLndpbmRvdyA9ICQoIHRoaXMuZG9jdW1lbnRbIDAgXS5kZWZhdWx0VmlldyB8fCB0aGlzLmRvY3VtZW50WyAwIF0ucGFyZW50V2luZG93ICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vcHRpb25zID0gJC53aWRnZXQuZXh0ZW5kKCB7fSxcblx0XHRcdHRoaXMub3B0aW9ucyxcblx0XHRcdHRoaXMuX2dldENyZWF0ZU9wdGlvbnMoKSxcblx0XHRcdG9wdGlvbnMgKTtcblxuXHRcdHRoaXMuX2NyZWF0ZSgpO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb25EaXNhYmxlZCggdGhpcy5vcHRpb25zLmRpc2FibGVkICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdHJpZ2dlciggXCJjcmVhdGVcIiwgbnVsbCwgdGhpcy5fZ2V0Q3JlYXRlRXZlbnREYXRhKCkgKTtcblx0XHR0aGlzLl9pbml0KCk7XG5cdH0sXG5cblx0X2dldENyZWF0ZU9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7fTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlRXZlbnREYXRhOiAkLm5vb3AsXG5cblx0X2NyZWF0ZTogJC5ub29wLFxuXG5cdF9pbml0OiAkLm5vb3AsXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5fZGVzdHJveSgpO1xuXHRcdCQuZWFjaCggdGhpcy5jbGFzc2VzRWxlbWVudExvb2t1cCwgZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHR0aGF0Ll9yZW1vdmVDbGFzcyggdmFsdWUsIGtleSApO1xuXHRcdH0gKTtcblxuXHRcdC8vIFdlIGNhbiBwcm9iYWJseSByZW1vdmUgdGhlIHVuYmluZCBjYWxscyBpbiAyLjBcblx0XHQvLyBhbGwgZXZlbnQgYmluZGluZ3Mgc2hvdWxkIGdvIHRocm91Z2ggdGhpcy5fb24oKVxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0Lm9mZiggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQucmVtb3ZlRGF0YSggdGhpcy53aWRnZXRGdWxsTmFtZSApO1xuXHRcdHRoaXMud2lkZ2V0KClcblx0XHRcdC5vZmYoIHRoaXMuZXZlbnROYW1lc3BhY2UgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiICk7XG5cblx0XHQvLyBDbGVhbiB1cCBldmVudHMgYW5kIHN0YXRlc1xuXHRcdHRoaXMuYmluZGluZ3Mub2ZmKCB0aGlzLmV2ZW50TmFtZXNwYWNlICk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6ICQubm9vcCxcblxuXHR3aWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVsZW1lbnQ7XG5cdH0sXG5cblx0b3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgb3B0aW9ucyA9IGtleTtcblx0XHR2YXIgcGFydHM7XG5cdFx0dmFyIGN1ck9wdGlvbjtcblx0XHR2YXIgaTtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBoYXNoXG5cdFx0XHRyZXR1cm4gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyBIYW5kbGUgbmVzdGVkIGtleXMsIGUuZy4sIFwiZm9vLmJhclwiID0+IHsgZm9vOiB7IGJhcjogX19fIH0gfVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0cGFydHMgPSBrZXkuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHRrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0aWYgKCBwYXJ0cy5sZW5ndGggKSB7XG5cdFx0XHRcdGN1ck9wdGlvbiA9IG9wdGlvbnNbIGtleSBdID0gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zWyBrZXkgXSApO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKyApIHtcblx0XHRcdFx0XHRjdXJPcHRpb25bIHBhcnRzWyBpIF0gXSA9IGN1ck9wdGlvblsgcGFydHNbIGkgXSBdIHx8IHt9O1xuXHRcdFx0XHRcdGN1ck9wdGlvbiA9IGN1ck9wdGlvblsgcGFydHNbIGkgXSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleSA9IHBhcnRzLnBvcCgpO1xuXHRcdFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGN1ck9wdGlvblsga2V5IF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjdXJPcHRpb25bIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN1ck9wdGlvblsga2V5IF0gPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zWyBrZXkgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHRoaXMub3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0b3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9zZXRPcHRpb25zKCBvcHRpb25zICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGtleTtcblxuXHRcdGZvciAoIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uKCBrZXksIG9wdGlvbnNbIGtleSBdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0aWYgKCBrZXkgPT09IFwiY2xhc3Nlc1wiICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uQ2xhc3NlcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHR0aGlzLm9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uRGlzYWJsZWQoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NldE9wdGlvbkNsYXNzZXM6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NLZXksIGVsZW1lbnRzLCBjdXJyZW50RWxlbWVudHM7XG5cblx0XHRmb3IgKCBjbGFzc0tleSBpbiB2YWx1ZSApIHtcblx0XHRcdGN1cnJlbnRFbGVtZW50cyA9IHRoaXMuY2xhc3Nlc0VsZW1lbnRMb29rdXBbIGNsYXNzS2V5IF07XG5cdFx0XHRpZiAoIHZhbHVlWyBjbGFzc0tleSBdID09PSB0aGlzLm9wdGlvbnMuY2xhc3Nlc1sgY2xhc3NLZXkgXSB8fFxuXHRcdFx0XHRcdCFjdXJyZW50RWxlbWVudHMgfHxcblx0XHRcdFx0XHQhY3VycmVudEVsZW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlIGFyZSBkb2luZyB0aGlzIHRvIGNyZWF0ZSBhIG5ldyBqUXVlcnkgb2JqZWN0IGJlY2F1c2UgdGhlIF9yZW1vdmVDbGFzcygpIGNhbGxcblx0XHRcdC8vIG9uIHRoZSBuZXh0IGxpbmUgaXMgZ29pbmcgdG8gZGVzdHJveSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGVsZW1lbnRzIGJlaW5nXG5cdFx0XHQvLyB0cmFja2VkLiBXZSBuZWVkIHRvIHNhdmUgYSBjb3B5IG9mIHRoaXMgY29sbGVjdGlvbiBzbyB0aGF0IHdlIGNhbiBhZGQgdGhlIG5ldyBjbGFzc2VzXG5cdFx0XHQvLyBiZWxvdy5cblx0XHRcdGVsZW1lbnRzID0gJCggY3VycmVudEVsZW1lbnRzLmdldCgpICk7XG5cdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggY3VycmVudEVsZW1lbnRzLCBjbGFzc0tleSApO1xuXG5cdFx0XHQvLyBXZSBkb24ndCB1c2UgX2FkZENsYXNzKCkgaGVyZSwgYmVjYXVzZSB0aGF0IHVzZXMgdGhpcy5vcHRpb25zLmNsYXNzZXNcblx0XHRcdC8vIGZvciBnZW5lcmF0aW5nIHRoZSBzdHJpbmcgb2YgY2xhc3Nlcy4gV2Ugd2FudCB0byB1c2UgdGhlIHZhbHVlIHBhc3NlZCBpbiBmcm9tXG5cdFx0XHQvLyBfc2V0T3B0aW9uKCksIHRoaXMgaXMgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgY2xhc3NlcyBvcHRpb24gd2hpY2ggd2FzIHBhc3NlZCB0b1xuXHRcdFx0Ly8gX3NldE9wdGlvbigpLiBXZSBwYXNzIHRoaXMgdmFsdWUgZGlyZWN0bHkgdG8gX2NsYXNzZXMoKS5cblx0XHRcdGVsZW1lbnRzLmFkZENsYXNzKCB0aGlzLl9jbGFzc2VzKCB7XG5cdFx0XHRcdGVsZW1lbnQ6IGVsZW1lbnRzLFxuXHRcdFx0XHRrZXlzOiBjbGFzc0tleSxcblx0XHRcdFx0Y2xhc3NlczogdmFsdWUsXG5cdFx0XHRcdGFkZDogdHJ1ZVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb25EaXNhYmxlZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHRoaXMuX3RvZ2dsZUNsYXNzKCB0aGlzLndpZGdldCgpLCB0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWRcIiwgbnVsbCwgISF2YWx1ZSApO1xuXG5cdFx0Ly8gSWYgdGhlIHdpZGdldCBpcyBiZWNvbWluZyBkaXNhYmxlZCwgdGhlbiBub3RoaW5nIGlzIGludGVyYWN0aXZlXG5cdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmhvdmVyYWJsZSwgbnVsbCwgXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggdGhpcy5mb2N1c2FibGUsIG51bGwsIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRPcHRpb25zKCB7IGRpc2FibGVkOiBmYWxzZSB9ICk7XG5cdH0sXG5cblx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbnMoIHsgZGlzYWJsZWQ6IHRydWUgfSApO1xuXHR9LFxuXG5cdF9jbGFzc2VzOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIgZnVsbCA9IFtdO1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdG9wdGlvbnMgPSAkLmV4dGVuZCgge1xuXHRcdFx0ZWxlbWVudDogdGhpcy5lbGVtZW50LFxuXHRcdFx0Y2xhc3NlczogdGhpcy5vcHRpb25zLmNsYXNzZXMgfHwge31cblx0XHR9LCBvcHRpb25zICk7XG5cblx0XHRmdW5jdGlvbiBwcm9jZXNzQ2xhc3NTdHJpbmcoIGNsYXNzZXMsIGNoZWNrT3B0aW9uICkge1xuXHRcdFx0dmFyIGN1cnJlbnQsIGk7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGN1cnJlbnQgPSB0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwWyBjbGFzc2VzWyBpIF0gXSB8fCAkKCk7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5hZGQgKSB7XG5cdFx0XHRcdFx0Y3VycmVudCA9ICQoICQudW5pcXVlKCBjdXJyZW50LmdldCgpLmNvbmNhdCggb3B0aW9ucy5lbGVtZW50LmdldCgpICkgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN1cnJlbnQgPSAkKCBjdXJyZW50Lm5vdCggb3B0aW9ucy5lbGVtZW50ICkuZ2V0KCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwWyBjbGFzc2VzWyBpIF0gXSA9IGN1cnJlbnQ7XG5cdFx0XHRcdGZ1bGwucHVzaCggY2xhc3Nlc1sgaSBdICk7XG5cdFx0XHRcdGlmICggY2hlY2tPcHRpb24gJiYgb3B0aW9ucy5jbGFzc2VzWyBjbGFzc2VzWyBpIF0gXSApIHtcblx0XHRcdFx0XHRmdWxsLnB1c2goIG9wdGlvbnMuY2xhc3Nlc1sgY2xhc3Nlc1sgaSBdIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX29uKCBvcHRpb25zLmVsZW1lbnQsIHtcblx0XHRcdFwicmVtb3ZlXCI6IFwiX3VudHJhY2tDbGFzc2VzRWxlbWVudFwiXG5cdFx0fSApO1xuXG5cdFx0aWYgKCBvcHRpb25zLmtleXMgKSB7XG5cdFx0XHRwcm9jZXNzQ2xhc3NTdHJpbmcoIG9wdGlvbnMua2V5cy5tYXRjaCggL1xcUysvZyApIHx8IFtdLCB0cnVlICk7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5leHRyYSApIHtcblx0XHRcdHByb2Nlc3NDbGFzc1N0cmluZyggb3B0aW9ucy5leHRyYS5tYXRjaCggL1xcUysvZyApIHx8IFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bGwuam9pbiggXCIgXCIgKTtcblx0fSxcblxuXHRfdW50cmFja0NsYXNzZXNFbGVtZW50OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdCQuZWFjaCggdGhhdC5jbGFzc2VzRWxlbWVudExvb2t1cCwgZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoICQuaW5BcnJheSggZXZlbnQudGFyZ2V0LCB2YWx1ZSApICE9PSAtMSApIHtcblx0XHRcdFx0dGhhdC5jbGFzc2VzRWxlbWVudExvb2t1cFsga2V5IF0gPSAkKCB2YWx1ZS5ub3QoIGV2ZW50LnRhcmdldCApLmdldCgpICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9yZW1vdmVDbGFzczogZnVuY3Rpb24oIGVsZW1lbnQsIGtleXMsIGV4dHJhICkge1xuXHRcdHJldHVybiB0aGlzLl90b2dnbGVDbGFzcyggZWxlbWVudCwga2V5cywgZXh0cmEsIGZhbHNlICk7XG5cdH0sXG5cblx0X2FkZENsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwga2V5cywgZXh0cmEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RvZ2dsZUNsYXNzKCBlbGVtZW50LCBrZXlzLCBleHRyYSwgdHJ1ZSApO1xuXHR9LFxuXG5cdF90b2dnbGVDbGFzczogZnVuY3Rpb24oIGVsZW1lbnQsIGtleXMsIGV4dHJhLCBhZGQgKSB7XG5cdFx0YWRkID0gKCB0eXBlb2YgYWRkID09PSBcImJvb2xlYW5cIiApID8gYWRkIDogZXh0cmE7XG5cdFx0dmFyIHNoaWZ0ID0gKCB0eXBlb2YgZWxlbWVudCA9PT0gXCJzdHJpbmdcIiB8fCBlbGVtZW50ID09PSBudWxsICksXG5cdFx0XHRvcHRpb25zID0ge1xuXHRcdFx0XHRleHRyYTogc2hpZnQgPyBrZXlzIDogZXh0cmEsXG5cdFx0XHRcdGtleXM6IHNoaWZ0ID8gZWxlbWVudCA6IGtleXMsXG5cdFx0XHRcdGVsZW1lbnQ6IHNoaWZ0ID8gdGhpcy5lbGVtZW50IDogZWxlbWVudCxcblx0XHRcdFx0YWRkOiBhZGRcblx0XHRcdH07XG5cdFx0b3B0aW9ucy5lbGVtZW50LnRvZ2dsZUNsYXNzKCB0aGlzLl9jbGFzc2VzKCBvcHRpb25zICksIGFkZCApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9vbjogZnVuY3Rpb24oIHN1cHByZXNzRGlzYWJsZWRDaGVjaywgZWxlbWVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGRlbGVnYXRlRWxlbWVudDtcblx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0Ly8gTm8gc3VwcHJlc3NEaXNhYmxlZENoZWNrIGZsYWcsIHNodWZmbGUgYXJndW1lbnRzXG5cdFx0aWYgKCB0eXBlb2Ygc3VwcHJlc3NEaXNhYmxlZENoZWNrICE9PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSBzdXBwcmVzc0Rpc2FibGVkQ2hlY2s7XG5cdFx0XHRzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBObyBlbGVtZW50IGFyZ3VtZW50LCBzaHVmZmxlIGFuZCB1c2UgdGhpcy5lbGVtZW50XG5cdFx0aWYgKCAhaGFuZGxlcnMgKSB7XG5cdFx0XHRoYW5kbGVycyA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0ZGVsZWdhdGVFbGVtZW50ID0gdGhpcy53aWRnZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudCA9IGRlbGVnYXRlRWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHRcdHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmFkZCggZWxlbWVudCApO1xuXHRcdH1cblxuXHRcdCQuZWFjaCggaGFuZGxlcnMsIGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlciApIHtcblx0XHRcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcblxuXHRcdFx0XHQvLyBBbGxvdyB3aWRnZXRzIHRvIGN1c3RvbWl6ZSB0aGUgZGlzYWJsZWQgaGFuZGxpbmdcblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBhcyBhbiBhcnJheSBpbnN0ZWFkIG9mIGJvb2xlYW5cblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBjbGFzcyBhcyBtZXRob2QgZm9yIGRpc2FibGluZyBpbmRpdmlkdWFsIHBhcnRzXG5cdFx0XHRcdGlmICggIXN1cHByZXNzRGlzYWJsZWRDaGVjayAmJlxuXHRcdFx0XHRcdFx0KCBpbnN0YW5jZS5vcHRpb25zLmRpc2FibGVkID09PSB0cnVlIHx8XG5cdFx0XHRcdFx0XHQkKCB0aGlzICkuaGFzQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAoIHR5cGVvZiBoYW5kbGVyID09PSBcInN0cmluZ1wiID8gaW5zdGFuY2VbIGhhbmRsZXIgXSA6IGhhbmRsZXIgKVxuXHRcdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb3B5IHRoZSBndWlkIHNvIGRpcmVjdCB1bmJpbmRpbmcgd29ya3Ncblx0XHRcdGlmICggdHlwZW9mIGhhbmRsZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdGhhbmRsZXJQcm94eS5ndWlkID0gaGFuZGxlci5ndWlkID1cblx0XHRcdFx0XHRoYW5kbGVyLmd1aWQgfHwgaGFuZGxlclByb3h5Lmd1aWQgfHwgJC5ndWlkKys7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBtYXRjaCA9IGV2ZW50Lm1hdGNoKCAvXihbXFx3Oi1dKilcXHMqKC4qKSQvICk7XG5cdFx0XHR2YXIgZXZlbnROYW1lID0gbWF0Y2hbIDEgXSArIGluc3RhbmNlLmV2ZW50TmFtZXNwYWNlO1xuXHRcdFx0dmFyIHNlbGVjdG9yID0gbWF0Y2hbIDIgXTtcblxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0ZGVsZWdhdGVFbGVtZW50Lm9uKCBldmVudE5hbWUsIHNlbGVjdG9yLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnQub24oIGV2ZW50TmFtZSwgaGFuZGxlclByb3h5ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9vZmY6IGZ1bmN0aW9uKCBlbGVtZW50LCBldmVudE5hbWUgKSB7XG5cdFx0ZXZlbnROYW1lID0gKCBldmVudE5hbWUgfHwgXCJcIiApLnNwbGl0KCBcIiBcIiApLmpvaW4oIHRoaXMuZXZlbnROYW1lc3BhY2UgKyBcIiBcIiApICtcblx0XHRcdHRoaXMuZXZlbnROYW1lc3BhY2U7XG5cdFx0ZWxlbWVudC5vZmYoIGV2ZW50TmFtZSApLm9mZiggZXZlbnROYW1lICk7XG5cblx0XHQvLyBDbGVhciB0aGUgc3RhY2sgdG8gYXZvaWQgbWVtb3J5IGxlYWtzICgjMTAwNTYpXG5cdFx0dGhpcy5iaW5kaW5ncyA9ICQoIHRoaXMuYmluZGluZ3Mubm90KCBlbGVtZW50ICkuZ2V0KCkgKTtcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoIHRoaXMuZm9jdXNhYmxlLm5vdCggZWxlbWVudCApLmdldCgpICk7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSAkKCB0aGlzLmhvdmVyYWJsZS5ub3QoIGVsZW1lbnQgKS5nZXQoKSApO1xuXHR9LFxuXG5cdF9kZWxheTogZnVuY3Rpb24oIGhhbmRsZXIsIGRlbGF5ICkge1xuXHRcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcblx0XHRcdHJldHVybiAoIHR5cGVvZiBoYW5kbGVyID09PSBcInN0cmluZ1wiID8gaW5zdGFuY2VbIGhhbmRsZXIgXSA6IGhhbmRsZXIgKVxuXHRcdFx0XHQuYXBwbHkoIGluc3RhbmNlLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdFx0dmFyIGluc3RhbmNlID0gdGhpcztcblx0XHRyZXR1cm4gc2V0VGltZW91dCggaGFuZGxlclByb3h5LCBkZWxheSB8fCAwICk7XG5cdH0sXG5cblx0X2hvdmVyYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSB0aGlzLmhvdmVyYWJsZS5hZGQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLl9vbiggZWxlbWVudCwge1xuXHRcdFx0bW91c2VlbnRlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR0aGlzLl9hZGRDbGFzcyggJCggZXZlbnQuY3VycmVudFRhcmdldCApLCBudWxsLCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRtb3VzZWxlYXZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRfZm9jdXNhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR0aGlzLmZvY3VzYWJsZSA9IHRoaXMuZm9jdXNhYmxlLmFkZCggZWxlbWVudCApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50LCB7XG5cdFx0XHRmb2N1c2luOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fSxcblx0XHRcdGZvY3Vzb3V0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRfdHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCBkYXRhICkge1xuXHRcdHZhciBwcm9wLCBvcmlnO1xuXHRcdHZhciBjYWxsYmFjayA9IHRoaXMub3B0aW9uc1sgdHlwZSBdO1xuXG5cdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cdFx0ZXZlbnQgPSAkLkV2ZW50KCBldmVudCApO1xuXHRcdGV2ZW50LnR5cGUgPSAoIHR5cGUgPT09IHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggP1xuXHRcdFx0dHlwZSA6XG5cdFx0XHR0aGlzLndpZGdldEV2ZW50UHJlZml4ICsgdHlwZSApLnRvTG93ZXJDYXNlKCk7XG5cblx0XHQvLyBUaGUgb3JpZ2luYWwgZXZlbnQgbWF5IGNvbWUgZnJvbSBhbnkgZWxlbWVudFxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHRhcmdldCBvbiB0aGUgbmV3IGV2ZW50XG5cdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcy5lbGVtZW50WyAwIF07XG5cblx0XHQvLyBDb3B5IG9yaWdpbmFsIGV2ZW50IHByb3BlcnRpZXMgb3ZlciB0byB0aGUgbmV3IGV2ZW50XG5cdFx0b3JpZyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cdFx0aWYgKCBvcmlnICkge1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRpZiAoICEoIHByb3AgaW4gZXZlbnQgKSApIHtcblx0XHRcdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ1sgcHJvcCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIGV2ZW50LCBkYXRhICk7XG5cdFx0cmV0dXJuICEoICQuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSAmJlxuXHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMuZWxlbWVudFsgMCBdLCBbIGV2ZW50IF0uY29uY2F0KCBkYXRhICkgKSA9PT0gZmFsc2UgfHxcblx0XHRcdGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICk7XG5cdH1cbn07XG5cbiQuZWFjaCggeyBzaG93OiBcImZhZGVJblwiLCBoaWRlOiBcImZhZGVPdXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBkZWZhdWx0RWZmZWN0ICkge1xuXHQkLldpZGdldC5wcm90b3R5cGVbIFwiX1wiICsgbWV0aG9kIF0gPSBmdW5jdGlvbiggZWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB7IGVmZmVjdDogb3B0aW9ucyB9O1xuXHRcdH1cblxuXHRcdHZhciBoYXNPcHRpb25zO1xuXHRcdHZhciBlZmZlY3ROYW1lID0gIW9wdGlvbnMgP1xuXHRcdFx0bWV0aG9kIDpcblx0XHRcdG9wdGlvbnMgPT09IHRydWUgfHwgdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgP1xuXHRcdFx0XHRkZWZhdWx0RWZmZWN0IDpcblx0XHRcdFx0b3B0aW9ucy5lZmZlY3QgfHwgZGVmYXVsdEVmZmVjdDtcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBkdXJhdGlvbjogb3B0aW9ucyB9O1xuXHRcdH1cblxuXHRcdGhhc09wdGlvbnMgPSAhJC5pc0VtcHR5T2JqZWN0KCBvcHRpb25zICk7XG5cdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGNhbGxiYWNrO1xuXG5cdFx0aWYgKCBvcHRpb25zLmRlbGF5ICkge1xuXHRcdFx0ZWxlbWVudC5kZWxheSggb3B0aW9ucy5kZWxheSApO1xuXHRcdH1cblxuXHRcdGlmICggaGFzT3B0aW9ucyAmJiAkLmVmZmVjdHMgJiYgJC5lZmZlY3RzLmVmZmVjdFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgbWV0aG9kIF0oIG9wdGlvbnMgKTtcblx0XHR9IGVsc2UgaWYgKCBlZmZlY3ROYW1lICE9PSBtZXRob2QgJiYgZWxlbWVudFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgZWZmZWN0TmFtZSBdKCBvcHRpb25zLmR1cmF0aW9uLCBvcHRpb25zLmVhc2luZywgY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudC5xdWV1ZSggZnVuY3Rpb24oIG5leHQgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKVsgbWV0aG9kIF0oKTtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKCBlbGVtZW50WyAwIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXh0KCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG52YXIgd2lkZ2V0ID0gJC53aWRnZXQ7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgUG9zaXRpb24gMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9wb3NpdGlvbi9cbiAqL1xuXG4vLz4+bGFiZWw6IFBvc2l0aW9uXG4vLz4+Z3JvdXA6IENvcmVcbi8vPj5kZXNjcmlwdGlvbjogUG9zaXRpb25zIGVsZW1lbnRzIHJlbGF0aXZlIHRvIG90aGVyIGVsZW1lbnRzLlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3Bvc2l0aW9uL1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL3Bvc2l0aW9uL1xuXG5cbiggZnVuY3Rpb24oKSB7XG52YXIgY2FjaGVkU2Nyb2xsYmFyV2lkdGgsXG5cdG1heCA9IE1hdGgubWF4LFxuXHRhYnMgPSBNYXRoLmFicyxcblx0cmhvcml6b250YWwgPSAvbGVmdHxjZW50ZXJ8cmlnaHQvLFxuXHRydmVydGljYWwgPSAvdG9wfGNlbnRlcnxib3R0b20vLFxuXHRyb2Zmc2V0ID0gL1tcXCtcXC1dXFxkKyhcXC5bXFxkXSspPyU/Lyxcblx0cnBvc2l0aW9uID0gL15cXHcrLyxcblx0cnBlcmNlbnQgPSAvJSQvLFxuXHRfcG9zaXRpb24gPSAkLmZuLnBvc2l0aW9uO1xuXG5mdW5jdGlvbiBnZXRPZmZzZXRzKCBvZmZzZXRzLCB3aWR0aCwgaGVpZ2h0ICkge1xuXHRyZXR1cm4gW1xuXHRcdHBhcnNlRmxvYXQoIG9mZnNldHNbIDAgXSApICogKCBycGVyY2VudC50ZXN0KCBvZmZzZXRzWyAwIF0gKSA/IHdpZHRoIC8gMTAwIDogMSApLFxuXHRcdHBhcnNlRmxvYXQoIG9mZnNldHNbIDEgXSApICogKCBycGVyY2VudC50ZXN0KCBvZmZzZXRzWyAxIF0gKSA/IGhlaWdodCAvIDEwMCA6IDEgKVxuXHRdO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNzcyggZWxlbWVudCwgcHJvcGVydHkgKSB7XG5cdHJldHVybiBwYXJzZUludCggJC5jc3MoIGVsZW1lbnQsIHByb3BlcnR5ICksIDEwICkgfHwgMDtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyggZWxlbSApIHtcblx0dmFyIHJhdyA9IGVsZW1bIDAgXTtcblx0aWYgKCByYXcubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiBlbGVtLndpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IGVsZW0uaGVpZ2h0KCksXG5cdFx0XHRvZmZzZXQ6IHsgdG9wOiAwLCBsZWZ0OiAwIH1cblx0XHR9O1xuXHR9XG5cdGlmICggJC5pc1dpbmRvdyggcmF3ICkgKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiBlbGVtLndpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IGVsZW0uaGVpZ2h0KCksXG5cdFx0XHRvZmZzZXQ6IHsgdG9wOiBlbGVtLnNjcm9sbFRvcCgpLCBsZWZ0OiBlbGVtLnNjcm9sbExlZnQoKSB9XG5cdFx0fTtcblx0fVxuXHRpZiAoIHJhdy5wcmV2ZW50RGVmYXVsdCApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDAsXG5cdFx0XHRvZmZzZXQ6IHsgdG9wOiByYXcucGFnZVksIGxlZnQ6IHJhdy5wYWdlWCB9XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHdpZHRoOiBlbGVtLm91dGVyV2lkdGgoKSxcblx0XHRoZWlnaHQ6IGVsZW0ub3V0ZXJIZWlnaHQoKSxcblx0XHRvZmZzZXQ6IGVsZW0ub2Zmc2V0KClcblx0fTtcbn1cblxuJC5wb3NpdGlvbiA9IHtcblx0c2Nyb2xsYmFyV2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggY2FjaGVkU2Nyb2xsYmFyV2lkdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBjYWNoZWRTY3JvbGxiYXJXaWR0aDtcblx0XHR9XG5cdFx0dmFyIHcxLCB3Mixcblx0XHRcdGRpdiA9ICQoIFwiPGRpdiBcIiArXG5cdFx0XHRcdFwic3R5bGU9J2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6NTBweDtoZWlnaHQ6NTBweDtvdmVyZmxvdzpoaWRkZW47Jz5cIiArXG5cdFx0XHRcdFwiPGRpdiBzdHlsZT0naGVpZ2h0OjEwMHB4O3dpZHRoOmF1dG87Jz48L2Rpdj48L2Rpdj5cIiApLFxuXHRcdFx0aW5uZXJEaXYgPSBkaXYuY2hpbGRyZW4oKVsgMCBdO1xuXG5cdFx0JCggXCJib2R5XCIgKS5hcHBlbmQoIGRpdiApO1xuXHRcdHcxID0gaW5uZXJEaXYub2Zmc2V0V2lkdGg7XG5cdFx0ZGl2LmNzcyggXCJvdmVyZmxvd1wiLCBcInNjcm9sbFwiICk7XG5cblx0XHR3MiA9IGlubmVyRGl2Lm9mZnNldFdpZHRoO1xuXG5cdFx0aWYgKCB3MSA9PT0gdzIgKSB7XG5cdFx0XHR3MiA9IGRpdlsgMCBdLmNsaWVudFdpZHRoO1xuXHRcdH1cblxuXHRcdGRpdi5yZW1vdmUoKTtcblxuXHRcdHJldHVybiAoIGNhY2hlZFNjcm9sbGJhcldpZHRoID0gdzEgLSB3MiApO1xuXHR9LFxuXHRnZXRTY3JvbGxJbmZvOiBmdW5jdGlvbiggd2l0aGluICkge1xuXHRcdHZhciBvdmVyZmxvd1ggPSB3aXRoaW4uaXNXaW5kb3cgfHwgd2l0aGluLmlzRG9jdW1lbnQgPyBcIlwiIDpcblx0XHRcdFx0d2l0aGluLmVsZW1lbnQuY3NzKCBcIm92ZXJmbG93LXhcIiApLFxuXHRcdFx0b3ZlcmZsb3dZID0gd2l0aGluLmlzV2luZG93IHx8IHdpdGhpbi5pc0RvY3VtZW50ID8gXCJcIiA6XG5cdFx0XHRcdHdpdGhpbi5lbGVtZW50LmNzcyggXCJvdmVyZmxvdy15XCIgKSxcblx0XHRcdGhhc092ZXJmbG93WCA9IG92ZXJmbG93WCA9PT0gXCJzY3JvbGxcIiB8fFxuXHRcdFx0XHQoIG92ZXJmbG93WCA9PT0gXCJhdXRvXCIgJiYgd2l0aGluLndpZHRoIDwgd2l0aGluLmVsZW1lbnRbIDAgXS5zY3JvbGxXaWR0aCApLFxuXHRcdFx0aGFzT3ZlcmZsb3dZID0gb3ZlcmZsb3dZID09PSBcInNjcm9sbFwiIHx8XG5cdFx0XHRcdCggb3ZlcmZsb3dZID09PSBcImF1dG9cIiAmJiB3aXRoaW4uaGVpZ2h0IDwgd2l0aGluLmVsZW1lbnRbIDAgXS5zY3JvbGxIZWlnaHQgKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IGhhc092ZXJmbG93WSA/ICQucG9zaXRpb24uc2Nyb2xsYmFyV2lkdGgoKSA6IDAsXG5cdFx0XHRoZWlnaHQ6IGhhc092ZXJmbG93WCA/ICQucG9zaXRpb24uc2Nyb2xsYmFyV2lkdGgoKSA6IDBcblx0XHR9O1xuXHR9LFxuXHRnZXRXaXRoaW5JbmZvOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR2YXIgd2l0aGluRWxlbWVudCA9ICQoIGVsZW1lbnQgfHwgd2luZG93ICksXG5cdFx0XHRpc1dpbmRvdyA9ICQuaXNXaW5kb3coIHdpdGhpbkVsZW1lbnRbIDAgXSApLFxuXHRcdFx0aXNEb2N1bWVudCA9ICEhd2l0aGluRWxlbWVudFsgMCBdICYmIHdpdGhpbkVsZW1lbnRbIDAgXS5ub2RlVHlwZSA9PT0gOSxcblx0XHRcdGhhc09mZnNldCA9ICFpc1dpbmRvdyAmJiAhaXNEb2N1bWVudDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZWxlbWVudDogd2l0aGluRWxlbWVudCxcblx0XHRcdGlzV2luZG93OiBpc1dpbmRvdyxcblx0XHRcdGlzRG9jdW1lbnQ6IGlzRG9jdW1lbnQsXG5cdFx0XHRvZmZzZXQ6IGhhc09mZnNldCA/ICQoIGVsZW1lbnQgKS5vZmZzZXQoKSA6IHsgbGVmdDogMCwgdG9wOiAwIH0sXG5cdFx0XHRzY3JvbGxMZWZ0OiB3aXRoaW5FbGVtZW50LnNjcm9sbExlZnQoKSxcblx0XHRcdHNjcm9sbFRvcDogd2l0aGluRWxlbWVudC5zY3JvbGxUb3AoKSxcblx0XHRcdHdpZHRoOiB3aXRoaW5FbGVtZW50Lm91dGVyV2lkdGgoKSxcblx0XHRcdGhlaWdodDogd2l0aGluRWxlbWVudC5vdXRlckhlaWdodCgpXG5cdFx0fTtcblx0fVxufTtcblxuJC5mbi5wb3NpdGlvbiA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRpZiAoICFvcHRpb25zIHx8ICFvcHRpb25zLm9mICkge1xuXHRcdHJldHVybiBfcG9zaXRpb24uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9XG5cblx0Ly8gTWFrZSBhIGNvcHksIHdlIGRvbid0IHdhbnQgdG8gbW9kaWZ5IGFyZ3VtZW50c1xuXHRvcHRpb25zID0gJC5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIGF0T2Zmc2V0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCB0YXJnZXRPZmZzZXQsIGJhc2VQb3NpdGlvbiwgZGltZW5zaW9ucyxcblx0XHR0YXJnZXQgPSAkKCBvcHRpb25zLm9mICksXG5cdFx0d2l0aGluID0gJC5wb3NpdGlvbi5nZXRXaXRoaW5JbmZvKCBvcHRpb25zLndpdGhpbiApLFxuXHRcdHNjcm9sbEluZm8gPSAkLnBvc2l0aW9uLmdldFNjcm9sbEluZm8oIHdpdGhpbiApLFxuXHRcdGNvbGxpc2lvbiA9ICggb3B0aW9ucy5jb2xsaXNpb24gfHwgXCJmbGlwXCIgKS5zcGxpdCggXCIgXCIgKSxcblx0XHRvZmZzZXRzID0ge307XG5cblx0ZGltZW5zaW9ucyA9IGdldERpbWVuc2lvbnMoIHRhcmdldCApO1xuXHRpZiAoIHRhcmdldFsgMCBdLnByZXZlbnREZWZhdWx0ICkge1xuXG5cdFx0Ly8gRm9yY2UgbGVmdCB0b3AgdG8gYWxsb3cgZmxpcHBpbmdcblx0XHRvcHRpb25zLmF0ID0gXCJsZWZ0IHRvcFwiO1xuXHR9XG5cdHRhcmdldFdpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcblx0dGFyZ2V0SGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG5cdHRhcmdldE9mZnNldCA9IGRpbWVuc2lvbnMub2Zmc2V0O1xuXG5cdC8vIENsb25lIHRvIHJldXNlIG9yaWdpbmFsIHRhcmdldE9mZnNldCBsYXRlclxuXHRiYXNlUG9zaXRpb24gPSAkLmV4dGVuZCgge30sIHRhcmdldE9mZnNldCApO1xuXG5cdC8vIEZvcmNlIG15IGFuZCBhdCB0byBoYXZlIHZhbGlkIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHBvc2l0aW9uc1xuXHQvLyBpZiBhIHZhbHVlIGlzIG1pc3Npbmcgb3IgaW52YWxpZCwgaXQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2VudGVyXG5cdCQuZWFjaCggWyBcIm15XCIsIFwiYXRcIiBdLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9zID0gKCBvcHRpb25zWyB0aGlzIF0gfHwgXCJcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRcdFx0aG9yaXpvbnRhbE9mZnNldCxcblx0XHRcdHZlcnRpY2FsT2Zmc2V0O1xuXG5cdFx0aWYgKCBwb3MubGVuZ3RoID09PSAxICkge1xuXHRcdFx0cG9zID0gcmhvcml6b250YWwudGVzdCggcG9zWyAwIF0gKSA/XG5cdFx0XHRcdHBvcy5jb25jYXQoIFsgXCJjZW50ZXJcIiBdICkgOlxuXHRcdFx0XHRydmVydGljYWwudGVzdCggcG9zWyAwIF0gKSA/XG5cdFx0XHRcdFx0WyBcImNlbnRlclwiIF0uY29uY2F0KCBwb3MgKSA6XG5cdFx0XHRcdFx0WyBcImNlbnRlclwiLCBcImNlbnRlclwiIF07XG5cdFx0fVxuXHRcdHBvc1sgMCBdID0gcmhvcml6b250YWwudGVzdCggcG9zWyAwIF0gKSA/IHBvc1sgMCBdIDogXCJjZW50ZXJcIjtcblx0XHRwb3NbIDEgXSA9IHJ2ZXJ0aWNhbC50ZXN0KCBwb3NbIDEgXSApID8gcG9zWyAxIF0gOiBcImNlbnRlclwiO1xuXG5cdFx0Ly8gQ2FsY3VsYXRlIG9mZnNldHNcblx0XHRob3Jpem9udGFsT2Zmc2V0ID0gcm9mZnNldC5leGVjKCBwb3NbIDAgXSApO1xuXHRcdHZlcnRpY2FsT2Zmc2V0ID0gcm9mZnNldC5leGVjKCBwb3NbIDEgXSApO1xuXHRcdG9mZnNldHNbIHRoaXMgXSA9IFtcblx0XHRcdGhvcml6b250YWxPZmZzZXQgPyBob3Jpem9udGFsT2Zmc2V0WyAwIF0gOiAwLFxuXHRcdFx0dmVydGljYWxPZmZzZXQgPyB2ZXJ0aWNhbE9mZnNldFsgMCBdIDogMFxuXHRcdF07XG5cblx0XHQvLyBSZWR1Y2UgdG8ganVzdCB0aGUgcG9zaXRpb25zIHdpdGhvdXQgdGhlIG9mZnNldHNcblx0XHRvcHRpb25zWyB0aGlzIF0gPSBbXG5cdFx0XHRycG9zaXRpb24uZXhlYyggcG9zWyAwIF0gKVsgMCBdLFxuXHRcdFx0cnBvc2l0aW9uLmV4ZWMoIHBvc1sgMSBdIClbIDAgXVxuXHRcdF07XG5cdH0gKTtcblxuXHQvLyBOb3JtYWxpemUgY29sbGlzaW9uIG9wdGlvblxuXHRpZiAoIGNvbGxpc2lvbi5sZW5ndGggPT09IDEgKSB7XG5cdFx0Y29sbGlzaW9uWyAxIF0gPSBjb2xsaXNpb25bIDAgXTtcblx0fVxuXG5cdGlmICggb3B0aW9ucy5hdFsgMCBdID09PSBcInJpZ2h0XCIgKSB7XG5cdFx0YmFzZVBvc2l0aW9uLmxlZnQgKz0gdGFyZ2V0V2lkdGg7XG5cdH0gZWxzZSBpZiAoIG9wdGlvbnMuYXRbIDAgXSA9PT0gXCJjZW50ZXJcIiApIHtcblx0XHRiYXNlUG9zaXRpb24ubGVmdCArPSB0YXJnZXRXaWR0aCAvIDI7XG5cdH1cblxuXHRpZiAoIG9wdGlvbnMuYXRbIDEgXSA9PT0gXCJib3R0b21cIiApIHtcblx0XHRiYXNlUG9zaXRpb24udG9wICs9IHRhcmdldEhlaWdodDtcblx0fSBlbHNlIGlmICggb3B0aW9ucy5hdFsgMSBdID09PSBcImNlbnRlclwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi50b3AgKz0gdGFyZ2V0SGVpZ2h0IC8gMjtcblx0fVxuXG5cdGF0T2Zmc2V0ID0gZ2V0T2Zmc2V0cyggb2Zmc2V0cy5hdCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCApO1xuXHRiYXNlUG9zaXRpb24ubGVmdCArPSBhdE9mZnNldFsgMCBdO1xuXHRiYXNlUG9zaXRpb24udG9wICs9IGF0T2Zmc2V0WyAxIF07XG5cblx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvbGxpc2lvblBvc2l0aW9uLCB1c2luZyxcblx0XHRcdGVsZW0gPSAkKCB0aGlzICksXG5cdFx0XHRlbGVtV2lkdGggPSBlbGVtLm91dGVyV2lkdGgoKSxcblx0XHRcdGVsZW1IZWlnaHQgPSBlbGVtLm91dGVySGVpZ2h0KCksXG5cdFx0XHRtYXJnaW5MZWZ0ID0gcGFyc2VDc3MoIHRoaXMsIFwibWFyZ2luTGVmdFwiICksXG5cdFx0XHRtYXJnaW5Ub3AgPSBwYXJzZUNzcyggdGhpcywgXCJtYXJnaW5Ub3BcIiApLFxuXHRcdFx0Y29sbGlzaW9uV2lkdGggPSBlbGVtV2lkdGggKyBtYXJnaW5MZWZ0ICsgcGFyc2VDc3MoIHRoaXMsIFwibWFyZ2luUmlnaHRcIiApICtcblx0XHRcdFx0c2Nyb2xsSW5mby53aWR0aCxcblx0XHRcdGNvbGxpc2lvbkhlaWdodCA9IGVsZW1IZWlnaHQgKyBtYXJnaW5Ub3AgKyBwYXJzZUNzcyggdGhpcywgXCJtYXJnaW5Cb3R0b21cIiApICtcblx0XHRcdFx0c2Nyb2xsSW5mby5oZWlnaHQsXG5cdFx0XHRwb3NpdGlvbiA9ICQuZXh0ZW5kKCB7fSwgYmFzZVBvc2l0aW9uICksXG5cdFx0XHRteU9mZnNldCA9IGdldE9mZnNldHMoIG9mZnNldHMubXksIGVsZW0ub3V0ZXJXaWR0aCgpLCBlbGVtLm91dGVySGVpZ2h0KCkgKTtcblxuXHRcdGlmICggb3B0aW9ucy5teVsgMCBdID09PSBcInJpZ2h0XCIgKSB7XG5cdFx0XHRwb3NpdGlvbi5sZWZ0IC09IGVsZW1XaWR0aDtcblx0XHR9IGVsc2UgaWYgKCBvcHRpb25zLm15WyAwIF0gPT09IFwiY2VudGVyXCIgKSB7XG5cdFx0XHRwb3NpdGlvbi5sZWZ0IC09IGVsZW1XaWR0aCAvIDI7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLm15WyAxIF0gPT09IFwiYm90dG9tXCIgKSB7XG5cdFx0XHRwb3NpdGlvbi50b3AgLT0gZWxlbUhlaWdodDtcblx0XHR9IGVsc2UgaWYgKCBvcHRpb25zLm15WyAxIF0gPT09IFwiY2VudGVyXCIgKSB7XG5cdFx0XHRwb3NpdGlvbi50b3AgLT0gZWxlbUhlaWdodCAvIDI7XG5cdFx0fVxuXG5cdFx0cG9zaXRpb24ubGVmdCArPSBteU9mZnNldFsgMCBdO1xuXHRcdHBvc2l0aW9uLnRvcCArPSBteU9mZnNldFsgMSBdO1xuXG5cdFx0Y29sbGlzaW9uUG9zaXRpb24gPSB7XG5cdFx0XHRtYXJnaW5MZWZ0OiBtYXJnaW5MZWZ0LFxuXHRcdFx0bWFyZ2luVG9wOiBtYXJnaW5Ub3Bcblx0XHR9O1xuXG5cdFx0JC5lYWNoKCBbIFwibGVmdFwiLCBcInRvcFwiIF0sIGZ1bmN0aW9uKCBpLCBkaXIgKSB7XG5cdFx0XHRpZiAoICQudWkucG9zaXRpb25bIGNvbGxpc2lvblsgaSBdIF0gKSB7XG5cdFx0XHRcdCQudWkucG9zaXRpb25bIGNvbGxpc2lvblsgaSBdIF1bIGRpciBdKCBwb3NpdGlvbiwge1xuXHRcdFx0XHRcdHRhcmdldFdpZHRoOiB0YXJnZXRXaWR0aCxcblx0XHRcdFx0XHR0YXJnZXRIZWlnaHQ6IHRhcmdldEhlaWdodCxcblx0XHRcdFx0XHRlbGVtV2lkdGg6IGVsZW1XaWR0aCxcblx0XHRcdFx0XHRlbGVtSGVpZ2h0OiBlbGVtSGVpZ2h0LFxuXHRcdFx0XHRcdGNvbGxpc2lvblBvc2l0aW9uOiBjb2xsaXNpb25Qb3NpdGlvbixcblx0XHRcdFx0XHRjb2xsaXNpb25XaWR0aDogY29sbGlzaW9uV2lkdGgsXG5cdFx0XHRcdFx0Y29sbGlzaW9uSGVpZ2h0OiBjb2xsaXNpb25IZWlnaHQsXG5cdFx0XHRcdFx0b2Zmc2V0OiBbIGF0T2Zmc2V0WyAwIF0gKyBteU9mZnNldFsgMCBdLCBhdE9mZnNldCBbIDEgXSArIG15T2Zmc2V0WyAxIF0gXSxcblx0XHRcdFx0XHRteTogb3B0aW9ucy5teSxcblx0XHRcdFx0XHRhdDogb3B0aW9ucy5hdCxcblx0XHRcdFx0XHR3aXRoaW46IHdpdGhpbixcblx0XHRcdFx0XHRlbGVtOiBlbGVtXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHRpZiAoIG9wdGlvbnMudXNpbmcgKSB7XG5cblx0XHRcdC8vIEFkZHMgZmVlZGJhY2sgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIHVzaW5nIGNhbGxiYWNrLCBpZiBwcmVzZW50XG5cdFx0XHR1c2luZyA9IGZ1bmN0aW9uKCBwcm9wcyApIHtcblx0XHRcdFx0dmFyIGxlZnQgPSB0YXJnZXRPZmZzZXQubGVmdCAtIHBvc2l0aW9uLmxlZnQsXG5cdFx0XHRcdFx0cmlnaHQgPSBsZWZ0ICsgdGFyZ2V0V2lkdGggLSBlbGVtV2lkdGgsXG5cdFx0XHRcdFx0dG9wID0gdGFyZ2V0T2Zmc2V0LnRvcCAtIHBvc2l0aW9uLnRvcCxcblx0XHRcdFx0XHRib3R0b20gPSB0b3AgKyB0YXJnZXRIZWlnaHQgLSBlbGVtSGVpZ2h0LFxuXHRcdFx0XHRcdGZlZWRiYWNrID0ge1xuXHRcdFx0XHRcdFx0dGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQ6IHRhcmdldCxcblx0XHRcdFx0XHRcdFx0bGVmdDogdGFyZ2V0T2Zmc2V0LmxlZnQsXG5cdFx0XHRcdFx0XHRcdHRvcDogdGFyZ2V0T2Zmc2V0LnRvcCxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IHRhcmdldFdpZHRoLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IHRhcmdldEhlaWdodFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGVsZW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudDogZWxlbSxcblx0XHRcdFx0XHRcdFx0bGVmdDogcG9zaXRpb24ubGVmdCxcblx0XHRcdFx0XHRcdFx0dG9wOiBwb3NpdGlvbi50b3AsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBlbGVtV2lkdGgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogZWxlbUhlaWdodFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGhvcml6b250YWw6IHJpZ2h0IDwgMCA/IFwibGVmdFwiIDogbGVmdCA+IDAgPyBcInJpZ2h0XCIgOiBcImNlbnRlclwiLFxuXHRcdFx0XHRcdFx0dmVydGljYWw6IGJvdHRvbSA8IDAgPyBcInRvcFwiIDogdG9wID4gMCA/IFwiYm90dG9tXCIgOiBcIm1pZGRsZVwiXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCB0YXJnZXRXaWR0aCA8IGVsZW1XaWR0aCAmJiBhYnMoIGxlZnQgKyByaWdodCApIDwgdGFyZ2V0V2lkdGggKSB7XG5cdFx0XHRcdFx0ZmVlZGJhY2suaG9yaXpvbnRhbCA9IFwiY2VudGVyXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0YXJnZXRIZWlnaHQgPCBlbGVtSGVpZ2h0ICYmIGFicyggdG9wICsgYm90dG9tICkgPCB0YXJnZXRIZWlnaHQgKSB7XG5cdFx0XHRcdFx0ZmVlZGJhY2sudmVydGljYWwgPSBcIm1pZGRsZVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbWF4KCBhYnMoIGxlZnQgKSwgYWJzKCByaWdodCApICkgPiBtYXgoIGFicyggdG9wICksIGFicyggYm90dG9tICkgKSApIHtcblx0XHRcdFx0XHRmZWVkYmFjay5pbXBvcnRhbnQgPSBcImhvcml6b250YWxcIjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmZWVkYmFjay5pbXBvcnRhbnQgPSBcInZlcnRpY2FsXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCB0aGlzLCBwcm9wcywgZmVlZGJhY2sgKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZWxlbS5vZmZzZXQoICQuZXh0ZW5kKCBwb3NpdGlvbiwgeyB1c2luZzogdXNpbmcgfSApICk7XG5cdH0gKTtcbn07XG5cbiQudWkucG9zaXRpb24gPSB7XG5cdGZpdDoge1xuXHRcdGxlZnQ6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbExlZnQgOiB3aXRoaW4ub2Zmc2V0LmxlZnQsXG5cdFx0XHRcdG91dGVyV2lkdGggPSB3aXRoaW4ud2lkdGgsXG5cdFx0XHRcdGNvbGxpc2lvblBvc0xlZnQgPSBwb3NpdGlvbi5sZWZ0IC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5MZWZ0LFxuXHRcdFx0XHRvdmVyTGVmdCA9IHdpdGhpbk9mZnNldCAtIGNvbGxpc2lvblBvc0xlZnQsXG5cdFx0XHRcdG92ZXJSaWdodCA9IGNvbGxpc2lvblBvc0xlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIHdpdGhpbk9mZnNldCxcblx0XHRcdFx0bmV3T3ZlclJpZ2h0O1xuXG5cdFx0XHQvLyBFbGVtZW50IGlzIHdpZGVyIHRoYW4gd2l0aGluXG5cdFx0XHRpZiAoIGRhdGEuY29sbGlzaW9uV2lkdGggPiBvdXRlcldpZHRoICkge1xuXG5cdFx0XHRcdC8vIEVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgdGhlIGxlZnQgc2lkZSBvZiB3aXRoaW5cblx0XHRcdFx0aWYgKCBvdmVyTGVmdCA+IDAgJiYgb3ZlclJpZ2h0IDw9IDAgKSB7XG5cdFx0XHRcdFx0bmV3T3ZlclJpZ2h0ID0gcG9zaXRpb24ubGVmdCArIG92ZXJMZWZ0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtIG91dGVyV2lkdGggLVxuXHRcdFx0XHRcdFx0d2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gb3ZlckxlZnQgLSBuZXdPdmVyUmlnaHQ7XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciByaWdodCBzaWRlIG9mIHdpdGhpblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvdmVyUmlnaHQgPiAwICYmIG92ZXJMZWZ0IDw9IDAgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IHdpdGhpbk9mZnNldDtcblxuXHRcdFx0XHQvLyBFbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIGJvdGggbGVmdCBhbmQgcmlnaHQgc2lkZXMgb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBvdmVyTGVmdCA+IG92ZXJSaWdodCApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgPSB3aXRoaW5PZmZzZXQgKyBvdXRlcldpZHRoIC0gZGF0YS5jb2xsaXNpb25XaWR0aDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9vIGZhciBsZWZ0IC0+IGFsaWduIHdpdGggbGVmdCBlZGdlXG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyTGVmdCA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gb3ZlckxlZnQ7XG5cblx0XHRcdC8vIFRvbyBmYXIgcmlnaHQgLT4gYWxpZ24gd2l0aCByaWdodCBlZGdlXG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyUmlnaHQgPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi5sZWZ0IC09IG92ZXJSaWdodDtcblxuXHRcdFx0Ly8gQWRqdXN0IGJhc2VkIG9uIHBvc2l0aW9uIGFuZCBtYXJnaW5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvc2l0aW9uLmxlZnQgPSBtYXgoIHBvc2l0aW9uLmxlZnQgLSBjb2xsaXNpb25Qb3NMZWZ0LCBwb3NpdGlvbi5sZWZ0ICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0b3A6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbFRvcCA6IHdpdGhpbi5vZmZzZXQudG9wLFxuXHRcdFx0XHRvdXRlckhlaWdodCA9IGRhdGEud2l0aGluLmhlaWdodCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zVG9wID0gcG9zaXRpb24udG9wIC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5Ub3AsXG5cdFx0XHRcdG92ZXJUb3AgPSB3aXRoaW5PZmZzZXQgLSBjb2xsaXNpb25Qb3NUb3AsXG5cdFx0XHRcdG92ZXJCb3R0b20gPSBjb2xsaXNpb25Qb3NUb3AgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC0gd2l0aGluT2Zmc2V0LFxuXHRcdFx0XHRuZXdPdmVyQm90dG9tO1xuXG5cdFx0XHQvLyBFbGVtZW50IGlzIHRhbGxlciB0aGFuIHdpdGhpblxuXHRcdFx0aWYgKCBkYXRhLmNvbGxpc2lvbkhlaWdodCA+IG91dGVySGVpZ2h0ICkge1xuXG5cdFx0XHRcdC8vIEVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgdGhlIHRvcCBvZiB3aXRoaW5cblx0XHRcdFx0aWYgKCBvdmVyVG9wID4gMCAmJiBvdmVyQm90dG9tIDw9IDAgKSB7XG5cdFx0XHRcdFx0bmV3T3ZlckJvdHRvbSA9IHBvc2l0aW9uLnRvcCArIG92ZXJUb3AgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC1cblx0XHRcdFx0XHRcdHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gb3ZlclRvcCAtIG5ld092ZXJCb3R0b207XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciBib3R0b20gb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG92ZXJCb3R0b20gPiAwICYmIG92ZXJUb3AgPD0gMCApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgPSB3aXRoaW5PZmZzZXQ7XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciBib3RoIHRvcCBhbmQgYm90dG9tIG9mIHdpdGhpblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggb3ZlclRvcCA+IG92ZXJCb3R0b20gKSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbi50b3AgPSB3aXRoaW5PZmZzZXQgKyBvdXRlckhlaWdodCAtIGRhdGEuY29sbGlzaW9uSGVpZ2h0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbi50b3AgPSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvbyBmYXIgdXAgLT4gYWxpZ24gd2l0aCB0b3Bcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJUb3AgPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gb3ZlclRvcDtcblxuXHRcdFx0Ly8gVG9vIGZhciBkb3duIC0+IGFsaWduIHdpdGggYm90dG9tIGVkZ2Vcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJCb3R0b20gPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi50b3AgLT0gb3ZlckJvdHRvbTtcblxuXHRcdFx0Ly8gQWRqdXN0IGJhc2VkIG9uIHBvc2l0aW9uIGFuZCBtYXJnaW5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvc2l0aW9uLnRvcCA9IG1heCggcG9zaXRpb24udG9wIC0gY29sbGlzaW9uUG9zVG9wLCBwb3NpdGlvbi50b3AgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGZsaXA6IHtcblx0XHRsZWZ0OiBmdW5jdGlvbiggcG9zaXRpb24sIGRhdGEgKSB7XG5cdFx0XHR2YXIgd2l0aGluID0gZGF0YS53aXRoaW4sXG5cdFx0XHRcdHdpdGhpbk9mZnNldCA9IHdpdGhpbi5vZmZzZXQubGVmdCArIHdpdGhpbi5zY3JvbGxMZWZ0LFxuXHRcdFx0XHRvdXRlcldpZHRoID0gd2l0aGluLndpZHRoLFxuXHRcdFx0XHRvZmZzZXRMZWZ0ID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbExlZnQgOiB3aXRoaW4ub2Zmc2V0LmxlZnQsXG5cdFx0XHRcdGNvbGxpc2lvblBvc0xlZnQgPSBwb3NpdGlvbi5sZWZ0IC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5MZWZ0LFxuXHRcdFx0XHRvdmVyTGVmdCA9IGNvbGxpc2lvblBvc0xlZnQgLSBvZmZzZXRMZWZ0LFxuXHRcdFx0XHRvdmVyUmlnaHQgPSBjb2xsaXNpb25Qb3NMZWZ0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtIG91dGVyV2lkdGggLSBvZmZzZXRMZWZ0LFxuXHRcdFx0XHRteU9mZnNldCA9IGRhdGEubXlbIDAgXSA9PT0gXCJsZWZ0XCIgP1xuXHRcdFx0XHRcdC1kYXRhLmVsZW1XaWR0aCA6XG5cdFx0XHRcdFx0ZGF0YS5teVsgMCBdID09PSBcInJpZ2h0XCIgP1xuXHRcdFx0XHRcdFx0ZGF0YS5lbGVtV2lkdGggOlxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0YXRPZmZzZXQgPSBkYXRhLmF0WyAwIF0gPT09IFwibGVmdFwiID9cblx0XHRcdFx0XHRkYXRhLnRhcmdldFdpZHRoIDpcblx0XHRcdFx0XHRkYXRhLmF0WyAwIF0gPT09IFwicmlnaHRcIiA/XG5cdFx0XHRcdFx0XHQtZGF0YS50YXJnZXRXaWR0aCA6XG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRvZmZzZXQgPSAtMiAqIGRhdGEub2Zmc2V0WyAwIF0sXG5cdFx0XHRcdG5ld092ZXJSaWdodCxcblx0XHRcdFx0bmV3T3ZlckxlZnQ7XG5cblx0XHRcdGlmICggb3ZlckxlZnQgPCAwICkge1xuXHRcdFx0XHRuZXdPdmVyUmlnaHQgPSBwb3NpdGlvbi5sZWZ0ICsgbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldCArIGRhdGEuY29sbGlzaW9uV2lkdGggLVxuXHRcdFx0XHRcdG91dGVyV2lkdGggLSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdGlmICggbmV3T3ZlclJpZ2h0IDwgMCB8fCBuZXdPdmVyUmlnaHQgPCBhYnMoIG92ZXJMZWZ0ICkgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyUmlnaHQgPiAwICkge1xuXHRcdFx0XHRuZXdPdmVyTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQgKyBteU9mZnNldCArXG5cdFx0XHRcdFx0YXRPZmZzZXQgKyBvZmZzZXQgLSBvZmZzZXRMZWZ0O1xuXHRcdFx0XHRpZiAoIG5ld092ZXJMZWZ0ID4gMCB8fCBhYnMoIG5ld092ZXJMZWZ0ICkgPCBvdmVyUmlnaHQgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0b3A6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLm9mZnNldC50b3AgKyB3aXRoaW4uc2Nyb2xsVG9wLFxuXHRcdFx0XHRvdXRlckhlaWdodCA9IHdpdGhpbi5oZWlnaHQsXG5cdFx0XHRcdG9mZnNldFRvcCA9IHdpdGhpbi5pc1dpbmRvdyA/IHdpdGhpbi5zY3JvbGxUb3AgOiB3aXRoaW4ub2Zmc2V0LnRvcCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zVG9wID0gcG9zaXRpb24udG9wIC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5Ub3AsXG5cdFx0XHRcdG92ZXJUb3AgPSBjb2xsaXNpb25Qb3NUb3AgLSBvZmZzZXRUb3AsXG5cdFx0XHRcdG92ZXJCb3R0b20gPSBjb2xsaXNpb25Qb3NUb3AgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC0gb2Zmc2V0VG9wLFxuXHRcdFx0XHR0b3AgPSBkYXRhLm15WyAxIF0gPT09IFwidG9wXCIsXG5cdFx0XHRcdG15T2Zmc2V0ID0gdG9wID9cblx0XHRcdFx0XHQtZGF0YS5lbGVtSGVpZ2h0IDpcblx0XHRcdFx0XHRkYXRhLm15WyAxIF0gPT09IFwiYm90dG9tXCIgP1xuXHRcdFx0XHRcdFx0ZGF0YS5lbGVtSGVpZ2h0IDpcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdGF0T2Zmc2V0ID0gZGF0YS5hdFsgMSBdID09PSBcInRvcFwiID9cblx0XHRcdFx0XHRkYXRhLnRhcmdldEhlaWdodCA6XG5cdFx0XHRcdFx0ZGF0YS5hdFsgMSBdID09PSBcImJvdHRvbVwiID9cblx0XHRcdFx0XHRcdC1kYXRhLnRhcmdldEhlaWdodCA6XG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRvZmZzZXQgPSAtMiAqIGRhdGEub2Zmc2V0WyAxIF0sXG5cdFx0XHRcdG5ld092ZXJUb3AsXG5cdFx0XHRcdG5ld092ZXJCb3R0b207XG5cdFx0XHRpZiAoIG92ZXJUb3AgPCAwICkge1xuXHRcdFx0XHRuZXdPdmVyQm90dG9tID0gcG9zaXRpb24udG9wICsgbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC1cblx0XHRcdFx0XHRvdXRlckhlaWdodCAtIHdpdGhpbk9mZnNldDtcblx0XHRcdFx0aWYgKCBuZXdPdmVyQm90dG9tIDwgMCB8fCBuZXdPdmVyQm90dG9tIDwgYWJzKCBvdmVyVG9wICkgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24udG9wICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJCb3R0b20gPiAwICkge1xuXHRcdFx0XHRuZXdPdmVyVG9wID0gcG9zaXRpb24udG9wIC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5Ub3AgKyBteU9mZnNldCArIGF0T2Zmc2V0ICtcblx0XHRcdFx0XHRvZmZzZXQgLSBvZmZzZXRUb3A7XG5cdFx0XHRcdGlmICggbmV3T3ZlclRvcCA+IDAgfHwgYWJzKCBuZXdPdmVyVG9wICkgPCBvdmVyQm90dG9tICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uLnRvcCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRmbGlwZml0OiB7XG5cdFx0bGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZsaXAubGVmdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZpdC5sZWZ0LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9LFxuXHRcdHRvcDogZnVuY3Rpb24oKSB7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZsaXAudG9wLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdCQudWkucG9zaXRpb24uZml0LnRvcC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9XG59O1xuXG59ICkoKTtcblxudmFyIHBvc2l0aW9uID0gJC51aS5wb3NpdGlvbjtcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSA6ZGF0YSAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogOmRhdGEgU2VsZWN0b3Jcbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBTZWxlY3RzIGVsZW1lbnRzIHdoaWNoIGhhdmUgZGF0YSBzdG9yZWQgdW5kZXIgdGhlIHNwZWNpZmllZCBrZXkuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vZGF0YS1zZWxlY3Rvci9cblxuXG52YXIgZGF0YSA9ICQuZXh0ZW5kKCAkLmV4cHJbIFwiOlwiIF0sIHtcblx0ZGF0YTogJC5leHByLmNyZWF0ZVBzZXVkbyA/XG5cdFx0JC5leHByLmNyZWF0ZVBzZXVkbyggZnVuY3Rpb24oIGRhdGFOYW1lICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIGRhdGFOYW1lICk7XG5cdFx0XHR9O1xuXHRcdH0gKSA6XG5cblx0XHQvLyBTdXBwb3J0OiBqUXVlcnkgPDEuOFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCApIHtcblx0XHRcdHJldHVybiAhISQuZGF0YSggZWxlbSwgbWF0Y2hbIDMgXSApO1xuXHRcdH1cbn0gKTtcblxuLyohXG4gKiBqUXVlcnkgVUkgRGlzYWJsZSBTZWxlY3Rpb24gMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IGRpc2FibGVTZWxlY3Rpb25cbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBEaXNhYmxlIHNlbGVjdGlvbiBvZiB0ZXh0IGNvbnRlbnQgd2l0aGluIHRoZSBzZXQgb2YgbWF0Y2hlZCBlbGVtZW50cy5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9kaXNhYmxlU2VsZWN0aW9uL1xuXG4vLyBUaGlzIGZpbGUgaXMgZGVwcmVjYXRlZFxuXG5cbnZhciBkaXNhYmxlU2VsZWN0aW9uID0gJC5mbi5leHRlbmQoIHtcblx0ZGlzYWJsZVNlbGVjdGlvbjogKCBmdW5jdGlvbigpIHtcblx0XHR2YXIgZXZlbnRUeXBlID0gXCJvbnNlbGVjdHN0YXJ0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApID9cblx0XHRcdFwic2VsZWN0c3RhcnRcIiA6XG5cdFx0XHRcIm1vdXNlZG93blwiO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMub24oIGV2ZW50VHlwZSArIFwiLnVpLWRpc2FibGVTZWxlY3Rpb25cIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSApO1xuXHRcdH07XG5cdH0gKSgpLFxuXG5cdGVuYWJsZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCBcIi51aS1kaXNhYmxlU2VsZWN0aW9uXCIgKTtcblx0fVxufSApO1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIEVmZmVjdHMgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IEVmZmVjdHMgQ29yZVxuLy8+Pmdyb3VwOiBFZmZlY3RzXG4vLyBqc2NzOmRpc2FibGUgbWF4aW11bUxpbmVMZW5ndGhcbi8vPj5kZXNjcmlwdGlvbjogRXh0ZW5kcyB0aGUgaW50ZXJuYWwgalF1ZXJ5IGVmZmVjdHMuIEluY2x1ZGVzIG1vcnBoaW5nIGFuZCBlYXNpbmcuIFJlcXVpcmVkIGJ5IGFsbCBvdGhlciBlZmZlY3RzLlxuLy8ganNjczplbmFibGUgbWF4aW11bUxpbmVMZW5ndGhcbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9jYXRlZ29yeS9lZmZlY3RzLWNvcmUvXG4vLz4+ZGVtb3M6IGh0dHA6Ly9qcXVlcnl1aS5jb20vZWZmZWN0L1xuXG5cblxudmFyIGRhdGFTcGFjZSA9IFwidWktZWZmZWN0cy1cIixcblx0ZGF0YVNwYWNlU3R5bGUgPSBcInVpLWVmZmVjdHMtc3R5bGVcIixcblx0ZGF0YVNwYWNlQW5pbWF0ZWQgPSBcInVpLWVmZmVjdHMtYW5pbWF0ZWRcIixcblxuXHQvLyBDcmVhdGUgYSBsb2NhbCBqUXVlcnkgYmVjYXVzZSBqUXVlcnkgQ29sb3IgcmVsaWVzIG9uIGl0IGFuZCB0aGVcblx0Ly8gZ2xvYmFsIG1heSBub3QgZXhpc3Qgd2l0aCBBTUQgYW5kIGEgY3VzdG9tIGJ1aWxkICgjMTAxOTkpXG5cdGpRdWVyeSA9ICQ7XG5cbiQuZWZmZWN0cyA9IHtcblx0ZWZmZWN0OiB7fVxufTtcblxuLyohXG4gKiBqUXVlcnkgQ29sb3IgQW5pbWF0aW9ucyB2Mi4xLjJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5LWNvbG9yXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IFdlZCBKYW4gMTYgMDg6NDc6MDkgMjAxMyAtMDYwMFxuICovXG4oIGZ1bmN0aW9uKCBqUXVlcnksIHVuZGVmaW5lZCApIHtcblxuXHR2YXIgc3RlcEhvb2tzID0gXCJiYWNrZ3JvdW5kQ29sb3IgYm9yZGVyQm90dG9tQ29sb3IgYm9yZGVyTGVmdENvbG9yIGJvcmRlclJpZ2h0Q29sb3IgXCIgK1xuXHRcdFwiYm9yZGVyVG9wQ29sb3IgY29sb3IgY29sdW1uUnVsZUNvbG9yIG91dGxpbmVDb2xvciB0ZXh0RGVjb3JhdGlvbkNvbG9yIHRleHRFbXBoYXNpc0NvbG9yXCIsXG5cblx0Ly8gUGx1c2VxdWFscyB0ZXN0IGZvciArPSAxMDAgLT0gMTAwXG5cdHJwbHVzZXF1YWxzID0gL14oW1xcLStdKT1cXHMqKFxcZCtcXC4/XFxkKikvLFxuXG5cdC8vIEEgc2V0IG9mIFJFJ3MgdGhhdCBjYW4gbWF0Y2ggc3RyaW5ncyBhbmQgZ2VuZXJhdGUgY29sb3IgdHVwbGVzLlxuXHRzdHJpbmdQYXJzZXJzID0gWyB7XG5cdFx0XHRyZTogL3JnYmE/XFwoXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyooPzosXFxzKihcXGQ/KD86XFwuXFxkKyk/KVxccyopP1xcKS8sXG5cdFx0XHRwYXJzZTogZnVuY3Rpb24oIGV4ZWNSZXN1bHQgKSB7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgMSBdLFxuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDIgXSxcblx0XHRcdFx0XHRleGVjUmVzdWx0WyAzIF0sXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgNCBdXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0cmU6IC9yZ2JhP1xcKFxccyooXFxkKyg/OlxcLlxcZCspPylcXCVcXHMqLFxccyooXFxkKyg/OlxcLlxcZCspPylcXCVcXHMqLFxccyooXFxkKyg/OlxcLlxcZCspPylcXCVcXHMqKD86LFxccyooXFxkPyg/OlxcLlxcZCspPylcXHMqKT9cXCkvLFxuXHRcdFx0cGFyc2U6IGZ1bmN0aW9uKCBleGVjUmVzdWx0ICkge1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDEgXSAqIDIuNTUsXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgMiBdICogMi41NSxcblx0XHRcdFx0XHRleGVjUmVzdWx0WyAzIF0gKiAyLjU1LFxuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDQgXVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdH0sIHtcblxuXHRcdFx0Ly8gVGhpcyByZWdleCBpZ25vcmVzIEEtRiBiZWNhdXNlIGl0J3MgY29tcGFyZWQgYWdhaW5zdCBhbiBhbHJlYWR5IGxvd2VyY2FzZWQgc3RyaW5nXG5cdFx0XHRyZTogLyMoW2EtZjAtOV17Mn0pKFthLWYwLTldezJ9KShbYS1mMC05XXsyfSkvLFxuXHRcdFx0cGFyc2U6IGZ1bmN0aW9uKCBleGVjUmVzdWx0ICkge1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdHBhcnNlSW50KCBleGVjUmVzdWx0WyAxIF0sIDE2ICksXG5cdFx0XHRcdFx0cGFyc2VJbnQoIGV4ZWNSZXN1bHRbIDIgXSwgMTYgKSxcblx0XHRcdFx0XHRwYXJzZUludCggZXhlY1Jlc3VsdFsgMyBdLCAxNiApXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0fSwge1xuXG5cdFx0XHQvLyBUaGlzIHJlZ2V4IGlnbm9yZXMgQS1GIGJlY2F1c2UgaXQncyBjb21wYXJlZCBhZ2FpbnN0IGFuIGFscmVhZHkgbG93ZXJjYXNlZCBzdHJpbmdcblx0XHRcdHJlOiAvIyhbYS1mMC05XSkoW2EtZjAtOV0pKFthLWYwLTldKS8sXG5cdFx0XHRwYXJzZTogZnVuY3Rpb24oIGV4ZWNSZXN1bHQgKSB7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0cGFyc2VJbnQoIGV4ZWNSZXN1bHRbIDEgXSArIGV4ZWNSZXN1bHRbIDEgXSwgMTYgKSxcblx0XHRcdFx0XHRwYXJzZUludCggZXhlY1Jlc3VsdFsgMiBdICsgZXhlY1Jlc3VsdFsgMiBdLCAxNiApLFxuXHRcdFx0XHRcdHBhcnNlSW50KCBleGVjUmVzdWx0WyAzIF0gKyBleGVjUmVzdWx0WyAzIF0sIDE2IClcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHRyZTogL2hzbGE/XFwoXFxzKihcXGQrKD86XFwuXFxkKyk/KVxccyosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxcJVxccyosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxcJVxccyooPzosXFxzKihcXGQ/KD86XFwuXFxkKyk/KVxccyopP1xcKS8sXG5cdFx0XHRzcGFjZTogXCJoc2xhXCIsXG5cdFx0XHRwYXJzZTogZnVuY3Rpb24oIGV4ZWNSZXN1bHQgKSB7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgMSBdLFxuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDIgXSAvIDEwMCxcblx0XHRcdFx0XHRleGVjUmVzdWx0WyAzIF0gLyAxMDAsXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgNCBdXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0fSBdLFxuXG5cdC8vIEpRdWVyeS5Db2xvciggKVxuXHRjb2xvciA9IGpRdWVyeS5Db2xvciA9IGZ1bmN0aW9uKCBjb2xvciwgZ3JlZW4sIGJsdWUsIGFscGhhICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkNvbG9yLmZuLnBhcnNlKCBjb2xvciwgZ3JlZW4sIGJsdWUsIGFscGhhICk7XG5cdH0sXG5cdHNwYWNlcyA9IHtcblx0XHRyZ2JhOiB7XG5cdFx0XHRwcm9wczoge1xuXHRcdFx0XHRyZWQ6IHtcblx0XHRcdFx0XHRpZHg6IDAsXG5cdFx0XHRcdFx0dHlwZTogXCJieXRlXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0Z3JlZW46IHtcblx0XHRcdFx0XHRpZHg6IDEsXG5cdFx0XHRcdFx0dHlwZTogXCJieXRlXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0Ymx1ZToge1xuXHRcdFx0XHRcdGlkeDogMixcblx0XHRcdFx0XHR0eXBlOiBcImJ5dGVcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGhzbGE6IHtcblx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdGh1ZToge1xuXHRcdFx0XHRcdGlkeDogMCxcblx0XHRcdFx0XHR0eXBlOiBcImRlZ3JlZXNcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzYXR1cmF0aW9uOiB7XG5cdFx0XHRcdFx0aWR4OiAxLFxuXHRcdFx0XHRcdHR5cGU6IFwicGVyY2VudFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGxpZ2h0bmVzczoge1xuXHRcdFx0XHRcdGlkeDogMixcblx0XHRcdFx0XHR0eXBlOiBcInBlcmNlbnRcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRwcm9wVHlwZXMgPSB7XG5cdFx0XCJieXRlXCI6IHtcblx0XHRcdGZsb29yOiB0cnVlLFxuXHRcdFx0bWF4OiAyNTVcblx0XHR9LFxuXHRcdFwicGVyY2VudFwiOiB7XG5cdFx0XHRtYXg6IDFcblx0XHR9LFxuXHRcdFwiZGVncmVlc1wiOiB7XG5cdFx0XHRtb2Q6IDM2MCxcblx0XHRcdGZsb29yOiB0cnVlXG5cdFx0fVxuXHR9LFxuXHRzdXBwb3J0ID0gY29sb3Iuc3VwcG9ydCA9IHt9LFxuXG5cdC8vIEVsZW1lbnQgZm9yIHN1cHBvcnQgdGVzdHNcblx0c3VwcG9ydEVsZW0gPSBqUXVlcnkoIFwiPHA+XCIgKVsgMCBdLFxuXG5cdC8vIENvbG9ycyA9IGpRdWVyeS5Db2xvci5uYW1lc1xuXHRjb2xvcnMsXG5cblx0Ly8gTG9jYWwgYWxpYXNlcyBvZiBmdW5jdGlvbnMgY2FsbGVkIG9mdGVuXG5cdGVhY2ggPSBqUXVlcnkuZWFjaDtcblxuLy8gRGV0ZXJtaW5lIHJnYmEgc3VwcG9ydCBpbW1lZGlhdGVseVxuc3VwcG9ydEVsZW0uc3R5bGUuY3NzVGV4dCA9IFwiYmFja2dyb3VuZC1jb2xvcjpyZ2JhKDEsMSwxLC41KVwiO1xuc3VwcG9ydC5yZ2JhID0gc3VwcG9ydEVsZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yLmluZGV4T2YoIFwicmdiYVwiICkgPiAtMTtcblxuLy8gRGVmaW5lIGNhY2hlIG5hbWUgYW5kIGFscGhhIHByb3BlcnRpZXNcbi8vIGZvciByZ2JhIGFuZCBoc2xhIHNwYWNlc1xuZWFjaCggc3BhY2VzLCBmdW5jdGlvbiggc3BhY2VOYW1lLCBzcGFjZSApIHtcblx0c3BhY2UuY2FjaGUgPSBcIl9cIiArIHNwYWNlTmFtZTtcblx0c3BhY2UucHJvcHMuYWxwaGEgPSB7XG5cdFx0aWR4OiAzLFxuXHRcdHR5cGU6IFwicGVyY2VudFwiLFxuXHRcdGRlZjogMVxuXHR9O1xufSApO1xuXG5mdW5jdGlvbiBjbGFtcCggdmFsdWUsIHByb3AsIGFsbG93RW1wdHkgKSB7XG5cdHZhciB0eXBlID0gcHJvcFR5cGVzWyBwcm9wLnR5cGUgXSB8fCB7fTtcblxuXHRpZiAoIHZhbHVlID09IG51bGwgKSB7XG5cdFx0cmV0dXJuICggYWxsb3dFbXB0eSB8fCAhcHJvcC5kZWYgKSA/IG51bGwgOiBwcm9wLmRlZjtcblx0fVxuXG5cdC8vIH5+IGlzIGFuIHNob3J0IHdheSBvZiBkb2luZyBmbG9vciBmb3IgcG9zaXRpdmUgbnVtYmVyc1xuXHR2YWx1ZSA9IHR5cGUuZmxvb3IgPyB+fnZhbHVlIDogcGFyc2VGbG9hdCggdmFsdWUgKTtcblxuXHQvLyBJRSB3aWxsIHBhc3MgaW4gZW1wdHkgc3RyaW5ncyBhcyB2YWx1ZSBmb3IgYWxwaGEsXG5cdC8vIHdoaWNoIHdpbGwgaGl0IHRoaXMgY2FzZVxuXHRpZiAoIGlzTmFOKCB2YWx1ZSApICkge1xuXHRcdHJldHVybiBwcm9wLmRlZjtcblx0fVxuXG5cdGlmICggdHlwZS5tb2QgKSB7XG5cblx0XHQvLyBXZSBhZGQgbW9kIGJlZm9yZSBtb2RkaW5nIHRvIG1ha2Ugc3VyZSB0aGF0IG5lZ2F0aXZlcyB2YWx1ZXNcblx0XHQvLyBnZXQgY29udmVydGVkIHByb3Blcmx5OiAtMTAgLT4gMzUwXG5cdFx0cmV0dXJuICggdmFsdWUgKyB0eXBlLm1vZCApICUgdHlwZS5tb2Q7XG5cdH1cblxuXHQvLyBGb3Igbm93IGFsbCBwcm9wZXJ0eSB0eXBlcyB3aXRob3V0IG1vZCBoYXZlIG1pbiBhbmQgbWF4XG5cdHJldHVybiAwID4gdmFsdWUgPyAwIDogdHlwZS5tYXggPCB2YWx1ZSA/IHR5cGUubWF4IDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1BhcnNlKCBzdHJpbmcgKSB7XG5cdHZhciBpbnN0ID0gY29sb3IoKSxcblx0XHRyZ2JhID0gaW5zdC5fcmdiYSA9IFtdO1xuXG5cdHN0cmluZyA9IHN0cmluZy50b0xvd2VyQ2FzZSgpO1xuXG5cdGVhY2goIHN0cmluZ1BhcnNlcnMsIGZ1bmN0aW9uKCBpLCBwYXJzZXIgKSB7XG5cdFx0dmFyIHBhcnNlZCxcblx0XHRcdG1hdGNoID0gcGFyc2VyLnJlLmV4ZWMoIHN0cmluZyApLFxuXHRcdFx0dmFsdWVzID0gbWF0Y2ggJiYgcGFyc2VyLnBhcnNlKCBtYXRjaCApLFxuXHRcdFx0c3BhY2VOYW1lID0gcGFyc2VyLnNwYWNlIHx8IFwicmdiYVwiO1xuXG5cdFx0aWYgKCB2YWx1ZXMgKSB7XG5cdFx0XHRwYXJzZWQgPSBpbnN0WyBzcGFjZU5hbWUgXSggdmFsdWVzICk7XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIHJnYmEgcGFyc2UgdGhlIGFzc2lnbm1lbnQgbWlnaHQgaGFwcGVuIHR3aWNlXG5cdFx0XHQvLyBvaCB3ZWxsLi4uLlxuXHRcdFx0aW5zdFsgc3BhY2VzWyBzcGFjZU5hbWUgXS5jYWNoZSBdID0gcGFyc2VkWyBzcGFjZXNbIHNwYWNlTmFtZSBdLmNhY2hlIF07XG5cdFx0XHRyZ2JhID0gaW5zdC5fcmdiYSA9IHBhcnNlZC5fcmdiYTtcblxuXHRcdFx0Ly8gRXhpdCBlYWNoKCBzdHJpbmdQYXJzZXJzICkgaGVyZSBiZWNhdXNlIHdlIG1hdGNoZWRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0gKTtcblxuXHQvLyBGb3VuZCBhIHN0cmluZ1BhcnNlciB0aGF0IGhhbmRsZWQgaXRcblx0aWYgKCByZ2JhLmxlbmd0aCApIHtcblxuXHRcdC8vIElmIHRoaXMgY2FtZSBmcm9tIGEgcGFyc2VkIHN0cmluZywgZm9yY2UgXCJ0cmFuc3BhcmVudFwiIHdoZW4gYWxwaGEgaXMgMFxuXHRcdC8vIGNocm9tZSwgKGFuZCBtYXliZSBvdGhlcnMpIHJldHVybiBcInRyYW5zcGFyZW50XCIgYXMgcmdiYSgwLDAsMCwwKVxuXHRcdGlmICggcmdiYS5qb2luKCkgPT09IFwiMCwwLDAsMFwiICkge1xuXHRcdFx0alF1ZXJ5LmV4dGVuZCggcmdiYSwgY29sb3JzLnRyYW5zcGFyZW50ICk7XG5cdFx0fVxuXHRcdHJldHVybiBpbnN0O1xuXHR9XG5cblx0Ly8gTmFtZWQgY29sb3JzXG5cdHJldHVybiBjb2xvcnNbIHN0cmluZyBdO1xufVxuXG5jb2xvci5mbiA9IGpRdWVyeS5leHRlbmQoIGNvbG9yLnByb3RvdHlwZSwge1xuXHRwYXJzZTogZnVuY3Rpb24oIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhICkge1xuXHRcdGlmICggcmVkID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLl9yZ2JhID0gWyBudWxsLCBudWxsLCBudWxsLCBudWxsIF07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCByZWQuanF1ZXJ5IHx8IHJlZC5ub2RlVHlwZSApIHtcblx0XHRcdHJlZCA9IGpRdWVyeSggcmVkICkuY3NzKCBncmVlbiApO1xuXHRcdFx0Z3JlZW4gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0dmFyIGluc3QgPSB0aGlzLFxuXHRcdFx0dHlwZSA9IGpRdWVyeS50eXBlKCByZWQgKSxcblx0XHRcdHJnYmEgPSB0aGlzLl9yZ2JhID0gW107XG5cblx0XHQvLyBNb3JlIHRoYW4gMSBhcmd1bWVudCBzcGVjaWZpZWQgLSBhc3N1bWUgKCByZWQsIGdyZWVuLCBibHVlLCBhbHBoYSApXG5cdFx0aWYgKCBncmVlbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmVkID0gWyByZWQsIGdyZWVuLCBibHVlLCBhbHBoYSBdO1xuXHRcdFx0dHlwZSA9IFwiYXJyYXlcIjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZSggc3RyaW5nUGFyc2UoIHJlZCApIHx8IGNvbG9ycy5fZGVmYXVsdCApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZSA9PT0gXCJhcnJheVwiICkge1xuXHRcdFx0ZWFjaCggc3BhY2VzLnJnYmEucHJvcHMsIGZ1bmN0aW9uKCBrZXksIHByb3AgKSB7XG5cdFx0XHRcdHJnYmFbIHByb3AuaWR4IF0gPSBjbGFtcCggcmVkWyBwcm9wLmlkeCBdLCBwcm9wICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRpZiAoIHJlZCBpbnN0YW5jZW9mIGNvbG9yICkge1xuXHRcdFx0XHRlYWNoKCBzcGFjZXMsIGZ1bmN0aW9uKCBzcGFjZU5hbWUsIHNwYWNlICkge1xuXHRcdFx0XHRcdGlmICggcmVkWyBzcGFjZS5jYWNoZSBdICkge1xuXHRcdFx0XHRcdFx0aW5zdFsgc3BhY2UuY2FjaGUgXSA9IHJlZFsgc3BhY2UuY2FjaGUgXS5zbGljZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWFjaCggc3BhY2VzLCBmdW5jdGlvbiggc3BhY2VOYW1lLCBzcGFjZSApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUgPSBzcGFjZS5jYWNoZTtcblx0XHRcdFx0XHRlYWNoKCBzcGFjZS5wcm9wcywgZnVuY3Rpb24oIGtleSwgcHJvcCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIGNhY2hlIGRvZXNuJ3QgZXhpc3QsIGFuZCB3ZSBrbm93IGhvdyB0byBjb252ZXJ0XG5cdFx0XHRcdFx0XHRpZiAoICFpbnN0WyBjYWNoZSBdICYmIHNwYWNlLnRvICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHRoZSB2YWx1ZSB3YXMgbnVsbCwgd2UgZG9uJ3QgbmVlZCB0byBjb3B5IGl0XG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBrZXkgd2FzIGFscGhhLCB3ZSBkb24ndCBuZWVkIHRvIGNvcHkgaXQgZWl0aGVyXG5cdFx0XHRcdFx0XHRcdGlmICgga2V5ID09PSBcImFscGhhXCIgfHwgcmVkWyBrZXkgXSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpbnN0WyBjYWNoZSBdID0gc3BhY2UudG8oIGluc3QuX3JnYmEgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyB0aGUgb25seSBjYXNlIHdoZXJlIHdlIGFsbG93IG51bGxzIGZvciBBTEwgcHJvcGVydGllcy5cblx0XHRcdFx0XHRcdC8vIGNhbGwgY2xhbXAgd2l0aCBhbHdheXNBbGxvd0VtcHR5XG5cdFx0XHRcdFx0XHRpbnN0WyBjYWNoZSBdWyBwcm9wLmlkeCBdID0gY2xhbXAoIHJlZFsga2V5IF0sIHByb3AsIHRydWUgKTtcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHQvLyBFdmVyeXRoaW5nIGRlZmluZWQgYnV0IGFscGhhP1xuXHRcdFx0XHRcdGlmICggaW5zdFsgY2FjaGUgXSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggbnVsbCwgaW5zdFsgY2FjaGUgXS5zbGljZSggMCwgMyApICkgPCAwICkge1xuXG5cdFx0XHRcdFx0XHQvLyBVc2UgdGhlIGRlZmF1bHQgb2YgMVxuXHRcdFx0XHRcdFx0aW5zdFsgY2FjaGUgXVsgMyBdID0gMTtcblx0XHRcdFx0XHRcdGlmICggc3BhY2UuZnJvbSApIHtcblx0XHRcdFx0XHRcdFx0aW5zdC5fcmdiYSA9IHNwYWNlLmZyb20oIGluc3RbIGNhY2hlIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBjb21wYXJlICkge1xuXHRcdHZhciBpcyA9IGNvbG9yKCBjb21wYXJlICksXG5cdFx0XHRzYW1lID0gdHJ1ZSxcblx0XHRcdGluc3QgPSB0aGlzO1xuXG5cdFx0ZWFjaCggc3BhY2VzLCBmdW5jdGlvbiggXywgc3BhY2UgKSB7XG5cdFx0XHR2YXIgbG9jYWxDYWNoZSxcblx0XHRcdFx0aXNDYWNoZSA9IGlzWyBzcGFjZS5jYWNoZSBdO1xuXHRcdFx0aWYgKCBpc0NhY2hlICkge1xuXHRcdFx0XHRsb2NhbENhY2hlID0gaW5zdFsgc3BhY2UuY2FjaGUgXSB8fCBzcGFjZS50byAmJiBzcGFjZS50byggaW5zdC5fcmdiYSApIHx8IFtdO1xuXHRcdFx0XHRlYWNoKCBzcGFjZS5wcm9wcywgZnVuY3Rpb24oIF8sIHByb3AgKSB7XG5cdFx0XHRcdFx0aWYgKCBpc0NhY2hlWyBwcm9wLmlkeCBdICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzYW1lID0gKCBpc0NhY2hlWyBwcm9wLmlkeCBdID09PSBsb2NhbENhY2hlWyBwcm9wLmlkeCBdICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2FtZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzYW1lO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2FtZTtcblx0fSxcblx0X3NwYWNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdXNlZCA9IFtdLFxuXHRcdFx0aW5zdCA9IHRoaXM7XG5cdFx0ZWFjaCggc3BhY2VzLCBmdW5jdGlvbiggc3BhY2VOYW1lLCBzcGFjZSApIHtcblx0XHRcdGlmICggaW5zdFsgc3BhY2UuY2FjaGUgXSApIHtcblx0XHRcdFx0dXNlZC5wdXNoKCBzcGFjZU5hbWUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHVzZWQucG9wKCk7XG5cdH0sXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKCBvdGhlciwgZGlzdGFuY2UgKSB7XG5cdFx0dmFyIGVuZCA9IGNvbG9yKCBvdGhlciApLFxuXHRcdFx0c3BhY2VOYW1lID0gZW5kLl9zcGFjZSgpLFxuXHRcdFx0c3BhY2UgPSBzcGFjZXNbIHNwYWNlTmFtZSBdLFxuXHRcdFx0c3RhcnRDb2xvciA9IHRoaXMuYWxwaGEoKSA9PT0gMCA/IGNvbG9yKCBcInRyYW5zcGFyZW50XCIgKSA6IHRoaXMsXG5cdFx0XHRzdGFydCA9IHN0YXJ0Q29sb3JbIHNwYWNlLmNhY2hlIF0gfHwgc3BhY2UudG8oIHN0YXJ0Q29sb3IuX3JnYmEgKSxcblx0XHRcdHJlc3VsdCA9IHN0YXJ0LnNsaWNlKCk7XG5cblx0XHRlbmQgPSBlbmRbIHNwYWNlLmNhY2hlIF07XG5cdFx0ZWFjaCggc3BhY2UucHJvcHMsIGZ1bmN0aW9uKCBrZXksIHByb3AgKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBwcm9wLmlkeCxcblx0XHRcdFx0c3RhcnRWYWx1ZSA9IHN0YXJ0WyBpbmRleCBdLFxuXHRcdFx0XHRlbmRWYWx1ZSA9IGVuZFsgaW5kZXggXSxcblx0XHRcdFx0dHlwZSA9IHByb3BUeXBlc1sgcHJvcC50eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIG51bGwsIGRvbid0IG92ZXJyaWRlIHN0YXJ0IHZhbHVlXG5cdFx0XHRpZiAoIGVuZFZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIG51bGwgLSB1c2UgZW5kXG5cdFx0XHRpZiAoIHN0YXJ0VmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdHJlc3VsdFsgaW5kZXggXSA9IGVuZFZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCB0eXBlLm1vZCApIHtcblx0XHRcdFx0XHRpZiAoIGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSA+IHR5cGUubW9kIC8gMiApIHtcblx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgKz0gdHlwZS5tb2Q7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggc3RhcnRWYWx1ZSAtIGVuZFZhbHVlID4gdHlwZS5tb2QgLyAyICkge1xuXHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSAtPSB0eXBlLm1vZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzdWx0WyBpbmRleCBdID0gY2xhbXAoICggZW5kVmFsdWUgLSBzdGFydFZhbHVlICkgKiBkaXN0YW5jZSArIHN0YXJ0VmFsdWUsIHByb3AgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXNbIHNwYWNlTmFtZSBdKCByZXN1bHQgKTtcblx0fSxcblx0YmxlbmQ6IGZ1bmN0aW9uKCBvcGFxdWUgKSB7XG5cblx0XHQvLyBJZiB3ZSBhcmUgYWxyZWFkeSBvcGFxdWUgLSByZXR1cm4gb3Vyc2VsZlxuXHRcdGlmICggdGhpcy5fcmdiYVsgMyBdID09PSAxICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dmFyIHJnYiA9IHRoaXMuX3JnYmEuc2xpY2UoKSxcblx0XHRcdGEgPSByZ2IucG9wKCksXG5cdFx0XHRibGVuZCA9IGNvbG9yKCBvcGFxdWUgKS5fcmdiYTtcblxuXHRcdHJldHVybiBjb2xvciggalF1ZXJ5Lm1hcCggcmdiLCBmdW5jdGlvbiggdiwgaSApIHtcblx0XHRcdHJldHVybiAoIDEgLSBhICkgKiBibGVuZFsgaSBdICsgYSAqIHY7XG5cdFx0fSApICk7XG5cdH0sXG5cdHRvUmdiYVN0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByZWZpeCA9IFwicmdiYShcIixcblx0XHRcdHJnYmEgPSBqUXVlcnkubWFwKCB0aGlzLl9yZ2JhLCBmdW5jdGlvbiggdiwgaSApIHtcblx0XHRcdFx0cmV0dXJuIHYgPT0gbnVsbCA/ICggaSA+IDIgPyAxIDogMCApIDogdjtcblx0XHRcdH0gKTtcblxuXHRcdGlmICggcmdiYVsgMyBdID09PSAxICkge1xuXHRcdFx0cmdiYS5wb3AoKTtcblx0XHRcdHByZWZpeCA9IFwicmdiKFwiO1xuXHRcdH1cblxuXHRcdHJldHVybiBwcmVmaXggKyByZ2JhLmpvaW4oKSArIFwiKVwiO1xuXHR9LFxuXHR0b0hzbGFTdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwcmVmaXggPSBcImhzbGEoXCIsXG5cdFx0XHRoc2xhID0galF1ZXJ5Lm1hcCggdGhpcy5oc2xhKCksIGZ1bmN0aW9uKCB2LCBpICkge1xuXHRcdFx0XHRpZiAoIHYgPT0gbnVsbCApIHtcblx0XHRcdFx0XHR2ID0gaSA+IDIgPyAxIDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhdGNoIDEgYW5kIDJcblx0XHRcdFx0aWYgKCBpICYmIGkgPCAzICkge1xuXHRcdFx0XHRcdHYgPSBNYXRoLnJvdW5kKCB2ICogMTAwICkgKyBcIiVcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdjtcblx0XHRcdH0gKTtcblxuXHRcdGlmICggaHNsYVsgMyBdID09PSAxICkge1xuXHRcdFx0aHNsYS5wb3AoKTtcblx0XHRcdHByZWZpeCA9IFwiaHNsKFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gcHJlZml4ICsgaHNsYS5qb2luKCkgKyBcIilcIjtcblx0fSxcblx0dG9IZXhTdHJpbmc6IGZ1bmN0aW9uKCBpbmNsdWRlQWxwaGEgKSB7XG5cdFx0dmFyIHJnYmEgPSB0aGlzLl9yZ2JhLnNsaWNlKCksXG5cdFx0XHRhbHBoYSA9IHJnYmEucG9wKCk7XG5cblx0XHRpZiAoIGluY2x1ZGVBbHBoYSApIHtcblx0XHRcdHJnYmEucHVzaCggfn4oIGFscGhhICogMjU1ICkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gXCIjXCIgKyBqUXVlcnkubWFwKCByZ2JhLCBmdW5jdGlvbiggdiApIHtcblxuXHRcdFx0Ly8gRGVmYXVsdCB0byAwIHdoZW4gbnVsbHMgZXhpc3Rcblx0XHRcdHYgPSAoIHYgfHwgMCApLnRvU3RyaW5nKCAxNiApO1xuXHRcdFx0cmV0dXJuIHYubGVuZ3RoID09PSAxID8gXCIwXCIgKyB2IDogdjtcblx0XHR9ICkuam9pbiggXCJcIiApO1xuXHR9LFxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JnYmFbIDMgXSA9PT0gMCA/IFwidHJhbnNwYXJlbnRcIiA6IHRoaXMudG9SZ2JhU3RyaW5nKCk7XG5cdH1cbn0gKTtcbmNvbG9yLmZuLnBhcnNlLnByb3RvdHlwZSA9IGNvbG9yLmZuO1xuXG4vLyBIc2xhIGNvbnZlcnNpb25zIGFkYXB0ZWQgZnJvbTpcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvbWFhc2hhYWNrL3NvdXJjZS9icm93c2UvcGFja2FnZXMvZ3JhcGhpY3MvdHJ1bmsvc3JjL2dyYXBoaWNzL2NvbG9ycy9IVUUyUkdCLmFzP3I9NTAyMVxuXG5mdW5jdGlvbiBodWUycmdiKCBwLCBxLCBoICkge1xuXHRoID0gKCBoICsgMSApICUgMTtcblx0aWYgKCBoICogNiA8IDEgKSB7XG5cdFx0cmV0dXJuIHAgKyAoIHEgLSBwICkgKiBoICogNjtcblx0fVxuXHRpZiAoIGggKiAyIDwgMSApIHtcblx0XHRyZXR1cm4gcTtcblx0fVxuXHRpZiAoIGggKiAzIDwgMiApIHtcblx0XHRyZXR1cm4gcCArICggcSAtIHAgKSAqICggKCAyIC8gMyApIC0gaCApICogNjtcblx0fVxuXHRyZXR1cm4gcDtcbn1cblxuc3BhY2VzLmhzbGEudG8gPSBmdW5jdGlvbiggcmdiYSApIHtcblx0aWYgKCByZ2JhWyAwIF0gPT0gbnVsbCB8fCByZ2JhWyAxIF0gPT0gbnVsbCB8fCByZ2JhWyAyIF0gPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gWyBudWxsLCBudWxsLCBudWxsLCByZ2JhWyAzIF0gXTtcblx0fVxuXHR2YXIgciA9IHJnYmFbIDAgXSAvIDI1NSxcblx0XHRnID0gcmdiYVsgMSBdIC8gMjU1LFxuXHRcdGIgPSByZ2JhWyAyIF0gLyAyNTUsXG5cdFx0YSA9IHJnYmFbIDMgXSxcblx0XHRtYXggPSBNYXRoLm1heCggciwgZywgYiApLFxuXHRcdG1pbiA9IE1hdGgubWluKCByLCBnLCBiICksXG5cdFx0ZGlmZiA9IG1heCAtIG1pbixcblx0XHRhZGQgPSBtYXggKyBtaW4sXG5cdFx0bCA9IGFkZCAqIDAuNSxcblx0XHRoLCBzO1xuXG5cdGlmICggbWluID09PSBtYXggKSB7XG5cdFx0aCA9IDA7XG5cdH0gZWxzZSBpZiAoIHIgPT09IG1heCApIHtcblx0XHRoID0gKCA2MCAqICggZyAtIGIgKSAvIGRpZmYgKSArIDM2MDtcblx0fSBlbHNlIGlmICggZyA9PT0gbWF4ICkge1xuXHRcdGggPSAoIDYwICogKCBiIC0gciApIC8gZGlmZiApICsgMTIwO1xuXHR9IGVsc2Uge1xuXHRcdGggPSAoIDYwICogKCByIC0gZyApIC8gZGlmZiApICsgMjQwO1xuXHR9XG5cblx0Ly8gQ2hyb21hIChkaWZmKSA9PSAwIG1lYW5zIGdyZXlzY2FsZSB3aGljaCwgYnkgZGVmaW5pdGlvbiwgc2F0dXJhdGlvbiA9IDAlXG5cdC8vIG90aGVyd2lzZSwgc2F0dXJhdGlvbiBpcyBiYXNlZCBvbiB0aGUgcmF0aW8gb2YgY2hyb21hIChkaWZmKSB0byBsaWdodG5lc3MgKGFkZClcblx0aWYgKCBkaWZmID09PSAwICkge1xuXHRcdHMgPSAwO1xuXHR9IGVsc2UgaWYgKCBsIDw9IDAuNSApIHtcblx0XHRzID0gZGlmZiAvIGFkZDtcblx0fSBlbHNlIHtcblx0XHRzID0gZGlmZiAvICggMiAtIGFkZCApO1xuXHR9XG5cdHJldHVybiBbIE1hdGgucm91bmQoIGggKSAlIDM2MCwgcywgbCwgYSA9PSBudWxsID8gMSA6IGEgXTtcbn07XG5cbnNwYWNlcy5oc2xhLmZyb20gPSBmdW5jdGlvbiggaHNsYSApIHtcblx0aWYgKCBoc2xhWyAwIF0gPT0gbnVsbCB8fCBoc2xhWyAxIF0gPT0gbnVsbCB8fCBoc2xhWyAyIF0gPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gWyBudWxsLCBudWxsLCBudWxsLCBoc2xhWyAzIF0gXTtcblx0fVxuXHR2YXIgaCA9IGhzbGFbIDAgXSAvIDM2MCxcblx0XHRzID0gaHNsYVsgMSBdLFxuXHRcdGwgPSBoc2xhWyAyIF0sXG5cdFx0YSA9IGhzbGFbIDMgXSxcblx0XHRxID0gbCA8PSAwLjUgPyBsICogKCAxICsgcyApIDogbCArIHMgLSBsICogcyxcblx0XHRwID0gMiAqIGwgLSBxO1xuXG5cdHJldHVybiBbXG5cdFx0TWF0aC5yb3VuZCggaHVlMnJnYiggcCwgcSwgaCArICggMSAvIDMgKSApICogMjU1ICksXG5cdFx0TWF0aC5yb3VuZCggaHVlMnJnYiggcCwgcSwgaCApICogMjU1ICksXG5cdFx0TWF0aC5yb3VuZCggaHVlMnJnYiggcCwgcSwgaCAtICggMSAvIDMgKSApICogMjU1ICksXG5cdFx0YVxuXHRdO1xufTtcblxuZWFjaCggc3BhY2VzLCBmdW5jdGlvbiggc3BhY2VOYW1lLCBzcGFjZSApIHtcblx0dmFyIHByb3BzID0gc3BhY2UucHJvcHMsXG5cdFx0Y2FjaGUgPSBzcGFjZS5jYWNoZSxcblx0XHR0byA9IHNwYWNlLnRvLFxuXHRcdGZyb20gPSBzcGFjZS5mcm9tO1xuXG5cdC8vIE1ha2VzIHJnYmEoKSBhbmQgaHNsYSgpXG5cdGNvbG9yLmZuWyBzcGFjZU5hbWUgXSA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuXHRcdC8vIEdlbmVyYXRlIGEgY2FjaGUgZm9yIHRoaXMgc3BhY2UgaWYgaXQgZG9lc24ndCBleGlzdFxuXHRcdGlmICggdG8gJiYgIXRoaXNbIGNhY2hlIF0gKSB7XG5cdFx0XHR0aGlzWyBjYWNoZSBdID0gdG8oIHRoaXMuX3JnYmEgKTtcblx0XHR9XG5cdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXNbIGNhY2hlIF0uc2xpY2UoKTtcblx0XHR9XG5cblx0XHR2YXIgcmV0LFxuXHRcdFx0dHlwZSA9IGpRdWVyeS50eXBlKCB2YWx1ZSApLFxuXHRcdFx0YXJyID0gKCB0eXBlID09PSBcImFycmF5XCIgfHwgdHlwZSA9PT0gXCJvYmplY3RcIiApID8gdmFsdWUgOiBhcmd1bWVudHMsXG5cdFx0XHRsb2NhbCA9IHRoaXNbIGNhY2hlIF0uc2xpY2UoKTtcblxuXHRcdGVhY2goIHByb3BzLCBmdW5jdGlvbigga2V5LCBwcm9wICkge1xuXHRcdFx0dmFyIHZhbCA9IGFyclsgdHlwZSA9PT0gXCJvYmplY3RcIiA/IGtleSA6IHByb3AuaWR4IF07XG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBsb2NhbFsgcHJvcC5pZHggXTtcblx0XHRcdH1cblx0XHRcdGxvY2FsWyBwcm9wLmlkeCBdID0gY2xhbXAoIHZhbCwgcHJvcCApO1xuXHRcdH0gKTtcblxuXHRcdGlmICggZnJvbSApIHtcblx0XHRcdHJldCA9IGNvbG9yKCBmcm9tKCBsb2NhbCApICk7XG5cdFx0XHRyZXRbIGNhY2hlIF0gPSBsb2NhbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBjb2xvciggbG9jYWwgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gTWFrZXMgcmVkKCkgZ3JlZW4oKSBibHVlKCkgYWxwaGEoKSBodWUoKSBzYXR1cmF0aW9uKCkgbGlnaHRuZXNzKClcblx0ZWFjaCggcHJvcHMsIGZ1bmN0aW9uKCBrZXksIHByb3AgKSB7XG5cblx0XHQvLyBBbHBoYSBpcyBpbmNsdWRlZCBpbiBtb3JlIHRoYW4gb25lIHNwYWNlXG5cdFx0aWYgKCBjb2xvci5mblsga2V5IF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGNvbG9yLmZuWyBrZXkgXSA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciB2dHlwZSA9IGpRdWVyeS50eXBlKCB2YWx1ZSApLFxuXHRcdFx0XHRmbiA9ICgga2V5ID09PSBcImFscGhhXCIgPyAoIHRoaXMuX2hzbGEgPyBcImhzbGFcIiA6IFwicmdiYVwiICkgOiBzcGFjZU5hbWUgKSxcblx0XHRcdFx0bG9jYWwgPSB0aGlzWyBmbiBdKCksXG5cdFx0XHRcdGN1ciA9IGxvY2FsWyBwcm9wLmlkeCBdLFxuXHRcdFx0XHRtYXRjaDtcblxuXHRcdFx0aWYgKCB2dHlwZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGN1cjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2dHlwZSA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmNhbGwoIHRoaXMsIGN1ciApO1xuXHRcdFx0XHR2dHlwZSA9IGpRdWVyeS50eXBlKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsICYmIHByb3AuZW1wdHkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2dHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0bWF0Y2ggPSBycGx1c2VxdWFscy5leGVjKCB2YWx1ZSApO1xuXHRcdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY3VyICsgcGFyc2VGbG9hdCggbWF0Y2hbIDIgXSApICogKCBtYXRjaFsgMSBdID09PSBcIitcIiA/IDEgOiAtMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsb2NhbFsgcHJvcC5pZHggXSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXNbIGZuIF0oIGxvY2FsICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG4vLyBBZGQgY3NzSG9vayBhbmQgLmZ4LnN0ZXAgZnVuY3Rpb24gZm9yIGVhY2ggbmFtZWQgaG9vay5cbi8vIGFjY2VwdCBhIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2YgcHJvcGVydGllc1xuY29sb3IuaG9vayA9IGZ1bmN0aW9uKCBob29rICkge1xuXHR2YXIgaG9va3MgPSBob29rLnNwbGl0KCBcIiBcIiApO1xuXHRlYWNoKCBob29rcywgZnVuY3Rpb24oIGksIGhvb2sgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBob29rIF0gPSB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIHBhcnNlZCwgY3VyRWxlbSxcblx0XHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3IgPSBcIlwiO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT09IFwidHJhbnNwYXJlbnRcIiAmJiAoIGpRdWVyeS50eXBlKCB2YWx1ZSApICE9PSBcInN0cmluZ1wiIHx8XG5cdFx0XHRcdFx0XHQoIHBhcnNlZCA9IHN0cmluZ1BhcnNlKCB2YWx1ZSApICkgKSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNvbG9yKCBwYXJzZWQgfHwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoICFzdXBwb3J0LnJnYmEgJiYgdmFsdWUuX3JnYmFbIDMgXSAhPT0gMSApIHtcblx0XHRcdFx0XHRcdGN1ckVsZW0gPSBob29rID09PSBcImJhY2tncm91bmRDb2xvclwiID8gZWxlbS5wYXJlbnROb2RlIDogZWxlbTtcblx0XHRcdFx0XHRcdHdoaWxlIChcblx0XHRcdFx0XHRcdFx0KCBiYWNrZ3JvdW5kQ29sb3IgPT09IFwiXCIgfHwgYmFja2dyb3VuZENvbG9yID09PSBcInRyYW5zcGFyZW50XCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRjdXJFbGVtICYmIGN1ckVsZW0uc3R5bGVcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdGJhY2tncm91bmRDb2xvciA9IGpRdWVyeS5jc3MoIGN1ckVsZW0sIFwiYmFja2dyb3VuZENvbG9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRjdXJFbGVtID0gY3VyRWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmJsZW5kKCBiYWNrZ3JvdW5kQ29sb3IgJiYgYmFja2dyb3VuZENvbG9yICE9PSBcInRyYW5zcGFyZW50XCIgP1xuXHRcdFx0XHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3IgOlxuXHRcdFx0XHRcdFx0XHRcIl9kZWZhdWx0XCIgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnRvUmdiYVN0cmluZygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZVsgaG9vayBdID0gdmFsdWU7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gV3JhcHBlZCB0byBwcmV2ZW50IElFIGZyb20gdGhyb3dpbmcgZXJyb3JzIG9uIFwiaW52YWxpZFwiIHZhbHVlcyBsaWtlXG5cdFx0XHRcdFx0Ly8gJ2F1dG8nIG9yICdpbmhlcml0J1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRqUXVlcnkuZnguc3RlcFsgaG9vayBdID0gZnVuY3Rpb24oIGZ4ICkge1xuXHRcdFx0aWYgKCAhZnguY29sb3JJbml0ICkge1xuXHRcdFx0XHRmeC5zdGFydCA9IGNvbG9yKCBmeC5lbGVtLCBob29rICk7XG5cdFx0XHRcdGZ4LmVuZCA9IGNvbG9yKCBmeC5lbmQgKTtcblx0XHRcdFx0ZnguY29sb3JJbml0ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGpRdWVyeS5jc3NIb29rc1sgaG9vayBdLnNldCggZnguZWxlbSwgZnguc3RhcnQudHJhbnNpdGlvbiggZnguZW5kLCBmeC5wb3MgKSApO1xuXHRcdH07XG5cdH0gKTtcblxufTtcblxuY29sb3IuaG9vayggc3RlcEhvb2tzICk7XG5cbmpRdWVyeS5jc3NIb29rcy5ib3JkZXJDb2xvciA9IHtcblx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGV4cGFuZGVkID0ge307XG5cblx0XHRlYWNoKCBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHBhcnQgKSB7XG5cdFx0XHRleHBhbmRlZFsgXCJib3JkZXJcIiArIHBhcnQgKyBcIkNvbG9yXCIgXSA9IHZhbHVlO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdH1cbn07XG5cbi8vIEJhc2ljIGNvbG9yIG5hbWVzIG9ubHkuXG4vLyBVc2FnZSBvZiBhbnkgb2YgdGhlIG90aGVyIGNvbG9yIG5hbWVzIHJlcXVpcmVzIGFkZGluZyB5b3Vyc2VsZiBvciBpbmNsdWRpbmdcbi8vIGpxdWVyeS5jb2xvci5zdmctbmFtZXMuanMuXG5jb2xvcnMgPSBqUXVlcnkuQ29sb3IubmFtZXMgPSB7XG5cblx0Ly8gNC4xLiBCYXNpYyBjb2xvciBrZXl3b3Jkc1xuXHRhcXVhOiBcIiMwMGZmZmZcIixcblx0YmxhY2s6IFwiIzAwMDAwMFwiLFxuXHRibHVlOiBcIiMwMDAwZmZcIixcblx0ZnVjaHNpYTogXCIjZmYwMGZmXCIsXG5cdGdyYXk6IFwiIzgwODA4MFwiLFxuXHRncmVlbjogXCIjMDA4MDAwXCIsXG5cdGxpbWU6IFwiIzAwZmYwMFwiLFxuXHRtYXJvb246IFwiIzgwMDAwMFwiLFxuXHRuYXZ5OiBcIiMwMDAwODBcIixcblx0b2xpdmU6IFwiIzgwODAwMFwiLFxuXHRwdXJwbGU6IFwiIzgwMDA4MFwiLFxuXHRyZWQ6IFwiI2ZmMDAwMFwiLFxuXHRzaWx2ZXI6IFwiI2MwYzBjMFwiLFxuXHR0ZWFsOiBcIiMwMDgwODBcIixcblx0d2hpdGU6IFwiI2ZmZmZmZlwiLFxuXHR5ZWxsb3c6IFwiI2ZmZmYwMFwiLFxuXG5cdC8vIDQuMi4zLiBcInRyYW5zcGFyZW50XCIgY29sb3Iga2V5d29yZFxuXHR0cmFuc3BhcmVudDogWyBudWxsLCBudWxsLCBudWxsLCAwIF0sXG5cblx0X2RlZmF1bHQ6IFwiI2ZmZmZmZlwiXG59O1xuXG59ICkoIGpRdWVyeSApO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBDTEFTUyBBTklNQVRJT05TICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4oIGZ1bmN0aW9uKCkge1xuXG52YXIgY2xhc3NBbmltYXRpb25BY3Rpb25zID0gWyBcImFkZFwiLCBcInJlbW92ZVwiLCBcInRvZ2dsZVwiIF0sXG5cdHNob3J0aGFuZFN0eWxlcyA9IHtcblx0XHRib3JkZXI6IDEsXG5cdFx0Ym9yZGVyQm90dG9tOiAxLFxuXHRcdGJvcmRlckNvbG9yOiAxLFxuXHRcdGJvcmRlckxlZnQ6IDEsXG5cdFx0Ym9yZGVyUmlnaHQ6IDEsXG5cdFx0Ym9yZGVyVG9wOiAxLFxuXHRcdGJvcmRlcldpZHRoOiAxLFxuXHRcdG1hcmdpbjogMSxcblx0XHRwYWRkaW5nOiAxXG5cdH07XG5cbiQuZWFjaChcblx0WyBcImJvcmRlckxlZnRTdHlsZVwiLCBcImJvcmRlclJpZ2h0U3R5bGVcIiwgXCJib3JkZXJCb3R0b21TdHlsZVwiLCBcImJvcmRlclRvcFN0eWxlXCIgXSxcblx0ZnVuY3Rpb24oIF8sIHByb3AgKSB7XG5cdFx0JC5meC5zdGVwWyBwcm9wIF0gPSBmdW5jdGlvbiggZnggKSB7XG5cdFx0XHRpZiAoIGZ4LmVuZCAhPT0gXCJub25lXCIgJiYgIWZ4LnNldEF0dHIgfHwgZngucG9zID09PSAxICYmICFmeC5zZXRBdHRyICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGZ4LmVsZW0sIHByb3AsIGZ4LmVuZCApO1xuXHRcdFx0XHRmeC5zZXRBdHRyID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG4pO1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50U3R5bGVzKCBlbGVtICkge1xuXHR2YXIga2V5LCBsZW4sXG5cdFx0c3R5bGUgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgP1xuXHRcdFx0ZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0sIG51bGwgKSA6XG5cdFx0XHRlbGVtLmN1cnJlbnRTdHlsZSxcblx0XHRzdHlsZXMgPSB7fTtcblxuXHRpZiAoIHN0eWxlICYmIHN0eWxlLmxlbmd0aCAmJiBzdHlsZVsgMCBdICYmIHN0eWxlWyBzdHlsZVsgMCBdIF0gKSB7XG5cdFx0bGVuID0gc3R5bGUubGVuZ3RoO1xuXHRcdHdoaWxlICggbGVuLS0gKSB7XG5cdFx0XHRrZXkgPSBzdHlsZVsgbGVuIF07XG5cdFx0XHRpZiAoIHR5cGVvZiBzdHlsZVsga2V5IF0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHN0eWxlc1sgJC5jYW1lbENhc2UoIGtleSApIF0gPSBzdHlsZVsga2V5IF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdC8vIFN1cHBvcnQ6IE9wZXJhLCBJRSA8OVxuXHR9IGVsc2Uge1xuXHRcdGZvciAoIGtleSBpbiBzdHlsZSApIHtcblx0XHRcdGlmICggdHlwZW9mIHN0eWxlWyBrZXkgXSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0c3R5bGVzWyBrZXkgXSA9IHN0eWxlWyBrZXkgXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBzdHlsZURpZmZlcmVuY2UoIG9sZFN0eWxlLCBuZXdTdHlsZSApIHtcblx0dmFyIGRpZmYgPSB7fSxcblx0XHRuYW1lLCB2YWx1ZTtcblxuXHRmb3IgKCBuYW1lIGluIG5ld1N0eWxlICkge1xuXHRcdHZhbHVlID0gbmV3U3R5bGVbIG5hbWUgXTtcblx0XHRpZiAoIG9sZFN0eWxlWyBuYW1lIF0gIT09IHZhbHVlICkge1xuXHRcdFx0aWYgKCAhc2hvcnRoYW5kU3R5bGVzWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGlmICggJC5meC5zdGVwWyBuYW1lIF0gfHwgIWlzTmFOKCBwYXJzZUZsb2F0KCB2YWx1ZSApICkgKSB7XG5cdFx0XHRcdFx0ZGlmZlsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZGlmZjtcbn1cblxuLy8gU3VwcG9ydDogalF1ZXJ5IDwxLjhcbmlmICggISQuZm4uYWRkQmFjayApIHtcblx0JC5mbi5hZGRCYWNrID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fTtcbn1cblxuJC5lZmZlY3RzLmFuaW1hdGVDbGFzcyA9IGZ1bmN0aW9uKCB2YWx1ZSwgZHVyYXRpb24sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdHZhciBvID0gJC5zcGVlZCggZHVyYXRpb24sIGVhc2luZywgY2FsbGJhY2sgKTtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFuaW1hdGVkID0gJCggdGhpcyApLFxuXHRcdFx0YmFzZUNsYXNzID0gYW5pbWF0ZWQuYXR0ciggXCJjbGFzc1wiICkgfHwgXCJcIixcblx0XHRcdGFwcGx5Q2xhc3NDaGFuZ2UsXG5cdFx0XHRhbGxBbmltYXRpb25zID0gby5jaGlsZHJlbiA/IGFuaW1hdGVkLmZpbmQoIFwiKlwiICkuYWRkQmFjaygpIDogYW5pbWF0ZWQ7XG5cblx0XHQvLyBNYXAgdGhlIGFuaW1hdGVkIG9iamVjdHMgdG8gc3RvcmUgdGhlIG9yaWdpbmFsIHN0eWxlcy5cblx0XHRhbGxBbmltYXRpb25zID0gYWxsQW5pbWF0aW9ucy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsID0gJCggdGhpcyApO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZWw6IGVsLFxuXHRcdFx0XHRzdGFydDogZ2V0RWxlbWVudFN0eWxlcyggdGhpcyApXG5cdFx0XHR9O1xuXHRcdH0gKTtcblxuXHRcdC8vIEFwcGx5IGNsYXNzIGNoYW5nZVxuXHRcdGFwcGx5Q2xhc3NDaGFuZ2UgPSBmdW5jdGlvbigpIHtcblx0XHRcdCQuZWFjaCggY2xhc3NBbmltYXRpb25BY3Rpb25zLCBmdW5jdGlvbiggaSwgYWN0aW9uICkge1xuXHRcdFx0XHRpZiAoIHZhbHVlWyBhY3Rpb24gXSApIHtcblx0XHRcdFx0XHRhbmltYXRlZFsgYWN0aW9uICsgXCJDbGFzc1wiIF0oIHZhbHVlWyBhY3Rpb24gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0XHRhcHBseUNsYXNzQ2hhbmdlKCk7XG5cblx0XHQvLyBNYXAgYWxsIGFuaW1hdGVkIG9iamVjdHMgYWdhaW4gLSBjYWxjdWxhdGUgbmV3IHN0eWxlcyBhbmQgZGlmZlxuXHRcdGFsbEFuaW1hdGlvbnMgPSBhbGxBbmltYXRpb25zLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmVuZCA9IGdldEVsZW1lbnRTdHlsZXMoIHRoaXMuZWxbIDAgXSApO1xuXHRcdFx0dGhpcy5kaWZmID0gc3R5bGVEaWZmZXJlbmNlKCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSApO1xuXG5cdFx0Ly8gQXBwbHkgb3JpZ2luYWwgY2xhc3Ncblx0XHRhbmltYXRlZC5hdHRyKCBcImNsYXNzXCIsIGJhc2VDbGFzcyApO1xuXG5cdFx0Ly8gTWFwIGFsbCBhbmltYXRlZCBvYmplY3RzIGFnYWluIC0gdGhpcyB0aW1lIGNvbGxlY3RpbmcgYSBwcm9taXNlXG5cdFx0YWxsQW5pbWF0aW9ucyA9IGFsbEFuaW1hdGlvbnMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzdHlsZUluZm8gPSB0aGlzLFxuXHRcdFx0XHRkZmQgPSAkLkRlZmVycmVkKCksXG5cdFx0XHRcdG9wdHMgPSAkLmV4dGVuZCgge30sIG8sIHtcblx0XHRcdFx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0XHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0ZGZkLnJlc29sdmUoIHN0eWxlSW5mbyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR0aGlzLmVsLmFuaW1hdGUoIHRoaXMuZGlmZiwgb3B0cyApO1xuXHRcdFx0cmV0dXJuIGRmZC5wcm9taXNlKCk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gT25jZSBhbGwgYW5pbWF0aW9ucyBoYXZlIGNvbXBsZXRlZDpcblx0XHQkLndoZW4uYXBwbHkoICQsIGFsbEFuaW1hdGlvbnMuZ2V0KCkgKS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU2V0IHRoZSBmaW5hbCBjbGFzc1xuXHRcdFx0YXBwbHlDbGFzc0NoYW5nZSgpO1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBhbmltYXRlZCBlbGVtZW50LFxuXHRcdFx0Ly8gY2xlYXIgYWxsIGNzcyBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBhbmltYXRlZFxuXHRcdFx0JC5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWwgPSB0aGlzLmVsO1xuXHRcdFx0XHQkLmVhY2goIHRoaXMuZGlmZiwgZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHRlbC5jc3MoIGtleSwgXCJcIiApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9ICk7XG5cblx0XHRcdC8vIFRoaXMgaXMgZ3Vhcm50ZWVkIHRvIGJlIHRoZXJlIGlmIHlvdSB1c2UgalF1ZXJ5LnNwZWVkKClcblx0XHRcdC8vIGl0IGFsc28gaGFuZGxlcyBkZXF1ZXVpbmcgdGhlIG5leHQgYW5pbS4uLlxuXHRcdFx0by5jb21wbGV0ZS5jYWxsKCBhbmltYXRlZFsgMCBdICk7XG5cdFx0fSApO1xuXHR9ICk7XG59O1xuXG4kLmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogKCBmdW5jdGlvbiggb3JpZyApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGNsYXNzTmFtZXMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdFx0cmV0dXJuIHNwZWVkID9cblx0XHRcdFx0JC5lZmZlY3RzLmFuaW1hdGVDbGFzcy5jYWxsKCB0aGlzLFxuXHRcdFx0XHRcdHsgYWRkOiBjbGFzc05hbWVzIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkgOlxuXHRcdFx0XHRvcmlnLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXHR9ICkoICQuZm4uYWRkQ2xhc3MgKSxcblxuXHRyZW1vdmVDbGFzczogKCBmdW5jdGlvbiggb3JpZyApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGNsYXNzTmFtZXMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID9cblx0XHRcdFx0JC5lZmZlY3RzLmFuaW1hdGVDbGFzcy5jYWxsKCB0aGlzLFxuXHRcdFx0XHRcdHsgcmVtb3ZlOiBjbGFzc05hbWVzIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkgOlxuXHRcdFx0XHRvcmlnLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXHR9ICkoICQuZm4ucmVtb3ZlQ2xhc3MgKSxcblxuXHR0b2dnbGVDbGFzczogKCBmdW5jdGlvbiggb3JpZyApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGNsYXNzTmFtZXMsIGZvcmNlLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRcdGlmICggdHlwZW9mIGZvcmNlID09PSBcImJvb2xlYW5cIiB8fCBmb3JjZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRpZiAoICFzcGVlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdpdGhvdXQgc3BlZWQgcGFyYW1ldGVyXG5cdFx0XHRcdFx0cmV0dXJuIG9yaWcuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiAkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwoIHRoaXMsXG5cdFx0XHRcdFx0XHQoIGZvcmNlID8geyBhZGQ6IGNsYXNzTmFtZXMgfSA6IHsgcmVtb3ZlOiBjbGFzc05hbWVzIH0gKSxcblx0XHRcdFx0XHRcdHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gV2l0aG91dCBmb3JjZSBwYXJhbWV0ZXJcblx0XHRcdFx0cmV0dXJuICQuZWZmZWN0cy5hbmltYXRlQ2xhc3MuY2FsbCggdGhpcyxcblx0XHRcdFx0XHR7IHRvZ2dsZTogY2xhc3NOYW1lcyB9LCBmb3JjZSwgc3BlZWQsIGVhc2luZyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gKSggJC5mbi50b2dnbGVDbGFzcyApLFxuXG5cdHN3aXRjaENsYXNzOiBmdW5jdGlvbiggcmVtb3ZlLCBhZGQsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiAkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwoIHRoaXMsIHtcblx0XHRcdGFkZDogYWRkLFxuXHRcdFx0cmVtb3ZlOiByZW1vdmVcblx0XHR9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9XG59ICk7XG5cbn0gKSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVGRkVDVFMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiggZnVuY3Rpb24oKSB7XG5cbmlmICggJC5leHByICYmICQuZXhwci5maWx0ZXJzICYmICQuZXhwci5maWx0ZXJzLmFuaW1hdGVkICkge1xuXHQkLmV4cHIuZmlsdGVycy5hbmltYXRlZCA9ICggZnVuY3Rpb24oIG9yaWcgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICEhJCggZWxlbSApLmRhdGEoIGRhdGFTcGFjZUFuaW1hdGVkICkgfHwgb3JpZyggZWxlbSApO1xuXHRcdH07XG5cdH0gKSggJC5leHByLmZpbHRlcnMuYW5pbWF0ZWQgKTtcbn1cblxuaWYgKCAkLnVpQmFja0NvbXBhdCAhPT0gZmFsc2UgKSB7XG5cdCQuZXh0ZW5kKCAkLmVmZmVjdHMsIHtcblxuXHRcdC8vIFNhdmVzIGEgc2V0IG9mIHByb3BlcnRpZXMgaW4gYSBkYXRhIHN0b3JhZ2Vcblx0XHRzYXZlOiBmdW5jdGlvbiggZWxlbWVudCwgc2V0ICkge1xuXHRcdFx0dmFyIGkgPSAwLCBsZW5ndGggPSBzZXQubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggc2V0WyBpIF0gIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5kYXRhKCBkYXRhU3BhY2UgKyBzZXRbIGkgXSwgZWxlbWVudFsgMCBdLnN0eWxlWyBzZXRbIGkgXSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gUmVzdG9yZXMgYSBzZXQgb2YgcHJldmlvdXNseSBzYXZlZCBwcm9wZXJ0aWVzIGZyb20gYSBkYXRhIHN0b3JhZ2Vcblx0XHRyZXN0b3JlOiBmdW5jdGlvbiggZWxlbWVudCwgc2V0ICkge1xuXHRcdFx0dmFyIHZhbCwgaSA9IDAsIGxlbmd0aCA9IHNldC5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBzZXRbIGkgXSAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHR2YWwgPSBlbGVtZW50LmRhdGEoIGRhdGFTcGFjZSArIHNldFsgaSBdICk7XG5cdFx0XHRcdFx0ZWxlbWVudC5jc3MoIHNldFsgaSBdLCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXRNb2RlOiBmdW5jdGlvbiggZWwsIG1vZGUgKSB7XG5cdFx0XHRpZiAoIG1vZGUgPT09IFwidG9nZ2xlXCIgKSB7XG5cdFx0XHRcdG1vZGUgPSBlbC5pcyggXCI6aGlkZGVuXCIgKSA/IFwic2hvd1wiIDogXCJoaWRlXCI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbW9kZTtcblx0XHR9LFxuXG5cdFx0Ly8gV3JhcHMgdGhlIGVsZW1lbnQgYXJvdW5kIGEgd3JhcHBlciB0aGF0IGNvcGllcyBwb3NpdGlvbiBwcm9wZXJ0aWVzXG5cdFx0Y3JlYXRlV3JhcHBlcjogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgd3JhcHBlZCwgcmV0dXJuIGl0XG5cdFx0XHRpZiAoIGVsZW1lbnQucGFyZW50KCkuaXMoIFwiLnVpLWVmZmVjdHMtd3JhcHBlclwiICkgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtZW50LnBhcmVudCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXcmFwIHRoZSBlbGVtZW50XG5cdFx0XHR2YXIgcHJvcHMgPSB7XG5cdFx0XHRcdFx0d2lkdGg6IGVsZW1lbnQub3V0ZXJXaWR0aCggdHJ1ZSApLFxuXHRcdFx0XHRcdGhlaWdodDogZWxlbWVudC5vdXRlckhlaWdodCggdHJ1ZSApLFxuXHRcdFx0XHRcdFwiZmxvYXRcIjogZWxlbWVudC5jc3MoIFwiZmxvYXRcIiApXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHdyYXBwZXIgPSAkKCBcIjxkaXY+PC9kaXY+XCIgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1lZmZlY3RzLXdyYXBwZXJcIiApXG5cdFx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdFx0Zm9udFNpemU6IFwiMTAwJVwiLFxuXHRcdFx0XHRcdFx0YmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiLFxuXHRcdFx0XHRcdFx0Ym9yZGVyOiBcIm5vbmVcIixcblx0XHRcdFx0XHRcdG1hcmdpbjogMCxcblx0XHRcdFx0XHRcdHBhZGRpbmc6IDBcblx0XHRcdFx0XHR9ICksXG5cblx0XHRcdFx0Ly8gU3RvcmUgdGhlIHNpemUgaW4gY2FzZSB3aWR0aC9oZWlnaHQgYXJlIGRlZmluZWQgaW4gJSAtIEZpeGVzICM1MjQ1XG5cdFx0XHRcdHNpemUgPSB7XG5cdFx0XHRcdFx0d2lkdGg6IGVsZW1lbnQud2lkdGgoKSxcblx0XHRcdFx0XHRoZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0KClcblx0XHRcdFx0fSxcblx0XHRcdFx0YWN0aXZlID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveFxuXHRcdFx0Ly8gRmlyZWZveCBpbmNvcnJlY3RseSBleHBvc2VzIGFub255bW91cyBjb250ZW50XG5cdFx0XHQvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NjE2NjRcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGFjdGl2ZS5pZDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRhY3RpdmUgPSBkb2N1bWVudC5ib2R5O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtZW50LndyYXAoIHdyYXBwZXIgKTtcblxuXHRcdFx0Ly8gRml4ZXMgIzc1OTUgLSBFbGVtZW50cyBsb3NlIGZvY3VzIHdoZW4gd3JhcHBlZC5cblx0XHRcdGlmICggZWxlbWVudFsgMCBdID09PSBhY3RpdmUgfHwgJC5jb250YWlucyggZWxlbWVudFsgMCBdLCBhY3RpdmUgKSApIHtcblx0XHRcdFx0JCggYWN0aXZlICkudHJpZ2dlciggXCJmb2N1c1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvdGZpeCBmb3IgalF1ZXJ5IDEuNCBzaW5jZSBzb21lIGNoYW5nZSBpbiB3cmFwKCkgc2VlbXMgdG8gYWN0dWFsbHlcblx0XHRcdC8vIGxvc2UgdGhlIHJlZmVyZW5jZSB0byB0aGUgd3JhcHBlZCBlbGVtZW50XG5cdFx0XHR3cmFwcGVyID0gZWxlbWVudC5wYXJlbnQoKTtcblxuXHRcdFx0Ly8gVHJhbnNmZXIgcG9zaXRpb25pbmcgcHJvcGVydGllcyB0byB0aGUgd3JhcHBlclxuXHRcdFx0aWYgKCBlbGVtZW50LmNzcyggXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdHdyYXBwZXIuY3NzKCB7IHBvc2l0aW9uOiBcInJlbGF0aXZlXCIgfSApO1xuXHRcdFx0XHRlbGVtZW50LmNzcyggeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQuZXh0ZW5kKCBwcm9wcywge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBlbGVtZW50LmNzcyggXCJwb3NpdGlvblwiICksXG5cdFx0XHRcdFx0ekluZGV4OiBlbGVtZW50LmNzcyggXCJ6LWluZGV4XCIgKVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdCQuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiwgXCJib3R0b21cIiwgXCJyaWdodFwiIF0sIGZ1bmN0aW9uKCBpLCBwb3MgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIHBvcyBdID0gZWxlbWVudC5jc3MoIHBvcyApO1xuXHRcdFx0XHRcdGlmICggaXNOYU4oIHBhcnNlSW50KCBwcm9wc1sgcG9zIF0sIDEwICkgKSApIHtcblx0XHRcdFx0XHRcdHByb3BzWyBwb3MgXSA9IFwiYXV0b1wiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRlbGVtZW50LmNzcygge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG5cdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0cmlnaHQ6IFwiYXV0b1wiLFxuXHRcdFx0XHRcdGJvdHRvbTogXCJhdXRvXCJcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudC5jc3MoIHNpemUgKTtcblxuXHRcdFx0cmV0dXJuIHdyYXBwZXIuY3NzKCBwcm9wcyApLnNob3coKTtcblx0XHR9LFxuXG5cdFx0cmVtb3ZlV3JhcHBlcjogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgYWN0aXZlID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuXHRcdFx0aWYgKCBlbGVtZW50LnBhcmVudCgpLmlzKCBcIi51aS1lZmZlY3RzLXdyYXBwZXJcIiApICkge1xuXHRcdFx0XHRlbGVtZW50LnBhcmVudCgpLnJlcGxhY2VXaXRoKCBlbGVtZW50ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgIzc1OTUgLSBFbGVtZW50cyBsb3NlIGZvY3VzIHdoZW4gd3JhcHBlZC5cblx0XHRcdFx0aWYgKCBlbGVtZW50WyAwIF0gPT09IGFjdGl2ZSB8fCAkLmNvbnRhaW5zKCBlbGVtZW50WyAwIF0sIGFjdGl2ZSApICkge1xuXHRcdFx0XHRcdCQoIGFjdGl2ZSApLnRyaWdnZXIoIFwiZm9jdXNcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtZW50O1xuXHRcdH1cblx0fSApO1xufVxuXG4kLmV4dGVuZCggJC5lZmZlY3RzLCB7XG5cdHZlcnNpb246IFwiMS4xMi4xXCIsXG5cblx0ZGVmaW5lOiBmdW5jdGlvbiggbmFtZSwgbW9kZSwgZWZmZWN0ICkge1xuXHRcdGlmICggIWVmZmVjdCApIHtcblx0XHRcdGVmZmVjdCA9IG1vZGU7XG5cdFx0XHRtb2RlID0gXCJlZmZlY3RcIjtcblx0XHR9XG5cblx0XHQkLmVmZmVjdHMuZWZmZWN0WyBuYW1lIF0gPSBlZmZlY3Q7XG5cdFx0JC5lZmZlY3RzLmVmZmVjdFsgbmFtZSBdLm1vZGUgPSBtb2RlO1xuXG5cdFx0cmV0dXJuIGVmZmVjdDtcblx0fSxcblxuXHRzY2FsZWREaW1lbnNpb25zOiBmdW5jdGlvbiggZWxlbWVudCwgcGVyY2VudCwgZGlyZWN0aW9uICkge1xuXHRcdGlmICggcGVyY2VudCA9PT0gMCApIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGhlaWdodDogMCxcblx0XHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRcdG91dGVySGVpZ2h0OiAwLFxuXHRcdFx0XHRvdXRlcldpZHRoOiAwXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHZhciB4ID0gZGlyZWN0aW9uICE9PSBcImhvcml6b250YWxcIiA/ICggKCBwZXJjZW50IHx8IDEwMCApIC8gMTAwICkgOiAxLFxuXHRcdFx0eSA9IGRpcmVjdGlvbiAhPT0gXCJ2ZXJ0aWNhbFwiID8gKCAoIHBlcmNlbnQgfHwgMTAwICkgLyAxMDAgKSA6IDE7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0aGVpZ2h0OiBlbGVtZW50LmhlaWdodCgpICogeSxcblx0XHRcdHdpZHRoOiBlbGVtZW50LndpZHRoKCkgKiB4LFxuXHRcdFx0b3V0ZXJIZWlnaHQ6IGVsZW1lbnQub3V0ZXJIZWlnaHQoKSAqIHksXG5cdFx0XHRvdXRlcldpZHRoOiBlbGVtZW50Lm91dGVyV2lkdGgoKSAqIHhcblx0XHR9O1xuXG5cdH0sXG5cblx0Y2xpcFRvQm94OiBmdW5jdGlvbiggYW5pbWF0aW9uICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogYW5pbWF0aW9uLmNsaXAucmlnaHQgLSBhbmltYXRpb24uY2xpcC5sZWZ0LFxuXHRcdFx0aGVpZ2h0OiBhbmltYXRpb24uY2xpcC5ib3R0b20gLSBhbmltYXRpb24uY2xpcC50b3AsXG5cdFx0XHRsZWZ0OiBhbmltYXRpb24uY2xpcC5sZWZ0LFxuXHRcdFx0dG9wOiBhbmltYXRpb24uY2xpcC50b3Bcblx0XHR9O1xuXHR9LFxuXG5cdC8vIEluamVjdHMgcmVjZW50bHkgcXVldWVkIGZ1bmN0aW9ucyB0byBiZSBmaXJzdCBpbiBsaW5lIChhZnRlciBcImlucHJvZ3Jlc3NcIilcblx0dW5zaGlmdDogZnVuY3Rpb24oIGVsZW1lbnQsIHF1ZXVlTGVuZ3RoLCBjb3VudCApIHtcblx0XHR2YXIgcXVldWUgPSBlbGVtZW50LnF1ZXVlKCk7XG5cblx0XHRpZiAoIHF1ZXVlTGVuZ3RoID4gMSApIHtcblx0XHRcdHF1ZXVlLnNwbGljZS5hcHBseSggcXVldWUsXG5cdFx0XHRcdFsgMSwgMCBdLmNvbmNhdCggcXVldWUuc3BsaWNlKCBxdWV1ZUxlbmd0aCwgY291bnQgKSApICk7XG5cdFx0fVxuXHRcdGVsZW1lbnQuZGVxdWV1ZSgpO1xuXHR9LFxuXG5cdHNhdmVTdHlsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0ZWxlbWVudC5kYXRhKCBkYXRhU3BhY2VTdHlsZSwgZWxlbWVudFsgMCBdLnN0eWxlLmNzc1RleHQgKTtcblx0fSxcblxuXHRyZXN0b3JlU3R5bGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdGVsZW1lbnRbIDAgXS5zdHlsZS5jc3NUZXh0ID0gZWxlbWVudC5kYXRhKCBkYXRhU3BhY2VTdHlsZSApIHx8IFwiXCI7XG5cdFx0ZWxlbWVudC5yZW1vdmVEYXRhKCBkYXRhU3BhY2VTdHlsZSApO1xuXHR9LFxuXG5cdG1vZGU6IGZ1bmN0aW9uKCBlbGVtZW50LCBtb2RlICkge1xuXHRcdHZhciBoaWRkZW4gPSBlbGVtZW50LmlzKCBcIjpoaWRkZW5cIiApO1xuXG5cdFx0aWYgKCBtb2RlID09PSBcInRvZ2dsZVwiICkge1xuXHRcdFx0bW9kZSA9IGhpZGRlbiA/IFwic2hvd1wiIDogXCJoaWRlXCI7XG5cdFx0fVxuXHRcdGlmICggaGlkZGVuID8gbW9kZSA9PT0gXCJoaWRlXCIgOiBtb2RlID09PSBcInNob3dcIiApIHtcblx0XHRcdG1vZGUgPSBcIm5vbmVcIjtcblx0XHR9XG5cdFx0cmV0dXJuIG1vZGU7XG5cdH0sXG5cblx0Ly8gVHJhbnNsYXRlcyBhIFt0b3AsbGVmdF0gYXJyYXkgaW50byBhIGJhc2VsaW5lIHZhbHVlXG5cdGdldEJhc2VsaW5lOiBmdW5jdGlvbiggb3JpZ2luLCBvcmlnaW5hbCApIHtcblx0XHR2YXIgeSwgeDtcblxuXHRcdHN3aXRjaCAoIG9yaWdpblsgMCBdICkge1xuXHRcdGNhc2UgXCJ0b3BcIjpcblx0XHRcdHkgPSAwO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcIm1pZGRsZVwiOlxuXHRcdFx0eSA9IDAuNTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgXCJib3R0b21cIjpcblx0XHRcdHkgPSAxO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHkgPSBvcmlnaW5bIDAgXSAvIG9yaWdpbmFsLmhlaWdodDtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKCBvcmlnaW5bIDEgXSApIHtcblx0XHRjYXNlIFwibGVmdFwiOlxuXHRcdFx0eCA9IDA7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwiY2VudGVyXCI6XG5cdFx0XHR4ID0gMC41O1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcInJpZ2h0XCI6XG5cdFx0XHR4ID0gMTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHR4ID0gb3JpZ2luWyAxIF0gLyBvcmlnaW5hbC53aWR0aDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCxcblx0XHRcdHk6IHlcblx0XHR9O1xuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBwbGFjZWhvbGRlciBlbGVtZW50IHNvIHRoYXQgdGhlIG9yaWdpbmFsIGVsZW1lbnQgY2FuIGJlIG1hZGUgYWJzb2x1dGVcblx0Y3JlYXRlUGxhY2Vob2xkZXI6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciBwbGFjZWhvbGRlcixcblx0XHRcdGNzc1Bvc2l0aW9uID0gZWxlbWVudC5jc3MoIFwicG9zaXRpb25cIiApLFxuXHRcdFx0cG9zaXRpb24gPSBlbGVtZW50LnBvc2l0aW9uKCk7XG5cblx0XHQvLyBMb2NrIGluIG1hcmdpbnMgZmlyc3QgdG8gYWNjb3VudCBmb3IgZm9ybSBlbGVtZW50cywgd2hpY2hcblx0XHQvLyB3aWxsIGNoYW5nZSBtYXJnaW4gaWYgeW91IGV4cGxpY2l0bHkgc2V0IGhlaWdodFxuXHRcdC8vIHNlZTogaHR0cDovL2pzZmlkZGxlLm5ldC9KWlNNdC8zLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTA3MzgwXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpXG5cdFx0ZWxlbWVudC5jc3MoIHtcblx0XHRcdG1hcmdpblRvcDogZWxlbWVudC5jc3MoIFwibWFyZ2luVG9wXCIgKSxcblx0XHRcdG1hcmdpbkJvdHRvbTogZWxlbWVudC5jc3MoIFwibWFyZ2luQm90dG9tXCIgKSxcblx0XHRcdG1hcmdpbkxlZnQ6IGVsZW1lbnQuY3NzKCBcIm1hcmdpbkxlZnRcIiApLFxuXHRcdFx0bWFyZ2luUmlnaHQ6IGVsZW1lbnQuY3NzKCBcIm1hcmdpblJpZ2h0XCIgKVxuXHRcdH0gKVxuXHRcdC5vdXRlcldpZHRoKCBlbGVtZW50Lm91dGVyV2lkdGgoKSApXG5cdFx0Lm91dGVySGVpZ2h0KCBlbGVtZW50Lm91dGVySGVpZ2h0KCkgKTtcblxuXHRcdGlmICggL14oc3RhdGljfHJlbGF0aXZlKS8udGVzdCggY3NzUG9zaXRpb24gKSApIHtcblx0XHRcdGNzc1Bvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXG5cdFx0XHRwbGFjZWhvbGRlciA9ICQoIFwiPFwiICsgZWxlbWVudFsgMCBdLm5vZGVOYW1lICsgXCI+XCIgKS5pbnNlcnRBZnRlciggZWxlbWVudCApLmNzcygge1xuXG5cdFx0XHRcdC8vIENvbnZlcnQgaW5saW5lIHRvIGlubGluZSBibG9jayB0byBhY2NvdW50IGZvciBpbmxpbmUgZWxlbWVudHNcblx0XHRcdFx0Ly8gdGhhdCB0dXJuIHRvIGlubGluZSBibG9jayBiYXNlZCBvbiBjb250ZW50IChsaWtlIGltZylcblx0XHRcdFx0ZGlzcGxheTogL14oaW5saW5lfHJ1YnkpLy50ZXN0KCBlbGVtZW50LmNzcyggXCJkaXNwbGF5XCIgKSApID9cblx0XHRcdFx0XHRcImlubGluZS1ibG9ja1wiIDpcblx0XHRcdFx0XHRcImJsb2NrXCIsXG5cdFx0XHRcdHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsXG5cblx0XHRcdFx0Ly8gTWFyZ2lucyBuZWVkIHRvIGJlIHNldCB0byBhY2NvdW50IGZvciBtYXJnaW4gY29sbGFwc2Vcblx0XHRcdFx0bWFyZ2luVG9wOiBlbGVtZW50LmNzcyggXCJtYXJnaW5Ub3BcIiApLFxuXHRcdFx0XHRtYXJnaW5Cb3R0b206IGVsZW1lbnQuY3NzKCBcIm1hcmdpbkJvdHRvbVwiICksXG5cdFx0XHRcdG1hcmdpbkxlZnQ6IGVsZW1lbnQuY3NzKCBcIm1hcmdpbkxlZnRcIiApLFxuXHRcdFx0XHRtYXJnaW5SaWdodDogZWxlbWVudC5jc3MoIFwibWFyZ2luUmlnaHRcIiApLFxuXHRcdFx0XHRcImZsb2F0XCI6IGVsZW1lbnQuY3NzKCBcImZsb2F0XCIgKVxuXHRcdFx0fSApXG5cdFx0XHQub3V0ZXJXaWR0aCggZWxlbWVudC5vdXRlcldpZHRoKCkgKVxuXHRcdFx0Lm91dGVySGVpZ2h0KCBlbGVtZW50Lm91dGVySGVpZ2h0KCkgKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLWVmZmVjdHMtcGxhY2Vob2xkZXJcIiApO1xuXG5cdFx0XHRlbGVtZW50LmRhdGEoIGRhdGFTcGFjZSArIFwicGxhY2Vob2xkZXJcIiwgcGxhY2Vob2xkZXIgKTtcblx0XHR9XG5cblx0XHRlbGVtZW50LmNzcygge1xuXHRcdFx0cG9zaXRpb246IGNzc1Bvc2l0aW9uLFxuXHRcdFx0bGVmdDogcG9zaXRpb24ubGVmdCxcblx0XHRcdHRvcDogcG9zaXRpb24udG9wXG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIHBsYWNlaG9sZGVyO1xuXHR9LFxuXG5cdHJlbW92ZVBsYWNlaG9sZGVyOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR2YXIgZGF0YUtleSA9IGRhdGFTcGFjZSArIFwicGxhY2Vob2xkZXJcIixcblx0XHRcdFx0cGxhY2Vob2xkZXIgPSBlbGVtZW50LmRhdGEoIGRhdGFLZXkgKTtcblxuXHRcdGlmICggcGxhY2Vob2xkZXIgKSB7XG5cdFx0XHRwbGFjZWhvbGRlci5yZW1vdmUoKTtcblx0XHRcdGVsZW1lbnQucmVtb3ZlRGF0YSggZGF0YUtleSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBSZW1vdmVzIGEgcGxhY2Vob2xkZXIgaWYgaXQgZXhpc3RzIGFuZCByZXN0b3Jlc1xuXHQvLyBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBtb2RpZmllZCBkdXJpbmcgcGxhY2Vob2xkZXIgY3JlYXRpb25cblx0Y2xlYW5VcDogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0JC5lZmZlY3RzLnJlc3RvcmVTdHlsZSggZWxlbWVudCApO1xuXHRcdCQuZWZmZWN0cy5yZW1vdmVQbGFjZWhvbGRlciggZWxlbWVudCApO1xuXHR9LFxuXG5cdHNldFRyYW5zaXRpb246IGZ1bmN0aW9uKCBlbGVtZW50LCBsaXN0LCBmYWN0b3IsIHZhbHVlICkge1xuXHRcdHZhbHVlID0gdmFsdWUgfHwge307XG5cdFx0JC5lYWNoKCBsaXN0LCBmdW5jdGlvbiggaSwgeCApIHtcblx0XHRcdHZhciB1bml0ID0gZWxlbWVudC5jc3NVbml0KCB4ICk7XG5cdFx0XHRpZiAoIHVuaXRbIDAgXSA+IDAgKSB7XG5cdFx0XHRcdHZhbHVlWyB4IF0gPSB1bml0WyAwIF0gKiBmYWN0b3IgKyB1bml0WyAxIF07XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxufSApO1xuXG4vLyBSZXR1cm4gYW4gZWZmZWN0IG9wdGlvbnMgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyczpcbmZ1bmN0aW9uIF9ub3JtYWxpemVBcmd1bWVudHMoIGVmZmVjdCwgb3B0aW9ucywgc3BlZWQsIGNhbGxiYWNrICkge1xuXG5cdC8vIEFsbG93IHBhc3NpbmcgYWxsIG9wdGlvbnMgYXMgdGhlIGZpcnN0IHBhcmFtZXRlclxuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggZWZmZWN0ICkgKSB7XG5cdFx0b3B0aW9ucyA9IGVmZmVjdDtcblx0XHRlZmZlY3QgPSBlZmZlY3QuZWZmZWN0O1xuXHR9XG5cblx0Ly8gQ29udmVydCB0byBhbiBvYmplY3Rcblx0ZWZmZWN0ID0geyBlZmZlY3Q6IGVmZmVjdCB9O1xuXG5cdC8vIENhdGNoIChlZmZlY3QsIG51bGwsIC4uLilcblx0aWYgKCBvcHRpb25zID09IG51bGwgKSB7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHR9XG5cblx0Ly8gQ2F0Y2ggKGVmZmVjdCwgY2FsbGJhY2spXG5cdGlmICggJC5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cdFx0Y2FsbGJhY2sgPSBvcHRpb25zO1xuXHRcdHNwZWVkID0gbnVsbDtcblx0XHRvcHRpb25zID0ge307XG5cdH1cblxuXHQvLyBDYXRjaCAoZWZmZWN0LCBzcGVlZCwgPylcblx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiB8fCAkLmZ4LnNwZWVkc1sgb3B0aW9ucyBdICkge1xuXHRcdGNhbGxiYWNrID0gc3BlZWQ7XG5cdFx0c3BlZWQgPSBvcHRpb25zO1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0fVxuXG5cdC8vIENhdGNoIChlZmZlY3QsIG9wdGlvbnMsIGNhbGxiYWNrKVxuXHRpZiAoICQuaXNGdW5jdGlvbiggc3BlZWQgKSApIHtcblx0XHRjYWxsYmFjayA9IHNwZWVkO1xuXHRcdHNwZWVkID0gbnVsbDtcblx0fVxuXG5cdC8vIEFkZCBvcHRpb25zIHRvIGVmZmVjdFxuXHRpZiAoIG9wdGlvbnMgKSB7XG5cdFx0JC5leHRlbmQoIGVmZmVjdCwgb3B0aW9ucyApO1xuXHR9XG5cblx0c3BlZWQgPSBzcGVlZCB8fCBvcHRpb25zLmR1cmF0aW9uO1xuXHRlZmZlY3QuZHVyYXRpb24gPSAkLmZ4Lm9mZiA/IDAgOlxuXHRcdHR5cGVvZiBzcGVlZCA9PT0gXCJudW1iZXJcIiA/IHNwZWVkIDpcblx0XHRzcGVlZCBpbiAkLmZ4LnNwZWVkcyA/ICQuZnguc3BlZWRzWyBzcGVlZCBdIDpcblx0XHQkLmZ4LnNwZWVkcy5fZGVmYXVsdDtcblxuXHRlZmZlY3QuY29tcGxldGUgPSBjYWxsYmFjayB8fCBvcHRpb25zLmNvbXBsZXRlO1xuXG5cdHJldHVybiBlZmZlY3Q7XG59XG5cbmZ1bmN0aW9uIHN0YW5kYXJkQW5pbWF0aW9uT3B0aW9uKCBvcHRpb24gKSB7XG5cblx0Ly8gVmFsaWQgc3RhbmRhcmQgc3BlZWRzIChub3RoaW5nLCBudW1iZXIsIG5hbWVkIHNwZWVkKVxuXHRpZiAoICFvcHRpb24gfHwgdHlwZW9mIG9wdGlvbiA9PT0gXCJudW1iZXJcIiB8fCAkLmZ4LnNwZWVkc1sgb3B0aW9uIF0gKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnZhbGlkIHN0cmluZ3MgLSB0cmVhdCBhcyBcIm5vcm1hbFwiIHNwZWVkXG5cdGlmICggdHlwZW9mIG9wdGlvbiA9PT0gXCJzdHJpbmdcIiAmJiAhJC5lZmZlY3RzLmVmZmVjdFsgb3B0aW9uIF0gKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBDb21wbGV0ZSBjYWxsYmFja1xuXHRpZiAoICQuaXNGdW5jdGlvbiggb3B0aW9uICkgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBPcHRpb25zIGhhc2ggKGJ1dCBub3QgbmFtaW5nIGFuIGVmZmVjdClcblx0aWYgKCB0eXBlb2Ygb3B0aW9uID09PSBcIm9iamVjdFwiICYmICFvcHRpb24uZWZmZWN0ICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gRGlkbid0IG1hdGNoIGFueSBzdGFuZGFyZCBBUElcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4kLmZuLmV4dGVuZCgge1xuXHRlZmZlY3Q6IGZ1bmN0aW9uKCAvKiBlZmZlY3QsIG9wdGlvbnMsIHNwZWVkLCBjYWxsYmFjayAqLyApIHtcblx0XHR2YXIgYXJncyA9IF9ub3JtYWxpemVBcmd1bWVudHMuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApLFxuXHRcdFx0ZWZmZWN0TWV0aG9kID0gJC5lZmZlY3RzLmVmZmVjdFsgYXJncy5lZmZlY3QgXSxcblx0XHRcdGRlZmF1bHRNb2RlID0gZWZmZWN0TWV0aG9kLm1vZGUsXG5cdFx0XHRxdWV1ZSA9IGFyZ3MucXVldWUsXG5cdFx0XHRxdWV1ZU5hbWUgPSBxdWV1ZSB8fCBcImZ4XCIsXG5cdFx0XHRjb21wbGV0ZSA9IGFyZ3MuY29tcGxldGUsXG5cdFx0XHRtb2RlID0gYXJncy5tb2RlLFxuXHRcdFx0bW9kZXMgPSBbXSxcblx0XHRcdHByZWZpbHRlciA9IGZ1bmN0aW9uKCBuZXh0ICkge1xuXHRcdFx0XHR2YXIgZWwgPSAkKCB0aGlzICksXG5cdFx0XHRcdFx0bm9ybWFsaXplZE1vZGUgPSAkLmVmZmVjdHMubW9kZSggZWwsIG1vZGUgKSB8fCBkZWZhdWx0TW9kZTtcblxuXHRcdFx0XHQvLyBTZW50aW5lbCBmb3IgZHVjay1wdW5jaGluZyB0aGUgOmFuaW1hdGVkIHBzdWVkby1zZWxlY3RvclxuXHRcdFx0XHRlbC5kYXRhKCBkYXRhU3BhY2VBbmltYXRlZCwgdHJ1ZSApO1xuXG5cdFx0XHRcdC8vIFNhdmUgZWZmZWN0IG1vZGUgZm9yIGxhdGVyIHVzZSxcblx0XHRcdFx0Ly8gd2UgY2FuJ3QganVzdCBjYWxsICQuZWZmZWN0cy5tb2RlIGFnYWluIGxhdGVyLFxuXHRcdFx0XHQvLyBhcyB0aGUgLnNob3coKSBiZWxvdyBkZXN0cm95cyB0aGUgaW5pdGlhbCBzdGF0ZVxuXHRcdFx0XHRtb2Rlcy5wdXNoKCBub3JtYWxpemVkTW9kZSApO1xuXG5cdFx0XHRcdC8vIFNlZSAkLnVpQmFja0NvbXBhdCBpbnNpZGUgb2YgcnVuKCkgZm9yIHJlbW92YWwgb2YgZGVmYXVsdE1vZGUgaW4gMS4xM1xuXHRcdFx0XHRpZiAoIGRlZmF1bHRNb2RlICYmICggbm9ybWFsaXplZE1vZGUgPT09IFwic2hvd1wiIHx8XG5cdFx0XHRcdFx0XHQoIG5vcm1hbGl6ZWRNb2RlID09PSBkZWZhdWx0TW9kZSAmJiBub3JtYWxpemVkTW9kZSA9PT0gXCJoaWRlXCIgKSApICkge1xuXHRcdFx0XHRcdGVsLnNob3coKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggIWRlZmF1bHRNb2RlIHx8IG5vcm1hbGl6ZWRNb2RlICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0XHQkLmVmZmVjdHMuc2F2ZVN0eWxlKCBlbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCAkLmlzRnVuY3Rpb24oIG5leHQgKSApIHtcblx0XHRcdFx0XHRuZXh0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoICQuZngub2ZmIHx8ICFlZmZlY3RNZXRob2QgKSB7XG5cblx0XHRcdC8vIERlbGVnYXRlIHRvIHRoZSBvcmlnaW5hbCBtZXRob2QgKGUuZy4sIC5zaG93KCkpIGlmIHBvc3NpYmxlXG5cdFx0XHRpZiAoIG1vZGUgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzWyBtb2RlIF0oIGFyZ3MuZHVyYXRpb24sIGNvbXBsZXRlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlICkge1xuXHRcdFx0XHRcdFx0Y29tcGxldGUuY2FsbCggdGhpcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJ1biggbmV4dCApIHtcblx0XHRcdHZhciBlbGVtID0gJCggdGhpcyApO1xuXG5cdFx0XHRmdW5jdGlvbiBjbGVhbnVwKCkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZURhdGEoIGRhdGFTcGFjZUFuaW1hdGVkICk7XG5cblx0XHRcdFx0JC5lZmZlY3RzLmNsZWFuVXAoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGFyZ3MubW9kZSA9PT0gXCJoaWRlXCIgKSB7XG5cdFx0XHRcdFx0ZWxlbS5oaWRlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkb25lKCk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGRvbmUoKSB7XG5cdFx0XHRcdGlmICggJC5pc0Z1bmN0aW9uKCBjb21wbGV0ZSApICkge1xuXHRcdFx0XHRcdGNvbXBsZXRlLmNhbGwoIGVsZW1bIDAgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCAkLmlzRnVuY3Rpb24oIG5leHQgKSApIHtcblx0XHRcdFx0XHRuZXh0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbW9kZSBvcHRpb24gb24gYSBwZXIgZWxlbWVudCBiYXNpcyxcblx0XHRcdC8vIGFzIHRvZ2dsZSBjYW4gYmUgZWl0aGVyIHNob3cgb3IgaGlkZSBkZXBlbmRpbmcgb24gZWxlbWVudCBzdGF0ZVxuXHRcdFx0YXJncy5tb2RlID0gbW9kZXMuc2hpZnQoKTtcblxuXHRcdFx0aWYgKCAkLnVpQmFja0NvbXBhdCAhPT0gZmFsc2UgJiYgIWRlZmF1bHRNb2RlICkge1xuXHRcdFx0XHRpZiAoIGVsZW0uaXMoIFwiOmhpZGRlblwiICkgPyBtb2RlID09PSBcImhpZGVcIiA6IG1vZGUgPT09IFwic2hvd1wiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FsbCB0aGUgY29yZSBtZXRob2QgdG8gdHJhY2sgXCJvbGRkaXNwbGF5XCIgcHJvcGVybHlcblx0XHRcdFx0XHRlbGVtWyBtb2RlIF0oKTtcblx0XHRcdFx0XHRkb25lKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWZmZWN0TWV0aG9kLmNhbGwoIGVsZW1bIDAgXSwgYXJncywgZG9uZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGFyZ3MubW9kZSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0XHQvLyBDYWxsIHRoZSBjb3JlIG1ldGhvZCB0byB0cmFjayBcIm9sZGRpc3BsYXlcIiBwcm9wZXJseVxuXHRcdFx0XHRcdGVsZW1bIG1vZGUgXSgpO1xuXHRcdFx0XHRcdGRvbmUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlZmZlY3RNZXRob2QuY2FsbCggZWxlbVsgMCBdLCBhcmdzLCBjbGVhbnVwICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSdW4gcHJlZmlsdGVyIG9uIGFsbCBlbGVtZW50cyBmaXJzdCB0byBlbnN1cmUgdGhhdFxuXHRcdC8vIGFueSBzaG93aW5nIG9yIGhpZGluZyBoYXBwZW5zIGJlZm9yZSBwbGFjZWhvbGRlciBjcmVhdGlvbixcblx0XHQvLyB3aGljaCBlbnN1cmVzIHRoYXQgYW55IGxheW91dCBjaGFuZ2VzIGFyZSBjb3JyZWN0bHkgY2FwdHVyZWQuXG5cdFx0cmV0dXJuIHF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIHByZWZpbHRlciApLmVhY2goIHJ1biApIDpcblx0XHRcdHRoaXMucXVldWUoIHF1ZXVlTmFtZSwgcHJlZmlsdGVyICkucXVldWUoIHF1ZXVlTmFtZSwgcnVuICk7XG5cdH0sXG5cblx0c2hvdzogKCBmdW5jdGlvbiggb3JpZyApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIG9wdGlvbiApIHtcblx0XHRcdGlmICggc3RhbmRhcmRBbmltYXRpb25PcHRpb24oIG9wdGlvbiApICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYXJncyA9IF9ub3JtYWxpemVBcmd1bWVudHMuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRhcmdzLm1vZGUgPSBcInNob3dcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWZmZWN0LmNhbGwoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9ICkoICQuZm4uc2hvdyApLFxuXG5cdGhpZGU6ICggZnVuY3Rpb24oIG9yaWcgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBvcHRpb24gKSB7XG5cdFx0XHRpZiAoIHN0YW5kYXJkQW5pbWF0aW9uT3B0aW9uKCBvcHRpb24gKSApIHtcblx0XHRcdFx0cmV0dXJuIG9yaWcuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBfbm9ybWFsaXplQXJndW1lbnRzLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0YXJncy5tb2RlID0gXCJoaWRlXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVmZmVjdC5jYWxsKCB0aGlzLCBhcmdzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApKCAkLmZuLmhpZGUgKSxcblxuXHR0b2dnbGU6ICggZnVuY3Rpb24oIG9yaWcgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBvcHRpb24gKSB7XG5cdFx0XHRpZiAoIHN0YW5kYXJkQW5pbWF0aW9uT3B0aW9uKCBvcHRpb24gKSB8fCB0eXBlb2Ygb3B0aW9uID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0cmV0dXJuIG9yaWcuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBfbm9ybWFsaXplQXJndW1lbnRzLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0YXJncy5tb2RlID0gXCJ0b2dnbGVcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWZmZWN0LmNhbGwoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9ICkoICQuZm4udG9nZ2xlICksXG5cblx0Y3NzVW5pdDogZnVuY3Rpb24oIGtleSApIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLmNzcygga2V5ICksXG5cdFx0XHR2YWwgPSBbXTtcblxuXHRcdCQuZWFjaCggWyBcImVtXCIsIFwicHhcIiwgXCIlXCIsIFwicHRcIiBdLCBmdW5jdGlvbiggaSwgdW5pdCApIHtcblx0XHRcdGlmICggc3R5bGUuaW5kZXhPZiggdW5pdCApID4gMCApIHtcblx0XHRcdFx0dmFsID0gWyBwYXJzZUZsb2F0KCBzdHlsZSApLCB1bml0IF07XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiB2YWw7XG5cdH0sXG5cblx0Y3NzQ2xpcDogZnVuY3Rpb24oIGNsaXBPYmogKSB7XG5cdFx0aWYgKCBjbGlwT2JqICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3NzKCBcImNsaXBcIiwgXCJyZWN0KFwiICsgY2xpcE9iai50b3AgKyBcInB4IFwiICsgY2xpcE9iai5yaWdodCArIFwicHggXCIgK1xuXHRcdFx0XHRjbGlwT2JqLmJvdHRvbSArIFwicHggXCIgKyBjbGlwT2JqLmxlZnQgKyBcInB4KVwiICk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJzZUNsaXAoIHRoaXMuY3NzKCBcImNsaXBcIiApLCB0aGlzICk7XG5cdH0sXG5cblx0dHJhbnNmZXI6IGZ1bmN0aW9uKCBvcHRpb25zLCBkb25lICkge1xuXHRcdHZhciBlbGVtZW50ID0gJCggdGhpcyApLFxuXHRcdFx0dGFyZ2V0ID0gJCggb3B0aW9ucy50byApLFxuXHRcdFx0dGFyZ2V0Rml4ZWQgPSB0YXJnZXQuY3NzKCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiLFxuXHRcdFx0Ym9keSA9ICQoIFwiYm9keVwiICksXG5cdFx0XHRmaXhUb3AgPSB0YXJnZXRGaXhlZCA/IGJvZHkuc2Nyb2xsVG9wKCkgOiAwLFxuXHRcdFx0Zml4TGVmdCA9IHRhcmdldEZpeGVkID8gYm9keS5zY3JvbGxMZWZ0KCkgOiAwLFxuXHRcdFx0ZW5kUG9zaXRpb24gPSB0YXJnZXQub2Zmc2V0KCksXG5cdFx0XHRhbmltYXRpb24gPSB7XG5cdFx0XHRcdHRvcDogZW5kUG9zaXRpb24udG9wIC0gZml4VG9wLFxuXHRcdFx0XHRsZWZ0OiBlbmRQb3NpdGlvbi5sZWZ0IC0gZml4TGVmdCxcblx0XHRcdFx0aGVpZ2h0OiB0YXJnZXQuaW5uZXJIZWlnaHQoKSxcblx0XHRcdFx0d2lkdGg6IHRhcmdldC5pbm5lcldpZHRoKClcblx0XHRcdH0sXG5cdFx0XHRzdGFydFBvc2l0aW9uID0gZWxlbWVudC5vZmZzZXQoKSxcblx0XHRcdHRyYW5zZmVyID0gJCggXCI8ZGl2IGNsYXNzPSd1aS1lZmZlY3RzLXRyYW5zZmVyJz48L2Rpdj5cIiApXG5cdFx0XHRcdC5hcHBlbmRUbyggXCJib2R5XCIgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIG9wdGlvbnMuY2xhc3NOYW1lIClcblx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdHRvcDogc3RhcnRQb3NpdGlvbi50b3AgLSBmaXhUb3AsXG5cdFx0XHRcdFx0bGVmdDogc3RhcnRQb3NpdGlvbi5sZWZ0IC0gZml4TGVmdCxcblx0XHRcdFx0XHRoZWlnaHQ6IGVsZW1lbnQuaW5uZXJIZWlnaHQoKSxcblx0XHRcdFx0XHR3aWR0aDogZWxlbWVudC5pbm5lcldpZHRoKCksXG5cdFx0XHRcdFx0cG9zaXRpb246IHRhcmdldEZpeGVkID8gXCJmaXhlZFwiIDogXCJhYnNvbHV0ZVwiXG5cdFx0XHRcdH0gKVxuXHRcdFx0XHQuYW5pbWF0ZSggYW5pbWF0aW9uLCBvcHRpb25zLmR1cmF0aW9uLCBvcHRpb25zLmVhc2luZywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dHJhbnNmZXIucmVtb3ZlKCk7XG5cdFx0XHRcdFx0aWYgKCAkLmlzRnVuY3Rpb24oIGRvbmUgKSApIHtcblx0XHRcdFx0XHRcdGRvbmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBwYXJzZUNsaXAoIHN0ciwgZWxlbWVudCApIHtcblx0XHR2YXIgb3V0ZXJXaWR0aCA9IGVsZW1lbnQub3V0ZXJXaWR0aCgpLFxuXHRcdFx0b3V0ZXJIZWlnaHQgPSBlbGVtZW50Lm91dGVySGVpZ2h0KCksXG5cdFx0XHRjbGlwUmVnZXggPSAvXnJlY3RcXCgoLT9cXGQqXFwuP1xcZCpweHwtP1xcZCslfGF1dG8pLD9cXHMqKC0/XFxkKlxcLj9cXGQqcHh8LT9cXGQrJXxhdXRvKSw/XFxzKigtP1xcZCpcXC4/XFxkKnB4fC0/XFxkKyV8YXV0byksP1xccyooLT9cXGQqXFwuP1xcZCpweHwtP1xcZCslfGF1dG8pXFwpJC8sXG5cdFx0XHR2YWx1ZXMgPSBjbGlwUmVnZXguZXhlYyggc3RyICkgfHwgWyBcIlwiLCAwLCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCwgMCBdO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcGFyc2VGbG9hdCggdmFsdWVzWyAxIF0gKSB8fCAwLFxuXHRcdFx0cmlnaHQ6IHZhbHVlc1sgMiBdID09PSBcImF1dG9cIiA/IG91dGVyV2lkdGggOiBwYXJzZUZsb2F0KCB2YWx1ZXNbIDIgXSApLFxuXHRcdFx0Ym90dG9tOiB2YWx1ZXNbIDMgXSA9PT0gXCJhdXRvXCIgPyBvdXRlckhlaWdodCA6IHBhcnNlRmxvYXQoIHZhbHVlc1sgMyBdICksXG5cdFx0XHRsZWZ0OiBwYXJzZUZsb2F0KCB2YWx1ZXNbIDQgXSApIHx8IDBcblx0XHR9O1xufVxuXG4kLmZ4LnN0ZXAuY2xpcCA9IGZ1bmN0aW9uKCBmeCApIHtcblx0aWYgKCAhZnguY2xpcEluaXQgKSB7XG5cdFx0Znguc3RhcnQgPSAkKCBmeC5lbGVtICkuY3NzQ2xpcCgpO1xuXHRcdGlmICggdHlwZW9mIGZ4LmVuZCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ4LmVuZCA9IHBhcnNlQ2xpcCggZnguZW5kLCBmeC5lbGVtICk7XG5cdFx0fVxuXHRcdGZ4LmNsaXBJbml0ID0gdHJ1ZTtcblx0fVxuXG5cdCQoIGZ4LmVsZW0gKS5jc3NDbGlwKCB7XG5cdFx0dG9wOiBmeC5wb3MgKiAoIGZ4LmVuZC50b3AgLSBmeC5zdGFydC50b3AgKSArIGZ4LnN0YXJ0LnRvcCxcblx0XHRyaWdodDogZngucG9zICogKCBmeC5lbmQucmlnaHQgLSBmeC5zdGFydC5yaWdodCApICsgZnguc3RhcnQucmlnaHQsXG5cdFx0Ym90dG9tOiBmeC5wb3MgKiAoIGZ4LmVuZC5ib3R0b20gLSBmeC5zdGFydC5ib3R0b20gKSArIGZ4LnN0YXJ0LmJvdHRvbSxcblx0XHRsZWZ0OiBmeC5wb3MgKiAoIGZ4LmVuZC5sZWZ0IC0gZnguc3RhcnQubGVmdCApICsgZnguc3RhcnQubGVmdFxuXHR9ICk7XG59O1xuXG59ICkoKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFQVNJTkcgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4oIGZ1bmN0aW9uKCkge1xuXG4vLyBCYXNlZCBvbiBlYXNpbmcgZXF1YXRpb25zIGZyb20gUm9iZXJ0IFBlbm5lciAoaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2luZylcblxudmFyIGJhc2VFYXNpbmdzID0ge307XG5cbiQuZWFjaCggWyBcIlF1YWRcIiwgXCJDdWJpY1wiLCBcIlF1YXJ0XCIsIFwiUXVpbnRcIiwgXCJFeHBvXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGJhc2VFYXNpbmdzWyBuYW1lIF0gPSBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coIHAsIGkgKyAyICk7XG5cdH07XG59ICk7XG5cbiQuZXh0ZW5kKCBiYXNlRWFzaW5ncywge1xuXHRTaW5lOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMSAtIE1hdGguY29zKCBwICogTWF0aC5QSSAvIDIgKTtcblx0fSxcblx0Q2lyYzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDEgLSBNYXRoLnNxcnQoIDEgLSBwICogcCApO1xuXHR9LFxuXHRFbGFzdGljOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcCA9PT0gMCB8fCBwID09PSAxID8gcCA6XG5cdFx0XHQtTWF0aC5wb3coIDIsIDggKiAoIHAgLSAxICkgKSAqIE1hdGguc2luKCAoICggcCAtIDEgKSAqIDgwIC0gNy41ICkgKiBNYXRoLlBJIC8gMTUgKTtcblx0fSxcblx0QmFjazogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHAgKiBwICogKCAzICogcCAtIDIgKTtcblx0fSxcblx0Qm91bmNlOiBmdW5jdGlvbiggcCApIHtcblx0XHR2YXIgcG93Mixcblx0XHRcdGJvdW5jZSA9IDQ7XG5cblx0XHR3aGlsZSAoIHAgPCAoICggcG93MiA9IE1hdGgucG93KCAyLCAtLWJvdW5jZSApICkgLSAxICkgLyAxMSApIHt9XG5cdFx0cmV0dXJuIDEgLyBNYXRoLnBvdyggNCwgMyAtIGJvdW5jZSApIC0gNy41NjI1ICogTWF0aC5wb3coICggcG93MiAqIDMgLSAyICkgLyAyMiAtIHAsIDIgKTtcblx0fVxufSApO1xuXG4kLmVhY2goIGJhc2VFYXNpbmdzLCBmdW5jdGlvbiggbmFtZSwgZWFzZUluICkge1xuXHQkLmVhc2luZ1sgXCJlYXNlSW5cIiArIG5hbWUgXSA9IGVhc2VJbjtcblx0JC5lYXNpbmdbIFwiZWFzZU91dFwiICsgbmFtZSBdID0gZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDEgLSBlYXNlSW4oIDEgLSBwICk7XG5cdH07XG5cdCQuZWFzaW5nWyBcImVhc2VJbk91dFwiICsgbmFtZSBdID0gZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHAgPCAwLjUgP1xuXHRcdFx0ZWFzZUluKCBwICogMiApIC8gMiA6XG5cdFx0XHQxIC0gZWFzZUluKCBwICogLTIgKyAyICkgLyAyO1xuXHR9O1xufSApO1xuXG59ICkoKTtcblxudmFyIGVmZmVjdCA9ICQuZWZmZWN0cztcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSBFZmZlY3RzIEJsaW5kIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBCbGluZCBFZmZlY3Rcbi8vPj5ncm91cDogRWZmZWN0c1xuLy8+PmRlc2NyaXB0aW9uOiBCbGluZHMgdGhlIGVsZW1lbnQuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vYmxpbmQtZWZmZWN0L1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2VmZmVjdC9cblxuXG5cbnZhciBlZmZlY3RzRWZmZWN0QmxpbmQgPSAkLmVmZmVjdHMuZGVmaW5lKCBcImJsaW5kXCIsIFwiaGlkZVwiLCBmdW5jdGlvbiggb3B0aW9ucywgZG9uZSApIHtcblx0dmFyIG1hcCA9IHtcblx0XHRcdHVwOiBbIFwiYm90dG9tXCIsIFwidG9wXCIgXSxcblx0XHRcdHZlcnRpY2FsOiBbIFwiYm90dG9tXCIsIFwidG9wXCIgXSxcblx0XHRcdGRvd246IFsgXCJ0b3BcIiwgXCJib3R0b21cIiBdLFxuXHRcdFx0bGVmdDogWyBcInJpZ2h0XCIsIFwibGVmdFwiIF0sXG5cdFx0XHRob3Jpem9udGFsOiBbIFwicmlnaHRcIiwgXCJsZWZ0XCIgXSxcblx0XHRcdHJpZ2h0OiBbIFwibGVmdFwiLCBcInJpZ2h0XCIgXVxuXHRcdH0sXG5cdFx0ZWxlbWVudCA9ICQoIHRoaXMgKSxcblx0XHRkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbiB8fCBcInVwXCIsXG5cdFx0c3RhcnQgPSBlbGVtZW50LmNzc0NsaXAoKSxcblx0XHRhbmltYXRlID0geyBjbGlwOiAkLmV4dGVuZCgge30sIHN0YXJ0ICkgfSxcblx0XHRwbGFjZWhvbGRlciA9ICQuZWZmZWN0cy5jcmVhdGVQbGFjZWhvbGRlciggZWxlbWVudCApO1xuXG5cdGFuaW1hdGUuY2xpcFsgbWFwWyBkaXJlY3Rpb24gXVsgMCBdIF0gPSBhbmltYXRlLmNsaXBbIG1hcFsgZGlyZWN0aW9uIF1bIDEgXSBdO1xuXG5cdGlmICggb3B0aW9ucy5tb2RlID09PSBcInNob3dcIiApIHtcblx0XHRlbGVtZW50LmNzc0NsaXAoIGFuaW1hdGUuY2xpcCApO1xuXHRcdGlmICggcGxhY2Vob2xkZXIgKSB7XG5cdFx0XHRwbGFjZWhvbGRlci5jc3MoICQuZWZmZWN0cy5jbGlwVG9Cb3goIGFuaW1hdGUgKSApO1xuXHRcdH1cblxuXHRcdGFuaW1hdGUuY2xpcCA9IHN0YXJ0O1xuXHR9XG5cblx0aWYgKCBwbGFjZWhvbGRlciApIHtcblx0XHRwbGFjZWhvbGRlci5hbmltYXRlKCAkLmVmZmVjdHMuY2xpcFRvQm94KCBhbmltYXRlICksIG9wdGlvbnMuZHVyYXRpb24sIG9wdGlvbnMuZWFzaW5nICk7XG5cdH1cblxuXHRlbGVtZW50LmFuaW1hdGUoIGFuaW1hdGUsIHtcblx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0ZWFzaW5nOiBvcHRpb25zLmVhc2luZyxcblx0XHRjb21wbGV0ZTogZG9uZVxuXHR9ICk7XG59ICk7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgRWZmZWN0cyBCb3VuY2UgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IEJvdW5jZSBFZmZlY3Rcbi8vPj5ncm91cDogRWZmZWN0c1xuLy8+PmRlc2NyaXB0aW9uOiBCb3VuY2VzIGFuIGVsZW1lbnQgaG9yaXpvbnRhbGx5IG9yIHZlcnRpY2FsbHkgbiB0aW1lcy5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9ib3VuY2UtZWZmZWN0L1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2VmZmVjdC9cblxuXG5cbnZhciBlZmZlY3RzRWZmZWN0Qm91bmNlID0gJC5lZmZlY3RzLmRlZmluZSggXCJib3VuY2VcIiwgZnVuY3Rpb24oIG9wdGlvbnMsIGRvbmUgKSB7XG5cdHZhciB1cEFuaW0sIGRvd25BbmltLCByZWZWYWx1ZSxcblx0XHRlbGVtZW50ID0gJCggdGhpcyApLFxuXG5cdFx0Ly8gRGVmYXVsdHM6XG5cdFx0bW9kZSA9IG9wdGlvbnMubW9kZSxcblx0XHRoaWRlID0gbW9kZSA9PT0gXCJoaWRlXCIsXG5cdFx0c2hvdyA9IG1vZGUgPT09IFwic2hvd1wiLFxuXHRcdGRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uIHx8IFwidXBcIixcblx0XHRkaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2UsXG5cdFx0dGltZXMgPSBvcHRpb25zLnRpbWVzIHx8IDUsXG5cblx0XHQvLyBOdW1iZXIgb2YgaW50ZXJuYWwgYW5pbWF0aW9uc1xuXHRcdGFuaW1zID0gdGltZXMgKiAyICsgKCBzaG93IHx8IGhpZGUgPyAxIDogMCApLFxuXHRcdHNwZWVkID0gb3B0aW9ucy5kdXJhdGlvbiAvIGFuaW1zLFxuXHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nLFxuXG5cdFx0Ly8gVXRpbGl0eTpcblx0XHRyZWYgPSAoIGRpcmVjdGlvbiA9PT0gXCJ1cFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJkb3duXCIgKSA/IFwidG9wXCIgOiBcImxlZnRcIixcblx0XHRtb3Rpb24gPSAoIGRpcmVjdGlvbiA9PT0gXCJ1cFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgKSxcblx0XHRpID0gMCxcblxuXHRcdHF1ZXVlbGVuID0gZWxlbWVudC5xdWV1ZSgpLmxlbmd0aDtcblxuXHQkLmVmZmVjdHMuY3JlYXRlUGxhY2Vob2xkZXIoIGVsZW1lbnQgKTtcblxuXHRyZWZWYWx1ZSA9IGVsZW1lbnQuY3NzKCByZWYgKTtcblxuXHQvLyBEZWZhdWx0IGRpc3RhbmNlIGZvciB0aGUgQklHR0VTVCBib3VuY2UgaXMgdGhlIG91dGVyIERpc3RhbmNlIC8gM1xuXHRpZiAoICFkaXN0YW5jZSApIHtcblx0XHRkaXN0YW5jZSA9IGVsZW1lbnRbIHJlZiA9PT0gXCJ0b3BcIiA/IFwib3V0ZXJIZWlnaHRcIiA6IFwib3V0ZXJXaWR0aFwiIF0oKSAvIDM7XG5cdH1cblxuXHRpZiAoIHNob3cgKSB7XG5cdFx0ZG93bkFuaW0gPSB7IG9wYWNpdHk6IDEgfTtcblx0XHRkb3duQW5pbVsgcmVmIF0gPSByZWZWYWx1ZTtcblxuXHRcdC8vIElmIHdlIGFyZSBzaG93aW5nLCBmb3JjZSBvcGFjaXR5IDAgYW5kIHNldCB0aGUgaW5pdGlhbCBwb3NpdGlvblxuXHRcdC8vIHRoZW4gZG8gdGhlIFwiZmlyc3RcIiBhbmltYXRpb25cblx0XHRlbGVtZW50XG5cdFx0XHQuY3NzKCBcIm9wYWNpdHlcIiwgMCApXG5cdFx0XHQuY3NzKCByZWYsIG1vdGlvbiA/IC1kaXN0YW5jZSAqIDIgOiBkaXN0YW5jZSAqIDIgKVxuXHRcdFx0LmFuaW1hdGUoIGRvd25BbmltLCBzcGVlZCwgZWFzaW5nICk7XG5cdH1cblxuXHQvLyBTdGFydCBhdCB0aGUgc21hbGxlc3QgZGlzdGFuY2UgaWYgd2UgYXJlIGhpZGluZ1xuXHRpZiAoIGhpZGUgKSB7XG5cdFx0ZGlzdGFuY2UgPSBkaXN0YW5jZSAvIE1hdGgucG93KCAyLCB0aW1lcyAtIDEgKTtcblx0fVxuXG5cdGRvd25BbmltID0ge307XG5cdGRvd25BbmltWyByZWYgXSA9IHJlZlZhbHVlO1xuXG5cdC8vIEJvdW5jZXMgdXAvZG93bi9sZWZ0L3JpZ2h0IHRoZW4gYmFjayB0byAwIC0tIHRpbWVzICogMiBhbmltYXRpb25zIGhhcHBlbiBoZXJlXG5cdGZvciAoIDsgaSA8IHRpbWVzOyBpKysgKSB7XG5cdFx0dXBBbmltID0ge307XG5cdFx0dXBBbmltWyByZWYgXSA9ICggbW90aW9uID8gXCItPVwiIDogXCIrPVwiICkgKyBkaXN0YW5jZTtcblxuXHRcdGVsZW1lbnRcblx0XHRcdC5hbmltYXRlKCB1cEFuaW0sIHNwZWVkLCBlYXNpbmcgKVxuXHRcdFx0LmFuaW1hdGUoIGRvd25BbmltLCBzcGVlZCwgZWFzaW5nICk7XG5cblx0XHRkaXN0YW5jZSA9IGhpZGUgPyBkaXN0YW5jZSAqIDIgOiBkaXN0YW5jZSAvIDI7XG5cdH1cblxuXHQvLyBMYXN0IEJvdW5jZSB3aGVuIEhpZGluZ1xuXHRpZiAoIGhpZGUgKSB7XG5cdFx0dXBBbmltID0geyBvcGFjaXR5OiAwIH07XG5cdFx0dXBBbmltWyByZWYgXSA9ICggbW90aW9uID8gXCItPVwiIDogXCIrPVwiICkgKyBkaXN0YW5jZTtcblxuXHRcdGVsZW1lbnQuYW5pbWF0ZSggdXBBbmltLCBzcGVlZCwgZWFzaW5nICk7XG5cdH1cblxuXHRlbGVtZW50LnF1ZXVlKCBkb25lICk7XG5cblx0JC5lZmZlY3RzLnVuc2hpZnQoIGVsZW1lbnQsIHF1ZXVlbGVuLCBhbmltcyArIDEgKTtcbn0gKTtcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSBFZmZlY3RzIENsaXAgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IENsaXAgRWZmZWN0XG4vLz4+Z3JvdXA6IEVmZmVjdHNcbi8vPj5kZXNjcmlwdGlvbjogQ2xpcHMgdGhlIGVsZW1lbnQgb24gYW5kIG9mZiBsaWtlIGFuIG9sZCBUVi5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9jbGlwLWVmZmVjdC9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9lZmZlY3QvXG5cblxuXG52YXIgZWZmZWN0c0VmZmVjdENsaXAgPSAkLmVmZmVjdHMuZGVmaW5lKCBcImNsaXBcIiwgXCJoaWRlXCIsIGZ1bmN0aW9uKCBvcHRpb25zLCBkb25lICkge1xuXHR2YXIgc3RhcnQsXG5cdFx0YW5pbWF0ZSA9IHt9LFxuXHRcdGVsZW1lbnQgPSAkKCB0aGlzICksXG5cdFx0ZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24gfHwgXCJ2ZXJ0aWNhbFwiLFxuXHRcdGJvdGggPSBkaXJlY3Rpb24gPT09IFwiYm90aFwiLFxuXHRcdGhvcml6b250YWwgPSBib3RoIHx8IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCIsXG5cdFx0dmVydGljYWwgPSBib3RoIHx8IGRpcmVjdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiO1xuXG5cdHN0YXJ0ID0gZWxlbWVudC5jc3NDbGlwKCk7XG5cdGFuaW1hdGUuY2xpcCA9IHtcblx0XHR0b3A6IHZlcnRpY2FsID8gKCBzdGFydC5ib3R0b20gLSBzdGFydC50b3AgKSAvIDIgOiBzdGFydC50b3AsXG5cdFx0cmlnaHQ6IGhvcml6b250YWwgPyAoIHN0YXJ0LnJpZ2h0IC0gc3RhcnQubGVmdCApIC8gMiA6IHN0YXJ0LnJpZ2h0LFxuXHRcdGJvdHRvbTogdmVydGljYWwgPyAoIHN0YXJ0LmJvdHRvbSAtIHN0YXJ0LnRvcCApIC8gMiA6IHN0YXJ0LmJvdHRvbSxcblx0XHRsZWZ0OiBob3Jpem9udGFsID8gKCBzdGFydC5yaWdodCAtIHN0YXJ0LmxlZnQgKSAvIDIgOiBzdGFydC5sZWZ0XG5cdH07XG5cblx0JC5lZmZlY3RzLmNyZWF0ZVBsYWNlaG9sZGVyKCBlbGVtZW50ICk7XG5cblx0aWYgKCBvcHRpb25zLm1vZGUgPT09IFwic2hvd1wiICkge1xuXHRcdGVsZW1lbnQuY3NzQ2xpcCggYW5pbWF0ZS5jbGlwICk7XG5cdFx0YW5pbWF0ZS5jbGlwID0gc3RhcnQ7XG5cdH1cblxuXHRlbGVtZW50LmFuaW1hdGUoIGFuaW1hdGUsIHtcblx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0ZWFzaW5nOiBvcHRpb25zLmVhc2luZyxcblx0XHRjb21wbGV0ZTogZG9uZVxuXHR9ICk7XG5cbn0gKTtcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSBFZmZlY3RzIERyb3AgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IERyb3AgRWZmZWN0XG4vLz4+Z3JvdXA6IEVmZmVjdHNcbi8vPj5kZXNjcmlwdGlvbjogTW92ZXMgYW4gZWxlbWVudCBpbiBvbmUgZGlyZWN0aW9uIGFuZCBoaWRlcyBpdCBhdCB0aGUgc2FtZSB0aW1lLlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2Ryb3AtZWZmZWN0L1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2VmZmVjdC9cblxuXG5cbnZhciBlZmZlY3RzRWZmZWN0RHJvcCA9ICQuZWZmZWN0cy5kZWZpbmUoIFwiZHJvcFwiLCBcImhpZGVcIiwgZnVuY3Rpb24oIG9wdGlvbnMsIGRvbmUgKSB7XG5cblx0dmFyIGRpc3RhbmNlLFxuXHRcdGVsZW1lbnQgPSAkKCB0aGlzICksXG5cdFx0bW9kZSA9IG9wdGlvbnMubW9kZSxcblx0XHRzaG93ID0gbW9kZSA9PT0gXCJzaG93XCIsXG5cdFx0ZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24gfHwgXCJsZWZ0XCIsXG5cdFx0cmVmID0gKCBkaXJlY3Rpb24gPT09IFwidXBcIiB8fCBkaXJlY3Rpb24gPT09IFwiZG93blwiICkgPyBcInRvcFwiIDogXCJsZWZ0XCIsXG5cdFx0bW90aW9uID0gKCBkaXJlY3Rpb24gPT09IFwidXBcIiB8fCBkaXJlY3Rpb24gPT09IFwibGVmdFwiICkgPyBcIi09XCIgOiBcIis9XCIsXG5cdFx0b3Bwb3NpdGVNb3Rpb24gPSAoIG1vdGlvbiA9PT0gXCIrPVwiICkgPyBcIi09XCIgOiBcIis9XCIsXG5cdFx0YW5pbWF0aW9uID0ge1xuXHRcdFx0b3BhY2l0eTogMFxuXHRcdH07XG5cblx0JC5lZmZlY3RzLmNyZWF0ZVBsYWNlaG9sZGVyKCBlbGVtZW50ICk7XG5cblx0ZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlIHx8XG5cdFx0ZWxlbWVudFsgcmVmID09PSBcInRvcFwiID8gXCJvdXRlckhlaWdodFwiIDogXCJvdXRlcldpZHRoXCIgXSggdHJ1ZSApIC8gMjtcblxuXHRhbmltYXRpb25bIHJlZiBdID0gbW90aW9uICsgZGlzdGFuY2U7XG5cblx0aWYgKCBzaG93ICkge1xuXHRcdGVsZW1lbnQuY3NzKCBhbmltYXRpb24gKTtcblxuXHRcdGFuaW1hdGlvblsgcmVmIF0gPSBvcHBvc2l0ZU1vdGlvbiArIGRpc3RhbmNlO1xuXHRcdGFuaW1hdGlvbi5vcGFjaXR5ID0gMTtcblx0fVxuXG5cdC8vIEFuaW1hdGVcblx0ZWxlbWVudC5hbmltYXRlKCBhbmltYXRpb24sIHtcblx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0ZWFzaW5nOiBvcHRpb25zLmVhc2luZyxcblx0XHRjb21wbGV0ZTogZG9uZVxuXHR9ICk7XG59ICk7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgRWZmZWN0cyBFeHBsb2RlIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBFeHBsb2RlIEVmZmVjdFxuLy8+Pmdyb3VwOiBFZmZlY3RzXG4vLyBqc2NzOmRpc2FibGUgbWF4aW11bUxpbmVMZW5ndGhcbi8vPj5kZXNjcmlwdGlvbjogRXhwbG9kZXMgYW4gZWxlbWVudCBpbiBhbGwgZGlyZWN0aW9ucyBpbnRvIG4gcGllY2VzLiBJbXBsb2RlcyBhbiBlbGVtZW50IHRvIGl0cyBvcmlnaW5hbCB3aG9sZW5lc3MuXG4vLyBqc2NzOmVuYWJsZSBtYXhpbXVtTGluZUxlbmd0aFxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2V4cGxvZGUtZWZmZWN0L1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2VmZmVjdC9cblxuXG5cbnZhciBlZmZlY3RzRWZmZWN0RXhwbG9kZSA9ICQuZWZmZWN0cy5kZWZpbmUoIFwiZXhwbG9kZVwiLCBcImhpZGVcIiwgZnVuY3Rpb24oIG9wdGlvbnMsIGRvbmUgKSB7XG5cblx0dmFyIGksIGosIGxlZnQsIHRvcCwgbXgsIG15LFxuXHRcdHJvd3MgPSBvcHRpb25zLnBpZWNlcyA/IE1hdGgucm91bmQoIE1hdGguc3FydCggb3B0aW9ucy5waWVjZXMgKSApIDogMyxcblx0XHRjZWxscyA9IHJvd3MsXG5cdFx0ZWxlbWVudCA9ICQoIHRoaXMgKSxcblx0XHRtb2RlID0gb3B0aW9ucy5tb2RlLFxuXHRcdHNob3cgPSBtb2RlID09PSBcInNob3dcIixcblxuXHRcdC8vIFNob3cgYW5kIHRoZW4gdmlzaWJpbGl0eTpoaWRkZW4gdGhlIGVsZW1lbnQgYmVmb3JlIGNhbGN1bGF0aW5nIG9mZnNldFxuXHRcdG9mZnNldCA9IGVsZW1lbnQuc2hvdygpLmNzcyggXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIgKS5vZmZzZXQoKSxcblxuXHRcdC8vIFdpZHRoIGFuZCBoZWlnaHQgb2YgYSBwaWVjZVxuXHRcdHdpZHRoID0gTWF0aC5jZWlsKCBlbGVtZW50Lm91dGVyV2lkdGgoKSAvIGNlbGxzICksXG5cdFx0aGVpZ2h0ID0gTWF0aC5jZWlsKCBlbGVtZW50Lm91dGVySGVpZ2h0KCkgLyByb3dzICksXG5cdFx0cGllY2VzID0gW107XG5cblx0Ly8gQ2hpbGRyZW4gYW5pbWF0ZSBjb21wbGV0ZTpcblx0ZnVuY3Rpb24gY2hpbGRDb21wbGV0ZSgpIHtcblx0XHRwaWVjZXMucHVzaCggdGhpcyApO1xuXHRcdGlmICggcGllY2VzLmxlbmd0aCA9PT0gcm93cyAqIGNlbGxzICkge1xuXHRcdFx0YW5pbUNvbXBsZXRlKCk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xvbmUgdGhlIGVsZW1lbnQgZm9yIGVhY2ggcm93IGFuZCBjZWxsLlxuXHRmb3IgKCBpID0gMDsgaSA8IHJvd3M7IGkrKyApIHsgLy8gPT09PlxuXHRcdHRvcCA9IG9mZnNldC50b3AgKyBpICogaGVpZ2h0O1xuXHRcdG15ID0gaSAtICggcm93cyAtIDEgKSAvIDI7XG5cblx0XHRmb3IgKCBqID0gMDsgaiA8IGNlbGxzOyBqKysgKSB7IC8vIHx8fFxuXHRcdFx0bGVmdCA9IG9mZnNldC5sZWZ0ICsgaiAqIHdpZHRoO1xuXHRcdFx0bXggPSBqIC0gKCBjZWxscyAtIDEgKSAvIDI7XG5cblx0XHRcdC8vIENyZWF0ZSBhIGNsb25lIG9mIHRoZSBub3cgaGlkZGVuIG1haW4gZWxlbWVudCB0aGF0IHdpbGwgYmUgYWJzb2x1dGUgcG9zaXRpb25lZFxuXHRcdFx0Ly8gd2l0aGluIGEgd3JhcHBlciBkaXYgb2ZmIHRoZSAtbGVmdCBhbmQgLXRvcCBlcXVhbCB0byBzaXplIG9mIG91ciBwaWVjZXNcblx0XHRcdGVsZW1lbnRcblx0XHRcdFx0LmNsb25lKClcblx0XHRcdFx0LmFwcGVuZFRvKCBcImJvZHlcIiApXG5cdFx0XHRcdC53cmFwKCBcIjxkaXY+PC9kaXY+XCIgKVxuXHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0cG9zaXRpb246IFwiYWJzb2x1dGVcIixcblx0XHRcdFx0XHR2aXNpYmlsaXR5OiBcInZpc2libGVcIixcblx0XHRcdFx0XHRsZWZ0OiAtaiAqIHdpZHRoLFxuXHRcdFx0XHRcdHRvcDogLWkgKiBoZWlnaHRcblx0XHRcdFx0fSApXG5cblx0XHRcdFx0Ly8gU2VsZWN0IHRoZSB3cmFwcGVyIC0gbWFrZSBpdCBvdmVyZmxvdzogaGlkZGVuIGFuZCBhYnNvbHV0ZSBwb3NpdGlvbmVkIGJhc2VkIG9uXG5cdFx0XHRcdC8vIHdoZXJlIHRoZSBvcmlnaW5hbCB3YXMgbG9jYXRlZCArbGVmdCBhbmQgK3RvcCBlcXVhbCB0byB0aGUgc2l6ZSBvZiBwaWVjZXNcblx0XHRcdFx0LnBhcmVudCgpXG5cdFx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWVmZmVjdHMtZXhwbG9kZVwiIClcblx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuXHRcdFx0XHRcdFx0b3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG5cdFx0XHRcdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdFx0XHRcdGxlZnQ6IGxlZnQgKyAoIHNob3cgPyBteCAqIHdpZHRoIDogMCApLFxuXHRcdFx0XHRcdFx0dG9wOiB0b3AgKyAoIHNob3cgPyBteSAqIGhlaWdodCA6IDAgKSxcblx0XHRcdFx0XHRcdG9wYWNpdHk6IHNob3cgPyAwIDogMVxuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdC5hbmltYXRlKCB7XG5cdFx0XHRcdFx0XHRsZWZ0OiBsZWZ0ICsgKCBzaG93ID8gMCA6IG14ICogd2lkdGggKSxcblx0XHRcdFx0XHRcdHRvcDogdG9wICsgKCBzaG93ID8gMCA6IG15ICogaGVpZ2h0ICksXG5cdFx0XHRcdFx0XHRvcGFjaXR5OiBzaG93ID8gMSA6IDBcblx0XHRcdFx0XHR9LCBvcHRpb25zLmR1cmF0aW9uIHx8IDUwMCwgb3B0aW9ucy5lYXNpbmcsIGNoaWxkQ29tcGxldGUgKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhbmltQ29tcGxldGUoKSB7XG5cdFx0ZWxlbWVudC5jc3MoIHtcblx0XHRcdHZpc2liaWxpdHk6IFwidmlzaWJsZVwiXG5cdFx0fSApO1xuXHRcdCQoIHBpZWNlcyApLnJlbW92ZSgpO1xuXHRcdGRvbmUoKTtcblx0fVxufSApO1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIEVmZmVjdHMgRmFkZSAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogRmFkZSBFZmZlY3Rcbi8vPj5ncm91cDogRWZmZWN0c1xuLy8+PmRlc2NyaXB0aW9uOiBGYWRlcyB0aGUgZWxlbWVudC5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9mYWRlLWVmZmVjdC9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9lZmZlY3QvXG5cblxuXG52YXIgZWZmZWN0c0VmZmVjdEZhZGUgPSAkLmVmZmVjdHMuZGVmaW5lKCBcImZhZGVcIiwgXCJ0b2dnbGVcIiwgZnVuY3Rpb24oIG9wdGlvbnMsIGRvbmUgKSB7XG5cdHZhciBzaG93ID0gb3B0aW9ucy5tb2RlID09PSBcInNob3dcIjtcblxuXHQkKCB0aGlzIClcblx0XHQuY3NzKCBcIm9wYWNpdHlcIiwgc2hvdyA/IDAgOiAxIClcblx0XHQuYW5pbWF0ZSgge1xuXHRcdFx0b3BhY2l0eTogc2hvdyA/IDEgOiAwXG5cdFx0fSwge1xuXHRcdFx0cXVldWU6IGZhbHNlLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHRlYXNpbmc6IG9wdGlvbnMuZWFzaW5nLFxuXHRcdFx0Y29tcGxldGU6IGRvbmVcblx0XHR9ICk7XG59ICk7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgRWZmZWN0cyBGb2xkIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBGb2xkIEVmZmVjdFxuLy8+Pmdyb3VwOiBFZmZlY3RzXG4vLz4+ZGVzY3JpcHRpb246IEZvbGRzIGFuIGVsZW1lbnQgZmlyc3QgaG9yaXpvbnRhbGx5IGFuZCB0aGVuIHZlcnRpY2FsbHkuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vZm9sZC1lZmZlY3QvXG4vLz4+ZGVtb3M6IGh0dHA6Ly9qcXVlcnl1aS5jb20vZWZmZWN0L1xuXG5cblxudmFyIGVmZmVjdHNFZmZlY3RGb2xkID0gJC5lZmZlY3RzLmRlZmluZSggXCJmb2xkXCIsIFwiaGlkZVwiLCBmdW5jdGlvbiggb3B0aW9ucywgZG9uZSApIHtcblxuXHQvLyBDcmVhdGUgZWxlbWVudFxuXHR2YXIgZWxlbWVudCA9ICQoIHRoaXMgKSxcblx0XHRtb2RlID0gb3B0aW9ucy5tb2RlLFxuXHRcdHNob3cgPSBtb2RlID09PSBcInNob3dcIixcblx0XHRoaWRlID0gbW9kZSA9PT0gXCJoaWRlXCIsXG5cdFx0c2l6ZSA9IG9wdGlvbnMuc2l6ZSB8fCAxNSxcblx0XHRwZXJjZW50ID0gLyhbMC05XSspJS8uZXhlYyggc2l6ZSApLFxuXHRcdGhvcml6Rmlyc3QgPSAhIW9wdGlvbnMuaG9yaXpGaXJzdCxcblx0XHRyZWYgPSBob3JpekZpcnN0ID8gWyBcInJpZ2h0XCIsIFwiYm90dG9tXCIgXSA6IFsgXCJib3R0b21cIiwgXCJyaWdodFwiIF0sXG5cdFx0ZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIC8gMixcblxuXHRcdHBsYWNlaG9sZGVyID0gJC5lZmZlY3RzLmNyZWF0ZVBsYWNlaG9sZGVyKCBlbGVtZW50ICksXG5cblx0XHRzdGFydCA9IGVsZW1lbnQuY3NzQ2xpcCgpLFxuXHRcdGFuaW1hdGlvbjEgPSB7IGNsaXA6ICQuZXh0ZW5kKCB7fSwgc3RhcnQgKSB9LFxuXHRcdGFuaW1hdGlvbjIgPSB7IGNsaXA6ICQuZXh0ZW5kKCB7fSwgc3RhcnQgKSB9LFxuXG5cdFx0ZGlzdGFuY2UgPSBbIHN0YXJ0WyByZWZbIDAgXSBdLCBzdGFydFsgcmVmWyAxIF0gXSBdLFxuXG5cdFx0cXVldWVsZW4gPSBlbGVtZW50LnF1ZXVlKCkubGVuZ3RoO1xuXG5cdGlmICggcGVyY2VudCApIHtcblx0XHRzaXplID0gcGFyc2VJbnQoIHBlcmNlbnRbIDEgXSwgMTAgKSAvIDEwMCAqIGRpc3RhbmNlWyBoaWRlID8gMCA6IDEgXTtcblx0fVxuXHRhbmltYXRpb24xLmNsaXBbIHJlZlsgMCBdIF0gPSBzaXplO1xuXHRhbmltYXRpb24yLmNsaXBbIHJlZlsgMCBdIF0gPSBzaXplO1xuXHRhbmltYXRpb24yLmNsaXBbIHJlZlsgMSBdIF0gPSAwO1xuXG5cdGlmICggc2hvdyApIHtcblx0XHRlbGVtZW50LmNzc0NsaXAoIGFuaW1hdGlvbjIuY2xpcCApO1xuXHRcdGlmICggcGxhY2Vob2xkZXIgKSB7XG5cdFx0XHRwbGFjZWhvbGRlci5jc3MoICQuZWZmZWN0cy5jbGlwVG9Cb3goIGFuaW1hdGlvbjIgKSApO1xuXHRcdH1cblxuXHRcdGFuaW1hdGlvbjIuY2xpcCA9IHN0YXJ0O1xuXHR9XG5cblx0Ly8gQW5pbWF0ZVxuXHRlbGVtZW50XG5cdFx0LnF1ZXVlKCBmdW5jdGlvbiggbmV4dCApIHtcblx0XHRcdGlmICggcGxhY2Vob2xkZXIgKSB7XG5cdFx0XHRcdHBsYWNlaG9sZGVyXG5cdFx0XHRcdFx0LmFuaW1hdGUoICQuZWZmZWN0cy5jbGlwVG9Cb3goIGFuaW1hdGlvbjEgKSwgZHVyYXRpb24sIG9wdGlvbnMuZWFzaW5nIClcblx0XHRcdFx0XHQuYW5pbWF0ZSggJC5lZmZlY3RzLmNsaXBUb0JveCggYW5pbWF0aW9uMiApLCBkdXJhdGlvbiwgb3B0aW9ucy5lYXNpbmcgKTtcblx0XHRcdH1cblxuXHRcdFx0bmV4dCgpO1xuXHRcdH0gKVxuXHRcdC5hbmltYXRlKCBhbmltYXRpb24xLCBkdXJhdGlvbiwgb3B0aW9ucy5lYXNpbmcgKVxuXHRcdC5hbmltYXRlKCBhbmltYXRpb24yLCBkdXJhdGlvbiwgb3B0aW9ucy5lYXNpbmcgKVxuXHRcdC5xdWV1ZSggZG9uZSApO1xuXG5cdCQuZWZmZWN0cy51bnNoaWZ0KCBlbGVtZW50LCBxdWV1ZWxlbiwgNCApO1xufSApO1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIEVmZmVjdHMgSGlnaGxpZ2h0IDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBIaWdobGlnaHQgRWZmZWN0XG4vLz4+Z3JvdXA6IEVmZmVjdHNcbi8vPj5kZXNjcmlwdGlvbjogSGlnaGxpZ2h0cyB0aGUgYmFja2dyb3VuZCBvZiBhbiBlbGVtZW50IGluIGEgZGVmaW5lZCBjb2xvciBmb3IgYSBjdXN0b20gZHVyYXRpb24uXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vaGlnaGxpZ2h0LWVmZmVjdC9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9lZmZlY3QvXG5cblxuXG52YXIgZWZmZWN0c0VmZmVjdEhpZ2hsaWdodCA9ICQuZWZmZWN0cy5kZWZpbmUoIFwiaGlnaGxpZ2h0XCIsIFwic2hvd1wiLCBmdW5jdGlvbiggb3B0aW9ucywgZG9uZSApIHtcblx0dmFyIGVsZW1lbnQgPSAkKCB0aGlzICksXG5cdFx0YW5pbWF0aW9uID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBlbGVtZW50LmNzcyggXCJiYWNrZ3JvdW5kQ29sb3JcIiApXG5cdFx0fTtcblxuXHRpZiAoIG9wdGlvbnMubW9kZSA9PT0gXCJoaWRlXCIgKSB7XG5cdFx0YW5pbWF0aW9uLm9wYWNpdHkgPSAwO1xuXHR9XG5cblx0JC5lZmZlY3RzLnNhdmVTdHlsZSggZWxlbWVudCApO1xuXG5cdGVsZW1lbnRcblx0XHQuY3NzKCB7XG5cdFx0XHRiYWNrZ3JvdW5kSW1hZ2U6IFwibm9uZVwiLFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmNvbG9yIHx8IFwiI2ZmZmY5OVwiXG5cdFx0fSApXG5cdFx0LmFuaW1hdGUoIGFuaW1hdGlvbiwge1xuXHRcdFx0cXVldWU6IGZhbHNlLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHRlYXNpbmc6IG9wdGlvbnMuZWFzaW5nLFxuXHRcdFx0Y29tcGxldGU6IGRvbmVcblx0XHR9ICk7XG59ICk7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgRWZmZWN0cyBTaXplIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBTaXplIEVmZmVjdFxuLy8+Pmdyb3VwOiBFZmZlY3RzXG4vLz4+ZGVzY3JpcHRpb246IFJlc2l6ZSBhbiBlbGVtZW50IHRvIGEgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vc2l6ZS1lZmZlY3QvXG4vLz4+ZGVtb3M6IGh0dHA6Ly9qcXVlcnl1aS5jb20vZWZmZWN0L1xuXG5cblxudmFyIGVmZmVjdHNFZmZlY3RTaXplID0gJC5lZmZlY3RzLmRlZmluZSggXCJzaXplXCIsIGZ1bmN0aW9uKCBvcHRpb25zLCBkb25lICkge1xuXG5cdC8vIENyZWF0ZSBlbGVtZW50XG5cdHZhciBiYXNlbGluZSwgZmFjdG9yLCB0ZW1wLFxuXHRcdGVsZW1lbnQgPSAkKCB0aGlzICksXG5cblx0XHQvLyBDb3B5IGZvciBjaGlsZHJlblxuXHRcdGNQcm9wcyA9IFsgXCJmb250U2l6ZVwiIF0sXG5cdFx0dlByb3BzID0gWyBcImJvcmRlclRvcFdpZHRoXCIsIFwiYm9yZGVyQm90dG9tV2lkdGhcIiwgXCJwYWRkaW5nVG9wXCIsIFwicGFkZGluZ0JvdHRvbVwiIF0sXG5cdFx0aFByb3BzID0gWyBcImJvcmRlckxlZnRXaWR0aFwiLCBcImJvcmRlclJpZ2h0V2lkdGhcIiwgXCJwYWRkaW5nTGVmdFwiLCBcInBhZGRpbmdSaWdodFwiIF0sXG5cblx0XHQvLyBTZXQgb3B0aW9uc1xuXHRcdG1vZGUgPSBvcHRpb25zLm1vZGUsXG5cdFx0cmVzdG9yZSA9IG1vZGUgIT09IFwiZWZmZWN0XCIsXG5cdFx0c2NhbGUgPSBvcHRpb25zLnNjYWxlIHx8IFwiYm90aFwiLFxuXHRcdG9yaWdpbiA9IG9wdGlvbnMub3JpZ2luIHx8IFsgXCJtaWRkbGVcIiwgXCJjZW50ZXJcIiBdLFxuXHRcdHBvc2l0aW9uID0gZWxlbWVudC5jc3MoIFwicG9zaXRpb25cIiApLFxuXHRcdHBvcyA9IGVsZW1lbnQucG9zaXRpb24oKSxcblx0XHRvcmlnaW5hbCA9ICQuZWZmZWN0cy5zY2FsZWREaW1lbnNpb25zKCBlbGVtZW50ICksXG5cdFx0ZnJvbSA9IG9wdGlvbnMuZnJvbSB8fCBvcmlnaW5hbCxcblx0XHR0byA9IG9wdGlvbnMudG8gfHwgJC5lZmZlY3RzLnNjYWxlZERpbWVuc2lvbnMoIGVsZW1lbnQsIDAgKTtcblxuXHQkLmVmZmVjdHMuY3JlYXRlUGxhY2Vob2xkZXIoIGVsZW1lbnQgKTtcblxuXHRpZiAoIG1vZGUgPT09IFwic2hvd1wiICkge1xuXHRcdHRlbXAgPSBmcm9tO1xuXHRcdGZyb20gPSB0bztcblx0XHR0byA9IHRlbXA7XG5cdH1cblxuXHQvLyBTZXQgc2NhbGluZyBmYWN0b3Jcblx0ZmFjdG9yID0ge1xuXHRcdGZyb206IHtcblx0XHRcdHk6IGZyb20uaGVpZ2h0IC8gb3JpZ2luYWwuaGVpZ2h0LFxuXHRcdFx0eDogZnJvbS53aWR0aCAvIG9yaWdpbmFsLndpZHRoXG5cdFx0fSxcblx0XHR0bzoge1xuXHRcdFx0eTogdG8uaGVpZ2h0IC8gb3JpZ2luYWwuaGVpZ2h0LFxuXHRcdFx0eDogdG8ud2lkdGggLyBvcmlnaW5hbC53aWR0aFxuXHRcdH1cblx0fTtcblxuXHQvLyBTY2FsZSB0aGUgY3NzIGJveFxuXHRpZiAoIHNjYWxlID09PSBcImJveFwiIHx8IHNjYWxlID09PSBcImJvdGhcIiApIHtcblxuXHRcdC8vIFZlcnRpY2FsIHByb3BzIHNjYWxpbmdcblx0XHRpZiAoIGZhY3Rvci5mcm9tLnkgIT09IGZhY3Rvci50by55ICkge1xuXHRcdFx0ZnJvbSA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBlbGVtZW50LCB2UHJvcHMsIGZhY3Rvci5mcm9tLnksIGZyb20gKTtcblx0XHRcdHRvID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oIGVsZW1lbnQsIHZQcm9wcywgZmFjdG9yLnRvLnksIHRvICk7XG5cdFx0fVxuXG5cdFx0Ly8gSG9yaXpvbnRhbCBwcm9wcyBzY2FsaW5nXG5cdFx0aWYgKCBmYWN0b3IuZnJvbS54ICE9PSBmYWN0b3IudG8ueCApIHtcblx0XHRcdGZyb20gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbiggZWxlbWVudCwgaFByb3BzLCBmYWN0b3IuZnJvbS54LCBmcm9tICk7XG5cdFx0XHR0byA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBlbGVtZW50LCBoUHJvcHMsIGZhY3Rvci50by54LCB0byApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFNjYWxlIHRoZSBjb250ZW50XG5cdGlmICggc2NhbGUgPT09IFwiY29udGVudFwiIHx8IHNjYWxlID09PSBcImJvdGhcIiApIHtcblxuXHRcdC8vIFZlcnRpY2FsIHByb3BzIHNjYWxpbmdcblx0XHRpZiAoIGZhY3Rvci5mcm9tLnkgIT09IGZhY3Rvci50by55ICkge1xuXHRcdFx0ZnJvbSA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBlbGVtZW50LCBjUHJvcHMsIGZhY3Rvci5mcm9tLnksIGZyb20gKTtcblx0XHRcdHRvID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oIGVsZW1lbnQsIGNQcm9wcywgZmFjdG9yLnRvLnksIHRvICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWRqdXN0IHRoZSBwb3NpdGlvbiBwcm9wZXJ0aWVzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcmlnaW4gcG9pbnRzXG5cdGlmICggb3JpZ2luICkge1xuXHRcdGJhc2VsaW5lID0gJC5lZmZlY3RzLmdldEJhc2VsaW5lKCBvcmlnaW4sIG9yaWdpbmFsICk7XG5cdFx0ZnJvbS50b3AgPSAoIG9yaWdpbmFsLm91dGVySGVpZ2h0IC0gZnJvbS5vdXRlckhlaWdodCApICogYmFzZWxpbmUueSArIHBvcy50b3A7XG5cdFx0ZnJvbS5sZWZ0ID0gKCBvcmlnaW5hbC5vdXRlcldpZHRoIC0gZnJvbS5vdXRlcldpZHRoICkgKiBiYXNlbGluZS54ICsgcG9zLmxlZnQ7XG5cdFx0dG8udG9wID0gKCBvcmlnaW5hbC5vdXRlckhlaWdodCAtIHRvLm91dGVySGVpZ2h0ICkgKiBiYXNlbGluZS55ICsgcG9zLnRvcDtcblx0XHR0by5sZWZ0ID0gKCBvcmlnaW5hbC5vdXRlcldpZHRoIC0gdG8ub3V0ZXJXaWR0aCApICogYmFzZWxpbmUueCArIHBvcy5sZWZ0O1xuXHR9XG5cdGVsZW1lbnQuY3NzKCBmcm9tICk7XG5cblx0Ly8gQW5pbWF0ZSB0aGUgY2hpbGRyZW4gaWYgZGVzaXJlZFxuXHRpZiAoIHNjYWxlID09PSBcImNvbnRlbnRcIiB8fCBzY2FsZSA9PT0gXCJib3RoXCIgKSB7XG5cblx0XHR2UHJvcHMgPSB2UHJvcHMuY29uY2F0KCBbIFwibWFyZ2luVG9wXCIsIFwibWFyZ2luQm90dG9tXCIgXSApLmNvbmNhdCggY1Byb3BzICk7XG5cdFx0aFByb3BzID0gaFByb3BzLmNvbmNhdCggWyBcIm1hcmdpbkxlZnRcIiwgXCJtYXJnaW5SaWdodFwiIF0gKTtcblxuXHRcdC8vIE9ubHkgYW5pbWF0ZSBjaGlsZHJlbiB3aXRoIHdpZHRoIGF0dHJpYnV0ZXMgc3BlY2lmaWVkXG5cdFx0Ly8gVE9ETzogaXMgdGhpcyByaWdodD8gc2hvdWxkIHdlIGluY2x1ZGUgYW55dGhpbmcgd2l0aCBjc3Mgd2lkdGggc3BlY2lmaWVkIGFzIHdlbGxcblx0XHRlbGVtZW50LmZpbmQoIFwiKlt3aWR0aF1cIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNoaWxkID0gJCggdGhpcyApLFxuXHRcdFx0XHRjaGlsZE9yaWdpbmFsID0gJC5lZmZlY3RzLnNjYWxlZERpbWVuc2lvbnMoIGNoaWxkICksXG5cdFx0XHRcdGNoaWxkRnJvbSA9IHtcblx0XHRcdFx0XHRoZWlnaHQ6IGNoaWxkT3JpZ2luYWwuaGVpZ2h0ICogZmFjdG9yLmZyb20ueSxcblx0XHRcdFx0XHR3aWR0aDogY2hpbGRPcmlnaW5hbC53aWR0aCAqIGZhY3Rvci5mcm9tLngsXG5cdFx0XHRcdFx0b3V0ZXJIZWlnaHQ6IGNoaWxkT3JpZ2luYWwub3V0ZXJIZWlnaHQgKiBmYWN0b3IuZnJvbS55LFxuXHRcdFx0XHRcdG91dGVyV2lkdGg6IGNoaWxkT3JpZ2luYWwub3V0ZXJXaWR0aCAqIGZhY3Rvci5mcm9tLnhcblx0XHRcdFx0fSxcblx0XHRcdFx0Y2hpbGRUbyA9IHtcblx0XHRcdFx0XHRoZWlnaHQ6IGNoaWxkT3JpZ2luYWwuaGVpZ2h0ICogZmFjdG9yLnRvLnksXG5cdFx0XHRcdFx0d2lkdGg6IGNoaWxkT3JpZ2luYWwud2lkdGggKiBmYWN0b3IudG8ueCxcblx0XHRcdFx0XHRvdXRlckhlaWdodDogY2hpbGRPcmlnaW5hbC5oZWlnaHQgKiBmYWN0b3IudG8ueSxcblx0XHRcdFx0XHRvdXRlcldpZHRoOiBjaGlsZE9yaWdpbmFsLndpZHRoICogZmFjdG9yLnRvLnhcblx0XHRcdFx0fTtcblxuXHRcdFx0Ly8gVmVydGljYWwgcHJvcHMgc2NhbGluZ1xuXHRcdFx0aWYgKCBmYWN0b3IuZnJvbS55ICE9PSBmYWN0b3IudG8ueSApIHtcblx0XHRcdFx0Y2hpbGRGcm9tID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oIGNoaWxkLCB2UHJvcHMsIGZhY3Rvci5mcm9tLnksIGNoaWxkRnJvbSApO1xuXHRcdFx0XHRjaGlsZFRvID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oIGNoaWxkLCB2UHJvcHMsIGZhY3Rvci50by55LCBjaGlsZFRvICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvcml6b250YWwgcHJvcHMgc2NhbGluZ1xuXHRcdFx0aWYgKCBmYWN0b3IuZnJvbS54ICE9PSBmYWN0b3IudG8ueCApIHtcblx0XHRcdFx0Y2hpbGRGcm9tID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oIGNoaWxkLCBoUHJvcHMsIGZhY3Rvci5mcm9tLngsIGNoaWxkRnJvbSApO1xuXHRcdFx0XHRjaGlsZFRvID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oIGNoaWxkLCBoUHJvcHMsIGZhY3Rvci50by54LCBjaGlsZFRvICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmVzdG9yZSApIHtcblx0XHRcdFx0JC5lZmZlY3RzLnNhdmVTdHlsZSggY2hpbGQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQW5pbWF0ZSBjaGlsZHJlblxuXHRcdFx0Y2hpbGQuY3NzKCBjaGlsZEZyb20gKTtcblx0XHRcdGNoaWxkLmFuaW1hdGUoIGNoaWxkVG8sIG9wdGlvbnMuZHVyYXRpb24sIG9wdGlvbnMuZWFzaW5nLCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIGNoaWxkcmVuXG5cdFx0XHRcdGlmICggcmVzdG9yZSApIHtcblx0XHRcdFx0XHQkLmVmZmVjdHMucmVzdG9yZVN0eWxlKCBjaGlsZCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQW5pbWF0ZVxuXHRlbGVtZW50LmFuaW1hdGUoIHRvLCB7XG5cdFx0cXVldWU6IGZhbHNlLFxuXHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdGVhc2luZzogb3B0aW9ucy5lYXNpbmcsXG5cdFx0Y29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHR2YXIgb2Zmc2V0ID0gZWxlbWVudC5vZmZzZXQoKTtcblxuXHRcdFx0aWYgKCB0by5vcGFjaXR5ID09PSAwICkge1xuXHRcdFx0XHRlbGVtZW50LmNzcyggXCJvcGFjaXR5XCIsIGZyb20ub3BhY2l0eSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICFyZXN0b3JlICkge1xuXHRcdFx0XHRlbGVtZW50XG5cdFx0XHRcdFx0LmNzcyggXCJwb3NpdGlvblwiLCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiA/IFwicmVsYXRpdmVcIiA6IHBvc2l0aW9uIClcblx0XHRcdFx0XHQub2Zmc2V0KCBvZmZzZXQgKTtcblxuXHRcdFx0XHQvLyBOZWVkIHRvIHNhdmUgc3R5bGUgaGVyZSBzbyB0aGF0IGF1dG9tYXRpYyBzdHlsZSByZXN0b3JhdGlvblxuXHRcdFx0XHQvLyBkb2Vzbid0IHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsIHN0eWxlcyBmcm9tIGJlZm9yZSB0aGUgYW5pbWF0aW9uLlxuXHRcdFx0XHQkLmVmZmVjdHMuc2F2ZVN0eWxlKCBlbGVtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRvbmUoKTtcblx0XHR9XG5cdH0gKTtcblxufSApO1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIEVmZmVjdHMgU2NhbGUgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IFNjYWxlIEVmZmVjdFxuLy8+Pmdyb3VwOiBFZmZlY3RzXG4vLz4+ZGVzY3JpcHRpb246IEdyb3dzIG9yIHNocmlua3MgYW4gZWxlbWVudCBhbmQgaXRzIGNvbnRlbnQuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vc2NhbGUtZWZmZWN0L1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2VmZmVjdC9cblxuXG5cbnZhciBlZmZlY3RzRWZmZWN0U2NhbGUgPSAkLmVmZmVjdHMuZGVmaW5lKCBcInNjYWxlXCIsIGZ1bmN0aW9uKCBvcHRpb25zLCBkb25lICkge1xuXG5cdC8vIENyZWF0ZSBlbGVtZW50XG5cdHZhciBlbCA9ICQoIHRoaXMgKSxcblx0XHRtb2RlID0gb3B0aW9ucy5tb2RlLFxuXHRcdHBlcmNlbnQgPSBwYXJzZUludCggb3B0aW9ucy5wZXJjZW50LCAxMCApIHx8XG5cdFx0XHQoIHBhcnNlSW50KCBvcHRpb25zLnBlcmNlbnQsIDEwICkgPT09IDAgPyAwIDogKCBtb2RlICE9PSBcImVmZmVjdFwiID8gMCA6IDEwMCApICksXG5cblx0XHRuZXdPcHRpb25zID0gJC5leHRlbmQoIHRydWUsIHtcblx0XHRcdGZyb206ICQuZWZmZWN0cy5zY2FsZWREaW1lbnNpb25zKCBlbCApLFxuXHRcdFx0dG86ICQuZWZmZWN0cy5zY2FsZWREaW1lbnNpb25zKCBlbCwgcGVyY2VudCwgb3B0aW9ucy5kaXJlY3Rpb24gfHwgXCJib3RoXCIgKSxcblx0XHRcdG9yaWdpbjogb3B0aW9ucy5vcmlnaW4gfHwgWyBcIm1pZGRsZVwiLCBcImNlbnRlclwiIF1cblx0XHR9LCBvcHRpb25zICk7XG5cblx0Ly8gRmFkZSBvcHRpb24gdG8gc3VwcG9ydCBwdWZmXG5cdGlmICggb3B0aW9ucy5mYWRlICkge1xuXHRcdG5ld09wdGlvbnMuZnJvbS5vcGFjaXR5ID0gMTtcblx0XHRuZXdPcHRpb25zLnRvLm9wYWNpdHkgPSAwO1xuXHR9XG5cblx0JC5lZmZlY3RzLmVmZmVjdC5zaXplLmNhbGwoIHRoaXMsIG5ld09wdGlvbnMsIGRvbmUgKTtcbn0gKTtcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSBFZmZlY3RzIFB1ZmYgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IFB1ZmYgRWZmZWN0XG4vLz4+Z3JvdXA6IEVmZmVjdHNcbi8vPj5kZXNjcmlwdGlvbjogQ3JlYXRlcyBhIHB1ZmYgZWZmZWN0IGJ5IHNjYWxpbmcgdGhlIGVsZW1lbnQgdXAgYW5kIGhpZGluZyBpdCBhdCB0aGUgc2FtZSB0aW1lLlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3B1ZmYtZWZmZWN0L1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2VmZmVjdC9cblxuXG5cbnZhciBlZmZlY3RzRWZmZWN0UHVmZiA9ICQuZWZmZWN0cy5kZWZpbmUoIFwicHVmZlwiLCBcImhpZGVcIiwgZnVuY3Rpb24oIG9wdGlvbnMsIGRvbmUgKSB7XG5cdHZhciBuZXdPcHRpb25zID0gJC5leHRlbmQoIHRydWUsIHt9LCBvcHRpb25zLCB7XG5cdFx0ZmFkZTogdHJ1ZSxcblx0XHRwZXJjZW50OiBwYXJzZUludCggb3B0aW9ucy5wZXJjZW50LCAxMCApIHx8IDE1MFxuXHR9ICk7XG5cblx0JC5lZmZlY3RzLmVmZmVjdC5zY2FsZS5jYWxsKCB0aGlzLCBuZXdPcHRpb25zLCBkb25lICk7XG59ICk7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgRWZmZWN0cyBQdWxzYXRlIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBQdWxzYXRlIEVmZmVjdFxuLy8+Pmdyb3VwOiBFZmZlY3RzXG4vLz4+ZGVzY3JpcHRpb246IFB1bHNhdGVzIGFuIGVsZW1lbnQgbiB0aW1lcyBieSBjaGFuZ2luZyB0aGUgb3BhY2l0eSB0byB6ZXJvIGFuZCBiYWNrLlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3B1bHNhdGUtZWZmZWN0L1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2VmZmVjdC9cblxuXG5cbnZhciBlZmZlY3RzRWZmZWN0UHVsc2F0ZSA9ICQuZWZmZWN0cy5kZWZpbmUoIFwicHVsc2F0ZVwiLCBcInNob3dcIiwgZnVuY3Rpb24oIG9wdGlvbnMsIGRvbmUgKSB7XG5cdHZhciBlbGVtZW50ID0gJCggdGhpcyApLFxuXHRcdG1vZGUgPSBvcHRpb25zLm1vZGUsXG5cdFx0c2hvdyA9IG1vZGUgPT09IFwic2hvd1wiLFxuXHRcdGhpZGUgPSBtb2RlID09PSBcImhpZGVcIixcblx0XHRzaG93aGlkZSA9IHNob3cgfHwgaGlkZSxcblxuXHRcdC8vIFNob3dpbmcgb3IgaGlkaW5nIGxlYXZlcyBvZmYgdGhlIFwibGFzdFwiIGFuaW1hdGlvblxuXHRcdGFuaW1zID0gKCAoIG9wdGlvbnMudGltZXMgfHwgNSApICogMiApICsgKCBzaG93aGlkZSA/IDEgOiAwICksXG5cdFx0ZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIC8gYW5pbXMsXG5cdFx0YW5pbWF0ZVRvID0gMCxcblx0XHRpID0gMSxcblx0XHRxdWV1ZWxlbiA9IGVsZW1lbnQucXVldWUoKS5sZW5ndGg7XG5cblx0aWYgKCBzaG93IHx8ICFlbGVtZW50LmlzKCBcIjp2aXNpYmxlXCIgKSApIHtcblx0XHRlbGVtZW50LmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KCk7XG5cdFx0YW5pbWF0ZVRvID0gMTtcblx0fVxuXG5cdC8vIEFuaW1zIC0gMSBvcGFjaXR5IFwidG9nZ2xlc1wiXG5cdGZvciAoIDsgaSA8IGFuaW1zOyBpKysgKSB7XG5cdFx0ZWxlbWVudC5hbmltYXRlKCB7IG9wYWNpdHk6IGFuaW1hdGVUbyB9LCBkdXJhdGlvbiwgb3B0aW9ucy5lYXNpbmcgKTtcblx0XHRhbmltYXRlVG8gPSAxIC0gYW5pbWF0ZVRvO1xuXHR9XG5cblx0ZWxlbWVudC5hbmltYXRlKCB7IG9wYWNpdHk6IGFuaW1hdGVUbyB9LCBkdXJhdGlvbiwgb3B0aW9ucy5lYXNpbmcgKTtcblxuXHRlbGVtZW50LnF1ZXVlKCBkb25lICk7XG5cblx0JC5lZmZlY3RzLnVuc2hpZnQoIGVsZW1lbnQsIHF1ZXVlbGVuLCBhbmltcyArIDEgKTtcbn0gKTtcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSBFZmZlY3RzIFNoYWtlIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBTaGFrZSBFZmZlY3Rcbi8vPj5ncm91cDogRWZmZWN0c1xuLy8+PmRlc2NyaXB0aW9uOiBTaGFrZXMgYW4gZWxlbWVudCBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseSBuIHRpbWVzLlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3NoYWtlLWVmZmVjdC9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9lZmZlY3QvXG5cblxuXG52YXIgZWZmZWN0c0VmZmVjdFNoYWtlID0gJC5lZmZlY3RzLmRlZmluZSggXCJzaGFrZVwiLCBmdW5jdGlvbiggb3B0aW9ucywgZG9uZSApIHtcblxuXHR2YXIgaSA9IDEsXG5cdFx0ZWxlbWVudCA9ICQoIHRoaXMgKSxcblx0XHRkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbiB8fCBcImxlZnRcIixcblx0XHRkaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2UgfHwgMjAsXG5cdFx0dGltZXMgPSBvcHRpb25zLnRpbWVzIHx8IDMsXG5cdFx0YW5pbXMgPSB0aW1lcyAqIDIgKyAxLFxuXHRcdHNwZWVkID0gTWF0aC5yb3VuZCggb3B0aW9ucy5kdXJhdGlvbiAvIGFuaW1zICksXG5cdFx0cmVmID0gKCBkaXJlY3Rpb24gPT09IFwidXBcIiB8fCBkaXJlY3Rpb24gPT09IFwiZG93blwiICkgPyBcInRvcFwiIDogXCJsZWZ0XCIsXG5cdFx0cG9zaXRpdmVNb3Rpb24gPSAoIGRpcmVjdGlvbiA9PT0gXCJ1cFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgKSxcblx0XHRhbmltYXRpb24gPSB7fSxcblx0XHRhbmltYXRpb24xID0ge30sXG5cdFx0YW5pbWF0aW9uMiA9IHt9LFxuXG5cdFx0cXVldWVsZW4gPSBlbGVtZW50LnF1ZXVlKCkubGVuZ3RoO1xuXG5cdCQuZWZmZWN0cy5jcmVhdGVQbGFjZWhvbGRlciggZWxlbWVudCApO1xuXG5cdC8vIEFuaW1hdGlvblxuXHRhbmltYXRpb25bIHJlZiBdID0gKCBwb3NpdGl2ZU1vdGlvbiA/IFwiLT1cIiA6IFwiKz1cIiApICsgZGlzdGFuY2U7XG5cdGFuaW1hdGlvbjFbIHJlZiBdID0gKCBwb3NpdGl2ZU1vdGlvbiA/IFwiKz1cIiA6IFwiLT1cIiApICsgZGlzdGFuY2UgKiAyO1xuXHRhbmltYXRpb24yWyByZWYgXSA9ICggcG9zaXRpdmVNb3Rpb24gPyBcIi09XCIgOiBcIis9XCIgKSArIGRpc3RhbmNlICogMjtcblxuXHQvLyBBbmltYXRlXG5cdGVsZW1lbnQuYW5pbWF0ZSggYW5pbWF0aW9uLCBzcGVlZCwgb3B0aW9ucy5lYXNpbmcgKTtcblxuXHQvLyBTaGFrZXNcblx0Zm9yICggOyBpIDwgdGltZXM7IGkrKyApIHtcblx0XHRlbGVtZW50XG5cdFx0XHQuYW5pbWF0ZSggYW5pbWF0aW9uMSwgc3BlZWQsIG9wdGlvbnMuZWFzaW5nIClcblx0XHRcdC5hbmltYXRlKCBhbmltYXRpb24yLCBzcGVlZCwgb3B0aW9ucy5lYXNpbmcgKTtcblx0fVxuXG5cdGVsZW1lbnRcblx0XHQuYW5pbWF0ZSggYW5pbWF0aW9uMSwgc3BlZWQsIG9wdGlvbnMuZWFzaW5nIClcblx0XHQuYW5pbWF0ZSggYW5pbWF0aW9uLCBzcGVlZCAvIDIsIG9wdGlvbnMuZWFzaW5nIClcblx0XHQucXVldWUoIGRvbmUgKTtcblxuXHQkLmVmZmVjdHMudW5zaGlmdCggZWxlbWVudCwgcXVldWVsZW4sIGFuaW1zICsgMSApO1xufSApO1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIEVmZmVjdHMgU2xpZGUgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IFNsaWRlIEVmZmVjdFxuLy8+Pmdyb3VwOiBFZmZlY3RzXG4vLz4+ZGVzY3JpcHRpb246IFNsaWRlcyBhbiBlbGVtZW50IGluIGFuZCBvdXQgb2YgdGhlIHZpZXdwb3J0LlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3NsaWRlLWVmZmVjdC9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9lZmZlY3QvXG5cblxuXG52YXIgZWZmZWN0c0VmZmVjdFNsaWRlID0gJC5lZmZlY3RzLmRlZmluZSggXCJzbGlkZVwiLCBcInNob3dcIiwgZnVuY3Rpb24oIG9wdGlvbnMsIGRvbmUgKSB7XG5cdHZhciBzdGFydENsaXAsIHN0YXJ0UmVmLFxuXHRcdGVsZW1lbnQgPSAkKCB0aGlzICksXG5cdFx0bWFwID0ge1xuXHRcdFx0dXA6IFsgXCJib3R0b21cIiwgXCJ0b3BcIiBdLFxuXHRcdFx0ZG93bjogWyBcInRvcFwiLCBcImJvdHRvbVwiIF0sXG5cdFx0XHRsZWZ0OiBbIFwicmlnaHRcIiwgXCJsZWZ0XCIgXSxcblx0XHRcdHJpZ2h0OiBbIFwibGVmdFwiLCBcInJpZ2h0XCIgXVxuXHRcdH0sXG5cdFx0bW9kZSA9IG9wdGlvbnMubW9kZSxcblx0XHRkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbiB8fCBcImxlZnRcIixcblx0XHRyZWYgPSAoIGRpcmVjdGlvbiA9PT0gXCJ1cFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJkb3duXCIgKSA/IFwidG9wXCIgOiBcImxlZnRcIixcblx0XHRwb3NpdGl2ZU1vdGlvbiA9ICggZGlyZWN0aW9uID09PSBcInVwXCIgfHwgZGlyZWN0aW9uID09PSBcImxlZnRcIiApLFxuXHRcdGRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZSB8fFxuXHRcdFx0ZWxlbWVudFsgcmVmID09PSBcInRvcFwiID8gXCJvdXRlckhlaWdodFwiIDogXCJvdXRlcldpZHRoXCIgXSggdHJ1ZSApLFxuXHRcdGFuaW1hdGlvbiA9IHt9O1xuXG5cdCQuZWZmZWN0cy5jcmVhdGVQbGFjZWhvbGRlciggZWxlbWVudCApO1xuXG5cdHN0YXJ0Q2xpcCA9IGVsZW1lbnQuY3NzQ2xpcCgpO1xuXHRzdGFydFJlZiA9IGVsZW1lbnQucG9zaXRpb24oKVsgcmVmIF07XG5cblx0Ly8gRGVmaW5lIGhpZGUgYW5pbWF0aW9uXG5cdGFuaW1hdGlvblsgcmVmIF0gPSAoIHBvc2l0aXZlTW90aW9uID8gLTEgOiAxICkgKiBkaXN0YW5jZSArIHN0YXJ0UmVmO1xuXHRhbmltYXRpb24uY2xpcCA9IGVsZW1lbnQuY3NzQ2xpcCgpO1xuXHRhbmltYXRpb24uY2xpcFsgbWFwWyBkaXJlY3Rpb24gXVsgMSBdIF0gPSBhbmltYXRpb24uY2xpcFsgbWFwWyBkaXJlY3Rpb24gXVsgMCBdIF07XG5cblx0Ly8gUmV2ZXJzZSB0aGUgYW5pbWF0aW9uIGlmIHdlJ3JlIHNob3dpbmdcblx0aWYgKCBtb2RlID09PSBcInNob3dcIiApIHtcblx0XHRlbGVtZW50LmNzc0NsaXAoIGFuaW1hdGlvbi5jbGlwICk7XG5cdFx0ZWxlbWVudC5jc3MoIHJlZiwgYW5pbWF0aW9uWyByZWYgXSApO1xuXHRcdGFuaW1hdGlvbi5jbGlwID0gc3RhcnRDbGlwO1xuXHRcdGFuaW1hdGlvblsgcmVmIF0gPSBzdGFydFJlZjtcblx0fVxuXG5cdC8vIEFjdHVhbGx5IGFuaW1hdGVcblx0ZWxlbWVudC5hbmltYXRlKCBhbmltYXRpb24sIHtcblx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0ZWFzaW5nOiBvcHRpb25zLmVhc2luZyxcblx0XHRjb21wbGV0ZTogZG9uZVxuXHR9ICk7XG59ICk7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgRWZmZWN0cyBUcmFuc2ZlciAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogVHJhbnNmZXIgRWZmZWN0XG4vLz4+Z3JvdXA6IEVmZmVjdHNcbi8vPj5kZXNjcmlwdGlvbjogRGlzcGxheXMgYSB0cmFuc2ZlciBlZmZlY3QgZnJvbSBvbmUgZWxlbWVudCB0byBhbm90aGVyLlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3RyYW5zZmVyLWVmZmVjdC9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9lZmZlY3QvXG5cblxuXG52YXIgZWZmZWN0O1xuaWYgKCAkLnVpQmFja0NvbXBhdCAhPT0gZmFsc2UgKSB7XG5cdGVmZmVjdCA9ICQuZWZmZWN0cy5kZWZpbmUoIFwidHJhbnNmZXJcIiwgZnVuY3Rpb24oIG9wdGlvbnMsIGRvbmUgKSB7XG5cdFx0JCggdGhpcyApLnRyYW5zZmVyKCBvcHRpb25zLCBkb25lICk7XG5cdH0gKTtcbn1cbnZhciBlZmZlY3RzRWZmZWN0VHJhbnNmZXIgPSBlZmZlY3Q7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgRm9jdXNhYmxlIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiA6Zm9jdXNhYmxlIFNlbGVjdG9yXG4vLz4+Z3JvdXA6IENvcmVcbi8vPj5kZXNjcmlwdGlvbjogU2VsZWN0cyBlbGVtZW50cyB3aGljaCBjYW4gYmUgZm9jdXNlZC5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9mb2N1c2FibGUtc2VsZWN0b3IvXG5cblxuXG4vLyBTZWxlY3RvcnNcbiQudWkuZm9jdXNhYmxlID0gZnVuY3Rpb24oIGVsZW1lbnQsIGhhc1RhYmluZGV4ICkge1xuXHR2YXIgbWFwLCBtYXBOYW1lLCBpbWcsIGZvY3VzYWJsZUlmVmlzaWJsZSwgZmllbGRzZXQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0aWYgKCBcImFyZWFcIiA9PT0gbm9kZU5hbWUgKSB7XG5cdFx0bWFwID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXHRcdG1hcE5hbWUgPSBtYXAubmFtZTtcblx0XHRpZiAoICFlbGVtZW50LmhyZWYgfHwgIW1hcE5hbWUgfHwgbWFwLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwibWFwXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGltZyA9ICQoIFwiaW1nW3VzZW1hcD0nI1wiICsgbWFwTmFtZSArIFwiJ11cIiApO1xuXHRcdHJldHVybiBpbWcubGVuZ3RoID4gMCAmJiBpbWcuaXMoIFwiOnZpc2libGVcIiApO1xuXHR9XG5cblx0aWYgKCAvXihpbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9ufG9iamVjdCkkLy50ZXN0KCBub2RlTmFtZSApICkge1xuXHRcdGZvY3VzYWJsZUlmVmlzaWJsZSA9ICFlbGVtZW50LmRpc2FibGVkO1xuXG5cdFx0aWYgKCBmb2N1c2FibGVJZlZpc2libGUgKSB7XG5cblx0XHRcdC8vIEZvcm0gY29udHJvbHMgd2l0aGluIGEgZGlzYWJsZWQgZmllbGRzZXQgYXJlIGRpc2FibGVkLlxuXHRcdFx0Ly8gSG93ZXZlciwgY29udHJvbHMgd2l0aGluIHRoZSBmaWVsZHNldCdzIGxlZ2VuZCBkbyBub3QgZ2V0IGRpc2FibGVkLlxuXHRcdFx0Ly8gU2luY2UgY29udHJvbHMgZ2VuZXJhbGx5IGFyZW4ndCBwbGFjZWQgaW5zaWRlIGxlZ2VuZHMsIHdlIHNraXBcblx0XHRcdC8vIHRoaXMgcG9ydGlvbiBvZiB0aGUgY2hlY2suXG5cdFx0XHRmaWVsZHNldCA9ICQoIGVsZW1lbnQgKS5jbG9zZXN0KCBcImZpZWxkc2V0XCIgKVsgMCBdO1xuXHRcdFx0aWYgKCBmaWVsZHNldCApIHtcblx0XHRcdFx0Zm9jdXNhYmxlSWZWaXNpYmxlID0gIWZpZWxkc2V0LmRpc2FibGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggXCJhXCIgPT09IG5vZGVOYW1lICkge1xuXHRcdGZvY3VzYWJsZUlmVmlzaWJsZSA9IGVsZW1lbnQuaHJlZiB8fCBoYXNUYWJpbmRleDtcblx0fSBlbHNlIHtcblx0XHRmb2N1c2FibGVJZlZpc2libGUgPSBoYXNUYWJpbmRleDtcblx0fVxuXG5cdHJldHVybiBmb2N1c2FibGVJZlZpc2libGUgJiYgJCggZWxlbWVudCApLmlzKCBcIjp2aXNpYmxlXCIgKSAmJiB2aXNpYmxlKCAkKCBlbGVtZW50ICkgKTtcbn07XG5cbi8vIFN1cHBvcnQ6IElFIDggb25seVxuLy8gSUUgOCBkb2Vzbid0IHJlc29sdmUgaW5oZXJpdCB0byB2aXNpYmxlL2hpZGRlbiBmb3IgY29tcHV0ZWQgdmFsdWVzXG5mdW5jdGlvbiB2aXNpYmxlKCBlbGVtZW50ICkge1xuXHR2YXIgdmlzaWJpbGl0eSA9IGVsZW1lbnQuY3NzKCBcInZpc2liaWxpdHlcIiApO1xuXHR3aGlsZSAoIHZpc2liaWxpdHkgPT09IFwiaW5oZXJpdFwiICkge1xuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudCgpO1xuXHRcdHZpc2liaWxpdHkgPSBlbGVtZW50LmNzcyggXCJ2aXNpYmlsaXR5XCIgKTtcblx0fVxuXHRyZXR1cm4gdmlzaWJpbGl0eSAhPT0gXCJoaWRkZW5cIjtcbn1cblxuJC5leHRlbmQoICQuZXhwclsgXCI6XCIgXSwge1xuXHRmb2N1c2FibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHJldHVybiAkLnVpLmZvY3VzYWJsZSggZWxlbWVudCwgJC5hdHRyKCBlbGVtZW50LCBcInRhYmluZGV4XCIgKSAhPSBudWxsICk7XG5cdH1cbn0gKTtcblxudmFyIGZvY3VzYWJsZSA9ICQudWkuZm9jdXNhYmxlO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBJRTggT25seVxuLy8gSUU4IGRvZXMgbm90IHN1cHBvcnQgdGhlIGZvcm0gYXR0cmlidXRlIGFuZCB3aGVuIGl0IGlzIHN1cHBsaWVkLiBJdCBvdmVyd3JpdGVzIHRoZSBmb3JtIHByb3Bcbi8vIHdpdGggYSBzdHJpbmcsIHNvIHdlIG5lZWQgdG8gZmluZCB0aGUgcHJvcGVyIGZvcm0uXG52YXIgZm9ybSA9ICQuZm4uZm9ybSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdHlwZW9mIHRoaXNbIDAgXS5mb3JtID09PSBcInN0cmluZ1wiID8gdGhpcy5jbG9zZXN0KCBcImZvcm1cIiApIDogJCggdGhpc1sgMCBdLmZvcm0gKTtcbn07XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgRm9ybSBSZXNldCBNaXhpbiAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogRm9ybSBSZXNldCBNaXhpblxuLy8+Pmdyb3VwOiBDb3JlXG4vLz4+ZGVzY3JpcHRpb246IFJlZnJlc2ggaW5wdXQgd2lkZ2V0cyB3aGVuIHRoZWlyIGZvcm0gaXMgcmVzZXRcbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9mb3JtLXJlc2V0LW1peGluL1xuXG5cblxudmFyIGZvcm1SZXNldE1peGluID0gJC51aS5mb3JtUmVzZXRNaXhpbiA9IHtcblx0X2Zvcm1SZXNldEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmb3JtID0gJCggdGhpcyApO1xuXG5cdFx0Ly8gV2FpdCBmb3IgdGhlIGZvcm0gcmVzZXQgdG8gYWN0dWFsbHkgaGFwcGVuIGJlZm9yZSByZWZyZXNoaW5nXG5cdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5zdGFuY2VzID0gZm9ybS5kYXRhKCBcInVpLWZvcm0tcmVzZXQtaW5zdGFuY2VzXCIgKTtcblx0XHRcdCQuZWFjaCggaW5zdGFuY2VzLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9iaW5kRm9ybVJlc2V0SGFuZGxlcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5mb3JtID0gdGhpcy5lbGVtZW50LmZvcm0oKTtcblx0XHRpZiAoICF0aGlzLmZvcm0ubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpbnN0YW5jZXMgPSB0aGlzLmZvcm0uZGF0YSggXCJ1aS1mb3JtLXJlc2V0LWluc3RhbmNlc1wiICkgfHwgW107XG5cdFx0aWYgKCAhaW5zdGFuY2VzLmxlbmd0aCApIHtcblxuXHRcdFx0Ly8gV2UgZG9uJ3QgdXNlIF9vbigpIGhlcmUgYmVjYXVzZSB3ZSB1c2UgYSBzaW5nbGUgZXZlbnQgaGFuZGxlciBwZXIgZm9ybVxuXHRcdFx0dGhpcy5mb3JtLm9uKCBcInJlc2V0LnVpLWZvcm0tcmVzZXRcIiwgdGhpcy5fZm9ybVJlc2V0SGFuZGxlciApO1xuXHRcdH1cblx0XHRpbnN0YW5jZXMucHVzaCggdGhpcyApO1xuXHRcdHRoaXMuZm9ybS5kYXRhKCBcInVpLWZvcm0tcmVzZXQtaW5zdGFuY2VzXCIsIGluc3RhbmNlcyApO1xuXHR9LFxuXG5cdF91bmJpbmRGb3JtUmVzZXRIYW5kbGVyOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzLmZvcm0ubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpbnN0YW5jZXMgPSB0aGlzLmZvcm0uZGF0YSggXCJ1aS1mb3JtLXJlc2V0LWluc3RhbmNlc1wiICk7XG5cdFx0aW5zdGFuY2VzLnNwbGljZSggJC5pbkFycmF5KCB0aGlzLCBpbnN0YW5jZXMgKSwgMSApO1xuXHRcdGlmICggaW5zdGFuY2VzLmxlbmd0aCApIHtcblx0XHRcdHRoaXMuZm9ybS5kYXRhKCBcInVpLWZvcm0tcmVzZXQtaW5zdGFuY2VzXCIsIGluc3RhbmNlcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmZvcm1cblx0XHRcdFx0LnJlbW92ZURhdGEoIFwidWktZm9ybS1yZXNldC1pbnN0YW5jZXNcIiApXG5cdFx0XHRcdC5vZmYoIFwicmVzZXQudWktZm9ybS1yZXNldFwiICk7XG5cdFx0fVxuXHR9XG59O1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIFN1cHBvcnQgZm9yIGpRdWVyeSBjb3JlIDEuNy54IDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICovXG5cbi8vPj5sYWJlbDogalF1ZXJ5IDEuNyBTdXBwb3J0XG4vLz4+Z3JvdXA6IENvcmVcbi8vPj5kZXNjcmlwdGlvbjogU3VwcG9ydCB2ZXJzaW9uIDEuNy54IG9mIGpRdWVyeSBjb3JlXG5cblxuXG4vLyBTdXBwb3J0OiBqUXVlcnkgMS43IG9ubHlcbi8vIE5vdCBhIGdyZWF0IHdheSB0byBjaGVjayB2ZXJzaW9ucywgYnV0IHNpbmNlIHdlIG9ubHkgc3VwcG9ydCAxLjcrIGFuZCBvbmx5XG4vLyBuZWVkIHRvIGRldGVjdCA8MS44LCB0aGlzIGlzIGEgc2ltcGxlIGNoZWNrIHRoYXQgc2hvdWxkIHN1ZmZpY2UuIENoZWNraW5nXG4vLyBmb3IgXCIxLjcuXCIgd291bGQgYmUgYSBiaXQgc2FmZXIsIGJ1dCB0aGUgdmVyc2lvbiBzdHJpbmcgaXMgMS43LCBub3QgMS43LjBcbi8vIGFuZCB3ZSdsbCBuZXZlciByZWFjaCAxLjcwLjAgKGlmIHdlIGRvLCB3ZSBjZXJ0YWlubHkgd29uJ3QgYmUgc3VwcG9ydGluZ1xuLy8gMS43IGFueW1vcmUpLiBTZWUgIzExMTk3IGZvciB3aHkgd2UncmUgbm90IHVzaW5nIGZlYXR1cmUgZGV0ZWN0aW9uLlxuaWYgKCAkLmZuLmpxdWVyeS5zdWJzdHJpbmcoIDAsIDMgKSA9PT0gXCIxLjdcIiApIHtcblxuXHQvLyBTZXR0ZXJzIGZvciAuaW5uZXJXaWR0aCgpLCAuaW5uZXJIZWlnaHQoKSwgLm91dGVyV2lkdGgoKSwgLm91dGVySGVpZ2h0KClcblx0Ly8gVW5saWtlIGpRdWVyeSBDb3JlIDEuOCssIHRoZXNlIG9ubHkgc3VwcG9ydCBudW1lcmljIHZhbHVlcyB0byBzZXQgdGhlXG5cdC8vIGRpbWVuc2lvbnMgaW4gcGl4ZWxzXG5cdCQuZWFjaCggWyBcIldpZHRoXCIsIFwiSGVpZ2h0XCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0dmFyIHNpZGUgPSBuYW1lID09PSBcIldpZHRoXCIgPyBbIFwiTGVmdFwiLCBcIlJpZ2h0XCIgXSA6IFsgXCJUb3BcIiwgXCJCb3R0b21cIiBdLFxuXHRcdFx0dHlwZSA9IG5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdG9yaWcgPSB7XG5cdFx0XHRcdGlubmVyV2lkdGg6ICQuZm4uaW5uZXJXaWR0aCxcblx0XHRcdFx0aW5uZXJIZWlnaHQ6ICQuZm4uaW5uZXJIZWlnaHQsXG5cdFx0XHRcdG91dGVyV2lkdGg6ICQuZm4ub3V0ZXJXaWR0aCxcblx0XHRcdFx0b3V0ZXJIZWlnaHQ6ICQuZm4ub3V0ZXJIZWlnaHRcblx0XHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWR1Y2UoIGVsZW0sIHNpemUsIGJvcmRlciwgbWFyZ2luICkge1xuXHRcdFx0JC5lYWNoKCBzaWRlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2l6ZSAtPSBwYXJzZUZsb2F0KCAkLmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyB0aGlzICkgKSB8fCAwO1xuXHRcdFx0XHRpZiAoIGJvcmRlciApIHtcblx0XHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgdGhpcyArIFwiV2lkdGhcIiApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG1hcmdpbiApIHtcblx0XHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcIm1hcmdpblwiICsgdGhpcyApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHNpemU7XG5cdFx0fVxuXG5cdFx0JC5mblsgXCJpbm5lclwiICsgbmFtZSBdID0gZnVuY3Rpb24oIHNpemUgKSB7XG5cdFx0XHRpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIG9yaWdbIFwiaW5uZXJcIiArIG5hbWUgXS5jYWxsKCB0aGlzICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkKCB0aGlzICkuY3NzKCB0eXBlLCByZWR1Y2UoIHRoaXMsIHNpemUgKSArIFwicHhcIiApO1xuXHRcdFx0fSApO1xuXHRcdH07XG5cblx0XHQkLmZuWyBcIm91dGVyXCIgKyBuYW1lIF0gPSBmdW5jdGlvbiggc2l6ZSwgbWFyZ2luICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc2l6ZSAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0cmV0dXJuIG9yaWdbIFwib3V0ZXJcIiArIG5hbWUgXS5jYWxsKCB0aGlzLCBzaXplICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkKCB0aGlzICkuY3NzKCB0eXBlLCByZWR1Y2UoIHRoaXMsIHNpemUsIHRydWUsIG1hcmdpbiApICsgXCJweFwiICk7XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0fSApO1xuXG5cdCQuZm4uYWRkQmFjayA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH07XG59XG5cbjtcbi8qIVxuICogalF1ZXJ5IFVJIEtleWNvZGUgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IEtleWNvZGVcbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBQcm92aWRlIGtleWNvZGVzIGFzIGtleW5hbWVzXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20valF1ZXJ5LnVpLmtleUNvZGUvXG5cblxudmFyIGtleWNvZGUgPSAkLnVpLmtleUNvZGUgPSB7XG5cdEJBQ0tTUEFDRTogOCxcblx0Q09NTUE6IDE4OCxcblx0REVMRVRFOiA0Nixcblx0RE9XTjogNDAsXG5cdEVORDogMzUsXG5cdEVOVEVSOiAxMyxcblx0RVNDQVBFOiAyNyxcblx0SE9NRTogMzYsXG5cdExFRlQ6IDM3LFxuXHRQQUdFX0RPV046IDM0LFxuXHRQQUdFX1VQOiAzMyxcblx0UEVSSU9EOiAxOTAsXG5cdFJJR0hUOiAzOSxcblx0U1BBQ0U6IDMyLFxuXHRUQUI6IDksXG5cdFVQOiAzOFxufTtcblxuXG5cblxuLy8gSW50ZXJuYWwgdXNlIG9ubHlcbnZhciBlc2NhcGVTZWxlY3RvciA9ICQudWkuZXNjYXBlU2VsZWN0b3IgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgc2VsZWN0b3JFc2NhcGUgPSAvKFshXCIjJCUmJygpKissLi86Ozw9Pj9AW1xcXV5ge3x9fl0pL2c7XG5cdHJldHVybiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoIHNlbGVjdG9yRXNjYXBlLCBcIlxcXFwkMVwiICk7XG5cdH07XG59ICkoKTtcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSBMYWJlbHMgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IGxhYmVsc1xuLy8+Pmdyb3VwOiBDb3JlXG4vLz4+ZGVzY3JpcHRpb246IEZpbmQgYWxsIHRoZSBsYWJlbHMgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gaW5wdXRcbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9sYWJlbHMvXG5cblxuXG52YXIgbGFiZWxzID0gJC5mbi5sYWJlbHMgPSBmdW5jdGlvbigpIHtcblx0dmFyIGFuY2VzdG9yLCBzZWxlY3RvciwgaWQsIGxhYmVscywgYW5jZXN0b3JzO1xuXG5cdC8vIENoZWNrIGNvbnRyb2wubGFiZWxzIGZpcnN0XG5cdGlmICggdGhpc1sgMCBdLmxhYmVscyAmJiB0aGlzWyAwIF0ubGFiZWxzLmxlbmd0aCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHRoaXNbIDAgXS5sYWJlbHMgKTtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9IDExLCBGRiA8PSAzNywgQW5kcm9pZCA8PSAyLjMgb25seVxuXHQvLyBBYm92ZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBjb250cm9sLmxhYmVscy4gRXZlcnl0aGluZyBiZWxvdyBpcyB0byBzdXBwb3J0IHRoZW1cblx0Ly8gYXMgd2VsbCBhcyBkb2N1bWVudCBmcmFnbWVudHMuIGNvbnRyb2wubGFiZWxzIGRvZXMgbm90IHdvcmsgb24gZG9jdW1lbnQgZnJhZ21lbnRzXG5cdGxhYmVscyA9IHRoaXMuZXEoIDAgKS5wYXJlbnRzKCBcImxhYmVsXCIgKTtcblxuXHQvLyBMb29rIGZvciB0aGUgbGFiZWwgYmFzZWQgb24gdGhlIGlkXG5cdGlkID0gdGhpcy5hdHRyKCBcImlkXCIgKTtcblx0aWYgKCBpZCApIHtcblxuXHRcdC8vIFdlIGRvbid0IHNlYXJjaCBhZ2FpbnN0IHRoZSBkb2N1bWVudCBpbiBjYXNlIHRoZSBlbGVtZW50XG5cdFx0Ly8gaXMgZGlzY29ubmVjdGVkIGZyb20gdGhlIERPTVxuXHRcdGFuY2VzdG9yID0gdGhpcy5lcSggMCApLnBhcmVudHMoKS5sYXN0KCk7XG5cblx0XHQvLyBHZXQgYSBmdWxsIHNldCBvZiB0b3AgbGV2ZWwgYW5jZXN0b3JzXG5cdFx0YW5jZXN0b3JzID0gYW5jZXN0b3IuYWRkKCBhbmNlc3Rvci5sZW5ndGggPyBhbmNlc3Rvci5zaWJsaW5ncygpIDogdGhpcy5zaWJsaW5ncygpICk7XG5cblx0XHQvLyBDcmVhdGUgYSBzZWxlY3RvciBmb3IgdGhlIGxhYmVsIGJhc2VkIG9uIHRoZSBpZFxuXHRcdHNlbGVjdG9yID0gXCJsYWJlbFtmb3I9J1wiICsgJC51aS5lc2NhcGVTZWxlY3RvciggaWQgKSArIFwiJ11cIjtcblxuXHRcdGxhYmVscyA9IGxhYmVscy5hZGQoIGFuY2VzdG9ycy5maW5kKCBzZWxlY3RvciApLmFkZEJhY2soIHNlbGVjdG9yICkgKTtcblxuXHR9XG5cblx0Ly8gUmV0dXJuIHdoYXRldmVyIHdlIGhhdmUgZm91bmQgZm9yIGxhYmVsc1xuXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGxhYmVscyApO1xufTtcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSBTY3JvbGwgUGFyZW50IDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBzY3JvbGxQYXJlbnRcbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBHZXQgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgZWxlbWVudCB0aGF0IGlzIHNjcm9sbGFibGUuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vc2Nyb2xsUGFyZW50L1xuXG5cblxudmFyIHNjcm9sbFBhcmVudCA9ICQuZm4uc2Nyb2xsUGFyZW50ID0gZnVuY3Rpb24oIGluY2x1ZGVIaWRkZW4gKSB7XG5cdHZhciBwb3NpdGlvbiA9IHRoaXMuY3NzKCBcInBvc2l0aW9uXCIgKSxcblx0XHRleGNsdWRlU3RhdGljUGFyZW50ID0gcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIixcblx0XHRvdmVyZmxvd1JlZ2V4ID0gaW5jbHVkZUhpZGRlbiA/IC8oYXV0b3xzY3JvbGx8aGlkZGVuKS8gOiAvKGF1dG98c2Nyb2xsKS8sXG5cdFx0c2Nyb2xsUGFyZW50ID0gdGhpcy5wYXJlbnRzKCkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwYXJlbnQgPSAkKCB0aGlzICk7XG5cdFx0XHRpZiAoIGV4Y2x1ZGVTdGF0aWNQYXJlbnQgJiYgcGFyZW50LmNzcyggXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvdmVyZmxvd1JlZ2V4LnRlc3QoIHBhcmVudC5jc3MoIFwib3ZlcmZsb3dcIiApICsgcGFyZW50LmNzcyggXCJvdmVyZmxvdy15XCIgKSArXG5cdFx0XHRcdHBhcmVudC5jc3MoIFwib3ZlcmZsb3cteFwiICkgKTtcblx0XHR9ICkuZXEoIDAgKTtcblxuXHRyZXR1cm4gcG9zaXRpb24gPT09IFwiZml4ZWRcIiB8fCAhc2Nyb2xsUGFyZW50Lmxlbmd0aCA/XG5cdFx0JCggdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSA6XG5cdFx0c2Nyb2xsUGFyZW50O1xufTtcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSBUYWJiYWJsZSAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogOnRhYmJhYmxlIFNlbGVjdG9yXG4vLz4+Z3JvdXA6IENvcmVcbi8vPj5kZXNjcmlwdGlvbjogU2VsZWN0cyBlbGVtZW50cyB3aGljaCBjYW4gYmUgdGFiYmVkIHRvLlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3RhYmJhYmxlLXNlbGVjdG9yL1xuXG5cblxudmFyIHRhYmJhYmxlID0gJC5leHRlbmQoICQuZXhwclsgXCI6XCIgXSwge1xuXHR0YWJiYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dmFyIHRhYkluZGV4ID0gJC5hdHRyKCBlbGVtZW50LCBcInRhYmluZGV4XCIgKSxcblx0XHRcdGhhc1RhYmluZGV4ID0gdGFiSW5kZXggIT0gbnVsbDtcblx0XHRyZXR1cm4gKCAhaGFzVGFiaW5kZXggfHwgdGFiSW5kZXggPj0gMCApICYmICQudWkuZm9jdXNhYmxlKCBlbGVtZW50LCBoYXNUYWJpbmRleCApO1xuXHR9XG59ICk7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgVW5pcXVlIElEIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiB1bmlxdWVJZFxuLy8+Pmdyb3VwOiBDb3JlXG4vLz4+ZGVzY3JpcHRpb246IEZ1bmN0aW9ucyB0byBnZW5lcmF0ZSBhbmQgcmVtb3ZlIHVuaXF1ZUlkJ3Ncbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS91bmlxdWVJZC9cblxuXG5cbnZhciB1bmlxdWVJZCA9ICQuZm4uZXh0ZW5kKCB7XG5cdHVuaXF1ZUlkOiAoIGZ1bmN0aW9uKCkge1xuXHRcdHZhciB1dWlkID0gMDtcblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLmlkICkge1xuXHRcdFx0XHRcdHRoaXMuaWQgPSBcInVpLWlkLVwiICsgKCArK3V1aWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH07XG5cdH0gKSgpLFxuXG5cdHJlbW92ZVVuaXF1ZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggL151aS1pZC1cXGQrJC8udGVzdCggdGhpcy5pZCApICkge1xuXHRcdFx0XHQkKCB0aGlzICkucmVtb3ZlQXR0ciggXCJpZFwiICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgQWNjb3JkaW9uIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBBY2NvcmRpb25cbi8vPj5ncm91cDogV2lkZ2V0c1xuLy8ganNjczpkaXNhYmxlIG1heGltdW1MaW5lTGVuZ3RoXG4vLz4+ZGVzY3JpcHRpb246IERpc3BsYXlzIGNvbGxhcHNpYmxlIGNvbnRlbnQgcGFuZWxzIGZvciBwcmVzZW50aW5nIGluZm9ybWF0aW9uIGluIGEgbGltaXRlZCBhbW91bnQgb2Ygc3BhY2UuXG4vLyBqc2NzOmVuYWJsZSBtYXhpbXVtTGluZUxlbmd0aFxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2FjY29yZGlvbi9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9hY2NvcmRpb24vXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2UvY29yZS5jc3Ncbi8vPj5jc3Muc3RydWN0dXJlOiAuLi8uLi90aGVtZXMvYmFzZS9hY2NvcmRpb24uY3NzXG4vLz4+Y3NzLnRoZW1lOiAuLi8uLi90aGVtZXMvYmFzZS90aGVtZS5jc3NcblxuXG5cbnZhciB3aWRnZXRzQWNjb3JkaW9uID0gJC53aWRnZXQoIFwidWkuYWNjb3JkaW9uXCIsIHtcblx0dmVyc2lvbjogXCIxLjEyLjFcIixcblx0b3B0aW9uczoge1xuXHRcdGFjdGl2ZTogMCxcblx0XHRhbmltYXRlOiB7fSxcblx0XHRjbGFzc2VzOiB7XG5cdFx0XHRcInVpLWFjY29yZGlvbi1oZWFkZXJcIjogXCJ1aS1jb3JuZXItdG9wXCIsXG5cdFx0XHRcInVpLWFjY29yZGlvbi1oZWFkZXItY29sbGFwc2VkXCI6IFwidWktY29ybmVyLWFsbFwiLFxuXHRcdFx0XCJ1aS1hY2NvcmRpb24tY29udGVudFwiOiBcInVpLWNvcm5lci1ib3R0b21cIlxuXHRcdH0sXG5cdFx0Y29sbGFwc2libGU6IGZhbHNlLFxuXHRcdGV2ZW50OiBcImNsaWNrXCIsXG5cdFx0aGVhZGVyOiBcIj4gbGkgPiA6Zmlyc3QtY2hpbGQsID4gOm5vdChsaSk6ZXZlblwiLFxuXHRcdGhlaWdodFN0eWxlOiBcImF1dG9cIixcblx0XHRpY29uczoge1xuXHRcdFx0YWN0aXZlSGVhZGVyOiBcInVpLWljb24tdHJpYW5nbGUtMS1zXCIsXG5cdFx0XHRoZWFkZXI6IFwidWktaWNvbi10cmlhbmdsZS0xLWVcIlxuXHRcdH0sXG5cblx0XHQvLyBDYWxsYmFja3Ncblx0XHRhY3RpdmF0ZTogbnVsbCxcblx0XHRiZWZvcmVBY3RpdmF0ZTogbnVsbFxuXHR9LFxuXG5cdGhpZGVQcm9wczoge1xuXHRcdGJvcmRlclRvcFdpZHRoOiBcImhpZGVcIixcblx0XHRib3JkZXJCb3R0b21XaWR0aDogXCJoaWRlXCIsXG5cdFx0cGFkZGluZ1RvcDogXCJoaWRlXCIsXG5cdFx0cGFkZGluZ0JvdHRvbTogXCJoaWRlXCIsXG5cdFx0aGVpZ2h0OiBcImhpZGVcIlxuXHR9LFxuXG5cdHNob3dQcm9wczoge1xuXHRcdGJvcmRlclRvcFdpZHRoOiBcInNob3dcIixcblx0XHRib3JkZXJCb3R0b21XaWR0aDogXCJzaG93XCIsXG5cdFx0cGFkZGluZ1RvcDogXCJzaG93XCIsXG5cdFx0cGFkZGluZ0JvdHRvbTogXCJzaG93XCIsXG5cdFx0aGVpZ2h0OiBcInNob3dcIlxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5wcmV2U2hvdyA9IHRoaXMucHJldkhpZGUgPSAkKCk7XG5cdFx0dGhpcy5fYWRkQ2xhc3MoIFwidWktYWNjb3JkaW9uXCIsIFwidWktd2lkZ2V0IHVpLWhlbHBlci1yZXNldFwiICk7XG5cdFx0dGhpcy5lbGVtZW50LmF0dHIoIFwicm9sZVwiLCBcInRhYmxpc3RcIiApO1xuXG5cdFx0Ly8gRG9uJ3QgYWxsb3cgY29sbGFwc2libGU6IGZhbHNlIGFuZCBhY3RpdmU6IGZhbHNlIC8gbnVsbFxuXHRcdGlmICggIW9wdGlvbnMuY29sbGFwc2libGUgJiYgKCBvcHRpb25zLmFjdGl2ZSA9PT0gZmFsc2UgfHwgb3B0aW9ucy5hY3RpdmUgPT0gbnVsbCApICkge1xuXHRcdFx0b3B0aW9ucy5hY3RpdmUgPSAwO1xuXHRcdH1cblxuXHRcdHRoaXMuX3Byb2Nlc3NQYW5lbHMoKTtcblxuXHRcdC8vIGhhbmRsZSBuZWdhdGl2ZSB2YWx1ZXNcblx0XHRpZiAoIG9wdGlvbnMuYWN0aXZlIDwgMCApIHtcblx0XHRcdG9wdGlvbnMuYWN0aXZlICs9IHRoaXMuaGVhZGVycy5sZW5ndGg7XG5cdFx0fVxuXHRcdHRoaXMuX3JlZnJlc2goKTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlRXZlbnREYXRhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0aGVhZGVyOiB0aGlzLmFjdGl2ZSxcblx0XHRcdHBhbmVsOiAhdGhpcy5hY3RpdmUubGVuZ3RoID8gJCgpIDogdGhpcy5hY3RpdmUubmV4dCgpXG5cdFx0fTtcblx0fSxcblxuXHRfY3JlYXRlSWNvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpY29uLCBjaGlsZHJlbixcblx0XHRcdGljb25zID0gdGhpcy5vcHRpb25zLmljb25zO1xuXG5cdFx0aWYgKCBpY29ucyApIHtcblx0XHRcdGljb24gPSAkKCBcIjxzcGFuPlwiICk7XG5cdFx0XHR0aGlzLl9hZGRDbGFzcyggaWNvbiwgXCJ1aS1hY2NvcmRpb24taGVhZGVyLWljb25cIiwgXCJ1aS1pY29uIFwiICsgaWNvbnMuaGVhZGVyICk7XG5cdFx0XHRpY29uLnByZXBlbmRUbyggdGhpcy5oZWFkZXJzICk7XG5cdFx0XHRjaGlsZHJlbiA9IHRoaXMuYWN0aXZlLmNoaWxkcmVuKCBcIi51aS1hY2NvcmRpb24taGVhZGVyLWljb25cIiApO1xuXHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIGNoaWxkcmVuLCBpY29ucy5oZWFkZXIgKVxuXHRcdFx0XHQuX2FkZENsYXNzKCBjaGlsZHJlbiwgbnVsbCwgaWNvbnMuYWN0aXZlSGVhZGVyIClcblx0XHRcdFx0Ll9hZGRDbGFzcyggdGhpcy5oZWFkZXJzLCBcInVpLWFjY29yZGlvbi1pY29uc1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kZXN0cm95SWNvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmhlYWRlcnMsIFwidWktYWNjb3JkaW9uLWljb25zXCIgKTtcblx0XHR0aGlzLmhlYWRlcnMuY2hpbGRyZW4oIFwiLnVpLWFjY29yZGlvbi1oZWFkZXItaWNvblwiICkucmVtb3ZlKCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb250ZW50cztcblxuXHRcdC8vIENsZWFuIHVwIG1haW4gZWxlbWVudFxuXHRcdHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyKCBcInJvbGVcIiApO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgaGVhZGVyc1xuXHRcdHRoaXMuaGVhZGVyc1xuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZSBhcmlhLWV4cGFuZGVkIGFyaWEtc2VsZWN0ZWQgYXJpYS1jb250cm9scyB0YWJJbmRleFwiIClcblx0XHRcdC5yZW1vdmVVbmlxdWVJZCgpO1xuXG5cdFx0dGhpcy5fZGVzdHJveUljb25zKCk7XG5cblx0XHQvLyBDbGVhbiB1cCBjb250ZW50IHBhbmVsc1xuXHRcdGNvbnRlbnRzID0gdGhpcy5oZWFkZXJzLm5leHQoKVxuXHRcdFx0LmNzcyggXCJkaXNwbGF5XCIsIFwiXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZSBhcmlhLWhpZGRlbiBhcmlhLWxhYmVsbGVkYnlcIiApXG5cdFx0XHQucmVtb3ZlVW5pcXVlSWQoKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmhlaWdodFN0eWxlICE9PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdGNvbnRlbnRzLmNzcyggXCJoZWlnaHRcIiwgXCJcIiApO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRpZiAoIGtleSA9PT0gXCJhY3RpdmVcIiApIHtcblxuXHRcdFx0Ly8gX2FjdGl2YXRlKCkgd2lsbCBoYW5kbGUgaW52YWxpZCB2YWx1ZXMgYW5kIHVwZGF0ZSB0aGlzLm9wdGlvbnNcblx0XHRcdHRoaXMuX2FjdGl2YXRlKCB2YWx1ZSApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ID09PSBcImV2ZW50XCIgKSB7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5ldmVudCApIHtcblx0XHRcdFx0dGhpcy5fb2ZmKCB0aGlzLmhlYWRlcnMsIHRoaXMub3B0aW9ucy5ldmVudCApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2V0dXBFdmVudHMoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNldHRpbmcgY29sbGFwc2libGU6IGZhbHNlIHdoaWxlIGNvbGxhcHNlZDsgb3BlbiBmaXJzdCBwYW5lbFxuXHRcdGlmICgga2V5ID09PSBcImNvbGxhcHNpYmxlXCIgJiYgIXZhbHVlICYmIHRoaXMub3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIDAgKTtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gXCJpY29uc1wiICkge1xuXHRcdFx0dGhpcy5fZGVzdHJveUljb25zKCk7XG5cdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHR0aGlzLl9jcmVhdGVJY29ucygpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfc2V0T3B0aW9uRGlzYWJsZWQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zdXBlciggdmFsdWUgKTtcblxuXHRcdHRoaXMuZWxlbWVudC5hdHRyKCBcImFyaWEtZGlzYWJsZWRcIiwgdmFsdWUgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFOCBPbmx5XG5cdFx0Ly8gIzUzMzIgLyAjNjA1OSAtIG9wYWNpdHkgZG9lc24ndCBjYXNjYWRlIHRvIHBvc2l0aW9uZWQgZWxlbWVudHMgaW4gSUVcblx0XHQvLyBzbyB3ZSBuZWVkIHRvIGFkZCB0aGUgZGlzYWJsZWQgY2xhc3MgdG8gdGhlIGhlYWRlcnMgYW5kIHBhbmVsc1xuXHRcdHRoaXMuX3RvZ2dsZUNsYXNzKCBudWxsLCBcInVpLXN0YXRlLWRpc2FibGVkXCIsICEhdmFsdWUgKTtcblx0XHR0aGlzLl90b2dnbGVDbGFzcyggdGhpcy5oZWFkZXJzLmFkZCggdGhpcy5oZWFkZXJzLm5leHQoKSApLCBudWxsLCBcInVpLXN0YXRlLWRpc2FibGVkXCIsXG5cdFx0XHQhIXZhbHVlICk7XG5cdH0sXG5cblx0X2tleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBrZXlDb2RlID0gJC51aS5rZXlDb2RlLFxuXHRcdFx0bGVuZ3RoID0gdGhpcy5oZWFkZXJzLmxlbmd0aCxcblx0XHRcdGN1cnJlbnRJbmRleCA9IHRoaXMuaGVhZGVycy5pbmRleCggZXZlbnQudGFyZ2V0ICksXG5cdFx0XHR0b0ZvY3VzID0gZmFsc2U7XG5cblx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdGNhc2Uga2V5Q29kZS5SSUdIVDpcblx0XHRjYXNlIGtleUNvZGUuRE9XTjpcblx0XHRcdHRvRm9jdXMgPSB0aGlzLmhlYWRlcnNbICggY3VycmVudEluZGV4ICsgMSApICUgbGVuZ3RoIF07XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGtleUNvZGUuTEVGVDpcblx0XHRjYXNlIGtleUNvZGUuVVA6XG5cdFx0XHR0b0ZvY3VzID0gdGhpcy5oZWFkZXJzWyAoIGN1cnJlbnRJbmRleCAtIDEgKyBsZW5ndGggKSAlIGxlbmd0aCBdO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBrZXlDb2RlLlNQQUNFOlxuXHRcdGNhc2Uga2V5Q29kZS5FTlRFUjpcblx0XHRcdHRoaXMuX2V2ZW50SGFuZGxlciggZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2Uga2V5Q29kZS5IT01FOlxuXHRcdFx0dG9Gb2N1cyA9IHRoaXMuaGVhZGVyc1sgMCBdO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBrZXlDb2RlLkVORDpcblx0XHRcdHRvRm9jdXMgPSB0aGlzLmhlYWRlcnNbIGxlbmd0aCAtIDEgXTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGlmICggdG9Gb2N1cyApIHtcblx0XHRcdCQoIGV2ZW50LnRhcmdldCApLmF0dHIoIFwidGFiSW5kZXhcIiwgLTEgKTtcblx0XHRcdCQoIHRvRm9jdXMgKS5hdHRyKCBcInRhYkluZGV4XCIsIDAgKTtcblx0XHRcdCQoIHRvRm9jdXMgKS50cmlnZ2VyKCBcImZvY3VzXCIgKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9wYW5lbEtleURvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5VUCAmJiBldmVudC5jdHJsS2V5ICkge1xuXHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLnByZXYoKS50cmlnZ2VyKCBcImZvY3VzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0cmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cdFx0dGhpcy5fcHJvY2Vzc1BhbmVscygpO1xuXG5cdFx0Ly8gV2FzIGNvbGxhcHNlZCBvciBubyBwYW5lbFxuXHRcdGlmICggKCBvcHRpb25zLmFjdGl2ZSA9PT0gZmFsc2UgJiYgb3B0aW9ucy5jb2xsYXBzaWJsZSA9PT0gdHJ1ZSApIHx8XG5cdFx0XHRcdCF0aGlzLmhlYWRlcnMubGVuZ3RoICkge1xuXHRcdFx0b3B0aW9ucy5hY3RpdmUgPSBmYWxzZTtcblx0XHRcdHRoaXMuYWN0aXZlID0gJCgpO1xuXG5cdFx0Ly8gYWN0aXZlIGZhbHNlIG9ubHkgd2hlbiBjb2xsYXBzaWJsZSBpcyB0cnVlXG5cdFx0fSBlbHNlIGlmICggb3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIDAgKTtcblxuXHRcdC8vIHdhcyBhY3RpdmUsIGJ1dCBhY3RpdmUgcGFuZWwgaXMgZ29uZVxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuYWN0aXZlLmxlbmd0aCAmJiAhJC5jb250YWlucyggdGhpcy5lbGVtZW50WyAwIF0sIHRoaXMuYWN0aXZlWyAwIF0gKSApIHtcblxuXHRcdFx0Ly8gYWxsIHJlbWFpbmluZyBwYW5lbCBhcmUgZGlzYWJsZWRcblx0XHRcdGlmICggdGhpcy5oZWFkZXJzLmxlbmd0aCA9PT0gdGhpcy5oZWFkZXJzLmZpbmQoIFwiLnVpLXN0YXRlLWRpc2FibGVkXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdG9wdGlvbnMuYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuYWN0aXZlID0gJCgpO1xuXG5cdFx0XHQvLyBhY3RpdmF0ZSBwcmV2aW91cyBwYW5lbFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZhdGUoIE1hdGgubWF4KCAwLCBvcHRpb25zLmFjdGl2ZSAtIDEgKSApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gd2FzIGFjdGl2ZSwgYWN0aXZlIHBhbmVsIHN0aWxsIGV4aXN0c1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIG1ha2Ugc3VyZSBhY3RpdmUgaW5kZXggaXMgY29ycmVjdFxuXHRcdFx0b3B0aW9ucy5hY3RpdmUgPSB0aGlzLmhlYWRlcnMuaW5kZXgoIHRoaXMuYWN0aXZlICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZGVzdHJveUljb25zKCk7XG5cblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdH0sXG5cblx0X3Byb2Nlc3NQYW5lbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwcmV2SGVhZGVycyA9IHRoaXMuaGVhZGVycyxcblx0XHRcdHByZXZQYW5lbHMgPSB0aGlzLnBhbmVscztcblxuXHRcdHRoaXMuaGVhZGVycyA9IHRoaXMuZWxlbWVudC5maW5kKCB0aGlzLm9wdGlvbnMuaGVhZGVyICk7XG5cdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMuaGVhZGVycywgXCJ1aS1hY2NvcmRpb24taGVhZGVyIHVpLWFjY29yZGlvbi1oZWFkZXItY29sbGFwc2VkXCIsXG5cdFx0XHRcInVpLXN0YXRlLWRlZmF1bHRcIiApO1xuXG5cdFx0dGhpcy5wYW5lbHMgPSB0aGlzLmhlYWRlcnMubmV4dCgpLmZpbHRlciggXCI6bm90KC51aS1hY2NvcmRpb24tY29udGVudC1hY3RpdmUpXCIgKS5oaWRlKCk7XG5cdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMucGFuZWxzLCBcInVpLWFjY29yZGlvbi1jb250ZW50XCIsIFwidWktaGVscGVyLXJlc2V0IHVpLXdpZGdldC1jb250ZW50XCIgKTtcblxuXHRcdC8vIEF2b2lkIG1lbW9yeSBsZWFrcyAoIzEwMDU2KVxuXHRcdGlmICggcHJldlBhbmVscyApIHtcblx0XHRcdHRoaXMuX29mZiggcHJldkhlYWRlcnMubm90KCB0aGlzLmhlYWRlcnMgKSApO1xuXHRcdFx0dGhpcy5fb2ZmKCBwcmV2UGFuZWxzLm5vdCggdGhpcy5wYW5lbHMgKSApO1xuXHRcdH1cblx0fSxcblxuXHRfcmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1heEhlaWdodCxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRoZWlnaHRTdHlsZSA9IG9wdGlvbnMuaGVpZ2h0U3R5bGUsXG5cdFx0XHRwYXJlbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50KCk7XG5cblx0XHR0aGlzLmFjdGl2ZSA9IHRoaXMuX2ZpbmRBY3RpdmUoIG9wdGlvbnMuYWN0aXZlICk7XG5cdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMuYWN0aXZlLCBcInVpLWFjY29yZGlvbi1oZWFkZXItYWN0aXZlXCIsIFwidWktc3RhdGUtYWN0aXZlXCIgKVxuXHRcdFx0Ll9yZW1vdmVDbGFzcyggdGhpcy5hY3RpdmUsIFwidWktYWNjb3JkaW9uLWhlYWRlci1jb2xsYXBzZWRcIiApO1xuXHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLmFjdGl2ZS5uZXh0KCksIFwidWktYWNjb3JkaW9uLWNvbnRlbnQtYWN0aXZlXCIgKTtcblx0XHR0aGlzLmFjdGl2ZS5uZXh0KCkuc2hvdygpO1xuXG5cdFx0dGhpcy5oZWFkZXJzXG5cdFx0XHQuYXR0ciggXCJyb2xlXCIsIFwidGFiXCIgKVxuXHRcdFx0LmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaGVhZGVyID0gJCggdGhpcyApLFxuXHRcdFx0XHRcdGhlYWRlcklkID0gaGVhZGVyLnVuaXF1ZUlkKCkuYXR0ciggXCJpZFwiICksXG5cdFx0XHRcdFx0cGFuZWwgPSBoZWFkZXIubmV4dCgpLFxuXHRcdFx0XHRcdHBhbmVsSWQgPSBwYW5lbC51bmlxdWVJZCgpLmF0dHIoIFwiaWRcIiApO1xuXHRcdFx0XHRoZWFkZXIuYXR0ciggXCJhcmlhLWNvbnRyb2xzXCIsIHBhbmVsSWQgKTtcblx0XHRcdFx0cGFuZWwuYXR0ciggXCJhcmlhLWxhYmVsbGVkYnlcIiwgaGVhZGVySWQgKTtcblx0XHRcdH0gKVxuXHRcdFx0Lm5leHQoKVxuXHRcdFx0XHQuYXR0ciggXCJyb2xlXCIsIFwidGFicGFuZWxcIiApO1xuXG5cdFx0dGhpcy5oZWFkZXJzXG5cdFx0XHQubm90KCB0aGlzLmFjdGl2ZSApXG5cdFx0XHRcdC5hdHRyKCB7XG5cdFx0XHRcdFx0XCJhcmlhLXNlbGVjdGVkXCI6IFwiZmFsc2VcIixcblx0XHRcdFx0XHRcImFyaWEtZXhwYW5kZWRcIjogXCJmYWxzZVwiLFxuXHRcdFx0XHRcdHRhYkluZGV4OiAtMVxuXHRcdFx0XHR9IClcblx0XHRcdFx0Lm5leHQoKVxuXHRcdFx0XHRcdC5hdHRyKCB7XG5cdFx0XHRcdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiXG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0LmhpZGUoKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSBhdCBsZWFzdCBvbmUgaGVhZGVyIGlzIGluIHRoZSB0YWIgb3JkZXJcblx0XHRpZiAoICF0aGlzLmFjdGl2ZS5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLmhlYWRlcnMuZXEoIDAgKS5hdHRyKCBcInRhYkluZGV4XCIsIDAgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hY3RpdmUuYXR0cigge1xuXHRcdFx0XHRcImFyaWEtc2VsZWN0ZWRcIjogXCJ0cnVlXCIsXG5cdFx0XHRcdFwiYXJpYS1leHBhbmRlZFwiOiBcInRydWVcIixcblx0XHRcdFx0dGFiSW5kZXg6IDBcblx0XHRcdH0gKVxuXHRcdFx0XHQubmV4dCgpXG5cdFx0XHRcdFx0LmF0dHIoIHtcblx0XHRcdFx0XHRcdFwiYXJpYS1oaWRkZW5cIjogXCJmYWxzZVwiXG5cdFx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NyZWF0ZUljb25zKCk7XG5cblx0XHR0aGlzLl9zZXR1cEV2ZW50cyggb3B0aW9ucy5ldmVudCApO1xuXG5cdFx0aWYgKCBoZWlnaHRTdHlsZSA9PT0gXCJmaWxsXCIgKSB7XG5cdFx0XHRtYXhIZWlnaHQgPSBwYXJlbnQuaGVpZ2h0KCk7XG5cdFx0XHR0aGlzLmVsZW1lbnQuc2libGluZ3MoIFwiOnZpc2libGVcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9ICQoIHRoaXMgKSxcblx0XHRcdFx0XHRwb3NpdGlvbiA9IGVsZW0uY3NzKCBcInBvc2l0aW9uXCIgKTtcblxuXHRcdFx0XHRpZiAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF4SGVpZ2h0IC09IGVsZW0ub3V0ZXJIZWlnaHQoIHRydWUgKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5oZWFkZXJzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRtYXhIZWlnaHQgLT0gJCggdGhpcyApLm91dGVySGVpZ2h0KCB0cnVlICk7XG5cdFx0XHR9ICk7XG5cblx0XHRcdHRoaXMuaGVhZGVycy5uZXh0KClcblx0XHRcdFx0LmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCQoIHRoaXMgKS5oZWlnaHQoIE1hdGgubWF4KCAwLCBtYXhIZWlnaHQgLVxuXHRcdFx0XHRcdFx0JCggdGhpcyApLmlubmVySGVpZ2h0KCkgKyAkKCB0aGlzICkuaGVpZ2h0KCkgKSApO1xuXHRcdFx0XHR9IClcblx0XHRcdFx0LmNzcyggXCJvdmVyZmxvd1wiLCBcImF1dG9cIiApO1xuXHRcdH0gZWxzZSBpZiAoIGhlaWdodFN0eWxlID09PSBcImF1dG9cIiApIHtcblx0XHRcdG1heEhlaWdodCA9IDA7XG5cdFx0XHR0aGlzLmhlYWRlcnMubmV4dCgpXG5cdFx0XHRcdC5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgaXNWaXNpYmxlID0gJCggdGhpcyApLmlzKCBcIjp2aXNpYmxlXCIgKTtcblx0XHRcdFx0XHRpZiAoICFpc1Zpc2libGUgKSB7XG5cdFx0XHRcdFx0XHQkKCB0aGlzICkuc2hvdygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtYXhIZWlnaHQgPSBNYXRoLm1heCggbWF4SGVpZ2h0LCAkKCB0aGlzICkuY3NzKCBcImhlaWdodFwiLCBcIlwiICkuaGVpZ2h0KCkgKTtcblx0XHRcdFx0XHRpZiAoICFpc1Zpc2libGUgKSB7XG5cdFx0XHRcdFx0XHQkKCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApXG5cdFx0XHRcdC5oZWlnaHQoIG1heEhlaWdodCApO1xuXHRcdH1cblx0fSxcblxuXHRfYWN0aXZhdGU6IGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHR2YXIgYWN0aXZlID0gdGhpcy5fZmluZEFjdGl2ZSggaW5kZXggKVsgMCBdO1xuXG5cdFx0Ly8gVHJ5aW5nIHRvIGFjdGl2YXRlIHRoZSBhbHJlYWR5IGFjdGl2ZSBwYW5lbFxuXHRcdGlmICggYWN0aXZlID09PSB0aGlzLmFjdGl2ZVsgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFRyeWluZyB0byBjb2xsYXBzZSwgc2ltdWxhdGUgYSBjbGljayBvbiB0aGUgY3VycmVudGx5IGFjdGl2ZSBoZWFkZXJcblx0XHRhY3RpdmUgPSBhY3RpdmUgfHwgdGhpcy5hY3RpdmVbIDAgXTtcblxuXHRcdHRoaXMuX2V2ZW50SGFuZGxlcigge1xuXHRcdFx0dGFyZ2V0OiBhY3RpdmUsXG5cdFx0XHRjdXJyZW50VGFyZ2V0OiBhY3RpdmUsXG5cdFx0XHRwcmV2ZW50RGVmYXVsdDogJC5ub29wXG5cdFx0fSApO1xuXHR9LFxuXG5cdF9maW5kQWN0aXZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJudW1iZXJcIiA/IHRoaXMuaGVhZGVycy5lcSggc2VsZWN0b3IgKSA6ICQoKTtcblx0fSxcblxuXHRfc2V0dXBFdmVudHM6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0a2V5ZG93bjogXCJfa2V5ZG93blwiXG5cdFx0fTtcblx0XHRpZiAoIGV2ZW50ICkge1xuXHRcdFx0JC5lYWNoKCBldmVudC5zcGxpdCggXCIgXCIgKSwgZnVuY3Rpb24oIGluZGV4LCBldmVudE5hbWUgKSB7XG5cdFx0XHRcdGV2ZW50c1sgZXZlbnROYW1lIF0gPSBcIl9ldmVudEhhbmRsZXJcIjtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR0aGlzLl9vZmYoIHRoaXMuaGVhZGVycy5hZGQoIHRoaXMuaGVhZGVycy5uZXh0KCkgKSApO1xuXHRcdHRoaXMuX29uKCB0aGlzLmhlYWRlcnMsIGV2ZW50cyApO1xuXHRcdHRoaXMuX29uKCB0aGlzLmhlYWRlcnMubmV4dCgpLCB7IGtleWRvd246IFwiX3BhbmVsS2V5RG93blwiIH0gKTtcblx0XHR0aGlzLl9ob3ZlcmFibGUoIHRoaXMuaGVhZGVycyApO1xuXHRcdHRoaXMuX2ZvY3VzYWJsZSggdGhpcy5oZWFkZXJzICk7XG5cdH0sXG5cblx0X2V2ZW50SGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBhY3RpdmVDaGlsZHJlbiwgY2xpY2tlZENoaWxkcmVuLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGFjdGl2ZSA9IHRoaXMuYWN0aXZlLFxuXHRcdFx0Y2xpY2tlZCA9ICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSxcblx0XHRcdGNsaWNrZWRJc0FjdGl2ZSA9IGNsaWNrZWRbIDAgXSA9PT0gYWN0aXZlWyAwIF0sXG5cdFx0XHRjb2xsYXBzaW5nID0gY2xpY2tlZElzQWN0aXZlICYmIG9wdGlvbnMuY29sbGFwc2libGUsXG5cdFx0XHR0b1Nob3cgPSBjb2xsYXBzaW5nID8gJCgpIDogY2xpY2tlZC5uZXh0KCksXG5cdFx0XHR0b0hpZGUgPSBhY3RpdmUubmV4dCgpLFxuXHRcdFx0ZXZlbnREYXRhID0ge1xuXHRcdFx0XHRvbGRIZWFkZXI6IGFjdGl2ZSxcblx0XHRcdFx0b2xkUGFuZWw6IHRvSGlkZSxcblx0XHRcdFx0bmV3SGVhZGVyOiBjb2xsYXBzaW5nID8gJCgpIDogY2xpY2tlZCxcblx0XHRcdFx0bmV3UGFuZWw6IHRvU2hvd1xuXHRcdFx0fTtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRpZiAoXG5cblx0XHRcdFx0Ly8gY2xpY2sgb24gYWN0aXZlIGhlYWRlciwgYnV0IG5vdCBjb2xsYXBzaWJsZVxuXHRcdFx0XHQoIGNsaWNrZWRJc0FjdGl2ZSAmJiAhb3B0aW9ucy5jb2xsYXBzaWJsZSApIHx8XG5cblx0XHRcdFx0Ly8gYWxsb3cgY2FuY2VsaW5nIGFjdGl2YXRpb25cblx0XHRcdFx0KCB0aGlzLl90cmlnZ2VyKCBcImJlZm9yZUFjdGl2YXRlXCIsIGV2ZW50LCBldmVudERhdGEgKSA9PT0gZmFsc2UgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRvcHRpb25zLmFjdGl2ZSA9IGNvbGxhcHNpbmcgPyBmYWxzZSA6IHRoaXMuaGVhZGVycy5pbmRleCggY2xpY2tlZCApO1xuXG5cdFx0Ly8gV2hlbiB0aGUgY2FsbCB0byAuX3RvZ2dsZSgpIGNvbWVzIGFmdGVyIHRoZSBjbGFzcyBjaGFuZ2VzXG5cdFx0Ly8gaXQgY2F1c2VzIGEgdmVyeSBvZGQgYnVnIGluIElFIDggKHNlZSAjNjcyMClcblx0XHR0aGlzLmFjdGl2ZSA9IGNsaWNrZWRJc0FjdGl2ZSA/ICQoKSA6IGNsaWNrZWQ7XG5cdFx0dGhpcy5fdG9nZ2xlKCBldmVudERhdGEgKTtcblxuXHRcdC8vIFN3aXRjaCBjbGFzc2VzXG5cdFx0Ly8gY29ybmVyIGNsYXNzZXMgb24gdGhlIHByZXZpb3VzbHkgYWN0aXZlIGhlYWRlciBzdGF5IGFmdGVyIHRoZSBhbmltYXRpb25cblx0XHR0aGlzLl9yZW1vdmVDbGFzcyggYWN0aXZlLCBcInVpLWFjY29yZGlvbi1oZWFkZXItYWN0aXZlXCIsIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRpZiAoIG9wdGlvbnMuaWNvbnMgKSB7XG5cdFx0XHRhY3RpdmVDaGlsZHJlbiA9IGFjdGl2ZS5jaGlsZHJlbiggXCIudWktYWNjb3JkaW9uLWhlYWRlci1pY29uXCIgKTtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBhY3RpdmVDaGlsZHJlbiwgbnVsbCwgb3B0aW9ucy5pY29ucy5hY3RpdmVIZWFkZXIgKVxuXHRcdFx0XHQuX2FkZENsYXNzKCBhY3RpdmVDaGlsZHJlbiwgbnVsbCwgb3B0aW9ucy5pY29ucy5oZWFkZXIgKTtcblx0XHR9XG5cblx0XHRpZiAoICFjbGlja2VkSXNBY3RpdmUgKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggY2xpY2tlZCwgXCJ1aS1hY2NvcmRpb24taGVhZGVyLWNvbGxhcHNlZFwiIClcblx0XHRcdFx0Ll9hZGRDbGFzcyggY2xpY2tlZCwgXCJ1aS1hY2NvcmRpb24taGVhZGVyLWFjdGl2ZVwiLCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRpZiAoIG9wdGlvbnMuaWNvbnMgKSB7XG5cdFx0XHRcdGNsaWNrZWRDaGlsZHJlbiA9IGNsaWNrZWQuY2hpbGRyZW4oIFwiLnVpLWFjY29yZGlvbi1oZWFkZXItaWNvblwiICk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBjbGlja2VkQ2hpbGRyZW4sIG51bGwsIG9wdGlvbnMuaWNvbnMuaGVhZGVyIClcblx0XHRcdFx0XHQuX2FkZENsYXNzKCBjbGlja2VkQ2hpbGRyZW4sIG51bGwsIG9wdGlvbnMuaWNvbnMuYWN0aXZlSGVhZGVyICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2FkZENsYXNzKCBjbGlja2VkLm5leHQoKSwgXCJ1aS1hY2NvcmRpb24tY29udGVudC1hY3RpdmVcIiApO1xuXHRcdH1cblx0fSxcblxuXHRfdG9nZ2xlOiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHR2YXIgdG9TaG93ID0gZGF0YS5uZXdQYW5lbCxcblx0XHRcdHRvSGlkZSA9IHRoaXMucHJldlNob3cubGVuZ3RoID8gdGhpcy5wcmV2U2hvdyA6IGRhdGEub2xkUGFuZWw7XG5cblx0XHQvLyBIYW5kbGUgYWN0aXZhdGluZyBhIHBhbmVsIGR1cmluZyB0aGUgYW5pbWF0aW9uIGZvciBhbm90aGVyIGFjdGl2YXRpb25cblx0XHR0aGlzLnByZXZTaG93LmFkZCggdGhpcy5wcmV2SGlkZSApLnN0b3AoIHRydWUsIHRydWUgKTtcblx0XHR0aGlzLnByZXZTaG93ID0gdG9TaG93O1xuXHRcdHRoaXMucHJldkhpZGUgPSB0b0hpZGU7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5hbmltYXRlICkge1xuXHRcdFx0dGhpcy5fYW5pbWF0ZSggdG9TaG93LCB0b0hpZGUsIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dG9IaWRlLmhpZGUoKTtcblx0XHRcdHRvU2hvdy5zaG93KCk7XG5cdFx0XHR0aGlzLl90b2dnbGVDb21wbGV0ZSggZGF0YSApO1xuXHRcdH1cblxuXHRcdHRvSGlkZS5hdHRyKCB7XG5cdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiXG5cdFx0fSApO1xuXHRcdHRvSGlkZS5wcmV2KCkuYXR0cigge1xuXHRcdFx0XCJhcmlhLXNlbGVjdGVkXCI6IFwiZmFsc2VcIixcblx0XHRcdFwiYXJpYS1leHBhbmRlZFwiOiBcImZhbHNlXCJcblx0XHR9ICk7XG5cblx0XHQvLyBpZiB3ZSdyZSBzd2l0Y2hpbmcgcGFuZWxzLCByZW1vdmUgdGhlIG9sZCBoZWFkZXIgZnJvbSB0aGUgdGFiIG9yZGVyXG5cdFx0Ly8gaWYgd2UncmUgb3BlbmluZyBmcm9tIGNvbGxhcHNlZCBzdGF0ZSwgcmVtb3ZlIHRoZSBwcmV2aW91cyBoZWFkZXIgZnJvbSB0aGUgdGFiIG9yZGVyXG5cdFx0Ly8gaWYgd2UncmUgY29sbGFwc2luZywgdGhlbiBrZWVwIHRoZSBjb2xsYXBzaW5nIGhlYWRlciBpbiB0aGUgdGFiIG9yZGVyXG5cdFx0aWYgKCB0b1Nob3cubGVuZ3RoICYmIHRvSGlkZS5sZW5ndGggKSB7XG5cdFx0XHR0b0hpZGUucHJldigpLmF0dHIoIHtcblx0XHRcdFx0XCJ0YWJJbmRleFwiOiAtMSxcblx0XHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwiZmFsc2VcIlxuXHRcdFx0fSApO1xuXHRcdH0gZWxzZSBpZiAoIHRvU2hvdy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLmhlYWRlcnMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCAkKCB0aGlzICkuYXR0ciggXCJ0YWJJbmRleFwiICksIDEwICkgPT09IDA7XG5cdFx0XHR9IClcblx0XHRcdFx0LmF0dHIoIFwidGFiSW5kZXhcIiwgLTEgKTtcblx0XHR9XG5cblx0XHR0b1Nob3dcblx0XHRcdC5hdHRyKCBcImFyaWEtaGlkZGVuXCIsIFwiZmFsc2VcIiApXG5cdFx0XHQucHJldigpXG5cdFx0XHRcdC5hdHRyKCB7XG5cdFx0XHRcdFx0XCJhcmlhLXNlbGVjdGVkXCI6IFwidHJ1ZVwiLFxuXHRcdFx0XHRcdFwiYXJpYS1leHBhbmRlZFwiOiBcInRydWVcIixcblx0XHRcdFx0XHR0YWJJbmRleDogMFxuXHRcdFx0XHR9ICk7XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZ1bmN0aW9uKCB0b1Nob3csIHRvSGlkZSwgZGF0YSApIHtcblx0XHR2YXIgdG90YWwsIGVhc2luZywgZHVyYXRpb24sXG5cdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdGFkanVzdCA9IDAsXG5cdFx0XHRib3hTaXppbmcgPSB0b1Nob3cuY3NzKCBcImJveC1zaXppbmdcIiApLFxuXHRcdFx0ZG93biA9IHRvU2hvdy5sZW5ndGggJiZcblx0XHRcdFx0KCAhdG9IaWRlLmxlbmd0aCB8fCAoIHRvU2hvdy5pbmRleCgpIDwgdG9IaWRlLmluZGV4KCkgKSApLFxuXHRcdFx0YW5pbWF0ZSA9IHRoaXMub3B0aW9ucy5hbmltYXRlIHx8IHt9LFxuXHRcdFx0b3B0aW9ucyA9IGRvd24gJiYgYW5pbWF0ZS5kb3duIHx8IGFuaW1hdGUsXG5cdFx0XHRjb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGF0Ll90b2dnbGVDb21wbGV0ZSggZGF0YSApO1xuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRkdXJhdGlvbiA9IG9wdGlvbnM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRlYXNpbmcgPSBvcHRpb25zO1xuXHRcdH1cblxuXHRcdC8vIGZhbGwgYmFjayBmcm9tIG9wdGlvbnMgdG8gYW5pbWF0aW9uIGluIGNhc2Ugb2YgcGFydGlhbCBkb3duIHNldHRpbmdzXG5cdFx0ZWFzaW5nID0gZWFzaW5nIHx8IG9wdGlvbnMuZWFzaW5nIHx8IGFuaW1hdGUuZWFzaW5nO1xuXHRcdGR1cmF0aW9uID0gZHVyYXRpb24gfHwgb3B0aW9ucy5kdXJhdGlvbiB8fCBhbmltYXRlLmR1cmF0aW9uO1xuXG5cdFx0aWYgKCAhdG9IaWRlLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0b1Nob3cuYW5pbWF0ZSggdGhpcy5zaG93UHJvcHMsIGR1cmF0aW9uLCBlYXNpbmcsIGNvbXBsZXRlICk7XG5cdFx0fVxuXHRcdGlmICggIXRvU2hvdy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdG9IaWRlLmFuaW1hdGUoIHRoaXMuaGlkZVByb3BzLCBkdXJhdGlvbiwgZWFzaW5nLCBjb21wbGV0ZSApO1xuXHRcdH1cblxuXHRcdHRvdGFsID0gdG9TaG93LnNob3coKS5vdXRlckhlaWdodCgpO1xuXHRcdHRvSGlkZS5hbmltYXRlKCB0aGlzLmhpZGVQcm9wcywge1xuXHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuXHRcdFx0ZWFzaW5nOiBlYXNpbmcsXG5cdFx0XHRzdGVwOiBmdW5jdGlvbiggbm93LCBmeCApIHtcblx0XHRcdFx0Zngubm93ID0gTWF0aC5yb3VuZCggbm93ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHRvU2hvd1xuXHRcdFx0LmhpZGUoKVxuXHRcdFx0LmFuaW1hdGUoIHRoaXMuc2hvd1Byb3BzLCB7XG5cdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvbixcblx0XHRcdFx0ZWFzaW5nOiBlYXNpbmcsXG5cdFx0XHRcdGNvbXBsZXRlOiBjb21wbGV0ZSxcblx0XHRcdFx0c3RlcDogZnVuY3Rpb24oIG5vdywgZnggKSB7XG5cdFx0XHRcdFx0Zngubm93ID0gTWF0aC5yb3VuZCggbm93ICk7XG5cdFx0XHRcdFx0aWYgKCBmeC5wcm9wICE9PSBcImhlaWdodFwiICkge1xuXHRcdFx0XHRcdFx0aWYgKCBib3hTaXppbmcgPT09IFwiY29udGVudC1ib3hcIiApIHtcblx0XHRcdFx0XHRcdFx0YWRqdXN0ICs9IGZ4Lm5vdztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0aGF0Lm9wdGlvbnMuaGVpZ2h0U3R5bGUgIT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRcdFx0Zngubm93ID0gTWF0aC5yb3VuZCggdG90YWwgLSB0b0hpZGUub3V0ZXJIZWlnaHQoKSAtIGFkanVzdCApO1xuXHRcdFx0XHRcdFx0YWRqdXN0ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblxuXHRfdG9nZ2xlQ29tcGxldGU6IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdHZhciB0b0hpZGUgPSBkYXRhLm9sZFBhbmVsLFxuXHRcdFx0cHJldiA9IHRvSGlkZS5wcmV2KCk7XG5cblx0XHR0aGlzLl9yZW1vdmVDbGFzcyggdG9IaWRlLCBcInVpLWFjY29yZGlvbi1jb250ZW50LWFjdGl2ZVwiICk7XG5cdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIHByZXYsIFwidWktYWNjb3JkaW9uLWhlYWRlci1hY3RpdmVcIiApXG5cdFx0XHQuX2FkZENsYXNzKCBwcmV2LCBcInVpLWFjY29yZGlvbi1oZWFkZXItY29sbGFwc2VkXCIgKTtcblxuXHRcdC8vIFdvcmsgYXJvdW5kIGZvciByZW5kZXJpbmcgYnVnIGluIElFICgjNTQyMSlcblx0XHRpZiAoIHRvSGlkZS5sZW5ndGggKSB7XG5cdFx0XHR0b0hpZGUucGFyZW50KClbIDAgXS5jbGFzc05hbWUgPSB0b0hpZGUucGFyZW50KClbIDAgXS5jbGFzc05hbWU7XG5cdFx0fVxuXHRcdHRoaXMuX3RyaWdnZXIoIFwiYWN0aXZhdGVcIiwgbnVsbCwgZGF0YSApO1xuXHR9XG59ICk7XG5cblxuXG52YXIgc2FmZUFjdGl2ZUVsZW1lbnQgPSAkLnVpLnNhZmVBY3RpdmVFbGVtZW50ID0gZnVuY3Rpb24oIGRvY3VtZW50ICkge1xuXHR2YXIgYWN0aXZlRWxlbWVudDtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0Ly8gSUU5IHRocm93cyBhbiBcIlVuc3BlY2lmaWVkIGVycm9yXCIgYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgZnJvbSBhbiA8aWZyYW1lPlxuXHR0cnkge1xuXHRcdGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyb3IgKSB7XG5cdFx0YWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmJvZHk7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSBtYXkgcmV0dXJuIG51bGwgaW5zdGVhZCBvZiBhbiBlbGVtZW50XG5cdC8vIEludGVyZXN0aW5nbHksIHRoaXMgb25seSBzZWVtcyB0byBvY2N1ciB3aGVuIE5PVCBpbiBhbiBpZnJhbWVcblx0aWYgKCAhYWN0aXZlRWxlbWVudCApIHtcblx0XHRhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0Ly8gSUUxMSByZXR1cm5zIGEgc2VlbWluZ2x5IGVtcHR5IG9iamVjdCBpbiBzb21lIGNhc2VzIHdoZW4gYWNjZXNzaW5nXG5cdC8vIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgZnJvbSBhbiA8aWZyYW1lPlxuXHRpZiAoICFhY3RpdmVFbGVtZW50Lm5vZGVOYW1lICkge1xuXHRcdGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5ib2R5O1xuXHR9XG5cblx0cmV0dXJuIGFjdGl2ZUVsZW1lbnQ7XG59O1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIE1lbnUgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IE1lbnVcbi8vPj5ncm91cDogV2lkZ2V0c1xuLy8+PmRlc2NyaXB0aW9uOiBDcmVhdGVzIG5lc3RhYmxlIG1lbnVzLlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL21lbnUvXG4vLz4+ZGVtb3M6IGh0dHA6Ly9qcXVlcnl1aS5jb20vbWVudS9cbi8vPj5jc3Muc3RydWN0dXJlOiAuLi8uLi90aGVtZXMvYmFzZS9jb3JlLmNzc1xuLy8+PmNzcy5zdHJ1Y3R1cmU6IC4uLy4uL3RoZW1lcy9iYXNlL21lbnUuY3NzXG4vLz4+Y3NzLnRoZW1lOiAuLi8uLi90aGVtZXMvYmFzZS90aGVtZS5jc3NcblxuXG5cbnZhciB3aWRnZXRzTWVudSA9ICQud2lkZ2V0KCBcInVpLm1lbnVcIiwge1xuXHR2ZXJzaW9uOiBcIjEuMTIuMVwiLFxuXHRkZWZhdWx0RWxlbWVudDogXCI8dWw+XCIsXG5cdGRlbGF5OiAzMDAsXG5cdG9wdGlvbnM6IHtcblx0XHRpY29uczoge1xuXHRcdFx0c3VibWVudTogXCJ1aS1pY29uLWNhcmV0LTEtZVwiXG5cdFx0fSxcblx0XHRpdGVtczogXCI+ICpcIixcblx0XHRtZW51czogXCJ1bFwiLFxuXHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRteTogXCJsZWZ0IHRvcFwiLFxuXHRcdFx0YXQ6IFwicmlnaHQgdG9wXCJcblx0XHR9LFxuXHRcdHJvbGU6IFwibWVudVwiLFxuXG5cdFx0Ly8gQ2FsbGJhY2tzXG5cdFx0Ymx1cjogbnVsbCxcblx0XHRmb2N1czogbnVsbCxcblx0XHRzZWxlY3Q6IG51bGxcblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmFjdGl2ZU1lbnUgPSB0aGlzLmVsZW1lbnQ7XG5cblx0XHQvLyBGbGFnIHVzZWQgdG8gcHJldmVudCBmaXJpbmcgb2YgdGhlIGNsaWNrIGhhbmRsZXJcblx0XHQvLyBhcyB0aGUgZXZlbnQgYnViYmxlcyB1cCB0aHJvdWdoIG5lc3RlZCBtZW51c1xuXHRcdHRoaXMubW91c2VIYW5kbGVkID0gZmFsc2U7XG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQudW5pcXVlSWQoKVxuXHRcdFx0LmF0dHIoIHtcblx0XHRcdFx0cm9sZTogdGhpcy5vcHRpb25zLnJvbGUsXG5cdFx0XHRcdHRhYkluZGV4OiAwXG5cdFx0XHR9ICk7XG5cblx0XHR0aGlzLl9hZGRDbGFzcyggXCJ1aS1tZW51XCIsIFwidWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50XCIgKTtcblx0XHR0aGlzLl9vbigge1xuXG5cdFx0XHQvLyBQcmV2ZW50IGZvY3VzIGZyb20gc3RpY2tpbmcgdG8gbGlua3MgaW5zaWRlIG1lbnUgYWZ0ZXIgY2xpY2tpbmdcblx0XHRcdC8vIHRoZW0gKGZvY3VzIHNob3VsZCBhbHdheXMgc3RheSBvbiBVTCBkdXJpbmcgbmF2aWdhdGlvbikuXG5cdFx0XHRcIm1vdXNlZG93biAudWktbWVudS1pdGVtXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH0sXG5cdFx0XHRcImNsaWNrIC51aS1tZW51LWl0ZW1cIjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gJCggZXZlbnQudGFyZ2V0ICk7XG5cdFx0XHRcdHZhciBhY3RpdmUgPSAkKCAkLnVpLnNhZmVBY3RpdmVFbGVtZW50KCB0aGlzLmRvY3VtZW50WyAwIF0gKSApO1xuXHRcdFx0XHRpZiAoICF0aGlzLm1vdXNlSGFuZGxlZCAmJiB0YXJnZXQubm90KCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0KCBldmVudCApO1xuXG5cdFx0XHRcdFx0Ly8gT25seSBzZXQgdGhlIG1vdXNlSGFuZGxlZCBmbGFnIGlmIHRoZSBldmVudCB3aWxsIGJ1YmJsZSwgc2VlICM5NDY5LlxuXHRcdFx0XHRcdGlmICggIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1vdXNlSGFuZGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT3BlbiBzdWJtZW51IG9uIGNsaWNrXG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQuaGFzKCBcIi51aS1tZW51XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmV4cGFuZCggZXZlbnQgKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhdGhpcy5lbGVtZW50LmlzKCBcIjpmb2N1c1wiICkgJiZcblx0XHRcdFx0XHRcdFx0YWN0aXZlLmNsb3Nlc3QoIFwiLnVpLW1lbnVcIiApLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVkaXJlY3QgZm9jdXMgdG8gdGhlIG1lbnVcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC50cmlnZ2VyKCBcImZvY3VzXCIsIFsgdHJ1ZSBdICk7XG5cblx0XHRcdFx0XHRcdC8vIElmIHRoZSBhY3RpdmUgaXRlbSBpcyBvbiB0aGUgdG9wIGxldmVsLCBsZXQgaXQgc3RheSBhY3RpdmUuXG5cdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGJsdXIgdGhlIGFjdGl2ZSBpdGVtIHNpbmNlIGl0IGlzIG5vIGxvbmdlciB2aXNpYmxlLlxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLmFjdGl2ZSAmJiB0aGlzLmFjdGl2ZS5wYXJlbnRzKCBcIi51aS1tZW51XCIgKS5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGNsZWFyVGltZW91dCggdGhpcy50aW1lciApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdFwibW91c2VlbnRlciAudWktbWVudS1pdGVtXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBJZ25vcmUgbW91c2UgZXZlbnRzIHdoaWxlIHR5cGVhaGVhZCBpcyBhY3RpdmUsIHNlZSAjMTA0NTguXG5cdFx0XHRcdC8vIFByZXZlbnRzIGZvY3VzaW5nIHRoZSB3cm9uZyBpdGVtIHdoZW4gdHlwZWFoZWFkIGNhdXNlcyBhIHNjcm9sbCB3aGlsZSB0aGUgbW91c2Vcblx0XHRcdFx0Ly8gaXMgb3ZlciBhbiBpdGVtIGluIHRoZSBtZW51XG5cdFx0XHRcdGlmICggdGhpcy5wcmV2aW91c0ZpbHRlciApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgYWN0dWFsVGFyZ2V0ID0gJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggXCIudWktbWVudS1pdGVtXCIgKSxcblx0XHRcdFx0XHR0YXJnZXQgPSAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICk7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGJ1YmJsZWQgZXZlbnRzIG9uIHBhcmVudCBpdGVtcywgc2VlICMxMTY0MVxuXHRcdFx0XHRpZiAoIGFjdHVhbFRhcmdldFsgMCBdICE9PSB0YXJnZXRbIDAgXSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZW1vdmUgdWktc3RhdGUtYWN0aXZlIGNsYXNzIGZyb20gc2libGluZ3Mgb2YgdGhlIG5ld2x5IGZvY3VzZWQgbWVudSBpdGVtXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGEganVtcCBjYXVzZWQgYnkgYWRqYWNlbnQgZWxlbWVudHMgYm90aCBoYXZpbmcgYSBjbGFzcyB3aXRoIGEgYm9yZGVyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0YXJnZXQuc2libGluZ3MoKS5jaGlsZHJlbiggXCIudWktc3RhdGUtYWN0aXZlXCIgKSxcblx0XHRcdFx0XHRudWxsLCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdHRoaXMuZm9jdXMoIGV2ZW50LCB0YXJnZXQgKTtcblx0XHRcdH0sXG5cdFx0XHRtb3VzZWxlYXZlOiBcImNvbGxhcHNlQWxsXCIsXG5cdFx0XHRcIm1vdXNlbGVhdmUgLnVpLW1lbnVcIjogXCJjb2xsYXBzZUFsbFwiLFxuXHRcdFx0Zm9jdXM6IGZ1bmN0aW9uKCBldmVudCwga2VlcEFjdGl2ZUl0ZW0gKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUncyBhbHJlYWR5IGFuIGFjdGl2ZSBpdGVtLCBrZWVwIGl0IGFjdGl2ZVxuXHRcdFx0XHQvLyBJZiBub3QsIGFjdGl2YXRlIHRoZSBmaXJzdCBpdGVtXG5cdFx0XHRcdHZhciBpdGVtID0gdGhpcy5hY3RpdmUgfHwgdGhpcy5lbGVtZW50LmZpbmQoIHRoaXMub3B0aW9ucy5pdGVtcyApLmVxKCAwICk7XG5cblx0XHRcdFx0aWYgKCAha2VlcEFjdGl2ZUl0ZW0gKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIGl0ZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGJsdXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dGhpcy5fZGVsYXkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBub3RDb250YWluZWQgPSAhJC5jb250YWlucyhcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudFsgMCBdLFxuXHRcdFx0XHRcdFx0JC51aS5zYWZlQWN0aXZlRWxlbWVudCggdGhpcy5kb2N1bWVudFsgMCBdIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGlmICggbm90Q29udGFpbmVkICkge1xuXHRcdFx0XHRcdFx0dGhpcy5jb2xsYXBzZUFsbCggZXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0sXG5cdFx0XHRrZXlkb3duOiBcIl9rZXlkb3duXCJcblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlZnJlc2goKTtcblxuXHRcdC8vIENsaWNrcyBvdXRzaWRlIG9mIGEgbWVudSBjb2xsYXBzZSBhbnkgb3BlbiBtZW51c1xuXHRcdHRoaXMuX29uKCB0aGlzLmRvY3VtZW50LCB7XG5cdFx0XHRjbGljazogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuX2Nsb3NlT25Eb2N1bWVudENsaWNrKCBldmVudCApICkge1xuXHRcdFx0XHRcdHRoaXMuY29sbGFwc2VBbGwoIGV2ZW50ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNldCB0aGUgbW91c2VIYW5kbGVkIGZsYWdcblx0XHRcdFx0dGhpcy5tb3VzZUhhbmRsZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpdGVtcyA9IHRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1tZW51LWl0ZW1cIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGUgYXJpYS1kaXNhYmxlZFwiICksXG5cdFx0XHRzdWJtZW51cyA9IGl0ZW1zLmNoaWxkcmVuKCBcIi51aS1tZW51LWl0ZW0td3JhcHBlclwiIClcblx0XHRcdFx0LnJlbW92ZVVuaXF1ZUlkKClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwidGFiSW5kZXggcm9sZSBhcmlhLWhhc3BvcHVwXCIgKTtcblxuXHRcdC8vIERlc3Ryb3kgKHN1YiltZW51c1xuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIgKVxuXHRcdFx0LmZpbmQoIFwiLnVpLW1lbnVcIiApLmFkZEJhY2soKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggXCJyb2xlIGFyaWEtbGFiZWxsZWRieSBhcmlhLWV4cGFuZGVkIGFyaWEtaGlkZGVuIGFyaWEtZGlzYWJsZWQgXCIgK1xuXHRcdFx0XHRcdFwidGFiSW5kZXhcIiApXG5cdFx0XHRcdC5yZW1vdmVVbmlxdWVJZCgpXG5cdFx0XHRcdC5zaG93KCk7XG5cblx0XHRzdWJtZW51cy5jaGlsZHJlbigpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsZW0gPSAkKCB0aGlzICk7XG5cdFx0XHRpZiAoIGVsZW0uZGF0YSggXCJ1aS1tZW51LXN1Ym1lbnUtY2FyZXRcIiApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRfa2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBtYXRjaCwgcHJldiwgY2hhcmFjdGVyLCBza2lwLFxuXHRcdFx0cHJldmVudERlZmF1bHQgPSB0cnVlO1xuXG5cdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcblx0XHRjYXNlICQudWkua2V5Q29kZS5QQUdFX1VQOlxuXHRcdFx0dGhpcy5wcmV2aW91c1BhZ2UoIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5QQUdFX0RPV046XG5cdFx0XHR0aGlzLm5leHRQYWdlKCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuSE9NRTpcblx0XHRcdHRoaXMuX21vdmUoIFwiZmlyc3RcIiwgXCJmaXJzdFwiLCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuRU5EOlxuXHRcdFx0dGhpcy5fbW92ZSggXCJsYXN0XCIsIFwibGFzdFwiLCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuVVA6XG5cdFx0XHR0aGlzLnByZXZpb3VzKCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuRE9XTjpcblx0XHRcdHRoaXMubmV4dCggZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLkxFRlQ6XG5cdFx0XHR0aGlzLmNvbGxhcHNlKCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuUklHSFQ6XG5cdFx0XHRpZiAoIHRoaXMuYWN0aXZlICYmICF0aGlzLmFjdGl2ZS5pcyggXCIudWktc3RhdGUtZGlzYWJsZWRcIiApICkge1xuXHRcdFx0XHR0aGlzLmV4cGFuZCggZXZlbnQgKTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLkVOVEVSOlxuXHRcdGNhc2UgJC51aS5rZXlDb2RlLlNQQUNFOlxuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5FU0NBUEU6XG5cdFx0XHR0aGlzLmNvbGxhcHNlKCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG5cdFx0XHRwcmV2ID0gdGhpcy5wcmV2aW91c0ZpbHRlciB8fCBcIlwiO1xuXHRcdFx0c2tpcCA9IGZhbHNlO1xuXG5cdFx0XHQvLyBTdXBwb3J0IG51bWJlciBwYWQgdmFsdWVzXG5cdFx0XHRjaGFyYWN0ZXIgPSBldmVudC5rZXlDb2RlID49IDk2ICYmIGV2ZW50LmtleUNvZGUgPD0gMTA1ID9cblx0XHRcdFx0KCBldmVudC5rZXlDb2RlIC0gOTYgKS50b1N0cmluZygpIDogU3RyaW5nLmZyb21DaGFyQ29kZSggZXZlbnQua2V5Q29kZSApO1xuXG5cdFx0XHRjbGVhclRpbWVvdXQoIHRoaXMuZmlsdGVyVGltZXIgKTtcblxuXHRcdFx0aWYgKCBjaGFyYWN0ZXIgPT09IHByZXYgKSB7XG5cdFx0XHRcdHNraXAgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hhcmFjdGVyID0gcHJldiArIGNoYXJhY3Rlcjtcblx0XHRcdH1cblxuXHRcdFx0bWF0Y2ggPSB0aGlzLl9maWx0ZXJNZW51SXRlbXMoIGNoYXJhY3RlciApO1xuXHRcdFx0bWF0Y2ggPSBza2lwICYmIG1hdGNoLmluZGV4KCB0aGlzLmFjdGl2ZS5uZXh0KCkgKSAhPT0gLTEgP1xuXHRcdFx0XHR0aGlzLmFjdGl2ZS5uZXh0QWxsKCBcIi51aS1tZW51LWl0ZW1cIiApIDpcblx0XHRcdFx0bWF0Y2g7XG5cblx0XHRcdC8vIElmIG5vIG1hdGNoZXMgb24gdGhlIGN1cnJlbnQgZmlsdGVyLCByZXNldCB0byB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJlc3NlZFxuXHRcdFx0Ly8gdG8gbW92ZSBkb3duIHRoZSBtZW51IHRvIHRoZSBmaXJzdCBpdGVtIHRoYXQgc3RhcnRzIHdpdGggdGhhdCBjaGFyYWN0ZXJcblx0XHRcdGlmICggIW1hdGNoLmxlbmd0aCApIHtcblx0XHRcdFx0Y2hhcmFjdGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZSggZXZlbnQua2V5Q29kZSApO1xuXHRcdFx0XHRtYXRjaCA9IHRoaXMuX2ZpbHRlck1lbnVJdGVtcyggY2hhcmFjdGVyICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0Y2gubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgbWF0Y2ggKTtcblx0XHRcdFx0dGhpcy5wcmV2aW91c0ZpbHRlciA9IGNoYXJhY3Rlcjtcblx0XHRcdFx0dGhpcy5maWx0ZXJUaW1lciA9IHRoaXMuX2RlbGF5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5wcmV2aW91c0ZpbHRlcjtcblx0XHRcdFx0fSwgMTAwMCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXMucHJldmlvdXNGaWx0ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBwcmV2ZW50RGVmYXVsdCApIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hY3RpdmF0ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggdGhpcy5hY3RpdmUgJiYgIXRoaXMuYWN0aXZlLmlzKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSB7XG5cdFx0XHRpZiAoIHRoaXMuYWN0aXZlLmNoaWxkcmVuKCBcIlthcmlhLWhhc3BvcHVwPSd0cnVlJ11cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0dGhpcy5leHBhbmQoIGV2ZW50ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNlbGVjdCggZXZlbnQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lbnVzLCBpdGVtcywgbmV3U3VibWVudXMsIG5ld0l0ZW1zLCBuZXdXcmFwcGVycyxcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0aWNvbiA9IHRoaXMub3B0aW9ucy5pY29ucy5zdWJtZW51LFxuXHRcdFx0c3VibWVudXMgPSB0aGlzLmVsZW1lbnQuZmluZCggdGhpcy5vcHRpb25zLm1lbnVzICk7XG5cblx0XHR0aGlzLl90b2dnbGVDbGFzcyggXCJ1aS1tZW51LWljb25zXCIsIG51bGwsICEhdGhpcy5lbGVtZW50LmZpbmQoIFwiLnVpLWljb25cIiApLmxlbmd0aCApO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSBuZXN0ZWQgbWVudXNcblx0XHRuZXdTdWJtZW51cyA9IHN1Ym1lbnVzLmZpbHRlciggXCI6bm90KC51aS1tZW51KVwiIClcblx0XHRcdC5oaWRlKClcblx0XHRcdC5hdHRyKCB7XG5cdFx0XHRcdHJvbGU6IHRoaXMub3B0aW9ucy5yb2xlLFxuXHRcdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLFxuXHRcdFx0XHRcImFyaWEtZXhwYW5kZWRcIjogXCJmYWxzZVwiXG5cdFx0XHR9IClcblx0XHRcdC5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG1lbnUgPSAkKCB0aGlzICksXG5cdFx0XHRcdFx0aXRlbSA9IG1lbnUucHJldigpLFxuXHRcdFx0XHRcdHN1Ym1lbnVDYXJldCA9ICQoIFwiPHNwYW4+XCIgKS5kYXRhKCBcInVpLW1lbnUtc3VibWVudS1jYXJldFwiLCB0cnVlICk7XG5cblx0XHRcdFx0dGhhdC5fYWRkQ2xhc3MoIHN1Ym1lbnVDYXJldCwgXCJ1aS1tZW51LWljb25cIiwgXCJ1aS1pY29uIFwiICsgaWNvbiApO1xuXHRcdFx0XHRpdGVtXG5cdFx0XHRcdFx0LmF0dHIoIFwiYXJpYS1oYXNwb3B1cFwiLCBcInRydWVcIiApXG5cdFx0XHRcdFx0LnByZXBlbmQoIHN1Ym1lbnVDYXJldCApO1xuXHRcdFx0XHRtZW51LmF0dHIoIFwiYXJpYS1sYWJlbGxlZGJ5XCIsIGl0ZW0uYXR0ciggXCJpZFwiICkgKTtcblx0XHRcdH0gKTtcblxuXHRcdHRoaXMuX2FkZENsYXNzKCBuZXdTdWJtZW51cywgXCJ1aS1tZW51XCIsIFwidWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWZyb250XCIgKTtcblxuXHRcdG1lbnVzID0gc3VibWVudXMuYWRkKCB0aGlzLmVsZW1lbnQgKTtcblx0XHRpdGVtcyA9IG1lbnVzLmZpbmQoIHRoaXMub3B0aW9ucy5pdGVtcyApO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSBtZW51LWl0ZW1zIGNvbnRhaW5pbmcgc3BhY2VzIGFuZC9vciBkYXNoZXMgb25seSBhcyBkaXZpZGVyc1xuXHRcdGl0ZW1zLm5vdCggXCIudWktbWVudS1pdGVtXCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpdGVtID0gJCggdGhpcyApO1xuXHRcdFx0aWYgKCB0aGF0Ll9pc0RpdmlkZXIoIGl0ZW0gKSApIHtcblx0XHRcdFx0dGhhdC5fYWRkQ2xhc3MoIGl0ZW0sIFwidWktbWVudS1kaXZpZGVyXCIsIFwidWktd2lkZ2V0LWNvbnRlbnRcIiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdC8vIERvbid0IHJlZnJlc2ggbGlzdCBpdGVtcyB0aGF0IGFyZSBhbHJlYWR5IGFkYXB0ZWRcblx0XHRuZXdJdGVtcyA9IGl0ZW1zLm5vdCggXCIudWktbWVudS1pdGVtLCAudWktbWVudS1kaXZpZGVyXCIgKTtcblx0XHRuZXdXcmFwcGVycyA9IG5ld0l0ZW1zLmNoaWxkcmVuKClcblx0XHRcdC5ub3QoIFwiLnVpLW1lbnVcIiApXG5cdFx0XHRcdC51bmlxdWVJZCgpXG5cdFx0XHRcdC5hdHRyKCB7XG5cdFx0XHRcdFx0dGFiSW5kZXg6IC0xLFxuXHRcdFx0XHRcdHJvbGU6IHRoaXMuX2l0ZW1Sb2xlKClcblx0XHRcdFx0fSApO1xuXHRcdHRoaXMuX2FkZENsYXNzKCBuZXdJdGVtcywgXCJ1aS1tZW51LWl0ZW1cIiApXG5cdFx0XHQuX2FkZENsYXNzKCBuZXdXcmFwcGVycywgXCJ1aS1tZW51LWl0ZW0td3JhcHBlclwiICk7XG5cblx0XHQvLyBBZGQgYXJpYS1kaXNhYmxlZCBhdHRyaWJ1dGUgdG8gYW55IGRpc2FibGVkIG1lbnUgaXRlbVxuXHRcdGl0ZW1zLmZpbHRlciggXCIudWktc3RhdGUtZGlzYWJsZWRcIiApLmF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiLCBcInRydWVcIiApO1xuXG5cdFx0Ly8gSWYgdGhlIGFjdGl2ZSBpdGVtIGhhcyBiZWVuIHJlbW92ZWQsIGJsdXIgdGhlIG1lbnVcblx0XHRpZiAoIHRoaXMuYWN0aXZlICYmICEkLmNvbnRhaW5zKCB0aGlzLmVsZW1lbnRbIDAgXSwgdGhpcy5hY3RpdmVbIDAgXSApICkge1xuXHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pdGVtUm9sZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG1lbnU6IFwibWVudWl0ZW1cIixcblx0XHRcdGxpc3Rib3g6IFwib3B0aW9uXCJcblx0XHR9WyB0aGlzLm9wdGlvbnMucm9sZSBdO1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdGlmICgga2V5ID09PSBcImljb25zXCIgKSB7XG5cdFx0XHR2YXIgaWNvbnMgPSB0aGlzLmVsZW1lbnQuZmluZCggXCIudWktbWVudS1pY29uXCIgKTtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBpY29ucywgbnVsbCwgdGhpcy5vcHRpb25zLmljb25zLnN1Ym1lbnUgKVxuXHRcdFx0XHQuX2FkZENsYXNzKCBpY29ucywgbnVsbCwgdmFsdWUuc3VibWVudSApO1xuXHRcdH1cblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXHR9LFxuXG5cdF9zZXRPcHRpb25EaXNhYmxlZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHRoaXMuX3N1cGVyKCB2YWx1ZSApO1xuXG5cdFx0dGhpcy5lbGVtZW50LmF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiLCBTdHJpbmcoIHZhbHVlICkgKTtcblx0XHR0aGlzLl90b2dnbGVDbGFzcyggbnVsbCwgXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiLCAhIXZhbHVlICk7XG5cdH0sXG5cblx0Zm9jdXM6IGZ1bmN0aW9uKCBldmVudCwgaXRlbSApIHtcblx0XHR2YXIgbmVzdGVkLCBmb2N1c2VkLCBhY3RpdmVQYXJlbnQ7XG5cdFx0dGhpcy5ibHVyKCBldmVudCwgZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJmb2N1c1wiICk7XG5cblx0XHR0aGlzLl9zY3JvbGxJbnRvVmlldyggaXRlbSApO1xuXG5cdFx0dGhpcy5hY3RpdmUgPSBpdGVtLmZpcnN0KCk7XG5cblx0XHRmb2N1c2VkID0gdGhpcy5hY3RpdmUuY2hpbGRyZW4oIFwiLnVpLW1lbnUtaXRlbS13cmFwcGVyXCIgKTtcblx0XHR0aGlzLl9hZGRDbGFzcyggZm9jdXNlZCwgbnVsbCwgXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXG5cdFx0Ly8gT25seSB1cGRhdGUgYXJpYS1hY3RpdmVkZXNjZW5kYW50IGlmIHRoZXJlJ3MgYSByb2xlXG5cdFx0Ly8gb3RoZXJ3aXNlIHdlIGFzc3VtZSBmb2N1cyBpcyBtYW5hZ2VkIGVsc2V3aGVyZVxuXHRcdGlmICggdGhpcy5vcHRpb25zLnJvbGUgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYXR0ciggXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgZm9jdXNlZC5hdHRyKCBcImlkXCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIEhpZ2hsaWdodCBhY3RpdmUgcGFyZW50IG1lbnUgaXRlbSwgaWYgYW55XG5cdFx0YWN0aXZlUGFyZW50ID0gdGhpcy5hY3RpdmVcblx0XHRcdC5wYXJlbnQoKVxuXHRcdFx0XHQuY2xvc2VzdCggXCIudWktbWVudS1pdGVtXCIgKVxuXHRcdFx0XHRcdC5jaGlsZHJlbiggXCIudWktbWVudS1pdGVtLXdyYXBwZXJcIiApO1xuXHRcdHRoaXMuX2FkZENsYXNzKCBhY3RpdmVQYXJlbnQsIG51bGwsIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblxuXHRcdGlmICggZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJrZXlkb3duXCIgKSB7XG5cdFx0XHR0aGlzLl9jbG9zZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnRpbWVyID0gdGhpcy5fZGVsYXkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl9jbG9zZSgpO1xuXHRcdFx0fSwgdGhpcy5kZWxheSApO1xuXHRcdH1cblxuXHRcdG5lc3RlZCA9IGl0ZW0uY2hpbGRyZW4oIFwiLnVpLW1lbnVcIiApO1xuXHRcdGlmICggbmVzdGVkLmxlbmd0aCAmJiBldmVudCAmJiAoIC9ebW91c2UvLnRlc3QoIGV2ZW50LnR5cGUgKSApICkge1xuXHRcdFx0dGhpcy5fc3RhcnRPcGVuaW5nKCBuZXN0ZWQgKTtcblx0XHR9XG5cdFx0dGhpcy5hY3RpdmVNZW51ID0gaXRlbS5wYXJlbnQoKTtcblxuXHRcdHRoaXMuX3RyaWdnZXIoIFwiZm9jdXNcIiwgZXZlbnQsIHsgaXRlbTogaXRlbSB9ICk7XG5cdH0sXG5cblx0X3Njcm9sbEludG9WaWV3OiBmdW5jdGlvbiggaXRlbSApIHtcblx0XHR2YXIgYm9yZGVyVG9wLCBwYWRkaW5nVG9wLCBvZmZzZXQsIHNjcm9sbCwgZWxlbWVudEhlaWdodCwgaXRlbUhlaWdodDtcblx0XHRpZiAoIHRoaXMuX2hhc1Njcm9sbCgpICkge1xuXHRcdFx0Ym9yZGVyVG9wID0gcGFyc2VGbG9hdCggJC5jc3MoIHRoaXMuYWN0aXZlTWVudVsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIgKSApIHx8IDA7XG5cdFx0XHRwYWRkaW5nVG9wID0gcGFyc2VGbG9hdCggJC5jc3MoIHRoaXMuYWN0aXZlTWVudVsgMCBdLCBcInBhZGRpbmdUb3BcIiApICkgfHwgMDtcblx0XHRcdG9mZnNldCA9IGl0ZW0ub2Zmc2V0KCkudG9wIC0gdGhpcy5hY3RpdmVNZW51Lm9mZnNldCgpLnRvcCAtIGJvcmRlclRvcCAtIHBhZGRpbmdUb3A7XG5cdFx0XHRzY3JvbGwgPSB0aGlzLmFjdGl2ZU1lbnUuc2Nyb2xsVG9wKCk7XG5cdFx0XHRlbGVtZW50SGVpZ2h0ID0gdGhpcy5hY3RpdmVNZW51LmhlaWdodCgpO1xuXHRcdFx0aXRlbUhlaWdodCA9IGl0ZW0ub3V0ZXJIZWlnaHQoKTtcblxuXHRcdFx0aWYgKCBvZmZzZXQgPCAwICkge1xuXHRcdFx0XHR0aGlzLmFjdGl2ZU1lbnUuc2Nyb2xsVG9wKCBzY3JvbGwgKyBvZmZzZXQgKTtcblx0XHRcdH0gZWxzZSBpZiAoIG9mZnNldCArIGl0ZW1IZWlnaHQgPiBlbGVtZW50SGVpZ2h0ICkge1xuXHRcdFx0XHR0aGlzLmFjdGl2ZU1lbnUuc2Nyb2xsVG9wKCBzY3JvbGwgKyBvZmZzZXQgLSBlbGVtZW50SGVpZ2h0ICsgaXRlbUhlaWdodCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRibHVyOiBmdW5jdGlvbiggZXZlbnQsIGZyb21Gb2N1cyApIHtcblx0XHRpZiAoICFmcm9tRm9jdXMgKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLmFjdGl2ZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9yZW1vdmVDbGFzcyggdGhpcy5hY3RpdmUuY2hpbGRyZW4oIFwiLnVpLW1lbnUtaXRlbS13cmFwcGVyXCIgKSxcblx0XHRcdG51bGwsIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblxuXHRcdHRoaXMuX3RyaWdnZXIoIFwiYmx1clwiLCBldmVudCwgeyBpdGVtOiB0aGlzLmFjdGl2ZSB9ICk7XG5cdFx0dGhpcy5hY3RpdmUgPSBudWxsO1xuXHR9LFxuXG5cdF9zdGFydE9wZW5pbmc6IGZ1bmN0aW9uKCBzdWJtZW51ICkge1xuXHRcdGNsZWFyVGltZW91dCggdGhpcy50aW1lciApO1xuXG5cdFx0Ly8gRG9uJ3Qgb3BlbiBpZiBhbHJlYWR5IG9wZW4gZml4ZXMgYSBGaXJlZm94IGJ1ZyB0aGF0IGNhdXNlZCBhIC41IHBpeGVsXG5cdFx0Ly8gc2hpZnQgaW4gdGhlIHN1Ym1lbnUgcG9zaXRpb24gd2hlbiBtb3VzaW5nIG92ZXIgdGhlIGNhcmV0IGljb25cblx0XHRpZiAoIHN1Ym1lbnUuYXR0ciggXCJhcmlhLWhpZGRlblwiICkgIT09IFwidHJ1ZVwiICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMudGltZXIgPSB0aGlzLl9kZWxheSggZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9jbG9zZSgpO1xuXHRcdFx0dGhpcy5fb3Blbiggc3VibWVudSApO1xuXHRcdH0sIHRoaXMuZGVsYXkgKTtcblx0fSxcblxuXHRfb3BlbjogZnVuY3Rpb24oIHN1Ym1lbnUgKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0gJC5leHRlbmQoIHtcblx0XHRcdG9mOiB0aGlzLmFjdGl2ZVxuXHRcdH0sIHRoaXMub3B0aW9ucy5wb3NpdGlvbiApO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnRpbWVyICk7XG5cdFx0dGhpcy5lbGVtZW50LmZpbmQoIFwiLnVpLW1lbnVcIiApLm5vdCggc3VibWVudS5wYXJlbnRzKCBcIi51aS1tZW51XCIgKSApXG5cdFx0XHQuaGlkZSgpXG5cdFx0XHQuYXR0ciggXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIiApO1xuXG5cdFx0c3VibWVudVxuXHRcdFx0LnNob3coKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1oaWRkZW5cIiApXG5cdFx0XHQuYXR0ciggXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiIClcblx0XHRcdC5wb3NpdGlvbiggcG9zaXRpb24gKTtcblx0fSxcblxuXHRjb2xsYXBzZUFsbDogZnVuY3Rpb24oIGV2ZW50LCBhbGwgKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnRpbWVyICk7XG5cdFx0dGhpcy50aW1lciA9IHRoaXMuX2RlbGF5KCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgd2Ugd2VyZSBwYXNzZWQgYW4gZXZlbnQsIGxvb2sgZm9yIHRoZSBzdWJtZW51IHRoYXQgY29udGFpbnMgdGhlIGV2ZW50XG5cdFx0XHR2YXIgY3VycmVudE1lbnUgPSBhbGwgPyB0aGlzLmVsZW1lbnQgOlxuXHRcdFx0XHQkKCBldmVudCAmJiBldmVudC50YXJnZXQgKS5jbG9zZXN0KCB0aGlzLmVsZW1lbnQuZmluZCggXCIudWktbWVudVwiICkgKTtcblxuXHRcdFx0Ly8gSWYgd2UgZm91bmQgbm8gdmFsaWQgc3VibWVudSBhbmNlc3RvciwgdXNlIHRoZSBtYWluIG1lbnUgdG8gY2xvc2UgYWxsXG5cdFx0XHQvLyBzdWIgbWVudXMgYW55d2F5XG5cdFx0XHRpZiAoICFjdXJyZW50TWVudS5sZW5ndGggKSB7XG5cdFx0XHRcdGN1cnJlbnRNZW51ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jbG9zZSggY3VycmVudE1lbnUgKTtcblxuXHRcdFx0dGhpcy5ibHVyKCBldmVudCApO1xuXG5cdFx0XHQvLyBXb3JrIGFyb3VuZCBhY3RpdmUgaXRlbSBzdGF5aW5nIGFjdGl2ZSBhZnRlciBtZW51IGlzIGJsdXJyZWRcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBjdXJyZW50TWVudS5maW5kKCBcIi51aS1zdGF0ZS1hY3RpdmVcIiApLCBudWxsLCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cblx0XHRcdHRoaXMuYWN0aXZlTWVudSA9IGN1cnJlbnRNZW51O1xuXHRcdH0sIHRoaXMuZGVsYXkgKTtcblx0fSxcblxuXHQvLyBXaXRoIG5vIGFyZ3VtZW50cywgY2xvc2VzIHRoZSBjdXJyZW50bHkgYWN0aXZlIG1lbnUgLSBpZiBub3RoaW5nIGlzIGFjdGl2ZVxuXHQvLyBpdCBjbG9zZXMgYWxsIG1lbnVzLiAgSWYgcGFzc2VkIGFuIGFyZ3VtZW50LCBpdCB3aWxsIHNlYXJjaCBmb3IgbWVudXMgQkVMT1dcblx0X2Nsb3NlOiBmdW5jdGlvbiggc3RhcnRNZW51ICkge1xuXHRcdGlmICggIXN0YXJ0TWVudSApIHtcblx0XHRcdHN0YXJ0TWVudSA9IHRoaXMuYWN0aXZlID8gdGhpcy5hY3RpdmUucGFyZW50KCkgOiB0aGlzLmVsZW1lbnQ7XG5cdFx0fVxuXG5cdFx0c3RhcnRNZW51LmZpbmQoIFwiLnVpLW1lbnVcIiApXG5cdFx0XHQuaGlkZSgpXG5cdFx0XHQuYXR0ciggXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIiApXG5cdFx0XHQuYXR0ciggXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIiApO1xuXHR9LFxuXG5cdF9jbG9zZU9uRG9jdW1lbnRDbGljazogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHJldHVybiAhJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggXCIudWktbWVudVwiICkubGVuZ3RoO1xuXHR9LFxuXG5cdF9pc0RpdmlkZXI6IGZ1bmN0aW9uKCBpdGVtICkge1xuXG5cdFx0Ly8gTWF0Y2ggaHlwaGVuLCBlbSBkYXNoLCBlbiBkYXNoXG5cdFx0cmV0dXJuICEvW15cXC1cXHUyMDE0XFx1MjAxM1xcc10vLnRlc3QoIGl0ZW0udGV4dCgpICk7XG5cdH0sXG5cblx0Y29sbGFwc2U6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgbmV3SXRlbSA9IHRoaXMuYWN0aXZlICYmXG5cdFx0XHR0aGlzLmFjdGl2ZS5wYXJlbnQoKS5jbG9zZXN0KCBcIi51aS1tZW51LWl0ZW1cIiwgdGhpcy5lbGVtZW50ICk7XG5cdFx0aWYgKCBuZXdJdGVtICYmIG5ld0l0ZW0ubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5fY2xvc2UoKTtcblx0XHRcdHRoaXMuZm9jdXMoIGV2ZW50LCBuZXdJdGVtICk7XG5cdFx0fVxuXHR9LFxuXG5cdGV4cGFuZDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBuZXdJdGVtID0gdGhpcy5hY3RpdmUgJiZcblx0XHRcdHRoaXMuYWN0aXZlXG5cdFx0XHRcdC5jaGlsZHJlbiggXCIudWktbWVudSBcIiApXG5cdFx0XHRcdFx0LmZpbmQoIHRoaXMub3B0aW9ucy5pdGVtcyApXG5cdFx0XHRcdFx0XHQuZmlyc3QoKTtcblxuXHRcdGlmICggbmV3SXRlbSAmJiBuZXdJdGVtLmxlbmd0aCApIHtcblx0XHRcdHRoaXMuX29wZW4oIG5ld0l0ZW0ucGFyZW50KCkgKTtcblxuXHRcdFx0Ly8gRGVsYXkgc28gRmlyZWZveCB3aWxsIG5vdCBoaWRlIGFjdGl2ZWRlc2NlbmRhbnQgY2hhbmdlIGluIGV4cGFuZGluZyBzdWJtZW51IGZyb20gQVRcblx0XHRcdHRoaXMuX2RlbGF5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIG5ld0l0ZW0gKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH0sXG5cblx0bmV4dDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHRoaXMuX21vdmUoIFwibmV4dFwiLCBcImZpcnN0XCIsIGV2ZW50ICk7XG5cdH0sXG5cblx0cHJldmlvdXM6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR0aGlzLl9tb3ZlKCBcInByZXZcIiwgXCJsYXN0XCIsIGV2ZW50ICk7XG5cdH0sXG5cblx0aXNGaXJzdEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmFjdGl2ZSAmJiAhdGhpcy5hY3RpdmUucHJldkFsbCggXCIudWktbWVudS1pdGVtXCIgKS5sZW5ndGg7XG5cdH0sXG5cblx0aXNMYXN0SXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWN0aXZlICYmICF0aGlzLmFjdGl2ZS5uZXh0QWxsKCBcIi51aS1tZW51LWl0ZW1cIiApLmxlbmd0aDtcblx0fSxcblxuXHRfbW92ZTogZnVuY3Rpb24oIGRpcmVjdGlvbiwgZmlsdGVyLCBldmVudCApIHtcblx0XHR2YXIgbmV4dDtcblx0XHRpZiAoIHRoaXMuYWN0aXZlICkge1xuXHRcdFx0aWYgKCBkaXJlY3Rpb24gPT09IFwiZmlyc3RcIiB8fCBkaXJlY3Rpb24gPT09IFwibGFzdFwiICkge1xuXHRcdFx0XHRuZXh0ID0gdGhpcy5hY3RpdmVcblx0XHRcdFx0XHRbIGRpcmVjdGlvbiA9PT0gXCJmaXJzdFwiID8gXCJwcmV2QWxsXCIgOiBcIm5leHRBbGxcIiBdKCBcIi51aS1tZW51LWl0ZW1cIiApXG5cdFx0XHRcdFx0LmVxKCAtMSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV4dCA9IHRoaXMuYWN0aXZlXG5cdFx0XHRcdFx0WyBkaXJlY3Rpb24gKyBcIkFsbFwiIF0oIFwiLnVpLW1lbnUtaXRlbVwiIClcblx0XHRcdFx0XHQuZXEoIDAgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCAhbmV4dCB8fCAhbmV4dC5sZW5ndGggfHwgIXRoaXMuYWN0aXZlICkge1xuXHRcdFx0bmV4dCA9IHRoaXMuYWN0aXZlTWVudS5maW5kKCB0aGlzLm9wdGlvbnMuaXRlbXMgKVsgZmlsdGVyIF0oKTtcblx0XHR9XG5cblx0XHR0aGlzLmZvY3VzKCBldmVudCwgbmV4dCApO1xuXHR9LFxuXG5cdG5leHRQYWdlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGl0ZW0sIGJhc2UsIGhlaWdodDtcblxuXHRcdGlmICggIXRoaXMuYWN0aXZlICkge1xuXHRcdFx0dGhpcy5uZXh0KCBldmVudCApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuaXNMYXN0SXRlbSgpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuX2hhc1Njcm9sbCgpICkge1xuXHRcdFx0YmFzZSA9IHRoaXMuYWN0aXZlLm9mZnNldCgpLnRvcDtcblx0XHRcdGhlaWdodCA9IHRoaXMuZWxlbWVudC5oZWlnaHQoKTtcblx0XHRcdHRoaXMuYWN0aXZlLm5leHRBbGwoIFwiLnVpLW1lbnUtaXRlbVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGl0ZW0gPSAkKCB0aGlzICk7XG5cdFx0XHRcdHJldHVybiBpdGVtLm9mZnNldCgpLnRvcCAtIGJhc2UgLSBoZWlnaHQgPCAwO1xuXHRcdFx0fSApO1xuXG5cdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgaXRlbSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgdGhpcy5hY3RpdmVNZW51LmZpbmQoIHRoaXMub3B0aW9ucy5pdGVtcyApXG5cdFx0XHRcdFsgIXRoaXMuYWN0aXZlID8gXCJmaXJzdFwiIDogXCJsYXN0XCIgXSgpICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZXZpb3VzUGFnZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBpdGVtLCBiYXNlLCBoZWlnaHQ7XG5cdFx0aWYgKCAhdGhpcy5hY3RpdmUgKSB7XG5cdFx0XHR0aGlzLm5leHQoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdGhpcy5pc0ZpcnN0SXRlbSgpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuX2hhc1Njcm9sbCgpICkge1xuXHRcdFx0YmFzZSA9IHRoaXMuYWN0aXZlLm9mZnNldCgpLnRvcDtcblx0XHRcdGhlaWdodCA9IHRoaXMuZWxlbWVudC5oZWlnaHQoKTtcblx0XHRcdHRoaXMuYWN0aXZlLnByZXZBbGwoIFwiLnVpLW1lbnUtaXRlbVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGl0ZW0gPSAkKCB0aGlzICk7XG5cdFx0XHRcdHJldHVybiBpdGVtLm9mZnNldCgpLnRvcCAtIGJhc2UgKyBoZWlnaHQgPiAwO1xuXHRcdFx0fSApO1xuXG5cdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgaXRlbSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgdGhpcy5hY3RpdmVNZW51LmZpbmQoIHRoaXMub3B0aW9ucy5pdGVtcyApLmZpcnN0KCkgKTtcblx0XHR9XG5cdH0sXG5cblx0X2hhc1Njcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpIDwgdGhpcy5lbGVtZW50LnByb3AoIFwic2Nyb2xsSGVpZ2h0XCIgKTtcblx0fSxcblxuXHRzZWxlY3Q6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIFRPRE86IEl0IHNob3VsZCBuZXZlciBiZSBwb3NzaWJsZSB0byBub3QgaGF2ZSBhbiBhY3RpdmUgaXRlbSBhdCB0aGlzXG5cdFx0Ly8gcG9pbnQsIGJ1dCB0aGUgdGVzdHMgZG9uJ3QgdHJpZ2dlciBtb3VzZWVudGVyIGJlZm9yZSBjbGljay5cblx0XHR0aGlzLmFjdGl2ZSA9IHRoaXMuYWN0aXZlIHx8ICQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIFwiLnVpLW1lbnUtaXRlbVwiICk7XG5cdFx0dmFyIHVpID0geyBpdGVtOiB0aGlzLmFjdGl2ZSB9O1xuXHRcdGlmICggIXRoaXMuYWN0aXZlLmhhcyggXCIudWktbWVudVwiICkubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5jb2xsYXBzZUFsbCggZXZlbnQsIHRydWUgKTtcblx0XHR9XG5cdFx0dGhpcy5fdHJpZ2dlciggXCJzZWxlY3RcIiwgZXZlbnQsIHVpICk7XG5cdH0sXG5cblx0X2ZpbHRlck1lbnVJdGVtczogZnVuY3Rpb24oIGNoYXJhY3RlciApIHtcblx0XHR2YXIgZXNjYXBlZENoYXJhY3RlciA9IGNoYXJhY3Rlci5yZXBsYWNlKCAvW1xcLVxcW1xcXXt9KCkqKz8uLFxcXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIgKSxcblx0XHRcdHJlZ2V4ID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBlc2NhcGVkQ2hhcmFjdGVyLCBcImlcIiApO1xuXG5cdFx0cmV0dXJuIHRoaXMuYWN0aXZlTWVudVxuXHRcdFx0LmZpbmQoIHRoaXMub3B0aW9ucy5pdGVtcyApXG5cblx0XHRcdFx0Ly8gT25seSBtYXRjaCBvbiBpdGVtcywgbm90IGRpdmlkZXJzIG9yIG90aGVyIGNvbnRlbnQgKCMxMDU3MSlcblx0XHRcdFx0LmZpbHRlciggXCIudWktbWVudS1pdGVtXCIgKVxuXHRcdFx0XHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZ2V4LnRlc3QoXG5cdFx0XHRcdFx0XHRcdCQudHJpbSggJCggdGhpcyApLmNoaWxkcmVuKCBcIi51aS1tZW51LWl0ZW0td3JhcHBlclwiICkudGV4dCgpICkgKTtcblx0XHRcdFx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSBBdXRvY29tcGxldGUgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IEF1dG9jb21wbGV0ZVxuLy8+Pmdyb3VwOiBXaWRnZXRzXG4vLz4+ZGVzY3JpcHRpb246IExpc3RzIHN1Z2dlc3RlZCB3b3JkcyBhcyB0aGUgdXNlciBpcyB0eXBpbmcuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vYXV0b2NvbXBsZXRlL1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2F1dG9jb21wbGV0ZS9cbi8vPj5jc3Muc3RydWN0dXJlOiAuLi8uLi90aGVtZXMvYmFzZS9jb3JlLmNzc1xuLy8+PmNzcy5zdHJ1Y3R1cmU6IC4uLy4uL3RoZW1lcy9iYXNlL2F1dG9jb21wbGV0ZS5jc3Ncbi8vPj5jc3MudGhlbWU6IC4uLy4uL3RoZW1lcy9iYXNlL3RoZW1lLmNzc1xuXG5cblxuJC53aWRnZXQoIFwidWkuYXV0b2NvbXBsZXRlXCIsIHtcblx0dmVyc2lvbjogXCIxLjEyLjFcIixcblx0ZGVmYXVsdEVsZW1lbnQ6IFwiPGlucHV0PlwiLFxuXHRvcHRpb25zOiB7XG5cdFx0YXBwZW5kVG86IG51bGwsXG5cdFx0YXV0b0ZvY3VzOiBmYWxzZSxcblx0XHRkZWxheTogMzAwLFxuXHRcdG1pbkxlbmd0aDogMSxcblx0XHRwb3NpdGlvbjoge1xuXHRcdFx0bXk6IFwibGVmdCB0b3BcIixcblx0XHRcdGF0OiBcImxlZnQgYm90dG9tXCIsXG5cdFx0XHRjb2xsaXNpb246IFwibm9uZVwiXG5cdFx0fSxcblx0XHRzb3VyY2U6IG51bGwsXG5cblx0XHQvLyBDYWxsYmFja3Ncblx0XHRjaGFuZ2U6IG51bGwsXG5cdFx0Y2xvc2U6IG51bGwsXG5cdFx0Zm9jdXM6IG51bGwsXG5cdFx0b3BlbjogbnVsbCxcblx0XHRyZXNwb25zZTogbnVsbCxcblx0XHRzZWFyY2g6IG51bGwsXG5cdFx0c2VsZWN0OiBudWxsXG5cdH0sXG5cblx0cmVxdWVzdEluZGV4OiAwLFxuXHRwZW5kaW5nOiAwLFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gU29tZSBicm93c2VycyBvbmx5IHJlcGVhdCBrZXlkb3duIGV2ZW50cywgbm90IGtleXByZXNzIGV2ZW50cyxcblx0XHQvLyBzbyB3ZSB1c2UgdGhlIHN1cHByZXNzS2V5UHJlc3MgZmxhZyB0byBkZXRlcm1pbmUgaWYgd2UndmUgYWxyZWFkeVxuXHRcdC8vIGhhbmRsZWQgdGhlIGtleWRvd24gZXZlbnQuICM3MjY5XG5cdFx0Ly8gVW5mb3J0dW5hdGVseSB0aGUgY29kZSBmb3IgJiBpbiBrZXlwcmVzcyBpcyB0aGUgc2FtZSBhcyB0aGUgdXAgYXJyb3csXG5cdFx0Ly8gc28gd2UgdXNlIHRoZSBzdXBwcmVzc0tleVByZXNzUmVwZWF0IGZsYWcgdG8gYXZvaWQgaGFuZGxpbmcga2V5cHJlc3Ncblx0XHQvLyBldmVudHMgd2hlbiB3ZSBrbm93IHRoZSBrZXlkb3duIGV2ZW50IHdhcyB1c2VkIHRvIG1vZGlmeSB0aGVcblx0XHQvLyBzZWFyY2ggdGVybS4gIzc3OTlcblx0XHR2YXIgc3VwcHJlc3NLZXlQcmVzcywgc3VwcHJlc3NLZXlQcmVzc1JlcGVhdCwgc3VwcHJlc3NJbnB1dCxcblx0XHRcdG5vZGVOYW1lID0gdGhpcy5lbGVtZW50WyAwIF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdGlzVGV4dGFyZWEgPSBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiLFxuXHRcdFx0aXNJbnB1dCA9IG5vZGVOYW1lID09PSBcImlucHV0XCI7XG5cblx0XHQvLyBUZXh0YXJlYXMgYXJlIGFsd2F5cyBtdWx0aS1saW5lXG5cdFx0Ly8gSW5wdXRzIGFyZSBhbHdheXMgc2luZ2xlLWxpbmUsIGV2ZW4gaWYgaW5zaWRlIGEgY29udGVudEVkaXRhYmxlIGVsZW1lbnRcblx0XHQvLyBJRSBhbHNvIHRyZWF0cyBpbnB1dHMgYXMgY29udGVudEVkaXRhYmxlXG5cdFx0Ly8gQWxsIG90aGVyIGVsZW1lbnQgdHlwZXMgYXJlIGRldGVybWluZWQgYnkgd2hldGhlciBvciBub3QgdGhleSdyZSBjb250ZW50RWRpdGFibGVcblx0XHR0aGlzLmlzTXVsdGlMaW5lID0gaXNUZXh0YXJlYSB8fCAhaXNJbnB1dCAmJiB0aGlzLl9pc0NvbnRlbnRFZGl0YWJsZSggdGhpcy5lbGVtZW50ICk7XG5cblx0XHR0aGlzLnZhbHVlTWV0aG9kID0gdGhpcy5lbGVtZW50WyBpc1RleHRhcmVhIHx8IGlzSW5wdXQgPyBcInZhbFwiIDogXCJ0ZXh0XCIgXTtcblx0XHR0aGlzLmlzTmV3TWVudSA9IHRydWU7XG5cblx0XHR0aGlzLl9hZGRDbGFzcyggXCJ1aS1hdXRvY29tcGxldGUtaW5wdXRcIiApO1xuXHRcdHRoaXMuZWxlbWVudC5hdHRyKCBcImF1dG9jb21wbGV0ZVwiLCBcIm9mZlwiICk7XG5cblx0XHR0aGlzLl9vbiggdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRrZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5lbGVtZW50LnByb3AoIFwicmVhZE9ubHlcIiApICkge1xuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdHN1cHByZXNzSW5wdXQgPSB0cnVlO1xuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3NSZXBlYXQgPSB0cnVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSBmYWxzZTtcblx0XHRcdFx0c3VwcHJlc3NJbnB1dCA9IGZhbHNlO1xuXHRcdFx0XHRzdXBwcmVzc0tleVByZXNzUmVwZWF0ID0gZmFsc2U7XG5cdFx0XHRcdHZhciBrZXlDb2RlID0gJC51aS5rZXlDb2RlO1xuXHRcdFx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuUEFHRV9VUDpcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLl9tb3ZlKCBcInByZXZpb3VzUGFnZVwiLCBldmVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuX21vdmUoIFwibmV4dFBhZ2VcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLlVQOlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuX2tleUV2ZW50KCBcInByZXZpb3VzXCIsIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5ET1dOOlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuX2tleUV2ZW50KCBcIm5leHRcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLkVOVEVSOlxuXG5cdFx0XHRcdFx0Ly8gd2hlbiBtZW51IGlzIG9wZW4gYW5kIGhhcyBmb2N1c1xuXHRcdFx0XHRcdGlmICggdGhpcy5tZW51LmFjdGl2ZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gIzYwNTUgLSBPcGVyYSBzdGlsbCBhbGxvd3MgdGhlIGtleXByZXNzIHRvIG9jY3VyXG5cdFx0XHRcdFx0XHQvLyB3aGljaCBjYXVzZXMgZm9ybXMgdG8gc3VibWl0XG5cdFx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHR0aGlzLm1lbnUuc2VsZWN0KCBldmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLlRBQjpcblx0XHRcdFx0XHRpZiAoIHRoaXMubWVudS5hY3RpdmUgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1lbnUuc2VsZWN0KCBldmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLkVTQ0FQRTpcblx0XHRcdFx0XHRpZiAoIHRoaXMubWVudS5lbGVtZW50LmlzKCBcIjp2aXNpYmxlXCIgKSApIHtcblx0XHRcdFx0XHRcdGlmICggIXRoaXMuaXNNdWx0aUxpbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3ZhbHVlKCB0aGlzLnRlcm0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuY2xvc2UoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRcdC8vIERpZmZlcmVudCBicm93c2VycyBoYXZlIGRpZmZlcmVudCBkZWZhdWx0IGJlaGF2aW9yIGZvciBlc2NhcGVcblx0XHRcdFx0XHRcdC8vIFNpbmdsZSBwcmVzcyBjYW4gbWVhbiB1bmRvIG9yIGNsZWFyXG5cdFx0XHRcdFx0XHQvLyBEb3VibGUgcHJlc3MgaW4gSUUgbWVhbnMgY2xlYXIgdGhlIHdob2xlIGZvcm1cblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3NSZXBlYXQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Ly8gc2VhcmNoIHRpbWVvdXQgc2hvdWxkIGJlIHRyaWdnZXJlZCBiZWZvcmUgdGhlIGlucHV0IHZhbHVlIGlzIGNoYW5nZWRcblx0XHRcdFx0XHR0aGlzLl9zZWFyY2hUaW1lb3V0KCBldmVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0a2V5cHJlc3M6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCBzdXBwcmVzc0tleVByZXNzICkge1xuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAoICF0aGlzLmlzTXVsdGlMaW5lIHx8IHRoaXMubWVudS5lbGVtZW50LmlzKCBcIjp2aXNpYmxlXCIgKSApIHtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHN1cHByZXNzS2V5UHJlc3NSZXBlYXQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVwbGljYXRlIHNvbWUga2V5IGhhbmRsZXJzIHRvIGFsbG93IHRoZW0gdG8gcmVwZWF0IGluIEZpcmVmb3ggYW5kIE9wZXJhXG5cdFx0XHRcdHZhciBrZXlDb2RlID0gJC51aS5rZXlDb2RlO1xuXHRcdFx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuUEFHRV9VUDpcblx0XHRcdFx0XHR0aGlzLl9tb3ZlKCBcInByZXZpb3VzUGFnZVwiLCBldmVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0XHRcdHRoaXMuX21vdmUoIFwibmV4dFBhZ2VcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLlVQOlxuXHRcdFx0XHRcdHRoaXMuX2tleUV2ZW50KCBcInByZXZpb3VzXCIsIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5ET1dOOlxuXHRcdFx0XHRcdHRoaXMuX2tleUV2ZW50KCBcIm5leHRcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGlucHV0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggc3VwcHJlc3NJbnB1dCApIHtcblx0XHRcdFx0XHRzdXBwcmVzc0lucHV0ID0gZmFsc2U7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fc2VhcmNoVGltZW91dCggZXZlbnQgKTtcblx0XHRcdH0sXG5cdFx0XHRmb2N1czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcblx0XHRcdFx0dGhpcy5wcmV2aW91cyA9IHRoaXMuX3ZhbHVlKCk7XG5cdFx0XHR9LFxuXHRcdFx0Ymx1cjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuY2FuY2VsQmx1ciApIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5jYW5jZWxCbHVyO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5zZWFyY2hpbmcgKTtcblx0XHRcdFx0dGhpcy5jbG9zZSggZXZlbnQgKTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlKCBldmVudCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdHRoaXMuX2luaXRTb3VyY2UoKTtcblx0XHR0aGlzLm1lbnUgPSAkKCBcIjx1bD5cIiApXG5cdFx0XHQuYXBwZW5kVG8oIHRoaXMuX2FwcGVuZFRvKCkgKVxuXHRcdFx0Lm1lbnUoIHtcblxuXHRcdFx0XHQvLyBkaXNhYmxlIEFSSUEgc3VwcG9ydCwgdGhlIGxpdmUgcmVnaW9uIHRha2VzIGNhcmUgb2YgdGhhdFxuXHRcdFx0XHRyb2xlOiBudWxsXG5cdFx0XHR9IClcblx0XHRcdC5oaWRlKClcblx0XHRcdC5tZW51KCBcImluc3RhbmNlXCIgKTtcblxuXHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLm1lbnUuZWxlbWVudCwgXCJ1aS1hdXRvY29tcGxldGVcIiwgXCJ1aS1mcm9udFwiICk7XG5cdFx0dGhpcy5fb24oIHRoaXMubWVudS5lbGVtZW50LCB7XG5cdFx0XHRtb3VzZWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBwcmV2ZW50IG1vdmluZyBmb2N1cyBvdXQgb2YgdGhlIHRleHQgZmllbGRcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHQvLyBJRSBkb2Vzbid0IHByZXZlbnQgbW92aW5nIGZvY3VzIGV2ZW4gd2l0aCBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRcdC8vIHNvIHdlIHNldCBhIGZsYWcgdG8ga25vdyB3aGVuIHdlIHNob3VsZCBpZ25vcmUgdGhlIGJsdXIgZXZlbnRcblx0XHRcdFx0dGhpcy5jYW5jZWxCbHVyID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fZGVsYXkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLmNhbmNlbEJsdXI7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA4IG9ubHlcblx0XHRcdFx0XHQvLyBSaWdodCBjbGlja2luZyBhIG1lbnUgaXRlbSBvciBzZWxlY3RpbmcgdGV4dCBmcm9tIHRoZSBtZW51IGl0ZW1zIHdpbGxcblx0XHRcdFx0XHQvLyByZXN1bHQgaW4gZm9jdXMgbW92aW5nIG91dCBvZiB0aGUgaW5wdXQuIEhvd2V2ZXIsIHdlJ3ZlIGFscmVhZHkgcmVjZWl2ZWRcblx0XHRcdFx0XHQvLyBhbmQgaWdub3JlZCB0aGUgYmx1ciBldmVudCBiZWNhdXNlIG9mIHRoZSBjYW5jZWxCbHVyIGZsYWcgc2V0IGFib3ZlLiBTb1xuXHRcdFx0XHRcdC8vIHdlIHJlc3RvcmUgZm9jdXMgdG8gZW5zdXJlIHRoYXQgdGhlIG1lbnUgY2xvc2VzIHByb3Blcmx5IGJhc2VkIG9uIHRoZSB1c2VyJ3Ncblx0XHRcdFx0XHQvLyBuZXh0IGFjdGlvbnMuXG5cdFx0XHRcdFx0aWYgKCB0aGlzLmVsZW1lbnRbIDAgXSAhPT0gJC51aS5zYWZlQWN0aXZlRWxlbWVudCggdGhpcy5kb2N1bWVudFsgMCBdICkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQudHJpZ2dlciggXCJmb2N1c1wiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9LFxuXHRcdFx0bWVudWZvY3VzOiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xuXHRcdFx0XHR2YXIgbGFiZWwsIGl0ZW07XG5cblx0XHRcdFx0Ly8gc3VwcG9ydDogRmlyZWZveFxuXHRcdFx0XHQvLyBQcmV2ZW50IGFjY2lkZW50YWwgYWN0aXZhdGlvbiBvZiBtZW51IGl0ZW1zIGluIEZpcmVmb3ggKCM3MDI0ICM5MTE4KVxuXHRcdFx0XHRpZiAoIHRoaXMuaXNOZXdNZW51ICkge1xuXHRcdFx0XHRcdHRoaXMuaXNOZXdNZW51ID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKCBldmVudC5vcmlnaW5hbEV2ZW50ICYmIC9ebW91c2UvLnRlc3QoIGV2ZW50Lm9yaWdpbmFsRXZlbnQudHlwZSApICkge1xuXHRcdFx0XHRcdFx0dGhpcy5tZW51LmJsdXIoKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5kb2N1bWVudC5vbmUoIFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHQkKCBldmVudC50YXJnZXQgKS50cmlnZ2VyKCBldmVudC5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpdGVtID0gdWkuaXRlbS5kYXRhKCBcInVpLWF1dG9jb21wbGV0ZS1pdGVtXCIgKTtcblx0XHRcdFx0aWYgKCBmYWxzZSAhPT0gdGhpcy5fdHJpZ2dlciggXCJmb2N1c1wiLCBldmVudCwgeyBpdGVtOiBpdGVtIH0gKSApIHtcblxuXHRcdFx0XHRcdC8vIHVzZSB2YWx1ZSB0byBtYXRjaCB3aGF0IHdpbGwgZW5kIHVwIGluIHRoZSBpbnB1dCwgaWYgaXQgd2FzIGEga2V5IGV2ZW50XG5cdFx0XHRcdFx0aWYgKCBldmVudC5vcmlnaW5hbEV2ZW50ICYmIC9ea2V5Ly50ZXN0KCBldmVudC5vcmlnaW5hbEV2ZW50LnR5cGUgKSApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3ZhbHVlKCBpdGVtLnZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQW5ub3VuY2UgdGhlIHZhbHVlIGluIHRoZSBsaXZlUmVnaW9uXG5cdFx0XHRcdGxhYmVsID0gdWkuaXRlbS5hdHRyKCBcImFyaWEtbGFiZWxcIiApIHx8IGl0ZW0udmFsdWU7XG5cdFx0XHRcdGlmICggbGFiZWwgJiYgJC50cmltKCBsYWJlbCApLmxlbmd0aCApIHtcblx0XHRcdFx0XHR0aGlzLmxpdmVSZWdpb24uY2hpbGRyZW4oKS5oaWRlKCk7XG5cdFx0XHRcdFx0JCggXCI8ZGl2PlwiICkudGV4dCggbGFiZWwgKS5hcHBlbmRUbyggdGhpcy5saXZlUmVnaW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRtZW51c2VsZWN0OiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xuXHRcdFx0XHR2YXIgaXRlbSA9IHVpLml0ZW0uZGF0YSggXCJ1aS1hdXRvY29tcGxldGUtaXRlbVwiICksXG5cdFx0XHRcdFx0cHJldmlvdXMgPSB0aGlzLnByZXZpb3VzO1xuXG5cdFx0XHRcdC8vIE9ubHkgdHJpZ2dlciB3aGVuIGZvY3VzIHdhcyBsb3N0IChjbGljayBvbiBtZW51KVxuXHRcdFx0XHRpZiAoIHRoaXMuZWxlbWVudFsgMCBdICE9PSAkLnVpLnNhZmVBY3RpdmVFbGVtZW50KCB0aGlzLmRvY3VtZW50WyAwIF0gKSApIHtcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQudHJpZ2dlciggXCJmb2N1c1wiICk7XG5cdFx0XHRcdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuXG5cdFx0XHRcdFx0Ly8gIzYxMDkgLSBJRSB0cmlnZ2VycyB0d28gZm9jdXMgZXZlbnRzIGFuZCB0aGUgc2Vjb25kXG5cdFx0XHRcdFx0Ly8gaXMgYXN5bmNocm9ub3VzLCBzbyB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBwcmV2aW91c1xuXHRcdFx0XHRcdC8vIHRlcm0gc3luY2hyb25vdXNseSBhbmQgYXN5bmNocm9ub3VzbHkgOi0oXG5cdFx0XHRcdFx0dGhpcy5fZGVsYXkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdFx0dGhpcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZmFsc2UgIT09IHRoaXMuX3RyaWdnZXIoIFwic2VsZWN0XCIsIGV2ZW50LCB7IGl0ZW06IGl0ZW0gfSApICkge1xuXHRcdFx0XHRcdHRoaXMuX3ZhbHVlKCBpdGVtLnZhbHVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZXNldCB0aGUgdGVybSBhZnRlciB0aGUgc2VsZWN0IGV2ZW50XG5cdFx0XHRcdC8vIHRoaXMgYWxsb3dzIGN1c3RvbSBzZWxlY3QgaGFuZGxpbmcgdG8gd29yayBwcm9wZXJseVxuXHRcdFx0XHR0aGlzLnRlcm0gPSB0aGlzLl92YWx1ZSgpO1xuXG5cdFx0XHRcdHRoaXMuY2xvc2UoIGV2ZW50ICk7XG5cdFx0XHRcdHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHR0aGlzLmxpdmVSZWdpb24gPSAkKCBcIjxkaXY+XCIsIHtcblx0XHRcdHJvbGU6IFwic3RhdHVzXCIsXG5cdFx0XHRcImFyaWEtbGl2ZVwiOiBcImFzc2VydGl2ZVwiLFxuXHRcdFx0XCJhcmlhLXJlbGV2YW50XCI6IFwiYWRkaXRpb25zXCJcblx0XHR9IClcblx0XHRcdC5hcHBlbmRUbyggdGhpcy5kb2N1bWVudFsgMCBdLmJvZHkgKTtcblxuXHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLmxpdmVSZWdpb24sIG51bGwsIFwidWktaGVscGVyLWhpZGRlbi1hY2Nlc3NpYmxlXCIgKTtcblxuXHRcdC8vIFR1cm5pbmcgb2ZmIGF1dG9jb21wbGV0ZSBwcmV2ZW50cyB0aGUgYnJvd3NlciBmcm9tIHJlbWVtYmVyaW5nIHRoZVxuXHRcdC8vIHZhbHVlIHdoZW4gbmF2aWdhdGluZyB0aHJvdWdoIGhpc3RvcnksIHNvIHdlIHJlLWVuYWJsZSBhdXRvY29tcGxldGVcblx0XHQvLyBpZiB0aGUgcGFnZSBpcyB1bmxvYWRlZCBiZWZvcmUgdGhlIHdpZGdldCBpcyBkZXN0cm95ZWQuICM3NzkwXG5cdFx0dGhpcy5fb24oIHRoaXMud2luZG93LCB7XG5cdFx0XHRiZWZvcmV1bmxvYWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQXR0ciggXCJhdXRvY29tcGxldGVcIiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLnNlYXJjaGluZyApO1xuXHRcdHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyKCBcImF1dG9jb21wbGV0ZVwiICk7XG5cdFx0dGhpcy5tZW51LmVsZW1lbnQucmVtb3ZlKCk7XG5cdFx0dGhpcy5saXZlUmVnaW9uLnJlbW92ZSgpO1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cdFx0aWYgKCBrZXkgPT09IFwic291cmNlXCIgKSB7XG5cdFx0XHR0aGlzLl9pbml0U291cmNlKCk7XG5cdFx0fVxuXHRcdGlmICgga2V5ID09PSBcImFwcGVuZFRvXCIgKSB7XG5cdFx0XHR0aGlzLm1lbnUuZWxlbWVudC5hcHBlbmRUbyggdGhpcy5fYXBwZW5kVG8oKSApO1xuXHRcdH1cblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICYmIHZhbHVlICYmIHRoaXMueGhyICkge1xuXHRcdFx0dGhpcy54aHIuYWJvcnQoKTtcblx0XHR9XG5cdH0sXG5cblx0X2lzRXZlbnRUYXJnZXRJbldpZGdldDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBtZW51RWxlbWVudCA9IHRoaXMubWVudS5lbGVtZW50WyAwIF07XG5cblx0XHRyZXR1cm4gZXZlbnQudGFyZ2V0ID09PSB0aGlzLmVsZW1lbnRbIDAgXSB8fFxuXHRcdFx0ZXZlbnQudGFyZ2V0ID09PSBtZW51RWxlbWVudCB8fFxuXHRcdFx0JC5jb250YWlucyggbWVudUVsZW1lbnQsIGV2ZW50LnRhcmdldCApO1xuXHR9LFxuXG5cdF9jbG9zZU9uQ2xpY2tPdXRzaWRlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCAhdGhpcy5faXNFdmVudFRhcmdldEluV2lkZ2V0KCBldmVudCApICkge1xuXHRcdFx0dGhpcy5jbG9zZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfYXBwZW5kVG86IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5vcHRpb25zLmFwcGVuZFRvO1xuXG5cdFx0aWYgKCBlbGVtZW50ICkge1xuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQuanF1ZXJ5IHx8IGVsZW1lbnQubm9kZVR5cGUgP1xuXHRcdFx0XHQkKCBlbGVtZW50ICkgOlxuXHRcdFx0XHR0aGlzLmRvY3VtZW50LmZpbmQoIGVsZW1lbnQgKS5lcSggMCApO1xuXHRcdH1cblxuXHRcdGlmICggIWVsZW1lbnQgfHwgIWVsZW1lbnRbIDAgXSApIHtcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQuY2xvc2VzdCggXCIudWktZnJvbnQsIGRpYWxvZ1wiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhZWxlbWVudC5sZW5ndGggKSB7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5kb2N1bWVudFsgMCBdLmJvZHk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdH0sXG5cblx0X2luaXRTb3VyY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcnJheSwgdXJsLFxuXHRcdFx0dGhhdCA9IHRoaXM7XG5cdFx0aWYgKCAkLmlzQXJyYXkoIHRoaXMub3B0aW9ucy5zb3VyY2UgKSApIHtcblx0XHRcdGFycmF5ID0gdGhpcy5vcHRpb25zLnNvdXJjZTtcblx0XHRcdHRoaXMuc291cmNlID0gZnVuY3Rpb24oIHJlcXVlc3QsIHJlc3BvbnNlICkge1xuXHRcdFx0XHRyZXNwb25zZSggJC51aS5hdXRvY29tcGxldGUuZmlsdGVyKCBhcnJheSwgcmVxdWVzdC50ZXJtICkgKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmICggdHlwZW9mIHRoaXMub3B0aW9ucy5zb3VyY2UgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR1cmwgPSB0aGlzLm9wdGlvbnMuc291cmNlO1xuXHRcdFx0dGhpcy5zb3VyY2UgPSBmdW5jdGlvbiggcmVxdWVzdCwgcmVzcG9uc2UgKSB7XG5cdFx0XHRcdGlmICggdGhhdC54aHIgKSB7XG5cdFx0XHRcdFx0dGhhdC54aHIuYWJvcnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGF0LnhociA9ICQuYWpheCgge1xuXHRcdFx0XHRcdHVybDogdXJsLFxuXHRcdFx0XHRcdGRhdGE6IHJlcXVlc3QsXG5cdFx0XHRcdFx0ZGF0YVR5cGU6IFwianNvblwiLFxuXHRcdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UoIGRhdGEgKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGVycm9yOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlKCBbXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zb3VyY2UgPSB0aGlzLm9wdGlvbnMuc291cmNlO1xuXHRcdH1cblx0fSxcblxuXHRfc2VhcmNoVGltZW91dDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGNsZWFyVGltZW91dCggdGhpcy5zZWFyY2hpbmcgKTtcblx0XHR0aGlzLnNlYXJjaGluZyA9IHRoaXMuX2RlbGF5KCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU2VhcmNoIGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZCwgb3IgaWYgdGhlIHVzZXIgcmV0eXBlcyB0aGUgc2FtZSB2YWx1ZSAoc2VlICM3NDM0KVxuXHRcdFx0dmFyIGVxdWFsVmFsdWVzID0gdGhpcy50ZXJtID09PSB0aGlzLl92YWx1ZSgpLFxuXHRcdFx0XHRtZW51VmlzaWJsZSA9IHRoaXMubWVudS5lbGVtZW50LmlzKCBcIjp2aXNpYmxlXCIgKSxcblx0XHRcdFx0bW9kaWZpZXJLZXkgPSBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5O1xuXG5cdFx0XHRpZiAoICFlcXVhbFZhbHVlcyB8fCAoIGVxdWFsVmFsdWVzICYmICFtZW51VmlzaWJsZSAmJiAhbW9kaWZpZXJLZXkgKSApIHtcblx0XHRcdFx0dGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuXHRcdFx0XHR0aGlzLnNlYXJjaCggbnVsbCwgZXZlbnQgKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzLm9wdGlvbnMuZGVsYXkgKTtcblx0fSxcblxuXHRzZWFyY2g6IGZ1bmN0aW9uKCB2YWx1ZSwgZXZlbnQgKSB7XG5cdFx0dmFsdWUgPSB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiB0aGlzLl92YWx1ZSgpO1xuXG5cdFx0Ly8gQWx3YXlzIHNhdmUgdGhlIGFjdHVhbCB2YWx1ZSwgbm90IHRoZSBvbmUgcGFzc2VkIGFzIGFuIGFyZ3VtZW50XG5cdFx0dGhpcy50ZXJtID0gdGhpcy5fdmFsdWUoKTtcblxuXHRcdGlmICggdmFsdWUubGVuZ3RoIDwgdGhpcy5vcHRpb25zLm1pbkxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmNsb3NlKCBldmVudCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fdHJpZ2dlciggXCJzZWFyY2hcIiwgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3NlYXJjaCggdmFsdWUgKTtcblx0fSxcblxuXHRfc2VhcmNoOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dGhpcy5wZW5kaW5nKys7XG5cdFx0dGhpcy5fYWRkQ2xhc3MoIFwidWktYXV0b2NvbXBsZXRlLWxvYWRpbmdcIiApO1xuXHRcdHRoaXMuY2FuY2VsU2VhcmNoID0gZmFsc2U7XG5cblx0XHR0aGlzLnNvdXJjZSggeyB0ZXJtOiB2YWx1ZSB9LCB0aGlzLl9yZXNwb25zZSgpICk7XG5cdH0sXG5cblx0X3Jlc3BvbnNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW5kZXggPSArK3RoaXMucmVxdWVzdEluZGV4O1xuXG5cdFx0cmV0dXJuICQucHJveHkoIGZ1bmN0aW9uKCBjb250ZW50ICkge1xuXHRcdFx0aWYgKCBpbmRleCA9PT0gdGhpcy5yZXF1ZXN0SW5kZXggKSB7XG5cdFx0XHRcdHRoaXMuX19yZXNwb25zZSggY29udGVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnBlbmRpbmctLTtcblx0XHRcdGlmICggIXRoaXMucGVuZGluZyApIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIFwidWktYXV0b2NvbXBsZXRlLWxvYWRpbmdcIiApO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMgKTtcblx0fSxcblxuXHRfX3Jlc3BvbnNlOiBmdW5jdGlvbiggY29udGVudCApIHtcblx0XHRpZiAoIGNvbnRlbnQgKSB7XG5cdFx0XHRjb250ZW50ID0gdGhpcy5fbm9ybWFsaXplKCBjb250ZW50ICk7XG5cdFx0fVxuXHRcdHRoaXMuX3RyaWdnZXIoIFwicmVzcG9uc2VcIiwgbnVsbCwgeyBjb250ZW50OiBjb250ZW50IH0gKTtcblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZWQgJiYgY29udGVudCAmJiBjb250ZW50Lmxlbmd0aCAmJiAhdGhpcy5jYW5jZWxTZWFyY2ggKSB7XG5cdFx0XHR0aGlzLl9zdWdnZXN0KCBjb250ZW50ICk7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCBcIm9wZW5cIiApO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIHVzZSAuX2Nsb3NlKCkgaW5zdGVhZCBvZiAuY2xvc2UoKSBzbyB3ZSBkb24ndCBjYW5jZWwgZnV0dXJlIHNlYXJjaGVzXG5cdFx0XHR0aGlzLl9jbG9zZSgpO1xuXHRcdH1cblx0fSxcblxuXHRjbG9zZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHRoaXMuY2FuY2VsU2VhcmNoID0gdHJ1ZTtcblx0XHR0aGlzLl9jbG9zZSggZXZlbnQgKTtcblx0fSxcblxuXHRfY2xvc2U6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIFJlbW92ZSB0aGUgaGFuZGxlciB0aGF0IGNsb3NlcyB0aGUgbWVudSBvbiBvdXRzaWRlIGNsaWNrc1xuXHRcdHRoaXMuX29mZiggdGhpcy5kb2N1bWVudCwgXCJtb3VzZWRvd25cIiApO1xuXG5cdFx0aWYgKCB0aGlzLm1lbnUuZWxlbWVudC5pcyggXCI6dmlzaWJsZVwiICkgKSB7XG5cdFx0XHR0aGlzLm1lbnUuZWxlbWVudC5oaWRlKCk7XG5cdFx0XHR0aGlzLm1lbnUuYmx1cigpO1xuXHRcdFx0dGhpcy5pc05ld01lbnUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJjbG9zZVwiLCBldmVudCApO1xuXHRcdH1cblx0fSxcblxuXHRfY2hhbmdlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCB0aGlzLnByZXZpb3VzICE9PSB0aGlzLl92YWx1ZSgpICkge1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJjaGFuZ2VcIiwgZXZlbnQsIHsgaXRlbTogdGhpcy5zZWxlY3RlZEl0ZW0gfSApO1xuXHRcdH1cblx0fSxcblxuXHRfbm9ybWFsaXplOiBmdW5jdGlvbiggaXRlbXMgKSB7XG5cblx0XHQvLyBhc3N1bWUgYWxsIGl0ZW1zIGhhdmUgdGhlIHJpZ2h0IGZvcm1hdCB3aGVuIHRoZSBmaXJzdCBpdGVtIGlzIGNvbXBsZXRlXG5cdFx0aWYgKCBpdGVtcy5sZW5ndGggJiYgaXRlbXNbIDAgXS5sYWJlbCAmJiBpdGVtc1sgMCBdLnZhbHVlICkge1xuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH1cblx0XHRyZXR1cm4gJC5tYXAoIGl0ZW1zLCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdGlmICggdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0bGFiZWw6IGl0ZW0sXG5cdFx0XHRcdFx0dmFsdWU6IGl0ZW1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAkLmV4dGVuZCgge30sIGl0ZW0sIHtcblx0XHRcdFx0bGFiZWw6IGl0ZW0ubGFiZWwgfHwgaXRlbS52YWx1ZSxcblx0XHRcdFx0dmFsdWU6IGl0ZW0udmFsdWUgfHwgaXRlbS5sYWJlbFxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRfc3VnZ2VzdDogZnVuY3Rpb24oIGl0ZW1zICkge1xuXHRcdHZhciB1bCA9IHRoaXMubWVudS5lbGVtZW50LmVtcHR5KCk7XG5cdFx0dGhpcy5fcmVuZGVyTWVudSggdWwsIGl0ZW1zICk7XG5cdFx0dGhpcy5pc05ld01lbnUgPSB0cnVlO1xuXHRcdHRoaXMubWVudS5yZWZyZXNoKCk7XG5cblx0XHQvLyBTaXplIGFuZCBwb3NpdGlvbiBtZW51XG5cdFx0dWwuc2hvdygpO1xuXHRcdHRoaXMuX3Jlc2l6ZU1lbnUoKTtcblx0XHR1bC5wb3NpdGlvbiggJC5leHRlbmQoIHtcblx0XHRcdG9mOiB0aGlzLmVsZW1lbnRcblx0XHR9LCB0aGlzLm9wdGlvbnMucG9zaXRpb24gKSApO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzICkge1xuXHRcdFx0dGhpcy5tZW51Lm5leHQoKTtcblx0XHR9XG5cblx0XHQvLyBMaXN0ZW4gZm9yIGludGVyYWN0aW9ucyBvdXRzaWRlIG9mIHRoZSB3aWRnZXQgKCM2NjQyKVxuXHRcdHRoaXMuX29uKCB0aGlzLmRvY3VtZW50LCB7XG5cdFx0XHRtb3VzZWRvd246IFwiX2Nsb3NlT25DbGlja091dHNpZGVcIlxuXHRcdH0gKTtcblx0fSxcblxuXHRfcmVzaXplTWVudTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHVsID0gdGhpcy5tZW51LmVsZW1lbnQ7XG5cdFx0dWwub3V0ZXJXaWR0aCggTWF0aC5tYXgoXG5cblx0XHRcdC8vIEZpcmVmb3ggd3JhcHMgbG9uZyB0ZXh0IChwb3NzaWJseSBhIHJvdW5kaW5nIGJ1Zylcblx0XHRcdC8vIHNvIHdlIGFkZCAxcHggdG8gYXZvaWQgdGhlIHdyYXBwaW5nICgjNzUxMylcblx0XHRcdHVsLndpZHRoKCBcIlwiICkub3V0ZXJXaWR0aCgpICsgMSxcblx0XHRcdHRoaXMuZWxlbWVudC5vdXRlcldpZHRoKClcblx0XHQpICk7XG5cdH0sXG5cblx0X3JlbmRlck1lbnU6IGZ1bmN0aW9uKCB1bCwgaXRlbXMgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdCQuZWFjaCggaXRlbXMsIGZ1bmN0aW9uKCBpbmRleCwgaXRlbSApIHtcblx0XHRcdHRoYXQuX3JlbmRlckl0ZW1EYXRhKCB1bCwgaXRlbSApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRfcmVuZGVySXRlbURhdGE6IGZ1bmN0aW9uKCB1bCwgaXRlbSApIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVuZGVySXRlbSggdWwsIGl0ZW0gKS5kYXRhKCBcInVpLWF1dG9jb21wbGV0ZS1pdGVtXCIsIGl0ZW0gKTtcblx0fSxcblxuXHRfcmVuZGVySXRlbTogZnVuY3Rpb24oIHVsLCBpdGVtICkge1xuXHRcdHJldHVybiAkKCBcIjxsaT5cIiApXG5cdFx0XHQuYXBwZW5kKCAkKCBcIjxkaXY+XCIgKS50ZXh0KCBpdGVtLmxhYmVsICkgKVxuXHRcdFx0LmFwcGVuZFRvKCB1bCApO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiggZGlyZWN0aW9uLCBldmVudCApIHtcblx0XHRpZiAoICF0aGlzLm1lbnUuZWxlbWVudC5pcyggXCI6dmlzaWJsZVwiICkgKSB7XG5cdFx0XHR0aGlzLnNlYXJjaCggbnVsbCwgZXZlbnQgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLm1lbnUuaXNGaXJzdEl0ZW0oKSAmJiAvXnByZXZpb3VzLy50ZXN0KCBkaXJlY3Rpb24gKSB8fFxuXHRcdFx0XHR0aGlzLm1lbnUuaXNMYXN0SXRlbSgpICYmIC9ebmV4dC8udGVzdCggZGlyZWN0aW9uICkgKSB7XG5cblx0XHRcdGlmICggIXRoaXMuaXNNdWx0aUxpbmUgKSB7XG5cdFx0XHRcdHRoaXMuX3ZhbHVlKCB0aGlzLnRlcm0gKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tZW51LmJsdXIoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5tZW51WyBkaXJlY3Rpb24gXSggZXZlbnQgKTtcblx0fSxcblxuXHR3aWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1lbnUuZWxlbWVudDtcblx0fSxcblxuXHRfdmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlTWV0aG9kLmFwcGx5KCB0aGlzLmVsZW1lbnQsIGFyZ3VtZW50cyApO1xuXHR9LFxuXG5cdF9rZXlFdmVudDogZnVuY3Rpb24oIGtleUV2ZW50LCBldmVudCApIHtcblx0XHRpZiAoICF0aGlzLmlzTXVsdGlMaW5lIHx8IHRoaXMubWVudS5lbGVtZW50LmlzKCBcIjp2aXNpYmxlXCIgKSApIHtcblx0XHRcdHRoaXMuX21vdmUoIGtleUV2ZW50LCBldmVudCApO1xuXG5cdFx0XHQvLyBQcmV2ZW50cyBtb3ZpbmcgY3Vyc29yIHRvIGJlZ2lubmluZy9lbmQgb2YgdGhlIHRleHQgZmllbGQgaW4gc29tZSBicm93c2Vyc1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9NTBcblx0Ly8gV2Ugc2hvdWxkIGJlIGFibGUgdG8ganVzdCB1c2UgdGhpcy5lbGVtZW50LnByb3AoIFwiaXNDb250ZW50RWRpdGFibGVcIiApXG5cdC8vIGJ1dCBoaWRkZW4gZWxlbWVudHMgYWx3YXlzIHJlcG9ydCBmYWxzZSBpbiBDaHJvbWUuXG5cdC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zMTMwODJcblx0X2lzQ29udGVudEVkaXRhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRpZiAoICFlbGVtZW50Lmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgZWRpdGFibGUgPSBlbGVtZW50LnByb3AoIFwiY29udGVudEVkaXRhYmxlXCIgKTtcblxuXHRcdGlmICggZWRpdGFibGUgPT09IFwiaW5oZXJpdFwiICkge1xuXHRcdCAgcmV0dXJuIHRoaXMuX2lzQ29udGVudEVkaXRhYmxlKCBlbGVtZW50LnBhcmVudCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVkaXRhYmxlID09PSBcInRydWVcIjtcblx0fVxufSApO1xuXG4kLmV4dGVuZCggJC51aS5hdXRvY29tcGxldGUsIHtcblx0ZXNjYXBlUmVnZXg6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gdmFsdWUucmVwbGFjZSggL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiICk7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIGFycmF5LCB0ZXJtICkge1xuXHRcdHZhciBtYXRjaGVyID0gbmV3IFJlZ0V4cCggJC51aS5hdXRvY29tcGxldGUuZXNjYXBlUmVnZXgoIHRlcm0gKSwgXCJpXCIgKTtcblx0XHRyZXR1cm4gJC5ncmVwKCBhcnJheSwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIG1hdGNoZXIudGVzdCggdmFsdWUubGFiZWwgfHwgdmFsdWUudmFsdWUgfHwgdmFsdWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gTGl2ZSByZWdpb24gZXh0ZW5zaW9uLCBhZGRpbmcgYSBgbWVzc2FnZXNgIG9wdGlvblxuLy8gTk9URTogVGhpcyBpcyBhbiBleHBlcmltZW50YWwgQVBJLiBXZSBhcmUgc3RpbGwgaW52ZXN0aWdhdGluZ1xuLy8gYSBmdWxsIHNvbHV0aW9uIGZvciBzdHJpbmcgbWFuaXB1bGF0aW9uIGFuZCBpbnRlcm5hdGlvbmFsaXphdGlvbi5cbiQud2lkZ2V0KCBcInVpLmF1dG9jb21wbGV0ZVwiLCAkLnVpLmF1dG9jb21wbGV0ZSwge1xuXHRvcHRpb25zOiB7XG5cdFx0bWVzc2FnZXM6IHtcblx0XHRcdG5vUmVzdWx0czogXCJObyBzZWFyY2ggcmVzdWx0cy5cIixcblx0XHRcdHJlc3VsdHM6IGZ1bmN0aW9uKCBhbW91bnQgKSB7XG5cdFx0XHRcdHJldHVybiBhbW91bnQgKyAoIGFtb3VudCA+IDEgPyBcIiByZXN1bHRzIGFyZVwiIDogXCIgcmVzdWx0IGlzXCIgKSArXG5cdFx0XHRcdFx0XCIgYXZhaWxhYmxlLCB1c2UgdXAgYW5kIGRvd24gYXJyb3cga2V5cyB0byBuYXZpZ2F0ZS5cIjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X19yZXNwb25zZTogZnVuY3Rpb24oIGNvbnRlbnQgKSB7XG5cdFx0dmFyIG1lc3NhZ2U7XG5cdFx0dGhpcy5fc3VwZXJBcHBseSggYXJndW1lbnRzICk7XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy5jYW5jZWxTZWFyY2ggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggY29udGVudCAmJiBjb250ZW50Lmxlbmd0aCApIHtcblx0XHRcdG1lc3NhZ2UgPSB0aGlzLm9wdGlvbnMubWVzc2FnZXMucmVzdWx0cyggY29udGVudC5sZW5ndGggKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWVzc2FnZSA9IHRoaXMub3B0aW9ucy5tZXNzYWdlcy5ub1Jlc3VsdHM7XG5cdFx0fVxuXHRcdHRoaXMubGl2ZVJlZ2lvbi5jaGlsZHJlbigpLmhpZGUoKTtcblx0XHQkKCBcIjxkaXY+XCIgKS50ZXh0KCBtZXNzYWdlICkuYXBwZW5kVG8oIHRoaXMubGl2ZVJlZ2lvbiApO1xuXHR9XG59ICk7XG5cbnZhciB3aWRnZXRzQXV0b2NvbXBsZXRlID0gJC51aS5hdXRvY29tcGxldGU7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgQ29udHJvbGdyb3VwIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBDb250cm9sZ3JvdXBcbi8vPj5ncm91cDogV2lkZ2V0c1xuLy8+PmRlc2NyaXB0aW9uOiBWaXN1YWxseSBncm91cHMgZm9ybSBjb250cm9sIHdpZGdldHNcbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9jb250cm9sZ3JvdXAvXG4vLz4+ZGVtb3M6IGh0dHA6Ly9qcXVlcnl1aS5jb20vY29udHJvbGdyb3VwL1xuLy8+PmNzcy5zdHJ1Y3R1cmU6IC4uLy4uL3RoZW1lcy9iYXNlL2NvcmUuY3NzXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2UvY29udHJvbGdyb3VwLmNzc1xuLy8+PmNzcy50aGVtZTogLi4vLi4vdGhlbWVzL2Jhc2UvdGhlbWUuY3NzXG5cblxudmFyIGNvbnRyb2xncm91cENvcm5lclJlZ2V4ID0gL3VpLWNvcm5lci0oW2Etel0pezIsNn0vZztcblxudmFyIHdpZGdldHNDb250cm9sZ3JvdXAgPSAkLndpZGdldCggXCJ1aS5jb250cm9sZ3JvdXBcIiwge1xuXHR2ZXJzaW9uOiBcIjEuMTIuMVwiLFxuXHRkZWZhdWx0RWxlbWVudDogXCI8ZGl2PlwiLFxuXHRvcHRpb25zOiB7XG5cdFx0ZGlyZWN0aW9uOiBcImhvcml6b250YWxcIixcblx0XHRkaXNhYmxlZDogbnVsbCxcblx0XHRvbmx5VmlzaWJsZTogdHJ1ZSxcblx0XHRpdGVtczoge1xuXHRcdFx0XCJidXR0b25cIjogXCJpbnB1dFt0eXBlPWJ1dHRvbl0sIGlucHV0W3R5cGU9c3VibWl0XSwgaW5wdXRbdHlwZT1yZXNldF0sIGJ1dHRvbiwgYVwiLFxuXHRcdFx0XCJjb250cm9sZ3JvdXBMYWJlbFwiOiBcIi51aS1jb250cm9sZ3JvdXAtbGFiZWxcIixcblx0XHRcdFwiY2hlY2tib3hyYWRpb1wiOiBcImlucHV0W3R5cGU9J2NoZWNrYm94J10sIGlucHV0W3R5cGU9J3JhZGlvJ11cIixcblx0XHRcdFwic2VsZWN0bWVudVwiOiBcInNlbGVjdFwiLFxuXHRcdFx0XCJzcGlubmVyXCI6IFwiLnVpLXNwaW5uZXItaW5wdXRcIlxuXHRcdH1cblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9lbmhhbmNlKCk7XG5cdH0sXG5cblx0Ly8gVG8gc3VwcG9ydCB0aGUgZW5oYW5jZWQgb3B0aW9uIGluIGpRdWVyeSBNb2JpbGUsIHdlIGlzb2xhdGUgRE9NIG1hbmlwdWxhdGlvblxuXHRfZW5oYW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50LmF0dHIoIFwicm9sZVwiLCBcInRvb2xiYXJcIiApO1xuXHRcdHRoaXMucmVmcmVzaCgpO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9jYWxsQ2hpbGRNZXRob2QoIFwiZGVzdHJveVwiICk7XG5cdFx0dGhpcy5jaGlsZFdpZGdldHMucmVtb3ZlRGF0YSggXCJ1aS1jb250cm9sZ3JvdXAtZGF0YVwiICk7XG5cdFx0dGhpcy5lbGVtZW50LnJlbW92ZUF0dHIoIFwicm9sZVwiICk7XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuaXRlbXMuY29udHJvbGdyb3VwTGFiZWwgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdFx0LmZpbmQoIHRoaXMub3B0aW9ucy5pdGVtcy5jb250cm9sZ3JvdXBMYWJlbCApXG5cdFx0XHRcdC5maW5kKCBcIi51aS1jb250cm9sZ3JvdXAtbGFiZWwtY29udGVudHNcIiApXG5cdFx0XHRcdC5jb250ZW50cygpLnVud3JhcCgpO1xuXHRcdH1cblx0fSxcblxuXHRfaW5pdFdpZGdldHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdGNoaWxkV2lkZ2V0cyA9IFtdO1xuXG5cdFx0Ly8gRmlyc3Qgd2UgaXRlcmF0ZSBvdmVyIGVhY2ggb2YgdGhlIGl0ZW1zIG9wdGlvbnNcblx0XHQkLmVhY2goIHRoaXMub3B0aW9ucy5pdGVtcywgZnVuY3Rpb24oIHdpZGdldCwgc2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbGFiZWxzO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB7fTtcblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoZSB3aWRnZXQgaGFzIGEgc2VsZWN0b3Igc2V0XG5cdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpZGdldCA9PT0gXCJjb250cm9sZ3JvdXBMYWJlbFwiICkge1xuXHRcdFx0XHRsYWJlbHMgPSB0aGF0LmVsZW1lbnQuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdFx0bGFiZWxzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBlbGVtZW50ID0gJCggdGhpcyApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtZW50LmNoaWxkcmVuKCBcIi51aS1jb250cm9sZ3JvdXAtbGFiZWwtY29udGVudHNcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxlbWVudC5jb250ZW50cygpXG5cdFx0XHRcdFx0XHQud3JhcEFsbCggXCI8c3BhbiBjbGFzcz0ndWktY29udHJvbGdyb3VwLWxhYmVsLWNvbnRlbnRzJz48L3NwYW4+XCIgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0aGF0Ll9hZGRDbGFzcyggbGFiZWxzLCBudWxsLCBcInVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1zdGF0ZS1kZWZhdWx0XCIgKTtcblx0XHRcdFx0Y2hpbGRXaWRnZXRzID0gY2hpbGRXaWRnZXRzLmNvbmNhdCggbGFiZWxzLmdldCgpICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoZSB3aWRnZXQgYWN0dWFsbHkgZXhpc3RzXG5cdFx0XHRpZiAoICEkLmZuWyB3aWRnZXQgXSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZSBhc3N1bWUgZXZlcnl0aGluZyBpcyBpbiB0aGUgbWlkZGxlIHRvIHN0YXJ0IGJlY2F1c2Ugd2UgY2FuJ3QgZGV0ZXJtaW5lXG5cdFx0XHQvLyBmaXJzdCAvIGxhc3QgZWxlbWVudHMgdW50aWwgYWxsIGVuaGFuY21lbnRzIGFyZSBkb25lLlxuXHRcdFx0aWYgKCB0aGF0WyBcIl9cIiArIHdpZGdldCArIFwiT3B0aW9uc1wiIF0gKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSB0aGF0WyBcIl9cIiArIHdpZGdldCArIFwiT3B0aW9uc1wiIF0oIFwibWlkZGxlXCIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdGlvbnMgPSB7IGNsYXNzZXM6IHt9IH07XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZpbmQgaW5zdGFuY2VzIG9mIHRoaXMgd2lkZ2V0IGluc2lkZSBjb250cm9sZ3JvdXAgYW5kIGluaXQgdGhlbVxuXHRcdFx0dGhhdC5lbGVtZW50XG5cdFx0XHRcdC5maW5kKCBzZWxlY3RvciApXG5cdFx0XHRcdC5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgZWxlbWVudCA9ICQoIHRoaXMgKTtcblx0XHRcdFx0XHR2YXIgaW5zdGFuY2UgPSBlbGVtZW50WyB3aWRnZXQgXSggXCJpbnN0YW5jZVwiICk7XG5cblx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIGNsb25lIHRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoaXMgdHlwZSBvZiB3aWRnZXQgdG8gYXZvaWRcblx0XHRcdFx0XHQvLyBwb2xsdXRpbmcgdGhlIHZhcmlhYmxlIG9wdGlvbnMgd2hpY2ggaGFzIGEgd2lkZXIgc2NvcGUgdGhhbiBhIHNpbmdsZSB3aWRnZXQuXG5cdFx0XHRcdFx0dmFyIGluc3RhbmNlT3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHRcdFx0XHRcdC8vIElmIHRoZSBidXR0b24gaXMgdGhlIGNoaWxkIG9mIGEgc3Bpbm5lciBpZ25vcmUgaXRcblx0XHRcdFx0XHQvLyBUT0RPOiBGaW5kIGEgbW9yZSBnZW5lcmljIHNvbHV0aW9uXG5cdFx0XHRcdFx0aWYgKCB3aWRnZXQgPT09IFwiYnV0dG9uXCIgJiYgZWxlbWVudC5wYXJlbnQoIFwiLnVpLXNwaW5uZXJcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgdGhlIHdpZGdldCBpZiBpdCBkb2Vzbid0IGV4aXN0XG5cdFx0XHRcdFx0aWYgKCAhaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0XHRpbnN0YW5jZSA9IGVsZW1lbnRbIHdpZGdldCBdKClbIHdpZGdldCBdKCBcImluc3RhbmNlXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRcdGluc3RhbmNlT3B0aW9ucy5jbGFzc2VzID1cblx0XHRcdFx0XHRcdFx0dGhhdC5fcmVzb2x2ZUNsYXNzZXNWYWx1ZXMoIGluc3RhbmNlT3B0aW9ucy5jbGFzc2VzLCBpbnN0YW5jZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbGVtZW50WyB3aWRnZXQgXSggaW5zdGFuY2VPcHRpb25zICk7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhbiBpbnN0YW5jZSBvZiB0aGUgY29udHJvbGdyb3VwIHRvIGJlIGFibGUgdG8gcmVmZXJlbmNlXG5cdFx0XHRcdFx0Ly8gZnJvbSB0aGUgb3V0ZXJtb3N0IGVsZW1lbnQgZm9yIGNoYW5naW5nIG9wdGlvbnMgYW5kIHJlZnJlc2hcblx0XHRcdFx0XHR2YXIgd2lkZ2V0RWxlbWVudCA9IGVsZW1lbnRbIHdpZGdldCBdKCBcIndpZGdldFwiICk7XG5cdFx0XHRcdFx0JC5kYXRhKCB3aWRnZXRFbGVtZW50WyAwIF0sIFwidWktY29udHJvbGdyb3VwLWRhdGFcIixcblx0XHRcdFx0XHRcdGluc3RhbmNlID8gaW5zdGFuY2UgOiBlbGVtZW50WyB3aWRnZXQgXSggXCJpbnN0YW5jZVwiICkgKTtcblxuXHRcdFx0XHRcdGNoaWxkV2lkZ2V0cy5wdXNoKCB3aWRnZXRFbGVtZW50WyAwIF0gKTtcblx0XHRcdFx0fSApO1xuXHRcdH0gKTtcblxuXHRcdHRoaXMuY2hpbGRXaWRnZXRzID0gJCggJC51bmlxdWUoIGNoaWxkV2lkZ2V0cyApICk7XG5cdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMuY2hpbGRXaWRnZXRzLCBcInVpLWNvbnRyb2xncm91cC1pdGVtXCIgKTtcblx0fSxcblxuXHRfY2FsbENoaWxkTWV0aG9kOiBmdW5jdGlvbiggbWV0aG9kICkge1xuXHRcdHRoaXMuY2hpbGRXaWRnZXRzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSAkKCB0aGlzICksXG5cdFx0XHRcdGRhdGEgPSBlbGVtZW50LmRhdGEoIFwidWktY29udHJvbGdyb3VwLWRhdGFcIiApO1xuXHRcdFx0aWYgKCBkYXRhICYmIGRhdGFbIG1ldGhvZCBdICkge1xuXHRcdFx0XHRkYXRhWyBtZXRob2QgXSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRfdXBkYXRlQ29ybmVyQ2xhc3M6IGZ1bmN0aW9uKCBlbGVtZW50LCBwb3NpdGlvbiApIHtcblx0XHR2YXIgcmVtb3ZlID0gXCJ1aS1jb3JuZXItdG9wIHVpLWNvcm5lci1ib3R0b20gdWktY29ybmVyLWxlZnQgdWktY29ybmVyLXJpZ2h0IHVpLWNvcm5lci1hbGxcIjtcblx0XHR2YXIgYWRkID0gdGhpcy5fYnVpbGRTaW1wbGVPcHRpb25zKCBwb3NpdGlvbiwgXCJsYWJlbFwiICkuY2xhc3Nlcy5sYWJlbDtcblxuXHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBlbGVtZW50LCBudWxsLCByZW1vdmUgKTtcblx0XHR0aGlzLl9hZGRDbGFzcyggZWxlbWVudCwgbnVsbCwgYWRkICk7XG5cdH0sXG5cblx0X2J1aWxkU2ltcGxlT3B0aW9uczogZnVuY3Rpb24oIHBvc2l0aW9uLCBrZXkgKSB7XG5cdFx0dmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24gPT09IFwidmVydGljYWxcIjtcblx0XHR2YXIgcmVzdWx0ID0ge1xuXHRcdFx0Y2xhc3Nlczoge31cblx0XHR9O1xuXHRcdHJlc3VsdC5jbGFzc2VzWyBrZXkgXSA9IHtcblx0XHRcdFwibWlkZGxlXCI6IFwiXCIsXG5cdFx0XHRcImZpcnN0XCI6IFwidWktY29ybmVyLVwiICsgKCBkaXJlY3Rpb24gPyBcInRvcFwiIDogXCJsZWZ0XCIgKSxcblx0XHRcdFwibGFzdFwiOiBcInVpLWNvcm5lci1cIiArICggZGlyZWN0aW9uID8gXCJib3R0b21cIiA6IFwicmlnaHRcIiApLFxuXHRcdFx0XCJvbmx5XCI6IFwidWktY29ybmVyLWFsbFwiXG5cdFx0fVsgcG9zaXRpb24gXTtcblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3NwaW5uZXJPcHRpb25zOiBmdW5jdGlvbiggcG9zaXRpb24gKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl9idWlsZFNpbXBsZU9wdGlvbnMoIHBvc2l0aW9uLCBcInVpLXNwaW5uZXJcIiApO1xuXG5cdFx0b3B0aW9ucy5jbGFzc2VzWyBcInVpLXNwaW5uZXItdXBcIiBdID0gXCJcIjtcblx0XHRvcHRpb25zLmNsYXNzZXNbIFwidWktc3Bpbm5lci1kb3duXCIgXSA9IFwiXCI7XG5cblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fSxcblxuXHRfYnV0dG9uT3B0aW9uczogZnVuY3Rpb24oIHBvc2l0aW9uICkge1xuXHRcdHJldHVybiB0aGlzLl9idWlsZFNpbXBsZU9wdGlvbnMoIHBvc2l0aW9uLCBcInVpLWJ1dHRvblwiICk7XG5cdH0sXG5cblx0X2NoZWNrYm94cmFkaW9PcHRpb25zOiBmdW5jdGlvbiggcG9zaXRpb24gKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2J1aWxkU2ltcGxlT3B0aW9ucyggcG9zaXRpb24sIFwidWktY2hlY2tib3hyYWRpby1sYWJlbFwiICk7XG5cdH0sXG5cblx0X3NlbGVjdG1lbnVPcHRpb25zOiBmdW5jdGlvbiggcG9zaXRpb24gKSB7XG5cdFx0dmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24gPT09IFwidmVydGljYWxcIjtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IGRpcmVjdGlvbiA/IFwiYXV0b1wiIDogZmFsc2UsXG5cdFx0XHRjbGFzc2VzOiB7XG5cdFx0XHRcdG1pZGRsZToge1xuXHRcdFx0XHRcdFwidWktc2VsZWN0bWVudS1idXR0b24tb3BlblwiOiBcIlwiLFxuXHRcdFx0XHRcdFwidWktc2VsZWN0bWVudS1idXR0b24tY2xvc2VkXCI6IFwiXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0Zmlyc3Q6IHtcblx0XHRcdFx0XHRcInVpLXNlbGVjdG1lbnUtYnV0dG9uLW9wZW5cIjogXCJ1aS1jb3JuZXItXCIgKyAoIGRpcmVjdGlvbiA/IFwidG9wXCIgOiBcInRsXCIgKSxcblx0XHRcdFx0XHRcInVpLXNlbGVjdG1lbnUtYnV0dG9uLWNsb3NlZFwiOiBcInVpLWNvcm5lci1cIiArICggZGlyZWN0aW9uID8gXCJ0b3BcIiA6IFwibGVmdFwiIClcblx0XHRcdFx0fSxcblx0XHRcdFx0bGFzdDoge1xuXHRcdFx0XHRcdFwidWktc2VsZWN0bWVudS1idXR0b24tb3BlblwiOiBkaXJlY3Rpb24gPyBcIlwiIDogXCJ1aS1jb3JuZXItdHJcIixcblx0XHRcdFx0XHRcInVpLXNlbGVjdG1lbnUtYnV0dG9uLWNsb3NlZFwiOiBcInVpLWNvcm5lci1cIiArICggZGlyZWN0aW9uID8gXCJib3R0b21cIiA6IFwicmlnaHRcIiApXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG9ubHk6IHtcblx0XHRcdFx0XHRcInVpLXNlbGVjdG1lbnUtYnV0dG9uLW9wZW5cIjogXCJ1aS1jb3JuZXItdG9wXCIsXG5cdFx0XHRcdFx0XCJ1aS1zZWxlY3RtZW51LWJ1dHRvbi1jbG9zZWRcIjogXCJ1aS1jb3JuZXItYWxsXCJcblx0XHRcdFx0fVxuXG5cdFx0XHR9WyBwb3NpdGlvbiBdXG5cdFx0fTtcblx0fSxcblxuXHRfcmVzb2x2ZUNsYXNzZXNWYWx1ZXM6IGZ1bmN0aW9uKCBjbGFzc2VzLCBpbnN0YW5jZSApIHtcblx0XHR2YXIgcmVzdWx0ID0ge307XG5cdFx0JC5lYWNoKCBjbGFzc2VzLCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0dmFyIGN1cnJlbnQgPSBpbnN0YW5jZS5vcHRpb25zLmNsYXNzZXNbIGtleSBdIHx8IFwiXCI7XG5cdFx0XHRjdXJyZW50ID0gJC50cmltKCBjdXJyZW50LnJlcGxhY2UoIGNvbnRyb2xncm91cENvcm5lclJlZ2V4LCBcIlwiICkgKTtcblx0XHRcdHJlc3VsdFsga2V5IF0gPSAoIGN1cnJlbnQgKyBcIiBcIiArIGNsYXNzZXNbIGtleSBdICkucmVwbGFjZSggL1xccysvZywgXCIgXCIgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRpZiAoIGtleSA9PT0gXCJkaXJlY3Rpb25cIiApIHtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBcInVpLWNvbnRyb2xncm91cC1cIiArIHRoaXMub3B0aW9ucy5kaXJlY3Rpb24gKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHR0aGlzLl9jYWxsQ2hpbGRNZXRob2QoIHZhbHVlID8gXCJkaXNhYmxlXCIgOiBcImVuYWJsZVwiICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5yZWZyZXNoKCk7XG5cdH0sXG5cblx0cmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuLFxuXHRcdFx0dGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLl9hZGRDbGFzcyggXCJ1aS1jb250cm9sZ3JvdXAgdWktY29udHJvbGdyb3VwLVwiICsgdGhpcy5vcHRpb25zLmRpcmVjdGlvbiApO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIiApIHtcblx0XHRcdHRoaXMuX2FkZENsYXNzKCBudWxsLCBcInVpLWhlbHBlci1jbGVhcmZpeFwiICk7XG5cdFx0fVxuXHRcdHRoaXMuX2luaXRXaWRnZXRzKCk7XG5cblx0XHRjaGlsZHJlbiA9IHRoaXMuY2hpbGRXaWRnZXRzO1xuXG5cdFx0Ly8gV2UgZmlsdGVyIGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIHRyYWNrIGFsbCBjaGlsZFdpZGdldHMgbm90IGp1c3QgdGhlIHZpc2libGUgb25lc1xuXHRcdGlmICggdGhpcy5vcHRpb25zLm9ubHlWaXNpYmxlICkge1xuXHRcdFx0Y2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoIFwiOnZpc2libGVcIiApO1xuXHRcdH1cblxuXHRcdGlmICggY2hpbGRyZW4ubGVuZ3RoICkge1xuXG5cdFx0XHQvLyBXZSBkbyB0aGlzIGxhc3QgYmVjYXVzZSB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBhbGwgZW5oYW5jbWVudCBpcyBkb25lXG5cdFx0XHQvLyBiZWZvcmUgZGV0ZXJtaW5pbmcgZmlyc3QgYW5kIGxhc3Rcblx0XHRcdCQuZWFjaCggWyBcImZpcnN0XCIsIFwibGFzdFwiIF0sIGZ1bmN0aW9uKCBpbmRleCwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBpbnN0YW5jZSA9IGNoaWxkcmVuWyB2YWx1ZSBdKCkuZGF0YSggXCJ1aS1jb250cm9sZ3JvdXAtZGF0YVwiICk7XG5cblx0XHRcdFx0aWYgKCBpbnN0YW5jZSAmJiB0aGF0WyBcIl9cIiArIGluc3RhbmNlLndpZGdldE5hbWUgKyBcIk9wdGlvbnNcIiBdICkge1xuXHRcdFx0XHRcdHZhciBvcHRpb25zID0gdGhhdFsgXCJfXCIgKyBpbnN0YW5jZS53aWRnZXROYW1lICsgXCJPcHRpb25zXCIgXShcblx0XHRcdFx0XHRcdGNoaWxkcmVuLmxlbmd0aCA9PT0gMSA/IFwib25seVwiIDogdmFsdWVcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdG9wdGlvbnMuY2xhc3NlcyA9IHRoYXQuX3Jlc29sdmVDbGFzc2VzVmFsdWVzKCBvcHRpb25zLmNsYXNzZXMsIGluc3RhbmNlICk7XG5cdFx0XHRcdFx0aW5zdGFuY2UuZWxlbWVudFsgaW5zdGFuY2Uud2lkZ2V0TmFtZSBdKCBvcHRpb25zICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhhdC5fdXBkYXRlQ29ybmVyQ2xhc3MoIGNoaWxkcmVuWyB2YWx1ZSBdKCksIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblxuXHRcdFx0Ly8gRmluYWxseSBjYWxsIHRoZSByZWZyZXNoIG1ldGhvZCBvbiBlYWNoIG9mIHRoZSBjaGlsZCB3aWRnZXRzLlxuXHRcdFx0dGhpcy5fY2FsbENoaWxkTWV0aG9kKCBcInJlZnJlc2hcIiApO1xuXHRcdH1cblx0fVxufSApO1xuXG4vKiFcbiAqIGpRdWVyeSBVSSBDaGVja2JveHJhZGlvIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBDaGVja2JveHJhZGlvXG4vLz4+Z3JvdXA6IFdpZGdldHNcbi8vPj5kZXNjcmlwdGlvbjogRW5oYW5jZXMgYSBmb3JtIHdpdGggbXVsdGlwbGUgdGhlbWVhYmxlIGNoZWNrYm94ZXMgb3IgcmFkaW8gYnV0dG9ucy5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9jaGVja2JveHJhZGlvL1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2NoZWNrYm94cmFkaW8vXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2UvY29yZS5jc3Ncbi8vPj5jc3Muc3RydWN0dXJlOiAuLi8uLi90aGVtZXMvYmFzZS9idXR0b24uY3NzXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2UvY2hlY2tib3hyYWRpby5jc3Ncbi8vPj5jc3MudGhlbWU6IC4uLy4uL3RoZW1lcy9iYXNlL3RoZW1lLmNzc1xuXG5cblxuJC53aWRnZXQoIFwidWkuY2hlY2tib3hyYWRpb1wiLCBbICQudWkuZm9ybVJlc2V0TWl4aW4sIHtcblx0dmVyc2lvbjogXCIxLjEyLjFcIixcblx0b3B0aW9uczoge1xuXHRcdGRpc2FibGVkOiBudWxsLFxuXHRcdGxhYmVsOiBudWxsLFxuXHRcdGljb246IHRydWUsXG5cdFx0Y2xhc3Nlczoge1xuXHRcdFx0XCJ1aS1jaGVja2JveHJhZGlvLWxhYmVsXCI6IFwidWktY29ybmVyLWFsbFwiLFxuXHRcdFx0XCJ1aS1jaGVja2JveHJhZGlvLWljb25cIjogXCJ1aS1jb3JuZXItYWxsXCJcblx0XHR9XG5cdH0sXG5cblx0X2dldENyZWF0ZU9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkaXNhYmxlZCwgbGFiZWxzO1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuX3N1cGVyKCkgfHwge307XG5cblx0XHQvLyBXZSByZWFkIHRoZSB0eXBlIGhlcmUsIGJlY2F1c2UgaXQgbWFrZXMgbW9yZSBzZW5zZSB0byB0aHJvdyBhIGVsZW1lbnQgdHlwZSBlcnJvciBmaXJzdCxcblx0XHQvLyByYXRoZXIgdGhlbiB0aGUgZXJyb3IgZm9yIGxhY2sgb2YgYSBsYWJlbC4gT2Z0ZW4gaWYgaXRzIHRoZSB3cm9uZyB0eXBlLCBpdFxuXHRcdC8vIHdvbid0IGhhdmUgYSBsYWJlbCAoZS5nLiBjYWxsaW5nIG9uIGEgZGl2LCBidG4sIGV0Yylcblx0XHR0aGlzLl9yZWFkVHlwZSgpO1xuXG5cdFx0bGFiZWxzID0gdGhpcy5lbGVtZW50LmxhYmVscygpO1xuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGxhYmVscywgdXNlIHRoZSBsYXN0IG9uZVxuXHRcdHRoaXMubGFiZWwgPSAkKCBsYWJlbHNbIGxhYmVscy5sZW5ndGggLSAxIF0gKTtcblx0XHRpZiAoICF0aGlzLmxhYmVsLmxlbmd0aCApIHtcblx0XHRcdCQuZXJyb3IoIFwiTm8gbGFiZWwgZm91bmQgZm9yIGNoZWNrYm94cmFkaW8gd2lkZ2V0XCIgKTtcblx0XHR9XG5cblx0XHR0aGlzLm9yaWdpbmFsTGFiZWwgPSBcIlwiO1xuXG5cdFx0Ly8gV2UgbmVlZCB0byBnZXQgdGhlIGxhYmVsIHRleHQgYnV0IHRoaXMgbWF5IGFsc28gbmVlZCB0byBtYWtlIHN1cmUgaXQgZG9lcyBub3QgY29udGFpbiB0aGVcblx0XHQvLyBpbnB1dCBpdHNlbGYuXG5cdFx0dGhpcy5sYWJlbC5jb250ZW50cygpLm5vdCggdGhpcy5lbGVtZW50WyAwIF0gKS5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gVGhlIGxhYmVsIGNvbnRlbnRzIGNvdWxkIGJlIHRleHQsIGh0bWwsIG9yIGEgbWl4LiBXZSBjb25jYXQgZWFjaCBlbGVtZW50IHRvIGdldCBhXG5cdFx0XHQvLyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxhYmVsLCB3aXRob3V0IHRoZSBpbnB1dCBhcyBwYXJ0IG9mIGl0LlxuXHRcdFx0dGhhdC5vcmlnaW5hbExhYmVsICs9IHRoaXMubm9kZVR5cGUgPT09IDMgPyAkKCB0aGlzICkudGV4dCgpIDogdGhpcy5vdXRlckhUTUw7XG5cdFx0fSApO1xuXG5cdFx0Ly8gU2V0IHRoZSBsYWJlbCBvcHRpb24gaWYgd2UgZm91bmQgbGFiZWwgdGV4dFxuXHRcdGlmICggdGhpcy5vcmlnaW5hbExhYmVsICkge1xuXHRcdFx0b3B0aW9ucy5sYWJlbCA9IHRoaXMub3JpZ2luYWxMYWJlbDtcblx0XHR9XG5cblx0XHRkaXNhYmxlZCA9IHRoaXMuZWxlbWVudFsgMCBdLmRpc2FibGVkO1xuXHRcdGlmICggZGlzYWJsZWQgIT0gbnVsbCApIHtcblx0XHRcdG9wdGlvbnMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcblx0XHR9XG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoZWNrZWQgPSB0aGlzLmVsZW1lbnRbIDAgXS5jaGVja2VkO1xuXG5cdFx0dGhpcy5fYmluZEZvcm1SZXNldEhhbmRsZXIoKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmRpc2FibGVkID09IG51bGwgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPSB0aGlzLmVsZW1lbnRbIDAgXS5kaXNhYmxlZDtcblx0XHR9XG5cblx0XHR0aGlzLl9zZXRPcHRpb24oIFwiZGlzYWJsZWRcIiwgdGhpcy5vcHRpb25zLmRpc2FibGVkICk7XG5cdFx0dGhpcy5fYWRkQ2xhc3MoIFwidWktY2hlY2tib3hyYWRpb1wiLCBcInVpLWhlbHBlci1oaWRkZW4tYWNjZXNzaWJsZVwiICk7XG5cdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMubGFiZWwsIFwidWktY2hlY2tib3hyYWRpby1sYWJlbFwiLCBcInVpLWJ1dHRvbiB1aS13aWRnZXRcIiApO1xuXG5cdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwicmFkaW9cIiApIHtcblx0XHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLmxhYmVsLCBcInVpLWNoZWNrYm94cmFkaW8tcmFkaW8tbGFiZWxcIiApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmxhYmVsICYmIHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdGhpcy5vcmlnaW5hbExhYmVsICkge1xuXHRcdFx0dGhpcy5fdXBkYXRlTGFiZWwoKTtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLm9yaWdpbmFsTGFiZWwgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMubGFiZWwgPSB0aGlzLm9yaWdpbmFsTGFiZWw7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZW5oYW5jZSgpO1xuXG5cdFx0aWYgKCBjaGVja2VkICkge1xuXHRcdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMubGFiZWwsIFwidWktY2hlY2tib3hyYWRpby1jaGVja2VkXCIsIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdGlmICggdGhpcy5pY29uICkge1xuXHRcdFx0XHR0aGlzLl9hZGRDbGFzcyggdGhpcy5pY29uLCBudWxsLCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9vbigge1xuXHRcdFx0Y2hhbmdlOiBcIl90b2dnbGVDbGFzc2VzXCIsXG5cdFx0XHRmb2N1czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLmxhYmVsLCBudWxsLCBcInVpLXN0YXRlLWZvY3VzIHVpLXZpc3VhbC1mb2N1c1wiICk7XG5cdFx0XHR9LFxuXHRcdFx0Ymx1cjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmxhYmVsLCBudWxsLCBcInVpLXN0YXRlLWZvY3VzIHVpLXZpc3VhbC1mb2N1c1wiICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9yZWFkVHlwZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5vZGVOYW1lID0gdGhpcy5lbGVtZW50WyAwIF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHR0aGlzLnR5cGUgPSB0aGlzLmVsZW1lbnRbIDAgXS50eXBlO1xuXHRcdGlmICggbm9kZU5hbWUgIT09IFwiaW5wdXRcIiB8fCAhL3JhZGlvfGNoZWNrYm94Ly50ZXN0KCB0aGlzLnR5cGUgKSApIHtcblx0XHRcdCQuZXJyb3IoIFwiQ2FuJ3QgY3JlYXRlIGNoZWNrYm94cmFkaW8gb24gZWxlbWVudC5ub2RlTmFtZT1cIiArIG5vZGVOYW1lICtcblx0XHRcdFx0XCIgYW5kIGVsZW1lbnQudHlwZT1cIiArIHRoaXMudHlwZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBTdXBwb3J0IGpRdWVyeSBNb2JpbGUgZW5oYW5jZWQgb3B0aW9uXG5cdF9lbmhhbmNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl91cGRhdGVJY29uKCB0aGlzLmVsZW1lbnRbIDAgXS5jaGVja2VkICk7XG5cdH0sXG5cblx0d2lkZ2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5sYWJlbDtcblx0fSxcblxuXHRfZ2V0UmFkaW9Hcm91cDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGdyb3VwO1xuXHRcdHZhciBuYW1lID0gdGhpcy5lbGVtZW50WyAwIF0ubmFtZTtcblx0XHR2YXIgbmFtZVNlbGVjdG9yID0gXCJpbnB1dFtuYW1lPSdcIiArICQudWkuZXNjYXBlU2VsZWN0b3IoIG5hbWUgKSArIFwiJ11cIjtcblxuXHRcdGlmICggIW5hbWUgKSB7XG5cdFx0XHRyZXR1cm4gJCggW10gKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuZm9ybS5sZW5ndGggKSB7XG5cdFx0XHRncm91cCA9ICQoIHRoaXMuZm9ybVsgMCBdLmVsZW1lbnRzICkuZmlsdGVyKCBuYW1lU2VsZWN0b3IgKTtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBOb3QgaW5zaWRlIGEgZm9ybSwgY2hlY2sgYWxsIGlucHV0cyB0aGF0IGFsc28gYXJlIG5vdCBpbnNpZGUgYSBmb3JtXG5cdFx0XHRncm91cCA9ICQoIG5hbWVTZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAkKCB0aGlzICkuZm9ybSgpLmxlbmd0aCA9PT0gMDtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZ3JvdXAubm90KCB0aGlzLmVsZW1lbnQgKTtcblx0fSxcblxuXHRfdG9nZ2xlQ2xhc3NlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoZWNrZWQgPSB0aGlzLmVsZW1lbnRbIDAgXS5jaGVja2VkO1xuXHRcdHRoaXMuX3RvZ2dsZUNsYXNzKCB0aGlzLmxhYmVsLCBcInVpLWNoZWNrYm94cmFkaW8tY2hlY2tlZFwiLCBcInVpLXN0YXRlLWFjdGl2ZVwiLCBjaGVja2VkICk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5pY29uICYmIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICkge1xuXHRcdFx0dGhpcy5fdG9nZ2xlQ2xhc3MoIHRoaXMuaWNvbiwgbnVsbCwgXCJ1aS1pY29uLWNoZWNrIHVpLXN0YXRlLWNoZWNrZWRcIiwgY2hlY2tlZCApXG5cdFx0XHRcdC5fdG9nZ2xlQ2xhc3MoIHRoaXMuaWNvbiwgbnVsbCwgXCJ1aS1pY29uLWJsYW5rXCIsICFjaGVja2VkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwicmFkaW9cIiApIHtcblx0XHRcdHRoaXMuX2dldFJhZGlvR3JvdXAoKVxuXHRcdFx0XHQuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGluc3RhbmNlID0gJCggdGhpcyApLmNoZWNrYm94cmFkaW8oIFwiaW5zdGFuY2VcIiApO1xuXG5cdFx0XHRcdFx0aWYgKCBpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRcdGluc3RhbmNlLl9yZW1vdmVDbGFzcyggaW5zdGFuY2UubGFiZWwsXG5cdFx0XHRcdFx0XHRcdFwidWktY2hlY2tib3hyYWRpby1jaGVja2VkXCIsIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3VuYmluZEZvcm1SZXNldEhhbmRsZXIoKTtcblxuXHRcdGlmICggdGhpcy5pY29uICkge1xuXHRcdFx0dGhpcy5pY29uLnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5pY29uU3BhY2UucmVtb3ZlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gV2UgZG9uJ3QgYWxsb3cgdGhlIHZhbHVlIHRvIGJlIHNldCB0byBub3RoaW5nXG5cdFx0aWYgKCBrZXkgPT09IFwibGFiZWxcIiAmJiAhdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblxuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHR0aGlzLl90b2dnbGVDbGFzcyggdGhpcy5sYWJlbCwgbnVsbCwgXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiLCB2YWx1ZSApO1xuXHRcdFx0dGhpcy5lbGVtZW50WyAwIF0uZGlzYWJsZWQgPSB2YWx1ZTtcblxuXHRcdFx0Ly8gRG9uJ3QgcmVmcmVzaCB3aGVuIHNldHRpbmcgZGlzYWJsZWRcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5yZWZyZXNoKCk7XG5cdH0sXG5cblx0X3VwZGF0ZUljb246IGZ1bmN0aW9uKCBjaGVja2VkICkge1xuXHRcdHZhciB0b0FkZCA9IFwidWktaWNvbiB1aS1pY29uLWJhY2tncm91bmQgXCI7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5pY29uICkge1xuXHRcdFx0aWYgKCAhdGhpcy5pY29uICkge1xuXHRcdFx0XHR0aGlzLmljb24gPSAkKCBcIjxzcGFuPlwiICk7XG5cdFx0XHRcdHRoaXMuaWNvblNwYWNlID0gJCggXCI8c3Bhbj4gPC9zcGFuPlwiICk7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLmljb25TcGFjZSwgXCJ1aS1jaGVja2JveHJhZGlvLWljb24tc3BhY2VcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICkge1xuXHRcdFx0XHR0b0FkZCArPSBjaGVja2VkID8gXCJ1aS1pY29uLWNoZWNrIHVpLXN0YXRlLWNoZWNrZWRcIiA6IFwidWktaWNvbi1ibGFua1wiO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggdGhpcy5pY29uLCBudWxsLCBjaGVja2VkID8gXCJ1aS1pY29uLWJsYW5rXCIgOiBcInVpLWljb24tY2hlY2tcIiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG9BZGQgKz0gXCJ1aS1pY29uLWJsYW5rXCI7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9hZGRDbGFzcyggdGhpcy5pY29uLCBcInVpLWNoZWNrYm94cmFkaW8taWNvblwiLCB0b0FkZCApO1xuXHRcdFx0aWYgKCAhY2hlY2tlZCApIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIHRoaXMuaWNvbiwgbnVsbCwgXCJ1aS1pY29uLWNoZWNrIHVpLXN0YXRlLWNoZWNrZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pY29uLnByZXBlbmRUbyggdGhpcy5sYWJlbCApLmFmdGVyKCB0aGlzLmljb25TcGFjZSApO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaWNvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5pY29uLnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5pY29uU3BhY2UucmVtb3ZlKCk7XG5cdFx0XHRkZWxldGUgdGhpcy5pY29uO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlTGFiZWw6IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBjb250ZW50cyBvZiB0aGUgbGFiZWwgKCBtaW51cyB0aGUgaWNvbiwgaWNvbiBzcGFjZSwgYW5kIGlucHV0IClcblx0XHR2YXIgY29udGVudHMgPSB0aGlzLmxhYmVsLmNvbnRlbnRzKCkubm90KCB0aGlzLmVsZW1lbnRbIDAgXSApO1xuXHRcdGlmICggdGhpcy5pY29uICkge1xuXHRcdFx0Y29udGVudHMgPSBjb250ZW50cy5ub3QoIHRoaXMuaWNvblsgMCBdICk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5pY29uU3BhY2UgKSB7XG5cdFx0XHRjb250ZW50cyA9IGNvbnRlbnRzLm5vdCggdGhpcy5pY29uU3BhY2VbIDAgXSApO1xuXHRcdH1cblx0XHRjb250ZW50cy5yZW1vdmUoKTtcblxuXHRcdHRoaXMubGFiZWwuYXBwZW5kKCB0aGlzLm9wdGlvbnMubGFiZWwgKTtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hlY2tlZCA9IHRoaXMuZWxlbWVudFsgMCBdLmNoZWNrZWQsXG5cdFx0XHRpc0Rpc2FibGVkID0gdGhpcy5lbGVtZW50WyAwIF0uZGlzYWJsZWQ7XG5cblx0XHR0aGlzLl91cGRhdGVJY29uKCBjaGVja2VkICk7XG5cdFx0dGhpcy5fdG9nZ2xlQ2xhc3MoIHRoaXMubGFiZWwsIFwidWktY2hlY2tib3hyYWRpby1jaGVja2VkXCIsIFwidWktc3RhdGUtYWN0aXZlXCIsIGNoZWNrZWQgKTtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gbnVsbCApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUxhYmVsKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Rpc2FibGVkICE9PSB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb25zKCB7IFwiZGlzYWJsZWRcIjogaXNEaXNhYmxlZCB9ICk7XG5cdFx0fVxuXHR9XG5cbn0gXSApO1xuXG52YXIgd2lkZ2V0c0NoZWNrYm94cmFkaW8gPSAkLnVpLmNoZWNrYm94cmFkaW87XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgQnV0dG9uIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBCdXR0b25cbi8vPj5ncm91cDogV2lkZ2V0c1xuLy8+PmRlc2NyaXB0aW9uOiBFbmhhbmNlcyBhIGZvcm0gd2l0aCB0aGVtZWFibGUgYnV0dG9ucy5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9idXR0b24vXG4vLz4+ZGVtb3M6IGh0dHA6Ly9qcXVlcnl1aS5jb20vYnV0dG9uL1xuLy8+PmNzcy5zdHJ1Y3R1cmU6IC4uLy4uL3RoZW1lcy9iYXNlL2NvcmUuY3NzXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2UvYnV0dG9uLmNzc1xuLy8+PmNzcy50aGVtZTogLi4vLi4vdGhlbWVzL2Jhc2UvdGhlbWUuY3NzXG5cblxuXG4kLndpZGdldCggXCJ1aS5idXR0b25cIiwge1xuXHR2ZXJzaW9uOiBcIjEuMTIuMVwiLFxuXHRkZWZhdWx0RWxlbWVudDogXCI8YnV0dG9uPlwiLFxuXHRvcHRpb25zOiB7XG5cdFx0Y2xhc3Nlczoge1xuXHRcdFx0XCJ1aS1idXR0b25cIjogXCJ1aS1jb3JuZXItYWxsXCJcblx0XHR9LFxuXHRcdGRpc2FibGVkOiBudWxsLFxuXHRcdGljb246IG51bGwsXG5cdFx0aWNvblBvc2l0aW9uOiBcImJlZ2lubmluZ1wiLFxuXHRcdGxhYmVsOiBudWxsLFxuXHRcdHNob3dMYWJlbDogdHJ1ZVxuXHR9LFxuXG5cdF9nZXRDcmVhdGVPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGlzYWJsZWQsXG5cblx0XHRcdC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBjYXNlcyBsaWtlIGluIGpRdWVyeSBNb2JpbGUgd2hlcmUgdGhlIGJhc2Ugd2lkZ2V0IGRvZXMgaGF2ZVxuXHRcdFx0Ly8gYW4gaW1wbGVtZW50YXRpb24gb2YgX2dldENyZWF0ZU9wdGlvbnNcblx0XHRcdG9wdGlvbnMgPSB0aGlzLl9zdXBlcigpIHx8IHt9O1xuXG5cdFx0dGhpcy5pc0lucHV0ID0gdGhpcy5lbGVtZW50LmlzKCBcImlucHV0XCIgKTtcblxuXHRcdGRpc2FibGVkID0gdGhpcy5lbGVtZW50WyAwIF0uZGlzYWJsZWQ7XG5cdFx0aWYgKCBkaXNhYmxlZCAhPSBudWxsICkge1xuXHRcdFx0b3B0aW9ucy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuXHRcdH1cblxuXHRcdHRoaXMub3JpZ2luYWxMYWJlbCA9IHRoaXMuaXNJbnB1dCA/IHRoaXMuZWxlbWVudC52YWwoKSA6IHRoaXMuZWxlbWVudC5odG1sKCk7XG5cdFx0aWYgKCB0aGlzLm9yaWdpbmFsTGFiZWwgKSB7XG5cdFx0XHRvcHRpb25zLmxhYmVsID0gdGhpcy5vcmlnaW5hbExhYmVsO1xuXHRcdH1cblxuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXMub3B0aW9uLnNob3dMYWJlbCAmICF0aGlzLm9wdGlvbnMuaWNvbiApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zaG93TGFiZWwgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFdlIGhhdmUgdG8gY2hlY2sgdGhlIG9wdGlvbiBhZ2FpbiBoZXJlIGV2ZW4gdGhvdWdoIHdlIGRpZCBpbiBfZ2V0Q3JlYXRlT3B0aW9ucyxcblx0XHQvLyBiZWNhdXNlIG51bGwgbWF5IGhhdmUgYmVlbiBwYXNzZWQgb24gaW5pdCB3aGljaCB3b3VsZCBvdmVycmlkZSB3aGF0IHdhcyBzZXQgaW5cblx0XHQvLyBfZ2V0Q3JlYXRlT3B0aW9uc1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmRpc2FibGVkID09IG51bGwgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPSB0aGlzLmVsZW1lbnRbIDAgXS5kaXNhYmxlZCB8fCBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLmhhc1RpdGxlID0gISF0aGlzLmVsZW1lbnQuYXR0ciggXCJ0aXRsZVwiICk7XG5cblx0XHQvLyBDaGVjayB0byBzZWUgaWYgdGhlIGxhYmVsIG5lZWRzIHRvIGJlIHNldCBvciBpZiBpdHMgYWxyZWFkeSBjb3JyZWN0XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubGFiZWwgJiYgdGhpcy5vcHRpb25zLmxhYmVsICE9PSB0aGlzLm9yaWdpbmFsTGFiZWwgKSB7XG5cdFx0XHRpZiAoIHRoaXMuaXNJbnB1dCApIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnZhbCggdGhpcy5vcHRpb25zLmxhYmVsICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuaHRtbCggdGhpcy5vcHRpb25zLmxhYmVsICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2FkZENsYXNzKCBcInVpLWJ1dHRvblwiLCBcInVpLXdpZGdldFwiICk7XG5cdFx0dGhpcy5fc2V0T3B0aW9uKCBcImRpc2FibGVkXCIsIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApO1xuXHRcdHRoaXMuX2VuaGFuY2UoKTtcblxuXHRcdGlmICggdGhpcy5lbGVtZW50LmlzKCBcImFcIiApICkge1xuXHRcdFx0dGhpcy5fb24oIHtcblx0XHRcdFx0XCJrZXl1cFwiOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuU1BBQ0UgKSB7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQaGFudG9tSlMgPD0gMS45LCBJRSA4IE9ubHlcblx0XHRcdFx0XHRcdC8vIElmIGEgbmF0aXZlIGNsaWNrIGlzIGF2YWlsYWJsZSB1c2UgaXQgc28gd2UgYWN0dWFsbHkgY2F1c2UgbmF2aWdhdGlvblxuXHRcdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIGp1c3QgdHJpZ2dlciBhIGNsaWNrIGV2ZW50XG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuZWxlbWVudFsgMCBdLmNsaWNrICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnRbIDAgXS5jbGljaygpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIFwiY2xpY2tcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0fSxcblxuXHRfZW5oYW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpcy5lbGVtZW50LmlzKCBcImJ1dHRvblwiICkgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYXR0ciggXCJyb2xlXCIsIFwiYnV0dG9uXCIgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5pY29uICkge1xuXHRcdFx0dGhpcy5fdXBkYXRlSWNvbiggXCJpY29uXCIsIHRoaXMub3B0aW9ucy5pY29uICk7XG5cdFx0XHR0aGlzLl91cGRhdGVUb29sdGlwKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVUb29sdGlwOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRpdGxlID0gdGhpcy5lbGVtZW50LmF0dHIoIFwidGl0bGVcIiApO1xuXG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLnNob3dMYWJlbCAmJiAhdGhpcy50aXRsZSApIHtcblx0XHRcdHRoaXMuZWxlbWVudC5hdHRyKCBcInRpdGxlXCIsIHRoaXMub3B0aW9ucy5sYWJlbCApO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlSWNvbjogZnVuY3Rpb24oIG9wdGlvbiwgdmFsdWUgKSB7XG5cdFx0dmFyIGljb24gPSBvcHRpb24gIT09IFwiaWNvblBvc2l0aW9uXCIsXG5cdFx0XHRwb3NpdGlvbiA9IGljb24gPyB0aGlzLm9wdGlvbnMuaWNvblBvc2l0aW9uIDogdmFsdWUsXG5cdFx0XHRkaXNwbGF5QmxvY2sgPSBwb3NpdGlvbiA9PT0gXCJ0b3BcIiB8fCBwb3NpdGlvbiA9PT0gXCJib3R0b21cIjtcblxuXHRcdC8vIENyZWF0ZSBpY29uXG5cdFx0aWYgKCAhdGhpcy5pY29uICkge1xuXHRcdFx0dGhpcy5pY29uID0gJCggXCI8c3Bhbj5cIiApO1xuXG5cdFx0XHR0aGlzLl9hZGRDbGFzcyggdGhpcy5pY29uLCBcInVpLWJ1dHRvbi1pY29uXCIsIFwidWktaWNvblwiICk7XG5cblx0XHRcdGlmICggIXRoaXMub3B0aW9ucy5zaG93TGFiZWwgKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKCBcInVpLWJ1dHRvbi1pY29uLW9ubHlcIiApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIGljb24gKSB7XG5cblx0XHRcdC8vIElmIHdlIGFyZSB1cGRhdGluZyB0aGUgaWNvbiByZW1vdmUgdGhlIG9sZCBpY29uIGNsYXNzXG5cdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggdGhpcy5pY29uLCBudWxsLCB0aGlzLm9wdGlvbnMuaWNvbiApO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGFyZSB1cGRhdGluZyB0aGUgaWNvbiBhZGQgdGhlIG5ldyBpY29uIGNsYXNzXG5cdFx0aWYgKCBpY29uICkge1xuXHRcdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMuaWNvbiwgbnVsbCwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9hdHRhY2hJY29uKCBwb3NpdGlvbiApO1xuXG5cdFx0Ly8gSWYgdGhlIGljb24gaXMgb24gdG9wIG9yIGJvdHRvbSB3ZSBuZWVkIHRvIGFkZCB0aGUgdWktd2lkZ2V0LWljb24tYmxvY2sgY2xhc3MgYW5kIHJlbW92ZVxuXHRcdC8vIHRoZSBpY29uU3BhY2UgaWYgdGhlcmUgaXMgb25lLlxuXHRcdGlmICggZGlzcGxheUJsb2NrICkge1xuXHRcdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMuaWNvbiwgbnVsbCwgXCJ1aS13aWRnZXQtaWNvbi1ibG9ja1wiICk7XG5cdFx0XHRpZiAoIHRoaXMuaWNvblNwYWNlICkge1xuXHRcdFx0XHR0aGlzLmljb25TcGFjZS5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBQb3NpdGlvbiBpcyBiZWdpbm5pbmcgb3IgZW5kIHNvIHJlbW92ZSB0aGUgdWktd2lkZ2V0LWljb24tYmxvY2sgY2xhc3MgYW5kIGFkZCB0aGVcblx0XHRcdC8vIHNwYWNlIGlmIGl0IGRvZXMgbm90IGV4aXN0XG5cdFx0XHRpZiAoICF0aGlzLmljb25TcGFjZSApIHtcblx0XHRcdFx0dGhpcy5pY29uU3BhY2UgPSAkKCBcIjxzcGFuPiA8L3NwYW4+XCIgKTtcblx0XHRcdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMuaWNvblNwYWNlLCBcInVpLWJ1dHRvbi1pY29uLXNwYWNlXCIgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmljb24sIG51bGwsIFwidWktd2lnZXQtaWNvbi1ibG9ja1wiICk7XG5cdFx0XHR0aGlzLl9hdHRhY2hJY29uU3BhY2UoIHBvc2l0aW9uICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQXR0ciggXCJyb2xlXCIgKTtcblxuXHRcdGlmICggdGhpcy5pY29uICkge1xuXHRcdFx0dGhpcy5pY29uLnJlbW92ZSgpO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuaWNvblNwYWNlICkge1xuXHRcdFx0dGhpcy5pY29uU3BhY2UucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdGlmICggIXRoaXMuaGFzVGl0bGUgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQXR0ciggXCJ0aXRsZVwiICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hdHRhY2hJY29uU3BhY2U6IGZ1bmN0aW9uKCBpY29uUG9zaXRpb24gKSB7XG5cdFx0dGhpcy5pY29uWyAvXig/OmVuZHxib3R0b20pLy50ZXN0KCBpY29uUG9zaXRpb24gKSA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCIgXSggdGhpcy5pY29uU3BhY2UgKTtcblx0fSxcblxuXHRfYXR0YWNoSWNvbjogZnVuY3Rpb24oIGljb25Qb3NpdGlvbiApIHtcblx0XHR0aGlzLmVsZW1lbnRbIC9eKD86ZW5kfGJvdHRvbSkvLnRlc3QoIGljb25Qb3NpdGlvbiApID8gXCJhcHBlbmRcIiA6IFwicHJlcGVuZFwiIF0oIHRoaXMuaWNvbiApO1xuXHR9LFxuXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIgbmV3U2hvd0xhYmVsID0gb3B0aW9ucy5zaG93TGFiZWwgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5zaG93TGFiZWwgOlxuXHRcdFx0XHRvcHRpb25zLnNob3dMYWJlbCxcblx0XHRcdG5ld0ljb24gPSBvcHRpb25zLmljb24gPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5pY29uIDogb3B0aW9ucy5pY29uO1xuXG5cdFx0aWYgKCAhbmV3U2hvd0xhYmVsICYmICFuZXdJY29uICkge1xuXHRcdFx0b3B0aW9ucy5zaG93TGFiZWwgPSB0cnVlO1xuXHRcdH1cblx0XHR0aGlzLl9zdXBlciggb3B0aW9ucyApO1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdGlmICgga2V5ID09PSBcImljb25cIiApIHtcblx0XHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUljb24oIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuaWNvbiApIHtcblx0XHRcdFx0dGhpcy5pY29uLnJlbW92ZSgpO1xuXHRcdFx0XHRpZiAoIHRoaXMuaWNvblNwYWNlICkge1xuXHRcdFx0XHRcdHRoaXMuaWNvblNwYWNlLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwiaWNvblBvc2l0aW9uXCIgKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVJY29uKCBrZXksIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIGNhbid0IGVuZCB1cCB3aXRoIGEgYnV0dG9uIHRoYXQgaGFzIG5laXRoZXIgdGV4dCBub3IgaWNvblxuXHRcdGlmICgga2V5ID09PSBcInNob3dMYWJlbFwiICkge1xuXHRcdFx0XHR0aGlzLl90b2dnbGVDbGFzcyggXCJ1aS1idXR0b24taWNvbi1vbmx5XCIsIG51bGwsICF2YWx1ZSApO1xuXHRcdFx0XHR0aGlzLl91cGRhdGVUb29sdGlwKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwibGFiZWxcIiApIHtcblx0XHRcdGlmICggdGhpcy5pc0lucHV0ICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQudmFsKCB2YWx1ZSApO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBpY29uLCBhcHBlbmQgaXQsIGVsc2Ugbm90aGluZyB0aGVuIGFwcGVuZCB0aGUgdmFsdWVcblx0XHRcdFx0Ly8gdGhpcyBhdm9pZHMgcmVtb3ZhbCBvZiB0aGUgaWNvbiB3aGVuIHNldHRpbmcgbGFiZWwgdGV4dFxuXHRcdFx0XHR0aGlzLmVsZW1lbnQuaHRtbCggdmFsdWUgKTtcblx0XHRcdFx0aWYgKCB0aGlzLmljb24gKSB7XG5cdFx0XHRcdFx0dGhpcy5fYXR0YWNoSWNvbiggdGhpcy5vcHRpb25zLmljb25Qb3NpdGlvbiApO1xuXHRcdFx0XHRcdHRoaXMuX2F0dGFjaEljb25TcGFjZSggdGhpcy5vcHRpb25zLmljb25Qb3NpdGlvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblxuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHR0aGlzLl90b2dnbGVDbGFzcyggbnVsbCwgXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiLCB2YWx1ZSApO1xuXHRcdFx0dGhpcy5lbGVtZW50WyAwIF0uZGlzYWJsZWQgPSB2YWx1ZTtcblx0XHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ibHVyKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRvIG9ubHkgY2hlY2sgZGlzYWJsZWQgaWYgaXRzIGFuIGVsZW1lbnQgdGhhdCBzdXBwb3J0cyB0aGlzIG90aGVyd2lzZVxuXHRcdC8vIGNoZWNrIGZvciB0aGUgZGlzYWJsZWQgY2xhc3MgdG8gZGV0ZXJtaW5lIHN0YXRlXG5cdFx0dmFyIGlzRGlzYWJsZWQgPSB0aGlzLmVsZW1lbnQuaXMoIFwiaW5wdXQsIGJ1dHRvblwiICkgP1xuXHRcdFx0dGhpcy5lbGVtZW50WyAwIF0uZGlzYWJsZWQgOiB0aGlzLmVsZW1lbnQuaGFzQ2xhc3MoIFwidWktYnV0dG9uLWRpc2FibGVkXCIgKTtcblxuXHRcdGlmICggaXNEaXNhYmxlZCAhPT0gdGhpcy5vcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9ucyggeyBkaXNhYmxlZDogaXNEaXNhYmxlZCB9ICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlVG9vbHRpcCgpO1xuXHR9XG59ICk7XG5cbi8vIERFUFJFQ0FURURcbmlmICggJC51aUJhY2tDb21wYXQgIT09IGZhbHNlICkge1xuXG5cdC8vIFRleHQgYW5kIEljb25zIG9wdGlvbnNcblx0JC53aWRnZXQoIFwidWkuYnV0dG9uXCIsICQudWkuYnV0dG9uLCB7XG5cdFx0b3B0aW9uczoge1xuXHRcdFx0dGV4dDogdHJ1ZSxcblx0XHRcdGljb25zOiB7XG5cdFx0XHRcdHByaW1hcnk6IG51bGwsXG5cdFx0XHRcdHNlY29uZGFyeTogbnVsbFxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNob3dMYWJlbCAmJiAhdGhpcy5vcHRpb25zLnRleHQgKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5zaG93TGFiZWwgPSB0aGlzLm9wdGlvbnMudGV4dDtcblx0XHRcdH1cblx0XHRcdGlmICggIXRoaXMub3B0aW9ucy5zaG93TGFiZWwgJiYgdGhpcy5vcHRpb25zLnRleHQgKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy50ZXh0ID0gdGhpcy5vcHRpb25zLnNob3dMYWJlbDtcblx0XHRcdH1cblx0XHRcdGlmICggIXRoaXMub3B0aW9ucy5pY29uICYmICggdGhpcy5vcHRpb25zLmljb25zLnByaW1hcnkgfHxcblx0XHRcdFx0XHR0aGlzLm9wdGlvbnMuaWNvbnMuc2Vjb25kYXJ5ICkgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLmljb25zLnByaW1hcnkgKSB7XG5cdFx0XHRcdFx0dGhpcy5vcHRpb25zLmljb24gPSB0aGlzLm9wdGlvbnMuaWNvbnMucHJpbWFyeTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLm9wdGlvbnMuaWNvbiA9IHRoaXMub3B0aW9ucy5pY29ucy5zZWNvbmRhcnk7XG5cdFx0XHRcdFx0dGhpcy5vcHRpb25zLmljb25Qb3NpdGlvbiA9IFwiZW5kXCI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMub3B0aW9ucy5pY29uICkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMuaWNvbnMucHJpbWFyeSA9IHRoaXMub3B0aW9ucy5pY29uO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHR9LFxuXG5cdFx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIGtleSA9PT0gXCJ0ZXh0XCIgKSB7XG5cdFx0XHRcdHRoaXMuX3N1cGVyKCBcInNob3dMYWJlbFwiLCB2YWx1ZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGtleSA9PT0gXCJzaG93TGFiZWxcIiApIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLnRleHQgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmICgga2V5ID09PSBcImljb25cIiApIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLmljb25zLnByaW1hcnkgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmICgga2V5ID09PSBcImljb25zXCIgKSB7XG5cdFx0XHRcdGlmICggdmFsdWUucHJpbWFyeSApIHtcblx0XHRcdFx0XHR0aGlzLl9zdXBlciggXCJpY29uXCIsIHZhbHVlLnByaW1hcnkgKTtcblx0XHRcdFx0XHR0aGlzLl9zdXBlciggXCJpY29uUG9zaXRpb25cIiwgXCJiZWdpbm5pbmdcIiApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZS5zZWNvbmRhcnkgKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIoIFwiaWNvblwiLCB2YWx1ZS5zZWNvbmRhcnkgKTtcblx0XHRcdFx0XHR0aGlzLl9zdXBlciggXCJpY29uUG9zaXRpb25cIiwgXCJlbmRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zdXBlckFwcGx5KCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH0gKTtcblxuXHQkLmZuLmJ1dHRvbiA9ICggZnVuY3Rpb24oIG9yaWcgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhdGhpcy5sZW5ndGggfHwgKCB0aGlzLmxlbmd0aCAmJiB0aGlzWyAwIF0udGFnTmFtZSAhPT0gXCJJTlBVVFwiICkgfHxcblx0XHRcdFx0XHQoIHRoaXMubGVuZ3RoICYmIHRoaXNbIDAgXS50YWdOYW1lID09PSBcIklOUFVUXCIgJiYgKFxuXHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBcInR5cGVcIiApICE9PSBcImNoZWNrYm94XCIgJiYgdGhpcy5hdHRyKCBcInR5cGVcIiApICE9PSBcInJhZGlvXCJcblx0XHRcdFx0XHQpICkgKSB7XG5cdFx0XHRcdHJldHVybiBvcmlnLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdH1cblx0XHRcdGlmICggISQudWkuY2hlY2tib3hyYWRpbyApIHtcblx0XHRcdFx0JC5lcnJvciggXCJDaGVja2JveHJhZGlvIHdpZGdldCBtaXNzaW5nXCIgKTtcblx0XHRcdH1cblx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY2hlY2tib3hyYWRpbygge1xuXHRcdFx0XHRcdFwiaWNvblwiOiBmYWxzZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5jaGVja2JveHJhZGlvLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXHR9ICkoICQuZm4uYnV0dG9uICk7XG5cblx0JC5mbi5idXR0b25zZXQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoICEkLnVpLmNvbnRyb2xncm91cCApIHtcblx0XHRcdCQuZXJyb3IoIFwiQ29udHJvbGdyb3VwIHdpZGdldCBtaXNzaW5nXCIgKTtcblx0XHR9XG5cdFx0aWYgKCBhcmd1bWVudHNbIDAgXSA9PT0gXCJvcHRpb25cIiAmJiBhcmd1bWVudHNbIDEgXSA9PT0gXCJpdGVtc1wiICYmIGFyZ3VtZW50c1sgMiBdICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY29udHJvbGdyb3VwLmFwcGx5KCB0aGlzLFxuXHRcdFx0XHRbIGFyZ3VtZW50c1sgMCBdLCBcIml0ZW1zLmJ1dHRvblwiLCBhcmd1bWVudHNbIDIgXSBdICk7XG5cdFx0fVxuXHRcdGlmICggYXJndW1lbnRzWyAwIF0gPT09IFwib3B0aW9uXCIgJiYgYXJndW1lbnRzWyAxIF0gPT09IFwiaXRlbXNcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmNvbnRyb2xncm91cC5hcHBseSggdGhpcywgWyBhcmd1bWVudHNbIDAgXSwgXCJpdGVtcy5idXR0b25cIiBdICk7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIGFyZ3VtZW50c1sgMCBdID09PSBcIm9iamVjdFwiICYmIGFyZ3VtZW50c1sgMCBdLml0ZW1zICkge1xuXHRcdFx0YXJndW1lbnRzWyAwIF0uaXRlbXMgPSB7XG5cdFx0XHRcdGJ1dHRvbjogYXJndW1lbnRzWyAwIF0uaXRlbXNcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmNvbnRyb2xncm91cC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdH07XG59XG5cbnZhciB3aWRnZXRzQnV0dG9uID0gJC51aS5idXR0b247XG5cblxuLy8ganNjczpkaXNhYmxlIG1heGltdW1MaW5lTGVuZ3RoXG4vKiBqc2NzOmRpc2FibGUgcmVxdWlyZUNhbWVsQ2FzZU9yVXBwZXJDYXNlSWRlbnRpZmllcnMgKi9cbi8qIVxuICogalF1ZXJ5IFVJIERhdGVwaWNrZXIgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IERhdGVwaWNrZXJcbi8vPj5ncm91cDogV2lkZ2V0c1xuLy8+PmRlc2NyaXB0aW9uOiBEaXNwbGF5cyBhIGNhbGVuZGFyIGZyb20gYW4gaW5wdXQgb3IgaW5saW5lIGZvciBzZWxlY3RpbmcgZGF0ZXMuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vZGF0ZXBpY2tlci9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9kYXRlcGlja2VyL1xuLy8+PmNzcy5zdHJ1Y3R1cmU6IC4uLy4uL3RoZW1lcy9iYXNlL2NvcmUuY3NzXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2UvZGF0ZXBpY2tlci5jc3Ncbi8vPj5jc3MudGhlbWU6IC4uLy4uL3RoZW1lcy9iYXNlL3RoZW1lLmNzc1xuXG5cblxuJC5leHRlbmQoICQudWksIHsgZGF0ZXBpY2tlcjogeyB2ZXJzaW9uOiBcIjEuMTIuMVwiIH0gfSApO1xuXG52YXIgZGF0ZXBpY2tlcl9pbnN0QWN0aXZlO1xuXG5mdW5jdGlvbiBkYXRlcGlja2VyX2dldFppbmRleCggZWxlbSApIHtcblx0dmFyIHBvc2l0aW9uLCB2YWx1ZTtcblx0d2hpbGUgKCBlbGVtLmxlbmd0aCAmJiBlbGVtWyAwIF0gIT09IGRvY3VtZW50ICkge1xuXG5cdFx0Ly8gSWdub3JlIHotaW5kZXggaWYgcG9zaXRpb24gaXMgc2V0IHRvIGEgdmFsdWUgd2hlcmUgei1pbmRleCBpcyBpZ25vcmVkIGJ5IHRoZSBicm93c2VyXG5cdFx0Ly8gVGhpcyBtYWtlcyBiZWhhdmlvciBvZiB0aGlzIGZ1bmN0aW9uIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzXG5cdFx0Ly8gV2ViS2l0IGFsd2F5cyByZXR1cm5zIGF1dG8gaWYgdGhlIGVsZW1lbnQgaXMgcG9zaXRpb25lZFxuXHRcdHBvc2l0aW9uID0gZWxlbS5jc3MoIFwicG9zaXRpb25cIiApO1xuXHRcdGlmICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJyZWxhdGl2ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIElFIHJldHVybnMgMCB3aGVuIHpJbmRleCBpcyBub3Qgc3BlY2lmaWVkXG5cdFx0XHQvLyBvdGhlciBicm93c2VycyByZXR1cm4gYSBzdHJpbmdcblx0XHRcdC8vIHdlIGlnbm9yZSB0aGUgY2FzZSBvZiBuZXN0ZWQgZWxlbWVudHMgd2l0aCBhbiBleHBsaWNpdCB2YWx1ZSBvZiAwXG5cdFx0XHQvLyA8ZGl2IHN0eWxlPVwiei1pbmRleDogLTEwO1wiPjxkaXYgc3R5bGU9XCJ6LWluZGV4OiAwO1wiPjwvZGl2PjwvZGl2PlxuXHRcdFx0dmFsdWUgPSBwYXJzZUludCggZWxlbS5jc3MoIFwiekluZGV4XCIgKSwgMTAgKTtcblx0XHRcdGlmICggIWlzTmFOKCB2YWx1ZSApICYmIHZhbHVlICE9PSAwICkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsZW0gPSBlbGVtLnBhcmVudCgpO1xuXHR9XG5cblx0cmV0dXJuIDA7XG59XG4vKiBEYXRlIHBpY2tlciBtYW5hZ2VyLlxuICAgVXNlIHRoZSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcywgJC5kYXRlcGlja2VyLCB0byBpbnRlcmFjdCB3aXRoIHRoZSBkYXRlIHBpY2tlci5cbiAgIFNldHRpbmdzIGZvciAoZ3JvdXBzIG9mKSBkYXRlIHBpY2tlcnMgYXJlIG1haW50YWluZWQgaW4gYW4gaW5zdGFuY2Ugb2JqZWN0LFxuICAgYWxsb3dpbmcgbXVsdGlwbGUgZGlmZmVyZW50IHNldHRpbmdzIG9uIHRoZSBzYW1lIHBhZ2UuICovXG5cbmZ1bmN0aW9uIERhdGVwaWNrZXIoKSB7XG5cdHRoaXMuX2N1ckluc3QgPSBudWxsOyAvLyBUaGUgY3VycmVudCBpbnN0YW5jZSBpbiB1c2Vcblx0dGhpcy5fa2V5RXZlbnQgPSBmYWxzZTsgLy8gSWYgdGhlIGxhc3QgZXZlbnQgd2FzIGEga2V5IGV2ZW50XG5cdHRoaXMuX2Rpc2FibGVkSW5wdXRzID0gW107IC8vIExpc3Qgb2YgZGF0ZSBwaWNrZXIgaW5wdXRzIHRoYXQgaGF2ZSBiZWVuIGRpc2FibGVkXG5cdHRoaXMuX2RhdGVwaWNrZXJTaG93aW5nID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIHBvcHVwIHBpY2tlciBpcyBzaG93aW5nICwgZmFsc2UgaWYgbm90XG5cdHRoaXMuX2luRGlhbG9nID0gZmFsc2U7IC8vIFRydWUgaWYgc2hvd2luZyB3aXRoaW4gYSBcImRpYWxvZ1wiLCBmYWxzZSBpZiBub3Rcblx0dGhpcy5fbWFpbkRpdklkID0gXCJ1aS1kYXRlcGlja2VyLWRpdlwiOyAvLyBUaGUgSUQgb2YgdGhlIG1haW4gZGF0ZXBpY2tlciBkaXZpc2lvblxuXHR0aGlzLl9pbmxpbmVDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1pbmxpbmVcIjsgLy8gVGhlIG5hbWUgb2YgdGhlIGlubGluZSBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fYXBwZW5kQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItYXBwZW5kXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBhcHBlbmQgbWFya2VyIGNsYXNzXG5cdHRoaXMuX3RyaWdnZXJDbGFzcyA9IFwidWktZGF0ZXBpY2tlci10cmlnZ2VyXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSB0cmlnZ2VyIG1hcmtlciBjbGFzc1xuXHR0aGlzLl9kaWFsb2dDbGFzcyA9IFwidWktZGF0ZXBpY2tlci1kaWFsb2dcIjsgLy8gVGhlIG5hbWUgb2YgdGhlIGRpYWxvZyBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fZGlzYWJsZUNsYXNzID0gXCJ1aS1kYXRlcGlja2VyLWRpc2FibGVkXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBkaXNhYmxlZCBjb3ZlcmluZyBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fdW5zZWxlY3RhYmxlQ2xhc3MgPSBcInVpLWRhdGVwaWNrZXItdW5zZWxlY3RhYmxlXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSB1bnNlbGVjdGFibGUgY2VsbCBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fY3VycmVudENsYXNzID0gXCJ1aS1kYXRlcGlja2VyLWN1cnJlbnQtZGF5XCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGRheSBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fZGF5T3ZlckNsYXNzID0gXCJ1aS1kYXRlcGlja2VyLWRheXMtY2VsbC1vdmVyXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBkYXkgaG92ZXIgbWFya2VyIGNsYXNzXG5cdHRoaXMucmVnaW9uYWwgPSBbXTsgLy8gQXZhaWxhYmxlIHJlZ2lvbmFsIHNldHRpbmdzLCBpbmRleGVkIGJ5IGxhbmd1YWdlIGNvZGVcblx0dGhpcy5yZWdpb25hbFsgXCJcIiBdID0geyAvLyBEZWZhdWx0IHJlZ2lvbmFsIHNldHRpbmdzXG5cdFx0Y2xvc2VUZXh0OiBcIkRvbmVcIiwgLy8gRGlzcGxheSB0ZXh0IGZvciBjbG9zZSBsaW5rXG5cdFx0cHJldlRleHQ6IFwiUHJldlwiLCAvLyBEaXNwbGF5IHRleHQgZm9yIHByZXZpb3VzIG1vbnRoIGxpbmtcblx0XHRuZXh0VGV4dDogXCJOZXh0XCIsIC8vIERpc3BsYXkgdGV4dCBmb3IgbmV4dCBtb250aCBsaW5rXG5cdFx0Y3VycmVudFRleHQ6IFwiVG9kYXlcIiwgLy8gRGlzcGxheSB0ZXh0IGZvciBjdXJyZW50IG1vbnRoIGxpbmtcblx0XHRtb250aE5hbWVzOiBbIFwiSmFudWFyeVwiLFwiRmVicnVhcnlcIixcIk1hcmNoXCIsXCJBcHJpbFwiLFwiTWF5XCIsXCJKdW5lXCIsXG5cdFx0XHRcIkp1bHlcIixcIkF1Z3VzdFwiLFwiU2VwdGVtYmVyXCIsXCJPY3RvYmVyXCIsXCJOb3ZlbWJlclwiLFwiRGVjZW1iZXJcIiBdLCAvLyBOYW1lcyBvZiBtb250aHMgZm9yIGRyb3AtZG93biBhbmQgZm9ybWF0dGluZ1xuXHRcdG1vbnRoTmFtZXNTaG9ydDogWyBcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiIF0sIC8vIEZvciBmb3JtYXR0aW5nXG5cdFx0ZGF5TmFtZXM6IFsgXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiIF0sIC8vIEZvciBmb3JtYXR0aW5nXG5cdFx0ZGF5TmFtZXNTaG9ydDogWyBcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiIF0sIC8vIEZvciBmb3JtYXR0aW5nXG5cdFx0ZGF5TmFtZXNNaW46IFsgXCJTdVwiLFwiTW9cIixcIlR1XCIsXCJXZVwiLFwiVGhcIixcIkZyXCIsXCJTYVwiIF0sIC8vIENvbHVtbiBoZWFkaW5ncyBmb3IgZGF5cyBzdGFydGluZyBhdCBTdW5kYXlcblx0XHR3ZWVrSGVhZGVyOiBcIldrXCIsIC8vIENvbHVtbiBoZWFkZXIgZm9yIHdlZWsgb2YgdGhlIHllYXJcblx0XHRkYXRlRm9ybWF0OiBcIm1tL2RkL3l5XCIsIC8vIFNlZSBmb3JtYXQgb3B0aW9ucyBvbiBwYXJzZURhdGVcblx0XHRmaXJzdERheTogMCwgLy8gVGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlaywgU3VuID0gMCwgTW9uID0gMSwgLi4uXG5cdFx0aXNSVEw6IGZhbHNlLCAvLyBUcnVlIGlmIHJpZ2h0LXRvLWxlZnQgbGFuZ3VhZ2UsIGZhbHNlIGlmIGxlZnQtdG8tcmlnaHRcblx0XHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLCAvLyBUcnVlIGlmIHRoZSB5ZWFyIHNlbGVjdCBwcmVjZWRlcyBtb250aCwgZmFsc2UgZm9yIG1vbnRoIHRoZW4geWVhclxuXHRcdHllYXJTdWZmaXg6IFwiXCIgLy8gQWRkaXRpb25hbCB0ZXh0IHRvIGFwcGVuZCB0byB0aGUgeWVhciBpbiB0aGUgbW9udGggaGVhZGVyc1xuXHR9O1xuXHR0aGlzLl9kZWZhdWx0cyA9IHsgLy8gR2xvYmFsIGRlZmF1bHRzIGZvciBhbGwgdGhlIGRhdGUgcGlja2VyIGluc3RhbmNlc1xuXHRcdHNob3dPbjogXCJmb2N1c1wiLCAvLyBcImZvY3VzXCIgZm9yIHBvcHVwIG9uIGZvY3VzLFxuXHRcdFx0Ly8gXCJidXR0b25cIiBmb3IgdHJpZ2dlciBidXR0b24sIG9yIFwiYm90aFwiIGZvciBlaXRoZXJcblx0XHRzaG93QW5pbTogXCJmYWRlSW5cIiwgLy8gTmFtZSBvZiBqUXVlcnkgYW5pbWF0aW9uIGZvciBwb3B1cFxuXHRcdHNob3dPcHRpb25zOiB7fSwgLy8gT3B0aW9ucyBmb3IgZW5oYW5jZWQgYW5pbWF0aW9uc1xuXHRcdGRlZmF1bHREYXRlOiBudWxsLCAvLyBVc2VkIHdoZW4gZmllbGQgaXMgYmxhbms6IGFjdHVhbCBkYXRlLFxuXHRcdFx0Ly8gKy8tbnVtYmVyIGZvciBvZmZzZXQgZnJvbSB0b2RheSwgbnVsbCBmb3IgdG9kYXlcblx0XHRhcHBlbmRUZXh0OiBcIlwiLCAvLyBEaXNwbGF5IHRleHQgZm9sbG93aW5nIHRoZSBpbnB1dCBib3gsIGUuZy4gc2hvd2luZyB0aGUgZm9ybWF0XG5cdFx0YnV0dG9uVGV4dDogXCIuLi5cIiwgLy8gVGV4dCBmb3IgdHJpZ2dlciBidXR0b25cblx0XHRidXR0b25JbWFnZTogXCJcIiwgLy8gVVJMIGZvciB0cmlnZ2VyIGJ1dHRvbiBpbWFnZVxuXHRcdGJ1dHRvbkltYWdlT25seTogZmFsc2UsIC8vIFRydWUgaWYgdGhlIGltYWdlIGFwcGVhcnMgYWxvbmUsIGZhbHNlIGlmIGl0IGFwcGVhcnMgb24gYSBidXR0b25cblx0XHRoaWRlSWZOb1ByZXZOZXh0OiBmYWxzZSwgLy8gVHJ1ZSB0byBoaWRlIG5leHQvcHJldmlvdXMgbW9udGggbGlua3Ncblx0XHRcdC8vIGlmIG5vdCBhcHBsaWNhYmxlLCBmYWxzZSB0byBqdXN0IGRpc2FibGUgdGhlbVxuXHRcdG5hdmlnYXRpb25Bc0RhdGVGb3JtYXQ6IGZhbHNlLCAvLyBUcnVlIGlmIGRhdGUgZm9ybWF0dGluZyBhcHBsaWVkIHRvIHByZXYvdG9kYXkvbmV4dCBsaW5rc1xuXHRcdGdvdG9DdXJyZW50OiBmYWxzZSwgLy8gVHJ1ZSBpZiB0b2RheSBsaW5rIGdvZXMgYmFjayB0byBjdXJyZW50IHNlbGVjdGlvbiBpbnN0ZWFkXG5cdFx0Y2hhbmdlTW9udGg6IGZhbHNlLCAvLyBUcnVlIGlmIG1vbnRoIGNhbiBiZSBzZWxlY3RlZCBkaXJlY3RseSwgZmFsc2UgaWYgb25seSBwcmV2L25leHRcblx0XHRjaGFuZ2VZZWFyOiBmYWxzZSwgLy8gVHJ1ZSBpZiB5ZWFyIGNhbiBiZSBzZWxlY3RlZCBkaXJlY3RseSwgZmFsc2UgaWYgb25seSBwcmV2L25leHRcblx0XHR5ZWFyUmFuZ2U6IFwiYy0xMDpjKzEwXCIsIC8vIFJhbmdlIG9mIHllYXJzIHRvIGRpc3BsYXkgaW4gZHJvcC1kb3duLFxuXHRcdFx0Ly8gZWl0aGVyIHJlbGF0aXZlIHRvIHRvZGF5J3MgeWVhciAoLW5uOitubiksIHJlbGF0aXZlIHRvIGN1cnJlbnRseSBkaXNwbGF5ZWQgeWVhclxuXHRcdFx0Ly8gKGMtbm46YytubiksIGFic29sdXRlIChubm5uOm5ubm4pLCBvciBhIGNvbWJpbmF0aW9uIG9mIHRoZSBhYm92ZSAobm5ubjotbilcblx0XHRzaG93T3RoZXJNb250aHM6IGZhbHNlLCAvLyBUcnVlIHRvIHNob3cgZGF0ZXMgaW4gb3RoZXIgbW9udGhzLCBmYWxzZSB0byBsZWF2ZSBibGFua1xuXHRcdHNlbGVjdE90aGVyTW9udGhzOiBmYWxzZSwgLy8gVHJ1ZSB0byBhbGxvdyBzZWxlY3Rpb24gb2YgZGF0ZXMgaW4gb3RoZXIgbW9udGhzLCBmYWxzZSBmb3IgdW5zZWxlY3RhYmxlXG5cdFx0c2hvd1dlZWs6IGZhbHNlLCAvLyBUcnVlIHRvIHNob3cgd2VlayBvZiB0aGUgeWVhciwgZmFsc2UgdG8gbm90IHNob3cgaXRcblx0XHRjYWxjdWxhdGVXZWVrOiB0aGlzLmlzbzg2MDFXZWVrLCAvLyBIb3cgdG8gY2FsY3VsYXRlIHRoZSB3ZWVrIG9mIHRoZSB5ZWFyLFxuXHRcdFx0Ly8gdGFrZXMgYSBEYXRlIGFuZCByZXR1cm5zIHRoZSBudW1iZXIgb2YgdGhlIHdlZWsgZm9yIGl0XG5cdFx0c2hvcnRZZWFyQ3V0b2ZmOiBcIisxMFwiLCAvLyBTaG9ydCB5ZWFyIHZhbHVlcyA8IHRoaXMgYXJlIGluIHRoZSBjdXJyZW50IGNlbnR1cnksXG5cdFx0XHQvLyA+IHRoaXMgYXJlIGluIHRoZSBwcmV2aW91cyBjZW50dXJ5LFxuXHRcdFx0Ly8gc3RyaW5nIHZhbHVlIHN0YXJ0aW5nIHdpdGggXCIrXCIgZm9yIGN1cnJlbnQgeWVhciArIHZhbHVlXG5cdFx0bWluRGF0ZTogbnVsbCwgLy8gVGhlIGVhcmxpZXN0IHNlbGVjdGFibGUgZGF0ZSwgb3IgbnVsbCBmb3Igbm8gbGltaXRcblx0XHRtYXhEYXRlOiBudWxsLCAvLyBUaGUgbGF0ZXN0IHNlbGVjdGFibGUgZGF0ZSwgb3IgbnVsbCBmb3Igbm8gbGltaXRcblx0XHRkdXJhdGlvbjogXCJmYXN0XCIsIC8vIER1cmF0aW9uIG9mIGRpc3BsYXkvY2xvc3VyZVxuXHRcdGJlZm9yZVNob3dEYXk6IG51bGwsIC8vIEZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBkYXRlIGFuZCByZXR1cm5zIGFuIGFycmF5IHdpdGhcblx0XHRcdC8vIFswXSA9IHRydWUgaWYgc2VsZWN0YWJsZSwgZmFsc2UgaWYgbm90LCBbMV0gPSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUocykgb3IgXCJcIixcblx0XHRcdC8vIFsyXSA9IGNlbGwgdGl0bGUgKG9wdGlvbmFsKSwgZS5nLiAkLmRhdGVwaWNrZXIubm9XZWVrZW5kc1xuXHRcdGJlZm9yZVNob3c6IG51bGwsIC8vIEZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gaW5wdXQgZmllbGQgYW5kXG5cdFx0XHQvLyByZXR1cm5zIGEgc2V0IG9mIGN1c3RvbSBzZXR0aW5ncyBmb3IgdGhlIGRhdGUgcGlja2VyXG5cdFx0b25TZWxlY3Q6IG51bGwsIC8vIERlZmluZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gYSBkYXRlIGlzIHNlbGVjdGVkXG5cdFx0b25DaGFuZ2VNb250aFllYXI6IG51bGwsIC8vIERlZmluZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIG1vbnRoIG9yIHllYXIgaXMgY2hhbmdlZFxuXHRcdG9uQ2xvc2U6IG51bGwsIC8vIERlZmluZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIGRhdGVwaWNrZXIgaXMgY2xvc2VkXG5cdFx0bnVtYmVyT2ZNb250aHM6IDEsIC8vIE51bWJlciBvZiBtb250aHMgdG8gc2hvdyBhdCBhIHRpbWVcblx0XHRzaG93Q3VycmVudEF0UG9zOiAwLCAvLyBUaGUgcG9zaXRpb24gaW4gbXVsdGlwZSBtb250aHMgYXQgd2hpY2ggdG8gc2hvdyB0aGUgY3VycmVudCBtb250aCAoc3RhcnRpbmcgYXQgMClcblx0XHRzdGVwTW9udGhzOiAxLCAvLyBOdW1iZXIgb2YgbW9udGhzIHRvIHN0ZXAgYmFjay9mb3J3YXJkXG5cdFx0c3RlcEJpZ01vbnRoczogMTIsIC8vIE51bWJlciBvZiBtb250aHMgdG8gc3RlcCBiYWNrL2ZvcndhcmQgZm9yIHRoZSBiaWcgbGlua3Ncblx0XHRhbHRGaWVsZDogXCJcIiwgLy8gU2VsZWN0b3IgZm9yIGFuIGFsdGVybmF0ZSBmaWVsZCB0byBzdG9yZSBzZWxlY3RlZCBkYXRlcyBpbnRvXG5cdFx0YWx0Rm9ybWF0OiBcIlwiLCAvLyBUaGUgZGF0ZSBmb3JtYXQgdG8gdXNlIGZvciB0aGUgYWx0ZXJuYXRlIGZpZWxkXG5cdFx0Y29uc3RyYWluSW5wdXQ6IHRydWUsIC8vIFRoZSBpbnB1dCBpcyBjb25zdHJhaW5lZCBieSB0aGUgY3VycmVudCBkYXRlIGZvcm1hdFxuXHRcdHNob3dCdXR0b25QYW5lbDogZmFsc2UsIC8vIFRydWUgdG8gc2hvdyBidXR0b24gcGFuZWwsIGZhbHNlIHRvIG5vdCBzaG93IGl0XG5cdFx0YXV0b1NpemU6IGZhbHNlLCAvLyBUcnVlIHRvIHNpemUgdGhlIGlucHV0IGZvciB0aGUgZGF0ZSBmb3JtYXQsIGZhbHNlIHRvIGxlYXZlIGFzIGlzXG5cdFx0ZGlzYWJsZWQ6IGZhbHNlIC8vIFRoZSBpbml0aWFsIGRpc2FibGVkIHN0YXRlXG5cdH07XG5cdCQuZXh0ZW5kKCB0aGlzLl9kZWZhdWx0cywgdGhpcy5yZWdpb25hbFsgXCJcIiBdICk7XG5cdHRoaXMucmVnaW9uYWwuZW4gPSAkLmV4dGVuZCggdHJ1ZSwge30sIHRoaXMucmVnaW9uYWxbIFwiXCIgXSApO1xuXHR0aGlzLnJlZ2lvbmFsWyBcImVuLVVTXCIgXSA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgdGhpcy5yZWdpb25hbC5lbiApO1xuXHR0aGlzLmRwRGl2ID0gZGF0ZXBpY2tlcl9iaW5kSG92ZXIoICQoIFwiPGRpdiBpZD0nXCIgKyB0aGlzLl9tYWluRGl2SWQgKyBcIicgY2xhc3M9J3VpLWRhdGVwaWNrZXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWhlbHBlci1jbGVhcmZpeCB1aS1jb3JuZXItYWxsJz48L2Rpdj5cIiApICk7XG59XG5cbiQuZXh0ZW5kKCBEYXRlcGlja2VyLnByb3RvdHlwZSwge1xuXHQvKiBDbGFzcyBuYW1lIGFkZGVkIHRvIGVsZW1lbnRzIHRvIGluZGljYXRlIGFscmVhZHkgY29uZmlndXJlZCB3aXRoIGEgZGF0ZSBwaWNrZXIuICovXG5cdG1hcmtlckNsYXNzTmFtZTogXCJoYXNEYXRlcGlja2VyXCIsXG5cblx0Ly9LZWVwIHRyYWNrIG9mIHRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzIGRpc3BsYXllZCAoc2VlICM3MDQzKVxuXHRtYXhSb3dzOiA0LFxuXG5cdC8vIFRPRE8gcmVuYW1lIHRvIFwid2lkZ2V0XCIgd2hlbiBzd2l0Y2hpbmcgdG8gd2lkZ2V0IGZhY3Rvcnlcblx0X3dpZGdldERhdGVwaWNrZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRwRGl2O1xuXHR9LFxuXG5cdC8qIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHNldHRpbmdzIGZvciBhbGwgaW5zdGFuY2VzIG9mIHRoZSBkYXRlIHBpY2tlci5cblx0ICogQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1c2UgYXMgZGVmYXVsdHMgKGFub255bW91cyBvYmplY3QpXG5cdCAqIEByZXR1cm4gdGhlIG1hbmFnZXIgb2JqZWN0XG5cdCAqL1xuXHRzZXREZWZhdWx0czogZnVuY3Rpb24oIHNldHRpbmdzICkge1xuXHRcdGRhdGVwaWNrZXJfZXh0ZW5kUmVtb3ZlKCB0aGlzLl9kZWZhdWx0cywgc2V0dGluZ3MgfHwge30gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKiBBdHRhY2ggdGhlIGRhdGUgcGlja2VyIHRvIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1c2UgZm9yIHRoaXMgZGF0ZSBwaWNrZXIgaW5zdGFuY2UgKGFub255bW91cylcblx0ICovXG5cdF9hdHRhY2hEYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHR2YXIgbm9kZU5hbWUsIGlubGluZSwgaW5zdDtcblx0XHRub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdGlubGluZSA9ICggbm9kZU5hbWUgPT09IFwiZGl2XCIgfHwgbm9kZU5hbWUgPT09IFwic3BhblwiICk7XG5cdFx0aWYgKCAhdGFyZ2V0LmlkICkge1xuXHRcdFx0dGhpcy51dWlkICs9IDE7XG5cdFx0XHR0YXJnZXQuaWQgPSBcImRwXCIgKyB0aGlzLnV1aWQ7XG5cdFx0fVxuXHRcdGluc3QgPSB0aGlzLl9uZXdJbnN0KCAkKCB0YXJnZXQgKSwgaW5saW5lICk7XG5cdFx0aW5zdC5zZXR0aW5ncyA9ICQuZXh0ZW5kKCB7fSwgc2V0dGluZ3MgfHwge30gKTtcblx0XHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHR0aGlzLl9jb25uZWN0RGF0ZXBpY2tlciggdGFyZ2V0LCBpbnN0ICk7XG5cdFx0fSBlbHNlIGlmICggaW5saW5lICkge1xuXHRcdFx0dGhpcy5faW5saW5lRGF0ZXBpY2tlciggdGFyZ2V0LCBpbnN0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvYmplY3QuICovXG5cdF9uZXdJbnN0OiBmdW5jdGlvbiggdGFyZ2V0LCBpbmxpbmUgKSB7XG5cdFx0dmFyIGlkID0gdGFyZ2V0WyAwIF0uaWQucmVwbGFjZSggLyhbXkEtWmEtejAtOV9cXC1dKS9nLCBcIlxcXFxcXFxcJDFcIiApOyAvLyBlc2NhcGUgalF1ZXJ5IG1ldGEgY2hhcnNcblx0XHRyZXR1cm4geyBpZDogaWQsIGlucHV0OiB0YXJnZXQsIC8vIGFzc29jaWF0ZWQgdGFyZ2V0XG5cdFx0XHRzZWxlY3RlZERheTogMCwgc2VsZWN0ZWRNb250aDogMCwgc2VsZWN0ZWRZZWFyOiAwLCAvLyBjdXJyZW50IHNlbGVjdGlvblxuXHRcdFx0ZHJhd01vbnRoOiAwLCBkcmF3WWVhcjogMCwgLy8gbW9udGggYmVpbmcgZHJhd25cblx0XHRcdGlubGluZTogaW5saW5lLCAvLyBpcyBkYXRlcGlja2VyIGlubGluZSBvciBub3Rcblx0XHRcdGRwRGl2OiAoICFpbmxpbmUgPyB0aGlzLmRwRGl2IDogLy8gcHJlc2VudGF0aW9uIGRpdlxuXHRcdFx0ZGF0ZXBpY2tlcl9iaW5kSG92ZXIoICQoIFwiPGRpdiBjbGFzcz0nXCIgKyB0aGlzLl9pbmxpbmVDbGFzcyArIFwiIHVpLWRhdGVwaWNrZXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWhlbHBlci1jbGVhcmZpeCB1aS1jb3JuZXItYWxsJz48L2Rpdj5cIiApICkgKSB9O1xuXHR9LFxuXG5cdC8qIEF0dGFjaCB0aGUgZGF0ZSBwaWNrZXIgdG8gYW4gaW5wdXQgZmllbGQuICovXG5cdF9jb25uZWN0RGF0ZXBpY2tlcjogZnVuY3Rpb24oIHRhcmdldCwgaW5zdCApIHtcblx0XHR2YXIgaW5wdXQgPSAkKCB0YXJnZXQgKTtcblx0XHRpbnN0LmFwcGVuZCA9ICQoIFtdICk7XG5cdFx0aW5zdC50cmlnZ2VyID0gJCggW10gKTtcblx0XHRpZiAoIGlucHV0Lmhhc0NsYXNzKCB0aGlzLm1hcmtlckNsYXNzTmFtZSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9hdHRhY2htZW50cyggaW5wdXQsIGluc3QgKTtcblx0XHRpbnB1dC5hZGRDbGFzcyggdGhpcy5tYXJrZXJDbGFzc05hbWUgKS5vbiggXCJrZXlkb3duXCIsIHRoaXMuX2RvS2V5RG93biApLlxuXHRcdFx0b24oIFwia2V5cHJlc3NcIiwgdGhpcy5fZG9LZXlQcmVzcyApLm9uKCBcImtleXVwXCIsIHRoaXMuX2RvS2V5VXAgKTtcblx0XHR0aGlzLl9hdXRvU2l6ZSggaW5zdCApO1xuXHRcdCQuZGF0YSggdGFyZ2V0LCBcImRhdGVwaWNrZXJcIiwgaW5zdCApO1xuXG5cdFx0Ly9JZiBkaXNhYmxlZCBvcHRpb24gaXMgdHJ1ZSwgZGlzYWJsZSB0aGUgZGF0ZXBpY2tlciBvbmNlIGl0IGhhcyBiZWVuIGF0dGFjaGVkIHRvIHRoZSBpbnB1dCAoc2VlIHRpY2tldCAjNTY2NSlcblx0XHRpZiAoIGluc3Quc2V0dGluZ3MuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9kaXNhYmxlRGF0ZXBpY2tlciggdGFyZ2V0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIE1ha2UgYXR0YWNobWVudHMgYmFzZWQgb24gc2V0dGluZ3MuICovXG5cdF9hdHRhY2htZW50czogZnVuY3Rpb24oIGlucHV0LCBpbnN0ICkge1xuXHRcdHZhciBzaG93T24sIGJ1dHRvblRleHQsIGJ1dHRvbkltYWdlLFxuXHRcdFx0YXBwZW5kVGV4dCA9IHRoaXMuX2dldCggaW5zdCwgXCJhcHBlbmRUZXh0XCIgKSxcblx0XHRcdGlzUlRMID0gdGhpcy5fZ2V0KCBpbnN0LCBcImlzUlRMXCIgKTtcblxuXHRcdGlmICggaW5zdC5hcHBlbmQgKSB7XG5cdFx0XHRpbnN0LmFwcGVuZC5yZW1vdmUoKTtcblx0XHR9XG5cdFx0aWYgKCBhcHBlbmRUZXh0ICkge1xuXHRcdFx0aW5zdC5hcHBlbmQgPSAkKCBcIjxzcGFuIGNsYXNzPSdcIiArIHRoaXMuX2FwcGVuZENsYXNzICsgXCInPlwiICsgYXBwZW5kVGV4dCArIFwiPC9zcGFuPlwiICk7XG5cdFx0XHRpbnB1dFsgaXNSVEwgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiIF0oIGluc3QuYXBwZW5kICk7XG5cdFx0fVxuXG5cdFx0aW5wdXQub2ZmKCBcImZvY3VzXCIsIHRoaXMuX3Nob3dEYXRlcGlja2VyICk7XG5cblx0XHRpZiAoIGluc3QudHJpZ2dlciApIHtcblx0XHRcdGluc3QudHJpZ2dlci5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRzaG93T24gPSB0aGlzLl9nZXQoIGluc3QsIFwic2hvd09uXCIgKTtcblx0XHRpZiAoIHNob3dPbiA9PT0gXCJmb2N1c1wiIHx8IHNob3dPbiA9PT0gXCJib3RoXCIgKSB7IC8vIHBvcC11cCBkYXRlIHBpY2tlciB3aGVuIGluIHRoZSBtYXJrZWQgZmllbGRcblx0XHRcdGlucHV0Lm9uKCBcImZvY3VzXCIsIHRoaXMuX3Nob3dEYXRlcGlja2VyICk7XG5cdFx0fVxuXHRcdGlmICggc2hvd09uID09PSBcImJ1dHRvblwiIHx8IHNob3dPbiA9PT0gXCJib3RoXCIgKSB7IC8vIHBvcC11cCBkYXRlIHBpY2tlciB3aGVuIGJ1dHRvbiBjbGlja2VkXG5cdFx0XHRidXR0b25UZXh0ID0gdGhpcy5fZ2V0KCBpbnN0LCBcImJ1dHRvblRleHRcIiApO1xuXHRcdFx0YnV0dG9uSW1hZ2UgPSB0aGlzLl9nZXQoIGluc3QsIFwiYnV0dG9uSW1hZ2VcIiApO1xuXHRcdFx0aW5zdC50cmlnZ2VyID0gJCggdGhpcy5fZ2V0KCBpbnN0LCBcImJ1dHRvbkltYWdlT25seVwiICkgP1xuXHRcdFx0XHQkKCBcIjxpbWcvPlwiICkuYWRkQ2xhc3MoIHRoaXMuX3RyaWdnZXJDbGFzcyApLlxuXHRcdFx0XHRcdGF0dHIoIHsgc3JjOiBidXR0b25JbWFnZSwgYWx0OiBidXR0b25UZXh0LCB0aXRsZTogYnV0dG9uVGV4dCB9ICkgOlxuXHRcdFx0XHQkKCBcIjxidXR0b24gdHlwZT0nYnV0dG9uJz48L2J1dHRvbj5cIiApLmFkZENsYXNzKCB0aGlzLl90cmlnZ2VyQ2xhc3MgKS5cblx0XHRcdFx0XHRodG1sKCAhYnV0dG9uSW1hZ2UgPyBidXR0b25UZXh0IDogJCggXCI8aW1nLz5cIiApLmF0dHIoXG5cdFx0XHRcdFx0eyBzcmM6YnV0dG9uSW1hZ2UsIGFsdDpidXR0b25UZXh0LCB0aXRsZTpidXR0b25UZXh0IH0gKSApICk7XG5cdFx0XHRpbnB1dFsgaXNSVEwgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiIF0oIGluc3QudHJpZ2dlciApO1xuXHRcdFx0aW5zdC50cmlnZ2VyLm9uKCBcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgJiYgJC5kYXRlcGlja2VyLl9sYXN0SW5wdXQgPT09IGlucHV0WyAwIF0gKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCAkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nICYmICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ICE9PSBpbnB1dFsgMCBdICkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3Nob3dEYXRlcGlja2VyKCBpbnB1dFsgMCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zaG93RGF0ZXBpY2tlciggaW5wdXRbIDAgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH0sXG5cblx0LyogQXBwbHkgdGhlIG1heGltdW0gbGVuZ3RoIGZvciB0aGUgZGF0ZSBmb3JtYXQuICovXG5cdF9hdXRvU2l6ZTogZnVuY3Rpb24oIGluc3QgKSB7XG5cdFx0aWYgKCB0aGlzLl9nZXQoIGluc3QsIFwiYXV0b1NpemVcIiApICYmICFpbnN0LmlubGluZSApIHtcblx0XHRcdHZhciBmaW5kTWF4LCBtYXgsIG1heEksIGksXG5cdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZSggMjAwOSwgMTIgLSAxLCAyMCApLCAvLyBFbnN1cmUgZG91YmxlIGRpZ2l0c1xuXHRcdFx0XHRkYXRlRm9ybWF0ID0gdGhpcy5fZ2V0KCBpbnN0LCBcImRhdGVGb3JtYXRcIiApO1xuXG5cdFx0XHRpZiAoIGRhdGVGb3JtYXQubWF0Y2goIC9bRE1dLyApICkge1xuXHRcdFx0XHRmaW5kTWF4ID0gZnVuY3Rpb24oIG5hbWVzICkge1xuXHRcdFx0XHRcdG1heCA9IDA7XG5cdFx0XHRcdFx0bWF4SSA9IDA7XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHRcdGlmICggbmFtZXNbIGkgXS5sZW5ndGggPiBtYXggKSB7XG5cdFx0XHRcdFx0XHRcdG1heCA9IG5hbWVzWyBpIF0ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRtYXhJID0gaTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1heEk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGRhdGUuc2V0TW9udGgoIGZpbmRNYXgoIHRoaXMuX2dldCggaW5zdCwgKCBkYXRlRm9ybWF0Lm1hdGNoKCAvTU0vICkgP1xuXHRcdFx0XHRcdFwibW9udGhOYW1lc1wiIDogXCJtb250aE5hbWVzU2hvcnRcIiApICkgKSApO1xuXHRcdFx0XHRkYXRlLnNldERhdGUoIGZpbmRNYXgoIHRoaXMuX2dldCggaW5zdCwgKCBkYXRlRm9ybWF0Lm1hdGNoKCAvREQvICkgP1xuXHRcdFx0XHRcdFwiZGF5TmFtZXNcIiA6IFwiZGF5TmFtZXNTaG9ydFwiICkgKSApICsgMjAgLSBkYXRlLmdldERheSgpICk7XG5cdFx0XHR9XG5cdFx0XHRpbnN0LmlucHV0LmF0dHIoIFwic2l6ZVwiLCB0aGlzLl9mb3JtYXREYXRlKCBpbnN0LCBkYXRlICkubGVuZ3RoICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEF0dGFjaCBhbiBpbmxpbmUgZGF0ZSBwaWNrZXIgdG8gYSBkaXYuICovXG5cdF9pbmxpbmVEYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0LCBpbnN0ICkge1xuXHRcdHZhciBkaXZTcGFuID0gJCggdGFyZ2V0ICk7XG5cdFx0aWYgKCBkaXZTcGFuLmhhc0NsYXNzKCB0aGlzLm1hcmtlckNsYXNzTmFtZSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRkaXZTcGFuLmFkZENsYXNzKCB0aGlzLm1hcmtlckNsYXNzTmFtZSApLmFwcGVuZCggaW5zdC5kcERpdiApO1xuXHRcdCQuZGF0YSggdGFyZ2V0LCBcImRhdGVwaWNrZXJcIiwgaW5zdCApO1xuXHRcdHRoaXMuX3NldERhdGUoIGluc3QsIHRoaXMuX2dldERlZmF1bHREYXRlKCBpbnN0ICksIHRydWUgKTtcblx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKCBpbnN0ICk7XG5cdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKCBpbnN0ICk7XG5cblx0XHQvL0lmIGRpc2FibGVkIG9wdGlvbiBpcyB0cnVlLCBkaXNhYmxlIHRoZSBkYXRlcGlja2VyIGJlZm9yZSBzaG93aW5nIGl0IChzZWUgdGlja2V0ICM1NjY1KVxuXHRcdGlmICggaW5zdC5zZXR0aW5ncy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX2Rpc2FibGVEYXRlcGlja2VyKCB0YXJnZXQgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgZGlzcGxheTpibG9jayBpbiBwbGFjZSBvZiBpbnN0LmRwRGl2LnNob3coKSB3aGljaCB3b24ndCB3b3JrIG9uIGRpc2Nvbm5lY3RlZCBlbGVtZW50c1xuXHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeXVpLmNvbS90aWNrZXQvNzU1MiAtIEEgRGF0ZXBpY2tlciBjcmVhdGVkIG9uIGEgZGV0YWNoZWQgZGl2IGhhcyB6ZXJvIGhlaWdodFxuXHRcdGluc3QuZHBEaXYuY3NzKCBcImRpc3BsYXlcIiwgXCJibG9ja1wiICk7XG5cdH0sXG5cblx0LyogUG9wLXVwIHRoZSBkYXRlIHBpY2tlciBpbiBhIFwiZGlhbG9nXCIgYm94LlxuXHQgKiBAcGFyYW0gIGlucHV0IGVsZW1lbnQgLSBpZ25vcmVkXG5cdCAqIEBwYXJhbSAgZGF0ZVx0c3RyaW5nIG9yIERhdGUgLSB0aGUgaW5pdGlhbCBkYXRlIHRvIGRpc3BsYXlcblx0ICogQHBhcmFtICBvblNlbGVjdCAgZnVuY3Rpb24gLSB0aGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgZGF0ZSBpcyBzZWxlY3RlZFxuXHQgKiBAcGFyYW0gIHNldHRpbmdzICBvYmplY3QgLSB1cGRhdGUgdGhlIGRpYWxvZyBkYXRlIHBpY2tlciBpbnN0YW5jZSdzIHNldHRpbmdzIChhbm9ueW1vdXMgb2JqZWN0KVxuXHQgKiBAcGFyYW0gIHBvcyBpbnRbMl0gLSBjb29yZGluYXRlcyBmb3IgdGhlIGRpYWxvZydzIHBvc2l0aW9uIHdpdGhpbiB0aGUgc2NyZWVuIG9yXG5cdCAqXHRcdFx0XHRcdGV2ZW50IC0gd2l0aCB4L3kgY29vcmRpbmF0ZXMgb3Jcblx0ICpcdFx0XHRcdFx0bGVhdmUgZW1wdHkgZm9yIGRlZmF1bHQgKHNjcmVlbiBjZW50cmUpXG5cdCAqIEByZXR1cm4gdGhlIG1hbmFnZXIgb2JqZWN0XG5cdCAqL1xuXHRfZGlhbG9nRGF0ZXBpY2tlcjogZnVuY3Rpb24oIGlucHV0LCBkYXRlLCBvblNlbGVjdCwgc2V0dGluZ3MsIHBvcyApIHtcblx0XHR2YXIgaWQsIGJyb3dzZXJXaWR0aCwgYnJvd3NlckhlaWdodCwgc2Nyb2xsWCwgc2Nyb2xsWSxcblx0XHRcdGluc3QgPSB0aGlzLl9kaWFsb2dJbnN0OyAvLyBpbnRlcm5hbCBpbnN0YW5jZVxuXG5cdFx0aWYgKCAhaW5zdCApIHtcblx0XHRcdHRoaXMudXVpZCArPSAxO1xuXHRcdFx0aWQgPSBcImRwXCIgKyB0aGlzLnV1aWQ7XG5cdFx0XHR0aGlzLl9kaWFsb2dJbnB1dCA9ICQoIFwiPGlucHV0IHR5cGU9J3RleHQnIGlkPSdcIiArIGlkICtcblx0XHRcdFx0XCInIHN0eWxlPSdwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogLTEwMHB4OyB3aWR0aDogMHB4OycvPlwiICk7XG5cdFx0XHR0aGlzLl9kaWFsb2dJbnB1dC5vbiggXCJrZXlkb3duXCIsIHRoaXMuX2RvS2V5RG93biApO1xuXHRcdFx0JCggXCJib2R5XCIgKS5hcHBlbmQoIHRoaXMuX2RpYWxvZ0lucHV0ICk7XG5cdFx0XHRpbnN0ID0gdGhpcy5fZGlhbG9nSW5zdCA9IHRoaXMuX25ld0luc3QoIHRoaXMuX2RpYWxvZ0lucHV0LCBmYWxzZSApO1xuXHRcdFx0aW5zdC5zZXR0aW5ncyA9IHt9O1xuXHRcdFx0JC5kYXRhKCB0aGlzLl9kaWFsb2dJbnB1dFsgMCBdLCBcImRhdGVwaWNrZXJcIiwgaW5zdCApO1xuXHRcdH1cblx0XHRkYXRlcGlja2VyX2V4dGVuZFJlbW92ZSggaW5zdC5zZXR0aW5ncywgc2V0dGluZ3MgfHwge30gKTtcblx0XHRkYXRlID0gKCBkYXRlICYmIGRhdGUuY29uc3RydWN0b3IgPT09IERhdGUgPyB0aGlzLl9mb3JtYXREYXRlKCBpbnN0LCBkYXRlICkgOiBkYXRlICk7XG5cdFx0dGhpcy5fZGlhbG9nSW5wdXQudmFsKCBkYXRlICk7XG5cblx0XHR0aGlzLl9wb3MgPSAoIHBvcyA/ICggcG9zLmxlbmd0aCA/IHBvcyA6IFsgcG9zLnBhZ2VYLCBwb3MucGFnZVkgXSApIDogbnVsbCApO1xuXHRcdGlmICggIXRoaXMuX3BvcyApIHtcblx0XHRcdGJyb3dzZXJXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcblx0XHRcdGJyb3dzZXJIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXHRcdFx0c2Nyb2xsWCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcblx0XHRcdHNjcm9sbFkgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuXHRcdFx0dGhpcy5fcG9zID0gLy8gc2hvdWxkIHVzZSBhY3R1YWwgd2lkdGgvaGVpZ2h0IGJlbG93XG5cdFx0XHRcdFsgKCBicm93c2VyV2lkdGggLyAyICkgLSAxMDAgKyBzY3JvbGxYLCAoIGJyb3dzZXJIZWlnaHQgLyAyICkgLSAxNTAgKyBzY3JvbGxZIF07XG5cdFx0fVxuXG5cdFx0Ly8gTW92ZSBpbnB1dCBvbiBzY3JlZW4gZm9yIGZvY3VzLCBidXQgaGlkZGVuIGJlaGluZCBkaWFsb2dcblx0XHR0aGlzLl9kaWFsb2dJbnB1dC5jc3MoIFwibGVmdFwiLCAoIHRoaXMuX3Bvc1sgMCBdICsgMjAgKSArIFwicHhcIiApLmNzcyggXCJ0b3BcIiwgdGhpcy5fcG9zWyAxIF0gKyBcInB4XCIgKTtcblx0XHRpbnN0LnNldHRpbmdzLm9uU2VsZWN0ID0gb25TZWxlY3Q7XG5cdFx0dGhpcy5faW5EaWFsb2cgPSB0cnVlO1xuXHRcdHRoaXMuZHBEaXYuYWRkQ2xhc3MoIHRoaXMuX2RpYWxvZ0NsYXNzICk7XG5cdFx0dGhpcy5fc2hvd0RhdGVwaWNrZXIoIHRoaXMuX2RpYWxvZ0lucHV0WyAwIF0gKTtcblx0XHRpZiAoICQuYmxvY2tVSSApIHtcblx0XHRcdCQuYmxvY2tVSSggdGhpcy5kcERpdiApO1xuXHRcdH1cblx0XHQkLmRhdGEoIHRoaXMuX2RpYWxvZ0lucHV0WyAwIF0sIFwiZGF0ZXBpY2tlclwiLCBpbnN0ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyogRGV0YWNoIGEgZGF0ZXBpY2tlciBmcm9tIGl0cyBjb250cm9sLlxuXHQgKiBAcGFyYW0gIHRhcmdldFx0ZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgKi9cblx0X2Rlc3Ryb3lEYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciBub2RlTmFtZSxcblx0XHRcdCR0YXJnZXQgPSAkKCB0YXJnZXQgKSxcblx0XHRcdGluc3QgPSAkLmRhdGEoIHRhcmdldCwgXCJkYXRlcGlja2VyXCIgKTtcblxuXHRcdGlmICggISR0YXJnZXQuaGFzQ2xhc3MoIHRoaXMubWFya2VyQ2xhc3NOYW1lICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHQkLnJlbW92ZURhdGEoIHRhcmdldCwgXCJkYXRlcGlja2VyXCIgKTtcblx0XHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRpbnN0LmFwcGVuZC5yZW1vdmUoKTtcblx0XHRcdGluc3QudHJpZ2dlci5yZW1vdmUoKTtcblx0XHRcdCR0YXJnZXQucmVtb3ZlQ2xhc3MoIHRoaXMubWFya2VyQ2xhc3NOYW1lICkuXG5cdFx0XHRcdG9mZiggXCJmb2N1c1wiLCB0aGlzLl9zaG93RGF0ZXBpY2tlciApLlxuXHRcdFx0XHRvZmYoIFwia2V5ZG93blwiLCB0aGlzLl9kb0tleURvd24gKS5cblx0XHRcdFx0b2ZmKCBcImtleXByZXNzXCIsIHRoaXMuX2RvS2V5UHJlc3MgKS5cblx0XHRcdFx0b2ZmKCBcImtleXVwXCIsIHRoaXMuX2RvS2V5VXAgKTtcblx0XHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJkaXZcIiB8fCBub2RlTmFtZSA9PT0gXCJzcGFuXCIgKSB7XG5cdFx0XHQkdGFyZ2V0LnJlbW92ZUNsYXNzKCB0aGlzLm1hcmtlckNsYXNzTmFtZSApLmVtcHR5KCk7XG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRlcGlja2VyX2luc3RBY3RpdmUgPT09IGluc3QgKSB7XG5cdFx0XHRkYXRlcGlja2VyX2luc3RBY3RpdmUgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHQvKiBFbmFibGUgdGhlIGRhdGUgcGlja2VyIHRvIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICovXG5cdF9lbmFibGVEYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciBub2RlTmFtZSwgaW5saW5lLFxuXHRcdFx0JHRhcmdldCA9ICQoIHRhcmdldCApLFxuXHRcdFx0aW5zdCA9ICQuZGF0YSggdGFyZ2V0LCBcImRhdGVwaWNrZXJcIiApO1xuXG5cdFx0aWYgKCAhJHRhcmdldC5oYXNDbGFzcyggdGhpcy5tYXJrZXJDbGFzc05hbWUgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHRhcmdldC5kaXNhYmxlZCA9IGZhbHNlO1xuXHRcdFx0aW5zdC50cmlnZ2VyLmZpbHRlciggXCJidXR0b25cIiApLlxuXHRcdFx0XHRlYWNoKCBmdW5jdGlvbigpIHsgdGhpcy5kaXNhYmxlZCA9IGZhbHNlOyB9ICkuZW5kKCkuXG5cdFx0XHRcdGZpbHRlciggXCJpbWdcIiApLmNzcyggeyBvcGFjaXR5OiBcIjEuMFwiLCBjdXJzb3I6IFwiXCIgfSApO1xuXHRcdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImRpdlwiIHx8IG5vZGVOYW1lID09PSBcInNwYW5cIiApIHtcblx0XHRcdGlubGluZSA9ICR0YXJnZXQuY2hpbGRyZW4oIFwiLlwiICsgdGhpcy5faW5saW5lQ2xhc3MgKTtcblx0XHRcdGlubGluZS5jaGlsZHJlbigpLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIgKTtcblx0XHRcdGlubGluZS5maW5kKCBcInNlbGVjdC51aS1kYXRlcGlja2VyLW1vbnRoLCBzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyXCIgKS5cblx0XHRcdFx0cHJvcCggXCJkaXNhYmxlZFwiLCBmYWxzZSApO1xuXHRcdH1cblx0XHR0aGlzLl9kaXNhYmxlZElucHV0cyA9ICQubWFwKCB0aGlzLl9kaXNhYmxlZElucHV0cyxcblx0XHRcdGZ1bmN0aW9uKCB2YWx1ZSApIHsgcmV0dXJuICggdmFsdWUgPT09IHRhcmdldCA/IG51bGwgOiB2YWx1ZSApOyB9ICk7IC8vIGRlbGV0ZSBlbnRyeVxuXHR9LFxuXG5cdC8qIERpc2FibGUgdGhlIGRhdGUgcGlja2VyIHRvIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICovXG5cdF9kaXNhYmxlRGF0ZXBpY2tlcjogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgbm9kZU5hbWUsIGlubGluZSxcblx0XHRcdCR0YXJnZXQgPSAkKCB0YXJnZXQgKSxcblx0XHRcdGluc3QgPSAkLmRhdGEoIHRhcmdldCwgXCJkYXRlcGlja2VyXCIgKTtcblxuXHRcdGlmICggISR0YXJnZXQuaGFzQ2xhc3MoIHRoaXMubWFya2VyQ2xhc3NOYW1lICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHR0YXJnZXQuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aW5zdC50cmlnZ2VyLmZpbHRlciggXCJidXR0b25cIiApLlxuXHRcdFx0XHRlYWNoKCBmdW5jdGlvbigpIHsgdGhpcy5kaXNhYmxlZCA9IHRydWU7IH0gKS5lbmQoKS5cblx0XHRcdFx0ZmlsdGVyKCBcImltZ1wiICkuY3NzKCB7IG9wYWNpdHk6IFwiMC41XCIsIGN1cnNvcjogXCJkZWZhdWx0XCIgfSApO1xuXHRcdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImRpdlwiIHx8IG5vZGVOYW1lID09PSBcInNwYW5cIiApIHtcblx0XHRcdGlubGluZSA9ICR0YXJnZXQuY2hpbGRyZW4oIFwiLlwiICsgdGhpcy5faW5saW5lQ2xhc3MgKTtcblx0XHRcdGlubGluZS5jaGlsZHJlbigpLmFkZENsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIgKTtcblx0XHRcdGlubGluZS5maW5kKCBcInNlbGVjdC51aS1kYXRlcGlja2VyLW1vbnRoLCBzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyXCIgKS5cblx0XHRcdFx0cHJvcCggXCJkaXNhYmxlZFwiLCB0cnVlICk7XG5cdFx0fVxuXHRcdHRoaXMuX2Rpc2FibGVkSW5wdXRzID0gJC5tYXAoIHRoaXMuX2Rpc2FibGVkSW5wdXRzLFxuXHRcdFx0ZnVuY3Rpb24oIHZhbHVlICkgeyByZXR1cm4gKCB2YWx1ZSA9PT0gdGFyZ2V0ID8gbnVsbCA6IHZhbHVlICk7IH0gKTsgLy8gZGVsZXRlIGVudHJ5XG5cdFx0dGhpcy5fZGlzYWJsZWRJbnB1dHNbIHRoaXMuX2Rpc2FibGVkSW5wdXRzLmxlbmd0aCBdID0gdGFyZ2V0O1xuXHR9LFxuXG5cdC8qIElzIHRoZSBmaXJzdCBmaWVsZCBpbiBhIGpRdWVyeSBjb2xsZWN0aW9uIGRpc2FibGVkIGFzIGEgZGF0ZXBpY2tlcj9cblx0ICogQHBhcmFtICB0YXJnZXRcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHJldHVybiBib29sZWFuIC0gdHJ1ZSBpZiBkaXNhYmxlZCwgZmFsc2UgaWYgZW5hYmxlZFxuXHQgKi9cblx0X2lzRGlzYWJsZWREYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdGlmICggIXRhcmdldCApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5fZGlzYWJsZWRJbnB1dHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRpZiAoIHRoaXMuX2Rpc2FibGVkSW5wdXRzWyBpIF0gPT09IHRhcmdldCApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKiBSZXRyaWV2ZSB0aGUgaW5zdGFuY2UgZGF0YSBmb3IgdGhlIHRhcmdldCBjb250cm9sLlxuXHQgKiBAcGFyYW0gIHRhcmdldCAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgKiBAcmV0dXJuICBvYmplY3QgLSB0aGUgYXNzb2NpYXRlZCBpbnN0YW5jZSBkYXRhXG5cdCAqIEB0aHJvd3MgIGVycm9yIGlmIGEgalF1ZXJ5IHByb2JsZW0gZ2V0dGluZyBkYXRhXG5cdCAqL1xuXHRfZ2V0SW5zdDogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuICQuZGF0YSggdGFyZ2V0LCBcImRhdGVwaWNrZXJcIiApO1xuXHRcdH1cblx0XHRjYXRjaCAoIGVyciApIHtcblx0XHRcdHRocm93IFwiTWlzc2luZyBpbnN0YW5jZSBkYXRhIGZvciB0aGlzIGRhdGVwaWNrZXJcIjtcblx0XHR9XG5cdH0sXG5cblx0LyogVXBkYXRlIG9yIHJldHJpZXZlIHRoZSBzZXR0aW5ncyBmb3IgYSBkYXRlIHBpY2tlciBhdHRhY2hlZCB0byBhbiBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbi5cblx0ICogQHBhcmFtICB0YXJnZXQgIGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICogQHBhcmFtICBuYW1lXHRvYmplY3QgLSB0aGUgbmV3IHNldHRpbmdzIHRvIHVwZGF0ZSBvclxuXHQgKlx0XHRcdFx0c3RyaW5nIC0gdGhlIG5hbWUgb2YgdGhlIHNldHRpbmcgdG8gY2hhbmdlIG9yIHJldHJpZXZlLFxuXHQgKlx0XHRcdFx0d2hlbiByZXRyaWV2aW5nIGFsc28gXCJhbGxcIiBmb3IgYWxsIGluc3RhbmNlIHNldHRpbmdzIG9yXG5cdCAqXHRcdFx0XHRcImRlZmF1bHRzXCIgZm9yIGFsbCBnbG9iYWwgZGVmYXVsdHNcblx0ICogQHBhcmFtICB2YWx1ZSAgIGFueSAtIHRoZSBuZXcgdmFsdWUgZm9yIHRoZSBzZXR0aW5nXG5cdCAqXHRcdFx0XHQob21pdCBpZiBhYm92ZSBpcyBhbiBvYmplY3Qgb3IgdG8gcmV0cmlldmUgYSB2YWx1ZSlcblx0ICovXG5cdF9vcHRpb25EYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0LCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgc2V0dGluZ3MsIGRhdGUsIG1pbkRhdGUsIG1heERhdGUsXG5cdFx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCggdGFyZ2V0ICk7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gKCBuYW1lID09PSBcImRlZmF1bHRzXCIgPyAkLmV4dGVuZCgge30sICQuZGF0ZXBpY2tlci5fZGVmYXVsdHMgKSA6XG5cdFx0XHRcdCggaW5zdCA/ICggbmFtZSA9PT0gXCJhbGxcIiA/ICQuZXh0ZW5kKCB7fSwgaW5zdC5zZXR0aW5ncyApIDpcblx0XHRcdFx0dGhpcy5fZ2V0KCBpbnN0LCBuYW1lICkgKSA6IG51bGwgKSApO1xuXHRcdH1cblxuXHRcdHNldHRpbmdzID0gbmFtZSB8fCB7fTtcblx0XHRpZiAoIHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0c2V0dGluZ3MgPSB7fTtcblx0XHRcdHNldHRpbmdzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGluc3QgKSB7XG5cdFx0XHRpZiAoIHRoaXMuX2N1ckluc3QgPT09IGluc3QgKSB7XG5cdFx0XHRcdHRoaXMuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHR9XG5cblx0XHRcdGRhdGUgPSB0aGlzLl9nZXREYXRlRGF0ZXBpY2tlciggdGFyZ2V0LCB0cnVlICk7XG5cdFx0XHRtaW5EYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZSggaW5zdCwgXCJtaW5cIiApO1xuXHRcdFx0bWF4RGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoIGluc3QsIFwibWF4XCIgKTtcblx0XHRcdGRhdGVwaWNrZXJfZXh0ZW5kUmVtb3ZlKCBpbnN0LnNldHRpbmdzLCBzZXR0aW5ncyApO1xuXG5cdFx0XHQvLyByZWZvcm1hdCB0aGUgb2xkIG1pbkRhdGUvbWF4RGF0ZSB2YWx1ZXMgaWYgZGF0ZUZvcm1hdCBjaGFuZ2VzIGFuZCBhIG5ldyBtaW5EYXRlL21heERhdGUgaXNuJ3QgcHJvdmlkZWRcblx0XHRcdGlmICggbWluRGF0ZSAhPT0gbnVsbCAmJiBzZXR0aW5ncy5kYXRlRm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3MubWluRGF0ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRpbnN0LnNldHRpbmdzLm1pbkRhdGUgPSB0aGlzLl9mb3JtYXREYXRlKCBpbnN0LCBtaW5EYXRlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG1heERhdGUgIT09IG51bGwgJiYgc2V0dGluZ3MuZGF0ZUZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIHNldHRpbmdzLm1heERhdGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0aW5zdC5zZXR0aW5ncy5tYXhEYXRlID0gdGhpcy5fZm9ybWF0RGF0ZSggaW5zdCwgbWF4RGF0ZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBcImRpc2FibGVkXCIgaW4gc2V0dGluZ3MgKSB7XG5cdFx0XHRcdGlmICggc2V0dGluZ3MuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5fZGlzYWJsZURhdGVwaWNrZXIoIHRhcmdldCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2VuYWJsZURhdGVwaWNrZXIoIHRhcmdldCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9hdHRhY2htZW50cyggJCggdGFyZ2V0ICksIGluc3QgKTtcblx0XHRcdHRoaXMuX2F1dG9TaXplKCBpbnN0ICk7XG5cdFx0XHR0aGlzLl9zZXREYXRlKCBpbnN0LCBkYXRlICk7XG5cdFx0XHR0aGlzLl91cGRhdGVBbHRlcm5hdGUoIGluc3QgKTtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoIGluc3QgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ2hhbmdlIG1ldGhvZCBkZXByZWNhdGVkXG5cdF9jaGFuZ2VEYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0LCBuYW1lLCB2YWx1ZSApIHtcblx0XHR0aGlzLl9vcHRpb25EYXRlcGlja2VyKCB0YXJnZXQsIG5hbWUsIHZhbHVlICk7XG5cdH0sXG5cblx0LyogUmVkcmF3IHRoZSBkYXRlIHBpY2tlciBhdHRhY2hlZCB0byBhbiBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbi5cblx0ICogQHBhcmFtICB0YXJnZXQgIGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICovXG5cdF9yZWZyZXNoRGF0ZXBpY2tlcjogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoIHRhcmdldCApO1xuXHRcdGlmICggaW5zdCApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoIGluc3QgKTtcblx0XHR9XG5cdH0sXG5cblx0LyogU2V0IHRoZSBkYXRlcyBmb3IgYSBqUXVlcnkgc2VsZWN0aW9uLlxuXHQgKiBAcGFyYW0gIHRhcmdldCBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAqIEBwYXJhbSAgZGF0ZVx0RGF0ZSAtIHRoZSBuZXcgZGF0ZVxuXHQgKi9cblx0X3NldERhdGVEYXRlcGlja2VyOiBmdW5jdGlvbiggdGFyZ2V0LCBkYXRlICkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCggdGFyZ2V0ICk7XG5cdFx0aWYgKCBpbnN0ICkge1xuXHRcdFx0dGhpcy5fc2V0RGF0ZSggaW5zdCwgZGF0ZSApO1xuXHRcdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlciggaW5zdCApO1xuXHRcdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKCBpbnN0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEdldCB0aGUgZGF0ZShzKSBmb3IgdGhlIGZpcnN0IGVudHJ5IGluIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICogQHBhcmFtICB0YXJnZXQgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgKiBAcGFyYW0gIG5vRGVmYXVsdCBib29sZWFuIC0gdHJ1ZSBpZiBubyBkZWZhdWx0IGRhdGUgaXMgdG8gYmUgdXNlZFxuXHQgKiBAcmV0dXJuIERhdGUgLSB0aGUgY3VycmVudCBkYXRlXG5cdCAqL1xuXHRfZ2V0RGF0ZURhdGVwaWNrZXI6IGZ1bmN0aW9uKCB0YXJnZXQsIG5vRGVmYXVsdCApIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoIHRhcmdldCApO1xuXHRcdGlmICggaW5zdCAmJiAhaW5zdC5pbmxpbmUgKSB7XG5cdFx0XHR0aGlzLl9zZXREYXRlRnJvbUZpZWxkKCBpbnN0LCBub0RlZmF1bHQgKTtcblx0XHR9XG5cdFx0cmV0dXJuICggaW5zdCA/IHRoaXMuX2dldERhdGUoIGluc3QgKSA6IG51bGwgKTtcblx0fSxcblxuXHQvKiBIYW5kbGUga2V5c3Ryb2tlcy4gKi9cblx0X2RvS2V5RG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBvblNlbGVjdCwgZGF0ZVN0ciwgc2VsLFxuXHRcdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdCggZXZlbnQudGFyZ2V0ICksXG5cdFx0XHRoYW5kbGVkID0gdHJ1ZSxcblx0XHRcdGlzUlRMID0gaW5zdC5kcERpdi5pcyggXCIudWktZGF0ZXBpY2tlci1ydGxcIiApO1xuXG5cdFx0aW5zdC5fa2V5RXZlbnQgPSB0cnVlO1xuXHRcdGlmICggJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyApIHtcblx0XHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0XHRcdGNhc2UgOTogJC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGhpZGUgb24gdGFiIG91dFxuXHRcdFx0XHRjYXNlIDEzOiBzZWwgPSAkKCBcInRkLlwiICsgJC5kYXRlcGlja2VyLl9kYXlPdmVyQ2xhc3MgKyBcIjpub3QoLlwiICtcblx0XHRcdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fY3VycmVudENsYXNzICsgXCIpXCIsIGluc3QuZHBEaXYgKTtcblx0XHRcdFx0XHRcdGlmICggc2VsWyAwIF0gKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2VsZWN0RGF5KCBldmVudC50YXJnZXQsIGluc3Quc2VsZWN0ZWRNb250aCwgaW5zdC5zZWxlY3RlZFllYXIsIHNlbFsgMCBdICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG9uU2VsZWN0ID0gJC5kYXRlcGlja2VyLl9nZXQoIGluc3QsIFwib25TZWxlY3RcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCBvblNlbGVjdCApIHtcblx0XHRcdFx0XHRcdFx0ZGF0ZVN0ciA9ICQuZGF0ZXBpY2tlci5fZm9ybWF0RGF0ZSggaW5zdCApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRyaWdnZXIgY3VzdG9tIGNhbGxiYWNrXG5cdFx0XHRcdFx0XHRcdG9uU2VsZWN0LmFwcGx5KCAoIGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WyAwIF0gOiBudWxsICksIFsgZGF0ZVN0ciwgaW5zdCBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTsgLy8gZG9uJ3Qgc3VibWl0IHRoZSBmb3JtXG5cdFx0XHRcdGNhc2UgMjc6ICQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBoaWRlIG9uIGVzY2FwZVxuXHRcdFx0XHRjYXNlIDMzOiAkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoIGV2ZW50LnRhcmdldCwgKCBldmVudC5jdHJsS2V5ID9cblx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcInN0ZXBCaWdNb250aHNcIiApIDpcblx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcInN0ZXBNb250aHNcIiApICksIFwiTVwiICk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gcHJldmlvdXMgbW9udGgveWVhciBvbiBwYWdlIHVwLysgY3RybFxuXHRcdFx0XHRjYXNlIDM0OiAkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoIGV2ZW50LnRhcmdldCwgKCBldmVudC5jdHJsS2V5ID9cblx0XHRcdFx0XHRcdFx0KyQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcInN0ZXBCaWdNb250aHNcIiApIDpcblx0XHRcdFx0XHRcdFx0KyQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcInN0ZXBNb250aHNcIiApICksIFwiTVwiICk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gbmV4dCBtb250aC95ZWFyIG9uIHBhZ2UgZG93bi8rIGN0cmxcblx0XHRcdFx0Y2FzZSAzNTogaWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fY2xlYXJEYXRlKCBldmVudC50YXJnZXQgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gY2xlYXIgb24gY3RybCBvciBjb21tYW5kICtlbmRcblx0XHRcdFx0Y2FzZSAzNjogaWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fZ290b1RvZGF5KCBldmVudC50YXJnZXQgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gY3VycmVudCBvbiBjdHJsIG9yIGNvbW1hbmQgK2hvbWVcblx0XHRcdFx0Y2FzZSAzNzogaWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZSggZXZlbnQudGFyZ2V0LCAoIGlzUlRMID8gKzEgOiAtMSApLCBcIkRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblxuXHRcdFx0XHRcdFx0Ly8gLTEgZGF5IG9uIGN0cmwgb3IgY29tbWFuZCArbGVmdFxuXHRcdFx0XHRcdFx0aWYgKCBldmVudC5vcmlnaW5hbEV2ZW50LmFsdEtleSApIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKCBldmVudC50YXJnZXQsICggZXZlbnQuY3RybEtleSA/XG5cdFx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcInN0ZXBCaWdNb250aHNcIiApIDpcblx0XHRcdFx0XHRcdFx0XHQtJC5kYXRlcGlja2VyLl9nZXQoIGluc3QsIFwic3RlcE1vbnRoc1wiICkgKSwgXCJNXCIgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gbmV4dCBtb250aC95ZWFyIG9uIGFsdCArbGVmdCBvbiBNYWNcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDM4OiBpZiAoIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSApIHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKCBldmVudC50YXJnZXQsIC03LCBcIkRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyAtMSB3ZWVrIG9uIGN0cmwgb3IgY29tbWFuZCArdXBcblx0XHRcdFx0Y2FzZSAzOTogaWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZSggZXZlbnQudGFyZ2V0LCAoIGlzUlRMID8gLTEgOiArMSApLCBcIkRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblxuXHRcdFx0XHRcdFx0Ly8gKzEgZGF5IG9uIGN0cmwgb3IgY29tbWFuZCArcmlnaHRcblx0XHRcdFx0XHRcdGlmICggZXZlbnQub3JpZ2luYWxFdmVudC5hbHRLZXkgKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZSggZXZlbnQudGFyZ2V0LCAoIGV2ZW50LmN0cmxLZXkgP1xuXHRcdFx0XHRcdFx0XHRcdCskLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJzdGVwQmlnTW9udGhzXCIgKSA6XG5cdFx0XHRcdFx0XHRcdFx0KyQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcInN0ZXBNb250aHNcIiApICksIFwiTVwiICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIG5leHQgbW9udGgveWVhciBvbiBhbHQgK3JpZ2h0XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA0MDogaWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgKSB7XG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZSggZXZlbnQudGFyZ2V0LCArNywgXCJEXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gKzEgd2VlayBvbiBjdHJsIG9yIGNvbW1hbmQgK2Rvd25cblx0XHRcdFx0ZGVmYXVsdDogaGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIGV2ZW50LmtleUNvZGUgPT09IDM2ICYmIGV2ZW50LmN0cmxLZXkgKSB7IC8vIGRpc3BsYXkgdGhlIGRhdGUgcGlja2VyIG9uIGN0cmwraG9tZVxuXHRcdFx0JC5kYXRlcGlja2VyLl9zaG93RGF0ZXBpY2tlciggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoYW5kbGVkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCBoYW5kbGVkICkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBGaWx0ZXIgZW50ZXJlZCBjaGFyYWN0ZXJzIC0gYmFzZWQgb24gZGF0ZSBmb3JtYXQuICovXG5cdF9kb0tleVByZXNzOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGNoYXJzLCBjaHIsXG5cdFx0XHRpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KCBldmVudC50YXJnZXQgKTtcblxuXHRcdGlmICggJC5kYXRlcGlja2VyLl9nZXQoIGluc3QsIFwiY29uc3RyYWluSW5wdXRcIiApICkge1xuXHRcdFx0Y2hhcnMgPSAkLmRhdGVwaWNrZXIuX3Bvc3NpYmxlQ2hhcnMoICQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcImRhdGVGb3JtYXRcIiApICk7XG5cdFx0XHRjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBldmVudC5jaGFyQ29kZSA9PSBudWxsID8gZXZlbnQua2V5Q29kZSA6IGV2ZW50LmNoYXJDb2RlICk7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8ICggY2hyIDwgXCIgXCIgfHwgIWNoYXJzIHx8IGNoYXJzLmluZGV4T2YoIGNociApID4gLTEgKTtcblx0XHR9XG5cdH0sXG5cblx0LyogU3luY2hyb25pc2UgbWFudWFsIGVudHJ5IGFuZCBmaWVsZC9hbHRlcm5hdGUgZmllbGQuICovXG5cdF9kb0tleVVwOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGRhdGUsXG5cdFx0XHRpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KCBldmVudC50YXJnZXQgKTtcblxuXHRcdGlmICggaW5zdC5pbnB1dC52YWwoKSAhPT0gaW5zdC5sYXN0VmFsICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0ZSA9ICQuZGF0ZXBpY2tlci5wYXJzZURhdGUoICQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcImRhdGVGb3JtYXRcIiApLFxuXHRcdFx0XHRcdCggaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBudWxsICksXG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9nZXRGb3JtYXRDb25maWcoIGluc3QgKSApO1xuXG5cdFx0XHRcdGlmICggZGF0ZSApIHsgLy8gb25seSBpZiB2YWxpZFxuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2V0RGF0ZUZyb21GaWVsZCggaW5zdCApO1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fdXBkYXRlQWx0ZXJuYXRlKCBpbnN0ICk7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyKCBpbnN0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoICggZXJyICkge1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKiBQb3AtdXAgdGhlIGRhdGUgcGlja2VyIGZvciBhIGdpdmVuIGlucHV0IGZpZWxkLlxuXHQgKiBJZiBmYWxzZSByZXR1cm5lZCBmcm9tIGJlZm9yZVNob3cgZXZlbnQgaGFuZGxlciBkbyBub3Qgc2hvdy5cblx0ICogQHBhcmFtICBpbnB1dCAgZWxlbWVudCAtIHRoZSBpbnB1dCBmaWVsZCBhdHRhY2hlZCB0byB0aGUgZGF0ZSBwaWNrZXIgb3Jcblx0ICpcdFx0XHRcdFx0ZXZlbnQgLSBpZiB0cmlnZ2VyZWQgYnkgZm9jdXNcblx0ICovXG5cdF9zaG93RGF0ZXBpY2tlcjogZnVuY3Rpb24oIGlucHV0ICkge1xuXHRcdGlucHV0ID0gaW5wdXQudGFyZ2V0IHx8IGlucHV0O1xuXHRcdGlmICggaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJpbnB1dFwiICkgeyAvLyBmaW5kIGZyb20gYnV0dG9uL2ltYWdlIHRyaWdnZXJcblx0XHRcdGlucHV0ID0gJCggXCJpbnB1dFwiLCBpbnB1dC5wYXJlbnROb2RlIClbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoICQuZGF0ZXBpY2tlci5faXNEaXNhYmxlZERhdGVwaWNrZXIoIGlucHV0ICkgfHwgJC5kYXRlcGlja2VyLl9sYXN0SW5wdXQgPT09IGlucHV0ICkgeyAvLyBhbHJlYWR5IGhlcmVcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaW5zdCwgYmVmb3JlU2hvdywgYmVmb3JlU2hvd1NldHRpbmdzLCBpc0ZpeGVkLFxuXHRcdFx0b2Zmc2V0LCBzaG93QW5pbSwgZHVyYXRpb247XG5cblx0XHRpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KCBpbnB1dCApO1xuXHRcdGlmICggJC5kYXRlcGlja2VyLl9jdXJJbnN0ICYmICQuZGF0ZXBpY2tlci5fY3VySW5zdCAhPT0gaW5zdCApIHtcblx0XHRcdCQuZGF0ZXBpY2tlci5fY3VySW5zdC5kcERpdi5zdG9wKCB0cnVlLCB0cnVlICk7XG5cdFx0XHRpZiAoIGluc3QgJiYgJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyApIHtcblx0XHRcdFx0JC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlciggJC5kYXRlcGlja2VyLl9jdXJJbnN0LmlucHV0WyAwIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRiZWZvcmVTaG93ID0gJC5kYXRlcGlja2VyLl9nZXQoIGluc3QsIFwiYmVmb3JlU2hvd1wiICk7XG5cdFx0YmVmb3JlU2hvd1NldHRpbmdzID0gYmVmb3JlU2hvdyA/IGJlZm9yZVNob3cuYXBwbHkoIGlucHV0LCBbIGlucHV0LCBpbnN0IF0gKSA6IHt9O1xuXHRcdGlmICggYmVmb3JlU2hvd1NldHRpbmdzID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZGF0ZXBpY2tlcl9leHRlbmRSZW1vdmUoIGluc3Quc2V0dGluZ3MsIGJlZm9yZVNob3dTZXR0aW5ncyApO1xuXG5cdFx0aW5zdC5sYXN0VmFsID0gbnVsbDtcblx0XHQkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCA9IGlucHV0O1xuXHRcdCQuZGF0ZXBpY2tlci5fc2V0RGF0ZUZyb21GaWVsZCggaW5zdCApO1xuXG5cdFx0aWYgKCAkLmRhdGVwaWNrZXIuX2luRGlhbG9nICkgeyAvLyBoaWRlIGN1cnNvclxuXHRcdFx0aW5wdXQudmFsdWUgPSBcIlwiO1xuXHRcdH1cblx0XHRpZiAoICEkLmRhdGVwaWNrZXIuX3BvcyApIHsgLy8gcG9zaXRpb24gYmVsb3cgaW5wdXRcblx0XHRcdCQuZGF0ZXBpY2tlci5fcG9zID0gJC5kYXRlcGlja2VyLl9maW5kUG9zKCBpbnB1dCApO1xuXHRcdFx0JC5kYXRlcGlja2VyLl9wb3NbIDEgXSArPSBpbnB1dC5vZmZzZXRIZWlnaHQ7IC8vIGFkZCB0aGUgaGVpZ2h0XG5cdFx0fVxuXG5cdFx0aXNGaXhlZCA9IGZhbHNlO1xuXHRcdCQoIGlucHV0ICkucGFyZW50cygpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aXNGaXhlZCB8PSAkKCB0aGlzICkuY3NzKCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiO1xuXHRcdFx0cmV0dXJuICFpc0ZpeGVkO1xuXHRcdH0gKTtcblxuXHRcdG9mZnNldCA9IHsgbGVmdDogJC5kYXRlcGlja2VyLl9wb3NbIDAgXSwgdG9wOiAkLmRhdGVwaWNrZXIuX3Bvc1sgMSBdIH07XG5cdFx0JC5kYXRlcGlja2VyLl9wb3MgPSBudWxsO1xuXG5cdFx0Ly90byBhdm9pZCBmbGFzaGVzIG9uIEZpcmVmb3hcblx0XHRpbnN0LmRwRGl2LmVtcHR5KCk7XG5cblx0XHQvLyBkZXRlcm1pbmUgc2l6aW5nIG9mZnNjcmVlblxuXHRcdGluc3QuZHBEaXYuY3NzKCB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiwgdG9wOiBcIi0xMDAwcHhcIiB9ICk7XG5cdFx0JC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyKCBpbnN0ICk7XG5cblx0XHQvLyBmaXggd2lkdGggZm9yIGR5bmFtaWMgbnVtYmVyIG9mIGRhdGUgcGlja2Vyc1xuXHRcdC8vIGFuZCBhZGp1c3QgcG9zaXRpb24gYmVmb3JlIHNob3dpbmdcblx0XHRvZmZzZXQgPSAkLmRhdGVwaWNrZXIuX2NoZWNrT2Zmc2V0KCBpbnN0LCBvZmZzZXQsIGlzRml4ZWQgKTtcblx0XHRpbnN0LmRwRGl2LmNzcyggeyBwb3NpdGlvbjogKCAkLmRhdGVwaWNrZXIuX2luRGlhbG9nICYmICQuYmxvY2tVSSA/XG5cdFx0XHRcInN0YXRpY1wiIDogKCBpc0ZpeGVkID8gXCJmaXhlZFwiIDogXCJhYnNvbHV0ZVwiICkgKSwgZGlzcGxheTogXCJub25lXCIsXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCArIFwicHhcIiwgdG9wOiBvZmZzZXQudG9wICsgXCJweFwiIH0gKTtcblxuXHRcdGlmICggIWluc3QuaW5saW5lICkge1xuXHRcdFx0c2hvd0FuaW0gPSAkLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJzaG93QW5pbVwiICk7XG5cdFx0XHRkdXJhdGlvbiA9ICQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcImR1cmF0aW9uXCIgKTtcblx0XHRcdGluc3QuZHBEaXYuY3NzKCBcInotaW5kZXhcIiwgZGF0ZXBpY2tlcl9nZXRaaW5kZXgoICQoIGlucHV0ICkgKSArIDEgKTtcblx0XHRcdCQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgPSB0cnVlO1xuXG5cdFx0XHRpZiAoICQuZWZmZWN0cyAmJiAkLmVmZmVjdHMuZWZmZWN0WyBzaG93QW5pbSBdICkge1xuXHRcdFx0XHRpbnN0LmRwRGl2LnNob3coIHNob3dBbmltLCAkLmRhdGVwaWNrZXIuX2dldCggaW5zdCwgXCJzaG93T3B0aW9uc1wiICksIGR1cmF0aW9uICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbnN0LmRwRGl2WyBzaG93QW5pbSB8fCBcInNob3dcIiBdKCBzaG93QW5pbSA/IGR1cmF0aW9uIDogbnVsbCApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICQuZGF0ZXBpY2tlci5fc2hvdWxkRm9jdXNJbnB1dCggaW5zdCApICkge1xuXHRcdFx0XHRpbnN0LmlucHV0LnRyaWdnZXIoIFwiZm9jdXNcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQkLmRhdGVwaWNrZXIuX2N1ckluc3QgPSBpbnN0O1xuXHRcdH1cblx0fSxcblxuXHQvKiBHZW5lcmF0ZSB0aGUgZGF0ZSBwaWNrZXIgY29udGVudC4gKi9cblx0X3VwZGF0ZURhdGVwaWNrZXI6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdHRoaXMubWF4Um93cyA9IDQ7IC8vUmVzZXQgdGhlIG1heCBudW1iZXIgb2Ygcm93cyBiZWluZyBkaXNwbGF5ZWQgKHNlZSAjNzA0Mylcblx0XHRkYXRlcGlja2VyX2luc3RBY3RpdmUgPSBpbnN0OyAvLyBmb3IgZGVsZWdhdGUgaG92ZXIgZXZlbnRzXG5cdFx0aW5zdC5kcERpdi5lbXB0eSgpLmFwcGVuZCggdGhpcy5fZ2VuZXJhdGVIVE1MKCBpbnN0ICkgKTtcblx0XHR0aGlzLl9hdHRhY2hIYW5kbGVycyggaW5zdCApO1xuXG5cdFx0dmFyIG9yaWd5ZWFyc2h0bWwsXG5cdFx0XHRudW1Nb250aHMgPSB0aGlzLl9nZXROdW1iZXJPZk1vbnRocyggaW5zdCApLFxuXHRcdFx0Y29scyA9IG51bU1vbnRoc1sgMSBdLFxuXHRcdFx0d2lkdGggPSAxNyxcblx0XHRcdGFjdGl2ZUNlbGwgPSBpbnN0LmRwRGl2LmZpbmQoIFwiLlwiICsgdGhpcy5fZGF5T3ZlckNsYXNzICsgXCIgYVwiICk7XG5cblx0XHRpZiAoIGFjdGl2ZUNlbGwubGVuZ3RoID4gMCApIHtcblx0XHRcdGRhdGVwaWNrZXJfaGFuZGxlTW91c2VvdmVyLmFwcGx5KCBhY3RpdmVDZWxsLmdldCggMCApICk7XG5cdFx0fVxuXG5cdFx0aW5zdC5kcERpdi5yZW1vdmVDbGFzcyggXCJ1aS1kYXRlcGlja2VyLW11bHRpLTIgdWktZGF0ZXBpY2tlci1tdWx0aS0zIHVpLWRhdGVwaWNrZXItbXVsdGktNFwiICkud2lkdGgoIFwiXCIgKTtcblx0XHRpZiAoIGNvbHMgPiAxICkge1xuXHRcdFx0aW5zdC5kcERpdi5hZGRDbGFzcyggXCJ1aS1kYXRlcGlja2VyLW11bHRpLVwiICsgY29scyApLmNzcyggXCJ3aWR0aFwiLCAoIHdpZHRoICogY29scyApICsgXCJlbVwiICk7XG5cdFx0fVxuXHRcdGluc3QuZHBEaXZbICggbnVtTW9udGhzWyAwIF0gIT09IDEgfHwgbnVtTW9udGhzWyAxIF0gIT09IDEgPyBcImFkZFwiIDogXCJyZW1vdmVcIiApICtcblx0XHRcdFwiQ2xhc3NcIiBdKCBcInVpLWRhdGVwaWNrZXItbXVsdGlcIiApO1xuXHRcdGluc3QuZHBEaXZbICggdGhpcy5fZ2V0KCBpbnN0LCBcImlzUlRMXCIgKSA/IFwiYWRkXCIgOiBcInJlbW92ZVwiICkgK1xuXHRcdFx0XCJDbGFzc1wiIF0oIFwidWktZGF0ZXBpY2tlci1ydGxcIiApO1xuXG5cdFx0aWYgKCBpbnN0ID09PSAkLmRhdGVwaWNrZXIuX2N1ckluc3QgJiYgJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAkLmRhdGVwaWNrZXIuX3Nob3VsZEZvY3VzSW5wdXQoIGluc3QgKSApIHtcblx0XHRcdGluc3QuaW5wdXQudHJpZ2dlciggXCJmb2N1c1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gRGVmZmVyZWQgcmVuZGVyIG9mIHRoZSB5ZWFycyBzZWxlY3QgKHRvIGF2b2lkIGZsYXNoZXMgb24gRmlyZWZveClcblx0XHRpZiAoIGluc3QueWVhcnNodG1sICkge1xuXHRcdFx0b3JpZ3llYXJzaHRtbCA9IGluc3QueWVhcnNodG1sO1xuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly9hc3N1cmUgdGhhdCBpbnN0LnllYXJzaHRtbCBkaWRuJ3QgY2hhbmdlLlxuXHRcdFx0XHRpZiAoIG9yaWd5ZWFyc2h0bWwgPT09IGluc3QueWVhcnNodG1sICYmIGluc3QueWVhcnNodG1sICkge1xuXHRcdFx0XHRcdGluc3QuZHBEaXYuZmluZCggXCJzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyOmZpcnN0XCIgKS5yZXBsYWNlV2l0aCggaW5zdC55ZWFyc2h0bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcmlneWVhcnNodG1sID0gaW5zdC55ZWFyc2h0bWwgPSBudWxsO1xuXHRcdFx0fSwgMCApO1xuXHRcdH1cblx0fSxcblxuXHQvLyAjNjY5NCAtIGRvbid0IGZvY3VzIHRoZSBpbnB1dCBpZiBpdCdzIGFscmVhZHkgZm9jdXNlZFxuXHQvLyB0aGlzIGJyZWFrcyB0aGUgY2hhbmdlIGV2ZW50IGluIElFXG5cdC8vIFN1cHBvcnQ6IElFIGFuZCBqUXVlcnkgPDEuOVxuXHRfc2hvdWxkRm9jdXNJbnB1dDogZnVuY3Rpb24oIGluc3QgKSB7XG5cdFx0cmV0dXJuIGluc3QuaW5wdXQgJiYgaW5zdC5pbnB1dC5pcyggXCI6dmlzaWJsZVwiICkgJiYgIWluc3QuaW5wdXQuaXMoIFwiOmRpc2FibGVkXCIgKSAmJiAhaW5zdC5pbnB1dC5pcyggXCI6Zm9jdXNcIiApO1xuXHR9LFxuXG5cdC8qIENoZWNrIHBvc2l0aW9uaW5nIHRvIHJlbWFpbiBvbiBzY3JlZW4uICovXG5cdF9jaGVja09mZnNldDogZnVuY3Rpb24oIGluc3QsIG9mZnNldCwgaXNGaXhlZCApIHtcblx0XHR2YXIgZHBXaWR0aCA9IGluc3QuZHBEaXYub3V0ZXJXaWR0aCgpLFxuXHRcdFx0ZHBIZWlnaHQgPSBpbnN0LmRwRGl2Lm91dGVySGVpZ2h0KCksXG5cdFx0XHRpbnB1dFdpZHRoID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQub3V0ZXJXaWR0aCgpIDogMCxcblx0XHRcdGlucHV0SGVpZ2h0ID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQub3V0ZXJIZWlnaHQoKSA6IDAsXG5cdFx0XHR2aWV3V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggKyAoIGlzRml4ZWQgPyAwIDogJCggZG9jdW1lbnQgKS5zY3JvbGxMZWZ0KCkgKSxcblx0XHRcdHZpZXdIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ICsgKCBpc0ZpeGVkID8gMCA6ICQoIGRvY3VtZW50ICkuc2Nyb2xsVG9wKCkgKTtcblxuXHRcdG9mZnNldC5sZWZ0IC09ICggdGhpcy5fZ2V0KCBpbnN0LCBcImlzUlRMXCIgKSA/ICggZHBXaWR0aCAtIGlucHV0V2lkdGggKSA6IDAgKTtcblx0XHRvZmZzZXQubGVmdCAtPSAoIGlzRml4ZWQgJiYgb2Zmc2V0LmxlZnQgPT09IGluc3QuaW5wdXQub2Zmc2V0KCkubGVmdCApID8gJCggZG9jdW1lbnQgKS5zY3JvbGxMZWZ0KCkgOiAwO1xuXHRcdG9mZnNldC50b3AgLT0gKCBpc0ZpeGVkICYmIG9mZnNldC50b3AgPT09ICggaW5zdC5pbnB1dC5vZmZzZXQoKS50b3AgKyBpbnB1dEhlaWdodCApICkgPyAkKCBkb2N1bWVudCApLnNjcm9sbFRvcCgpIDogMDtcblxuXHRcdC8vIE5vdyBjaGVjayBpZiBkYXRlcGlja2VyIGlzIHNob3dpbmcgb3V0c2lkZSB3aW5kb3cgdmlld3BvcnQgLSBtb3ZlIHRvIGEgYmV0dGVyIHBsYWNlIGlmIHNvLlxuXHRcdG9mZnNldC5sZWZ0IC09IE1hdGgubWluKCBvZmZzZXQubGVmdCwgKCBvZmZzZXQubGVmdCArIGRwV2lkdGggPiB2aWV3V2lkdGggJiYgdmlld1dpZHRoID4gZHBXaWR0aCApID9cblx0XHRcdE1hdGguYWJzKCBvZmZzZXQubGVmdCArIGRwV2lkdGggLSB2aWV3V2lkdGggKSA6IDAgKTtcblx0XHRvZmZzZXQudG9wIC09IE1hdGgubWluKCBvZmZzZXQudG9wLCAoIG9mZnNldC50b3AgKyBkcEhlaWdodCA+IHZpZXdIZWlnaHQgJiYgdmlld0hlaWdodCA+IGRwSGVpZ2h0ICkgP1xuXHRcdFx0TWF0aC5hYnMoIGRwSGVpZ2h0ICsgaW5wdXRIZWlnaHQgKSA6IDAgKTtcblxuXHRcdHJldHVybiBvZmZzZXQ7XG5cdH0sXG5cblx0LyogRmluZCBhbiBvYmplY3QncyBwb3NpdGlvbiBvbiB0aGUgc2NyZWVuLiAqL1xuXHRfZmluZFBvczogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcG9zaXRpb24sXG5cdFx0XHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCggb2JqICksXG5cdFx0XHRpc1JUTCA9IHRoaXMuX2dldCggaW5zdCwgXCJpc1JUTFwiICk7XG5cblx0XHR3aGlsZSAoIG9iaiAmJiAoIG9iai50eXBlID09PSBcImhpZGRlblwiIHx8IG9iai5ub2RlVHlwZSAhPT0gMSB8fCAkLmV4cHIuZmlsdGVycy5oaWRkZW4oIG9iaiApICkgKSB7XG5cdFx0XHRvYmogPSBvYmpbIGlzUlRMID8gXCJwcmV2aW91c1NpYmxpbmdcIiA6IFwibmV4dFNpYmxpbmdcIiBdO1xuXHRcdH1cblxuXHRcdHBvc2l0aW9uID0gJCggb2JqICkub2Zmc2V0KCk7XG5cdFx0cmV0dXJuIFsgcG9zaXRpb24ubGVmdCwgcG9zaXRpb24udG9wIF07XG5cdH0sXG5cblx0LyogSGlkZSB0aGUgZGF0ZSBwaWNrZXIgZnJvbSB2aWV3LlxuXHQgKiBAcGFyYW0gIGlucHV0ICBlbGVtZW50IC0gdGhlIGlucHV0IGZpZWxkIGF0dGFjaGVkIHRvIHRoZSBkYXRlIHBpY2tlclxuXHQgKi9cblx0X2hpZGVEYXRlcGlja2VyOiBmdW5jdGlvbiggaW5wdXQgKSB7XG5cdFx0dmFyIHNob3dBbmltLCBkdXJhdGlvbiwgcG9zdFByb2Nlc3MsIG9uQ2xvc2UsXG5cdFx0XHRpbnN0ID0gdGhpcy5fY3VySW5zdDtcblxuXHRcdGlmICggIWluc3QgfHwgKCBpbnB1dCAmJiBpbnN0ICE9PSAkLmRhdGEoIGlucHV0LCBcImRhdGVwaWNrZXJcIiApICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9kYXRlcGlja2VyU2hvd2luZyApIHtcblx0XHRcdHNob3dBbmltID0gdGhpcy5fZ2V0KCBpbnN0LCBcInNob3dBbmltXCIgKTtcblx0XHRcdGR1cmF0aW9uID0gdGhpcy5fZ2V0KCBpbnN0LCBcImR1cmF0aW9uXCIgKTtcblx0XHRcdHBvc3RQcm9jZXNzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5fdGlkeURpYWxvZyggaW5zdCApO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gREVQUkVDQVRFRDogYWZ0ZXIgQkMgZm9yIDEuOC54ICQuZWZmZWN0c1sgc2hvd0FuaW0gXSBpcyBub3QgbmVlZGVkXG5cdFx0XHRpZiAoICQuZWZmZWN0cyAmJiAoICQuZWZmZWN0cy5lZmZlY3RbIHNob3dBbmltIF0gfHwgJC5lZmZlY3RzWyBzaG93QW5pbSBdICkgKSB7XG5cdFx0XHRcdGluc3QuZHBEaXYuaGlkZSggc2hvd0FuaW0sICQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcInNob3dPcHRpb25zXCIgKSwgZHVyYXRpb24sIHBvc3RQcm9jZXNzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbnN0LmRwRGl2WyAoIHNob3dBbmltID09PSBcInNsaWRlRG93blwiID8gXCJzbGlkZVVwXCIgOlxuXHRcdFx0XHRcdCggc2hvd0FuaW0gPT09IFwiZmFkZUluXCIgPyBcImZhZGVPdXRcIiA6IFwiaGlkZVwiICkgKSBdKCAoIHNob3dBbmltID8gZHVyYXRpb24gOiBudWxsICksIHBvc3RQcm9jZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggIXNob3dBbmltICkge1xuXHRcdFx0XHRwb3N0UHJvY2VzcygpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZGF0ZXBpY2tlclNob3dpbmcgPSBmYWxzZTtcblxuXHRcdFx0b25DbG9zZSA9IHRoaXMuX2dldCggaW5zdCwgXCJvbkNsb3NlXCIgKTtcblx0XHRcdGlmICggb25DbG9zZSApIHtcblx0XHRcdFx0b25DbG9zZS5hcHBseSggKCBpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFsgMCBdIDogbnVsbCApLCBbICggaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBcIlwiICksIGluc3QgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sYXN0SW5wdXQgPSBudWxsO1xuXHRcdFx0aWYgKCB0aGlzLl9pbkRpYWxvZyApIHtcblx0XHRcdFx0dGhpcy5fZGlhbG9nSW5wdXQuY3NzKCB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIGxlZnQ6IFwiMFwiLCB0b3A6IFwiLTEwMHB4XCIgfSApO1xuXHRcdFx0XHRpZiAoICQuYmxvY2tVSSApIHtcblx0XHRcdFx0XHQkLnVuYmxvY2tVSSgpO1xuXHRcdFx0XHRcdCQoIFwiYm9keVwiICkuYXBwZW5kKCB0aGlzLmRwRGl2ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2luRGlhbG9nID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFRpZHkgdXAgYWZ0ZXIgYSBkaWFsb2cgZGlzcGxheS4gKi9cblx0X3RpZHlEaWFsb2c6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdGluc3QuZHBEaXYucmVtb3ZlQ2xhc3MoIHRoaXMuX2RpYWxvZ0NsYXNzICkub2ZmKCBcIi51aS1kYXRlcGlja2VyLWNhbGVuZGFyXCIgKTtcblx0fSxcblxuXHQvKiBDbG9zZSBkYXRlIHBpY2tlciBpZiBjbGlja2VkIGVsc2V3aGVyZS4gKi9cblx0X2NoZWNrRXh0ZXJuYWxDbGljazogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggISQuZGF0ZXBpY2tlci5fY3VySW5zdCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgJHRhcmdldCA9ICQoIGV2ZW50LnRhcmdldCApLFxuXHRcdFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdCggJHRhcmdldFsgMCBdICk7XG5cblx0XHRpZiAoICggKCAkdGFyZ2V0WyAwIF0uaWQgIT09ICQuZGF0ZXBpY2tlci5fbWFpbkRpdklkICYmXG5cdFx0XHRcdCR0YXJnZXQucGFyZW50cyggXCIjXCIgKyAkLmRhdGVwaWNrZXIuX21haW5EaXZJZCApLmxlbmd0aCA9PT0gMCAmJlxuXHRcdFx0XHQhJHRhcmdldC5oYXNDbGFzcyggJC5kYXRlcGlja2VyLm1hcmtlckNsYXNzTmFtZSApICYmXG5cdFx0XHRcdCEkdGFyZ2V0LmNsb3Nlc3QoIFwiLlwiICsgJC5kYXRlcGlja2VyLl90cmlnZ2VyQ2xhc3MgKS5sZW5ndGggJiZcblx0XHRcdFx0JC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAhKCAkLmRhdGVwaWNrZXIuX2luRGlhbG9nICYmICQuYmxvY2tVSSApICkgKSB8fFxuXHRcdFx0KCAkdGFyZ2V0Lmhhc0NsYXNzKCAkLmRhdGVwaWNrZXIubWFya2VyQ2xhc3NOYW1lICkgJiYgJC5kYXRlcGlja2VyLl9jdXJJbnN0ICE9PSBpbnN0ICkgKSB7XG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHR9XG5cdH0sXG5cblx0LyogQWRqdXN0IG9uZSBvZiB0aGUgZGF0ZSBzdWItZmllbGRzLiAqL1xuXHRfYWRqdXN0RGF0ZTogZnVuY3Rpb24oIGlkLCBvZmZzZXQsIHBlcmlvZCApIHtcblx0XHR2YXIgdGFyZ2V0ID0gJCggaWQgKSxcblx0XHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KCB0YXJnZXRbIDAgXSApO1xuXG5cdFx0aWYgKCB0aGlzLl9pc0Rpc2FibGVkRGF0ZXBpY2tlciggdGFyZ2V0WyAwIF0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fYWRqdXN0SW5zdERhdGUoIGluc3QsIG9mZnNldCArXG5cdFx0XHQoIHBlcmlvZCA9PT0gXCJNXCIgPyB0aGlzLl9nZXQoIGluc3QsIFwic2hvd0N1cnJlbnRBdFBvc1wiICkgOiAwICksIC8vIHVuZG8gcG9zaXRpb25pbmdcblx0XHRcdHBlcmlvZCApO1xuXHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoIGluc3QgKTtcblx0fSxcblxuXHQvKiBBY3Rpb24gZm9yIGN1cnJlbnQgbGluay4gKi9cblx0X2dvdG9Ub2RheTogZnVuY3Rpb24oIGlkICkge1xuXHRcdHZhciBkYXRlLFxuXHRcdFx0dGFyZ2V0ID0gJCggaWQgKSxcblx0XHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KCB0YXJnZXRbIDAgXSApO1xuXG5cdFx0aWYgKCB0aGlzLl9nZXQoIGluc3QsIFwiZ290b0N1cnJlbnRcIiApICYmIGluc3QuY3VycmVudERheSApIHtcblx0XHRcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXk7XG5cdFx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGluc3QuY3VycmVudE1vbnRoO1xuXHRcdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gaW5zdC5jdXJyZW50WWVhcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcblx0XHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHR9XG5cdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKCBpbnN0ICk7XG5cdFx0dGhpcy5fYWRqdXN0RGF0ZSggdGFyZ2V0ICk7XG5cdH0sXG5cblx0LyogQWN0aW9uIGZvciBzZWxlY3RpbmcgYSBuZXcgbW9udGgveWVhci4gKi9cblx0X3NlbGVjdE1vbnRoWWVhcjogZnVuY3Rpb24oIGlkLCBzZWxlY3QsIHBlcmlvZCApIHtcblx0XHR2YXIgdGFyZ2V0ID0gJCggaWQgKSxcblx0XHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KCB0YXJnZXRbIDAgXSApO1xuXG5cdFx0aW5zdFsgXCJzZWxlY3RlZFwiICsgKCBwZXJpb2QgPT09IFwiTVwiID8gXCJNb250aFwiIDogXCJZZWFyXCIgKSBdID1cblx0XHRpbnN0WyBcImRyYXdcIiArICggcGVyaW9kID09PSBcIk1cIiA/IFwiTW9udGhcIiA6IFwiWWVhclwiICkgXSA9XG5cdFx0XHRwYXJzZUludCggc2VsZWN0Lm9wdGlvbnNbIHNlbGVjdC5zZWxlY3RlZEluZGV4IF0udmFsdWUsIDEwICk7XG5cblx0XHR0aGlzLl9ub3RpZnlDaGFuZ2UoIGluc3QgKTtcblx0XHR0aGlzLl9hZGp1c3REYXRlKCB0YXJnZXQgKTtcblx0fSxcblxuXHQvKiBBY3Rpb24gZm9yIHNlbGVjdGluZyBhIGRheS4gKi9cblx0X3NlbGVjdERheTogZnVuY3Rpb24oIGlkLCBtb250aCwgeWVhciwgdGQgKSB7XG5cdFx0dmFyIGluc3QsXG5cdFx0XHR0YXJnZXQgPSAkKCBpZCApO1xuXG5cdFx0aWYgKCAkKCB0ZCApLmhhc0NsYXNzKCB0aGlzLl91bnNlbGVjdGFibGVDbGFzcyApIHx8IHRoaXMuX2lzRGlzYWJsZWREYXRlcGlja2VyKCB0YXJnZXRbIDAgXSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGluc3QgPSB0aGlzLl9nZXRJbnN0KCB0YXJnZXRbIDAgXSApO1xuXHRcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXkgPSAkKCBcImFcIiwgdGQgKS5odG1sKCk7XG5cdFx0aW5zdC5zZWxlY3RlZE1vbnRoID0gaW5zdC5jdXJyZW50TW9udGggPSBtb250aDtcblx0XHRpbnN0LnNlbGVjdGVkWWVhciA9IGluc3QuY3VycmVudFllYXIgPSB5ZWFyO1xuXHRcdHRoaXMuX3NlbGVjdERhdGUoIGlkLCB0aGlzLl9mb3JtYXREYXRlKCBpbnN0LFxuXHRcdFx0aW5zdC5jdXJyZW50RGF5LCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50WWVhciApICk7XG5cdH0sXG5cblx0LyogRXJhc2UgdGhlIGlucHV0IGZpZWxkIGFuZCBoaWRlIHRoZSBkYXRlIHBpY2tlci4gKi9cblx0X2NsZWFyRGF0ZTogZnVuY3Rpb24oIGlkICkge1xuXHRcdHZhciB0YXJnZXQgPSAkKCBpZCApO1xuXHRcdHRoaXMuX3NlbGVjdERhdGUoIHRhcmdldCwgXCJcIiApO1xuXHR9LFxuXG5cdC8qIFVwZGF0ZSB0aGUgaW5wdXQgZmllbGQgd2l0aCB0aGUgc2VsZWN0ZWQgZGF0ZS4gKi9cblx0X3NlbGVjdERhdGU6IGZ1bmN0aW9uKCBpZCwgZGF0ZVN0ciApIHtcblx0XHR2YXIgb25TZWxlY3QsXG5cdFx0XHR0YXJnZXQgPSAkKCBpZCApLFxuXHRcdFx0aW5zdCA9IHRoaXMuX2dldEluc3QoIHRhcmdldFsgMCBdICk7XG5cblx0XHRkYXRlU3RyID0gKCBkYXRlU3RyICE9IG51bGwgPyBkYXRlU3RyIDogdGhpcy5fZm9ybWF0RGF0ZSggaW5zdCApICk7XG5cdFx0aWYgKCBpbnN0LmlucHV0ICkge1xuXHRcdFx0aW5zdC5pbnB1dC52YWwoIGRhdGVTdHIgKTtcblx0XHR9XG5cdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKCBpbnN0ICk7XG5cblx0XHRvblNlbGVjdCA9IHRoaXMuX2dldCggaW5zdCwgXCJvblNlbGVjdFwiICk7XG5cdFx0aWYgKCBvblNlbGVjdCApIHtcblx0XHRcdG9uU2VsZWN0LmFwcGx5KCAoIGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WyAwIF0gOiBudWxsICksIFsgZGF0ZVN0ciwgaW5zdCBdICk7ICAvLyB0cmlnZ2VyIGN1c3RvbSBjYWxsYmFja1xuXHRcdH0gZWxzZSBpZiAoIGluc3QuaW5wdXQgKSB7XG5cdFx0XHRpbnN0LmlucHV0LnRyaWdnZXIoIFwiY2hhbmdlXCIgKTsgLy8gZmlyZSB0aGUgY2hhbmdlIGV2ZW50XG5cdFx0fVxuXG5cdFx0aWYgKCBpbnN0LmlubGluZSApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoIGluc3QgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdHRoaXMuX2xhc3RJbnB1dCA9IGluc3QuaW5wdXRbIDAgXTtcblx0XHRcdGlmICggdHlwZW9mKCBpbnN0LmlucHV0WyAwIF0gKSAhPT0gXCJvYmplY3RcIiApIHtcblx0XHRcdFx0aW5zdC5pbnB1dC50cmlnZ2VyKCBcImZvY3VzXCIgKTsgLy8gcmVzdG9yZSBmb2N1c1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fbGFzdElucHV0ID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0LyogVXBkYXRlIGFueSBhbHRlcm5hdGUgZmllbGQgdG8gc3luY2hyb25pc2Ugd2l0aCB0aGUgbWFpbiBmaWVsZC4gKi9cblx0X3VwZGF0ZUFsdGVybmF0ZTogZnVuY3Rpb24oIGluc3QgKSB7XG5cdFx0dmFyIGFsdEZvcm1hdCwgZGF0ZSwgZGF0ZVN0cixcblx0XHRcdGFsdEZpZWxkID0gdGhpcy5fZ2V0KCBpbnN0LCBcImFsdEZpZWxkXCIgKTtcblxuXHRcdGlmICggYWx0RmllbGQgKSB7IC8vIHVwZGF0ZSBhbHRlcm5hdGUgZmllbGQgdG9vXG5cdFx0XHRhbHRGb3JtYXQgPSB0aGlzLl9nZXQoIGluc3QsIFwiYWx0Rm9ybWF0XCIgKSB8fCB0aGlzLl9nZXQoIGluc3QsIFwiZGF0ZUZvcm1hdFwiICk7XG5cdFx0XHRkYXRlID0gdGhpcy5fZ2V0RGF0ZSggaW5zdCApO1xuXHRcdFx0ZGF0ZVN0ciA9IHRoaXMuZm9ybWF0RGF0ZSggYWx0Rm9ybWF0LCBkYXRlLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoIGluc3QgKSApO1xuXHRcdFx0JCggYWx0RmllbGQgKS52YWwoIGRhdGVTdHIgKTtcblx0XHR9XG5cdH0sXG5cblx0LyogU2V0IGFzIGJlZm9yZVNob3dEYXkgZnVuY3Rpb24gdG8gcHJldmVudCBzZWxlY3Rpb24gb2Ygd2Vla2VuZHMuXG5cdCAqIEBwYXJhbSAgZGF0ZSAgRGF0ZSAtIHRoZSBkYXRlIHRvIGN1c3RvbWlzZVxuXHQgKiBAcmV0dXJuIFtib29sZWFuLCBzdHJpbmddIC0gaXMgdGhpcyBkYXRlIHNlbGVjdGFibGU/LCB3aGF0IGlzIGl0cyBDU1MgY2xhc3M/XG5cdCAqL1xuXHRub1dlZWtlbmRzOiBmdW5jdGlvbiggZGF0ZSApIHtcblx0XHR2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKTtcblx0XHRyZXR1cm4gWyAoIGRheSA+IDAgJiYgZGF5IDwgNiApLCBcIlwiIF07XG5cdH0sXG5cblx0LyogU2V0IGFzIGNhbGN1bGF0ZVdlZWsgdG8gZGV0ZXJtaW5lIHRoZSB3ZWVrIG9mIHRoZSB5ZWFyIGJhc2VkIG9uIHRoZSBJU08gODYwMSBkZWZpbml0aW9uLlxuXHQgKiBAcGFyYW0gIGRhdGUgIERhdGUgLSB0aGUgZGF0ZSB0byBnZXQgdGhlIHdlZWsgZm9yXG5cdCAqIEByZXR1cm4gIG51bWJlciAtIHRoZSBudW1iZXIgb2YgdGhlIHdlZWsgd2l0aGluIHRoZSB5ZWFyIHRoYXQgY29udGFpbnMgdGhpcyBkYXRlXG5cdCAqL1xuXHRpc284NjAxV2VlazogZnVuY3Rpb24oIGRhdGUgKSB7XG5cdFx0dmFyIHRpbWUsXG5cdFx0XHRjaGVja0RhdGUgPSBuZXcgRGF0ZSggZGF0ZS5nZXRUaW1lKCkgKTtcblxuXHRcdC8vIEZpbmQgVGh1cnNkYXkgb2YgdGhpcyB3ZWVrIHN0YXJ0aW5nIG9uIE1vbmRheVxuXHRcdGNoZWNrRGF0ZS5zZXREYXRlKCBjaGVja0RhdGUuZ2V0RGF0ZSgpICsgNCAtICggY2hlY2tEYXRlLmdldERheSgpIHx8IDcgKSApO1xuXG5cdFx0dGltZSA9IGNoZWNrRGF0ZS5nZXRUaW1lKCk7XG5cdFx0Y2hlY2tEYXRlLnNldE1vbnRoKCAwICk7IC8vIENvbXBhcmUgd2l0aCBKYW4gMVxuXHRcdGNoZWNrRGF0ZS5zZXREYXRlKCAxICk7XG5cdFx0cmV0dXJuIE1hdGguZmxvb3IoIE1hdGgucm91bmQoICggdGltZSAtIGNoZWNrRGF0ZSApIC8gODY0MDAwMDAgKSAvIDcgKSArIDE7XG5cdH0sXG5cblx0LyogUGFyc2UgYSBzdHJpbmcgdmFsdWUgaW50byBhIGRhdGUgb2JqZWN0LlxuXHQgKiBTZWUgZm9ybWF0RGF0ZSBiZWxvdyBmb3IgdGhlIHBvc3NpYmxlIGZvcm1hdHMuXG5cdCAqXG5cdCAqIEBwYXJhbSAgZm9ybWF0IHN0cmluZyAtIHRoZSBleHBlY3RlZCBmb3JtYXQgb2YgdGhlIGRhdGVcblx0ICogQHBhcmFtICB2YWx1ZSBzdHJpbmcgLSB0aGUgZGF0ZSBpbiB0aGUgYWJvdmUgZm9ybWF0XG5cdCAqIEBwYXJhbSAgc2V0dGluZ3MgT2JqZWN0IC0gYXR0cmlidXRlcyBpbmNsdWRlOlxuXHQgKlx0XHRcdFx0XHRzaG9ydFllYXJDdXRvZmYgIG51bWJlciAtIHRoZSBjdXRvZmYgeWVhciBmb3IgZGV0ZXJtaW5pbmcgdGhlIGNlbnR1cnkgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRkYXlOYW1lc1Nob3J0XHRzdHJpbmdbN10gLSBhYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheSAob3B0aW9uYWwpXG5cdCAqXHRcdFx0XHRcdGRheU5hbWVzXHRcdHN0cmluZ1s3XSAtIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5IChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0bW9udGhOYW1lc1Nob3J0IHN0cmluZ1sxMl0gLSBhYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0bW9udGhOYW1lc1x0XHRzdHJpbmdbMTJdIC0gbmFtZXMgb2YgdGhlIG1vbnRocyAob3B0aW9uYWwpXG5cdCAqIEByZXR1cm4gIERhdGUgLSB0aGUgZXh0cmFjdGVkIGRhdGUgdmFsdWUgb3IgbnVsbCBpZiB2YWx1ZSBpcyBibGFua1xuXHQgKi9cblx0cGFyc2VEYXRlOiBmdW5jdGlvbiggZm9ybWF0LCB2YWx1ZSwgc2V0dGluZ3MgKSB7XG5cdFx0aWYgKCBmb3JtYXQgPT0gbnVsbCB8fCB2YWx1ZSA9PSBudWxsICkge1xuXHRcdFx0dGhyb3cgXCJJbnZhbGlkIGFyZ3VtZW50c1wiO1xuXHRcdH1cblxuXHRcdHZhbHVlID0gKCB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWUgKyBcIlwiICk7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gXCJcIiApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBpRm9ybWF0LCBkaW0sIGV4dHJhLFxuXHRcdFx0aVZhbHVlID0gMCxcblx0XHRcdHNob3J0WWVhckN1dG9mZlRlbXAgPSAoIHNldHRpbmdzID8gc2V0dGluZ3Muc2hvcnRZZWFyQ3V0b2ZmIDogbnVsbCApIHx8IHRoaXMuX2RlZmF1bHRzLnNob3J0WWVhckN1dG9mZixcblx0XHRcdHNob3J0WWVhckN1dG9mZiA9ICggdHlwZW9mIHNob3J0WWVhckN1dG9mZlRlbXAgIT09IFwic3RyaW5nXCIgPyBzaG9ydFllYXJDdXRvZmZUZW1wIDpcblx0XHRcdFx0bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICUgMTAwICsgcGFyc2VJbnQoIHNob3J0WWVhckN1dG9mZlRlbXAsIDEwICkgKSxcblx0XHRcdGRheU5hbWVzU2hvcnQgPSAoIHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXNTaG9ydCA6IG51bGwgKSB8fCB0aGlzLl9kZWZhdWx0cy5kYXlOYW1lc1Nob3J0LFxuXHRcdFx0ZGF5TmFtZXMgPSAoIHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXMgOiBudWxsICkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXMsXG5cdFx0XHRtb250aE5hbWVzU2hvcnQgPSAoIHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lc1Nob3J0IDogbnVsbCApIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXNTaG9ydCxcblx0XHRcdG1vbnRoTmFtZXMgPSAoIHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lcyA6IG51bGwgKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzLFxuXHRcdFx0eWVhciA9IC0xLFxuXHRcdFx0bW9udGggPSAtMSxcblx0XHRcdGRheSA9IC0xLFxuXHRcdFx0ZG95ID0gLTEsXG5cdFx0XHRsaXRlcmFsID0gZmFsc2UsXG5cdFx0XHRkYXRlLFxuXG5cdFx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXG5cdFx0XHRsb29rQWhlYWQgPSBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVzID0gKCBpRm9ybWF0ICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdCggaUZvcm1hdCArIDEgKSA9PT0gbWF0Y2ggKTtcblx0XHRcdFx0aWYgKCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdGlGb3JtYXQrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hlcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEV4dHJhY3QgYSBudW1iZXIgZnJvbSB0aGUgc3RyaW5nIHZhbHVlXG5cdFx0XHRnZXROdW1iZXIgPSBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRcdHZhciBpc0RvdWJsZWQgPSBsb29rQWhlYWQoIG1hdGNoICksXG5cdFx0XHRcdFx0c2l6ZSA9ICggbWF0Y2ggPT09IFwiQFwiID8gMTQgOiAoIG1hdGNoID09PSBcIiFcIiA/IDIwIDpcblx0XHRcdFx0XHQoIG1hdGNoID09PSBcInlcIiAmJiBpc0RvdWJsZWQgPyA0IDogKCBtYXRjaCA9PT0gXCJvXCIgPyAzIDogMiApICkgKSApLFxuXHRcdFx0XHRcdG1pblNpemUgPSAoIG1hdGNoID09PSBcInlcIiA/IHNpemUgOiAxICksXG5cdFx0XHRcdFx0ZGlnaXRzID0gbmV3IFJlZ0V4cCggXCJeXFxcXGR7XCIgKyBtaW5TaXplICsgXCIsXCIgKyBzaXplICsgXCJ9XCIgKSxcblx0XHRcdFx0XHRudW0gPSB2YWx1ZS5zdWJzdHJpbmcoIGlWYWx1ZSApLm1hdGNoKCBkaWdpdHMgKTtcblx0XHRcdFx0aWYgKCAhbnVtICkge1xuXHRcdFx0XHRcdHRocm93IFwiTWlzc2luZyBudW1iZXIgYXQgcG9zaXRpb24gXCIgKyBpVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aVZhbHVlICs9IG51bVsgMCBdLmxlbmd0aDtcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCBudW1bIDAgXSwgMTAgKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEV4dHJhY3QgYSBuYW1lIGZyb20gdGhlIHN0cmluZyB2YWx1ZSBhbmQgY29udmVydCB0byBhbiBpbmRleFxuXHRcdFx0Z2V0TmFtZSA9IGZ1bmN0aW9uKCBtYXRjaCwgc2hvcnROYW1lcywgbG9uZ05hbWVzICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAtMSxcblx0XHRcdFx0XHRuYW1lcyA9ICQubWFwKCBsb29rQWhlYWQoIG1hdGNoICkgPyBsb25nTmFtZXMgOiBzaG9ydE5hbWVzLCBmdW5jdGlvbiggdiwgayApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIFsgaywgdiBdIF07XG5cdFx0XHRcdFx0fSApLnNvcnQoIGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIC0oIGFbIDEgXS5sZW5ndGggLSBiWyAxIF0ubGVuZ3RoICk7XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdCQuZWFjaCggbmFtZXMsIGZ1bmN0aW9uKCBpLCBwYWlyICkge1xuXHRcdFx0XHRcdHZhciBuYW1lID0gcGFpclsgMSBdO1xuXHRcdFx0XHRcdGlmICggdmFsdWUuc3Vic3RyKCBpVmFsdWUsIG5hbWUubGVuZ3RoICkudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0aW5kZXggPSBwYWlyWyAwIF07XG5cdFx0XHRcdFx0XHRpVmFsdWUgKz0gbmFtZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiBpbmRleCArIDE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgXCJVbmtub3duIG5hbWUgYXQgcG9zaXRpb24gXCIgKyBpVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIENvbmZpcm0gdGhhdCBhIGxpdGVyYWwgY2hhcmFjdGVyIG1hdGNoZXMgdGhlIHN0cmluZyB2YWx1ZVxuXHRcdFx0Y2hlY2tMaXRlcmFsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdmFsdWUuY2hhckF0KCBpVmFsdWUgKSAhPT0gZm9ybWF0LmNoYXJBdCggaUZvcm1hdCApICkge1xuXHRcdFx0XHRcdHRocm93IFwiVW5leHBlY3RlZCBsaXRlcmFsIGF0IHBvc2l0aW9uIFwiICsgaVZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlWYWx1ZSsrO1xuXHRcdFx0fTtcblxuXHRcdGZvciAoIGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrICkge1xuXHRcdFx0aWYgKCBsaXRlcmFsICkge1xuXHRcdFx0XHRpZiAoIGZvcm1hdC5jaGFyQXQoIGlGb3JtYXQgKSA9PT0gXCInXCIgJiYgIWxvb2tBaGVhZCggXCInXCIgKSApIHtcblx0XHRcdFx0XHRsaXRlcmFsID0gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2hlY2tMaXRlcmFsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN3aXRjaCAoIGZvcm1hdC5jaGFyQXQoIGlGb3JtYXQgKSApIHtcblx0XHRcdFx0XHRjYXNlIFwiZFwiOlxuXHRcdFx0XHRcdFx0ZGF5ID0gZ2V0TnVtYmVyKCBcImRcIiApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIkRcIjpcblx0XHRcdFx0XHRcdGdldE5hbWUoIFwiRFwiLCBkYXlOYW1lc1Nob3J0LCBkYXlOYW1lcyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIm9cIjpcblx0XHRcdFx0XHRcdGRveSA9IGdldE51bWJlciggXCJvXCIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJtXCI6XG5cdFx0XHRcdFx0XHRtb250aCA9IGdldE51bWJlciggXCJtXCIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJNXCI6XG5cdFx0XHRcdFx0XHRtb250aCA9IGdldE5hbWUoIFwiTVwiLCBtb250aE5hbWVzU2hvcnQsIG1vbnRoTmFtZXMgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJ5XCI6XG5cdFx0XHRcdFx0XHR5ZWFyID0gZ2V0TnVtYmVyKCBcInlcIiApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIkBcIjpcblx0XHRcdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZSggZ2V0TnVtYmVyKCBcIkBcIiApICk7XG5cdFx0XHRcdFx0XHR5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHRcdFx0bW9udGggPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xuXHRcdFx0XHRcdFx0ZGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiIVwiOlxuXHRcdFx0XHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKCAoIGdldE51bWJlciggXCIhXCIgKSAtIHRoaXMuX3RpY2tzVG8xOTcwICkgLyAxMDAwMCApO1xuXHRcdFx0XHRcdFx0eWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0XHRcdG1vbnRoID0gZGF0ZS5nZXRNb250aCgpICsgMTtcblx0XHRcdFx0XHRcdGRheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0XHRcdGlmICggbG9va0FoZWFkKCBcIidcIiApICkge1xuXHRcdFx0XHRcdFx0XHRjaGVja0xpdGVyYWwoKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxpdGVyYWwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNoZWNrTGl0ZXJhbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBpVmFsdWUgPCB2YWx1ZS5sZW5ndGggKSB7XG5cdFx0XHRleHRyYSA9IHZhbHVlLnN1YnN0ciggaVZhbHVlICk7XG5cdFx0XHRpZiAoICEvXlxccysvLnRlc3QoIGV4dHJhICkgKSB7XG5cdFx0XHRcdHRocm93IFwiRXh0cmEvdW5wYXJzZWQgY2hhcmFjdGVycyBmb3VuZCBpbiBkYXRlOiBcIiArIGV4dHJhO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggeWVhciA9PT0gLTEgKSB7XG5cdFx0XHR5ZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXHRcdH0gZWxzZSBpZiAoIHllYXIgPCAxMDAgKSB7XG5cdFx0XHR5ZWFyICs9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAtIG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAlIDEwMCArXG5cdFx0XHRcdCggeWVhciA8PSBzaG9ydFllYXJDdXRvZmYgPyAwIDogLTEwMCApO1xuXHRcdH1cblxuXHRcdGlmICggZG95ID4gLTEgKSB7XG5cdFx0XHRtb250aCA9IDE7XG5cdFx0XHRkYXkgPSBkb3k7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGRpbSA9IHRoaXMuX2dldERheXNJbk1vbnRoKCB5ZWFyLCBtb250aCAtIDEgKTtcblx0XHRcdFx0aWYgKCBkYXkgPD0gZGltICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1vbnRoKys7XG5cdFx0XHRcdGRheSAtPSBkaW07XG5cdFx0XHR9IHdoaWxlICggdHJ1ZSApO1xuXHRcdH1cblxuXHRcdGRhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3IERhdGUoIHllYXIsIG1vbnRoIC0gMSwgZGF5ICkgKTtcblx0XHRpZiAoIGRhdGUuZ2V0RnVsbFllYXIoKSAhPT0geWVhciB8fCBkYXRlLmdldE1vbnRoKCkgKyAxICE9PSBtb250aCB8fCBkYXRlLmdldERhdGUoKSAhPT0gZGF5ICkge1xuXHRcdFx0dGhyb3cgXCJJbnZhbGlkIGRhdGVcIjsgLy8gRS5nLiAzMS8wMi8wMFxuXHRcdH1cblx0XHRyZXR1cm4gZGF0ZTtcblx0fSxcblxuXHQvKiBTdGFuZGFyZCBkYXRlIGZvcm1hdHMuICovXG5cdEFUT006IFwieXktbW0tZGRcIiwgLy8gUkZDIDMzMzkgKElTTyA4NjAxKVxuXHRDT09LSUU6IFwiRCwgZGQgTSB5eVwiLFxuXHRJU09fODYwMTogXCJ5eS1tbS1kZFwiLFxuXHRSRkNfODIyOiBcIkQsIGQgTSB5XCIsXG5cdFJGQ184NTA6IFwiREQsIGRkLU0teVwiLFxuXHRSRkNfMTAzNjogXCJELCBkIE0geVwiLFxuXHRSRkNfMTEyMzogXCJELCBkIE0geXlcIixcblx0UkZDXzI4MjI6IFwiRCwgZCBNIHl5XCIsXG5cdFJTUzogXCJELCBkIE0geVwiLCAvLyBSRkMgODIyXG5cdFRJQ0tTOiBcIiFcIixcblx0VElNRVNUQU1QOiBcIkBcIixcblx0VzNDOiBcInl5LW1tLWRkXCIsIC8vIElTTyA4NjAxXG5cblx0X3RpY2tzVG8xOTcwOiAoICggKCAxOTcwIC0gMSApICogMzY1ICsgTWF0aC5mbG9vciggMTk3MCAvIDQgKSAtIE1hdGguZmxvb3IoIDE5NzAgLyAxMDAgKSArXG5cdFx0TWF0aC5mbG9vciggMTk3MCAvIDQwMCApICkgKiAyNCAqIDYwICogNjAgKiAxMDAwMDAwMCApLFxuXG5cdC8qIEZvcm1hdCBhIGRhdGUgb2JqZWN0IGludG8gYSBzdHJpbmcgdmFsdWUuXG5cdCAqIFRoZSBmb3JtYXQgY2FuIGJlIGNvbWJpbmF0aW9ucyBvZiB0aGUgZm9sbG93aW5nOlxuXHQgKiBkICAtIGRheSBvZiBtb250aCAobm8gbGVhZGluZyB6ZXJvKVxuXHQgKiBkZCAtIGRheSBvZiBtb250aCAodHdvIGRpZ2l0KVxuXHQgKiBvICAtIGRheSBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm9zKVxuXHQgKiBvbyAtIGRheSBvZiB5ZWFyICh0aHJlZSBkaWdpdClcblx0ICogRCAgLSBkYXkgbmFtZSBzaG9ydFxuXHQgKiBERCAtIGRheSBuYW1lIGxvbmdcblx0ICogbSAgLSBtb250aCBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm8pXG5cdCAqIG1tIC0gbW9udGggb2YgeWVhciAodHdvIGRpZ2l0KVxuXHQgKiBNICAtIG1vbnRoIG5hbWUgc2hvcnRcblx0ICogTU0gLSBtb250aCBuYW1lIGxvbmdcblx0ICogeSAgLSB5ZWFyICh0d28gZGlnaXQpXG5cdCAqIHl5IC0geWVhciAoZm91ciBkaWdpdClcblx0ICogQCAtIFVuaXggdGltZXN0YW1wIChtcyBzaW5jZSAwMS8wMS8xOTcwKVxuXHQgKiAhIC0gV2luZG93cyB0aWNrcyAoMTAwbnMgc2luY2UgMDEvMDEvMDAwMSlcblx0ICogXCIuLi5cIiAtIGxpdGVyYWwgdGV4dFxuXHQgKiAnJyAtIHNpbmdsZSBxdW90ZVxuXHQgKlxuXHQgKiBAcGFyYW0gIGZvcm1hdCBzdHJpbmcgLSB0aGUgZGVzaXJlZCBmb3JtYXQgb2YgdGhlIGRhdGVcblx0ICogQHBhcmFtICBkYXRlIERhdGUgLSB0aGUgZGF0ZSB2YWx1ZSB0byBmb3JtYXRcblx0ICogQHBhcmFtICBzZXR0aW5ncyBPYmplY3QgLSBhdHRyaWJ1dGVzIGluY2x1ZGU6XG5cdCAqXHRcdFx0XHRcdGRheU5hbWVzU2hvcnRcdHN0cmluZ1s3XSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5IChvcHRpb25hbClcblx0ICpcdFx0XHRcdFx0ZGF5TmFtZXNcdFx0c3RyaW5nWzddIC0gbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRtb250aE5hbWVzU2hvcnQgc3RyaW5nWzEyXSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBtb250aHMgKG9wdGlvbmFsKVxuXHQgKlx0XHRcdFx0XHRtb250aE5hbWVzXHRcdHN0cmluZ1sxMl0gLSBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcblx0ICogQHJldHVybiAgc3RyaW5nIC0gdGhlIGRhdGUgaW4gdGhlIGFib3ZlIGZvcm1hdFxuXHQgKi9cblx0Zm9ybWF0RGF0ZTogZnVuY3Rpb24oIGZvcm1hdCwgZGF0ZSwgc2V0dGluZ3MgKSB7XG5cdFx0aWYgKCAhZGF0ZSApIHtcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH1cblxuXHRcdHZhciBpRm9ybWF0LFxuXHRcdFx0ZGF5TmFtZXNTaG9ydCA9ICggc2V0dGluZ3MgPyBzZXR0aW5ncy5kYXlOYW1lc1Nob3J0IDogbnVsbCApIHx8IHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzU2hvcnQsXG5cdFx0XHRkYXlOYW1lcyA9ICggc2V0dGluZ3MgPyBzZXR0aW5ncy5kYXlOYW1lcyA6IG51bGwgKSB8fCB0aGlzLl9kZWZhdWx0cy5kYXlOYW1lcyxcblx0XHRcdG1vbnRoTmFtZXNTaG9ydCA9ICggc2V0dGluZ3MgPyBzZXR0aW5ncy5tb250aE5hbWVzU2hvcnQgOiBudWxsICkgfHwgdGhpcy5fZGVmYXVsdHMubW9udGhOYW1lc1Nob3J0LFxuXHRcdFx0bW9udGhOYW1lcyA9ICggc2V0dGluZ3MgPyBzZXR0aW5ncy5tb250aE5hbWVzIDogbnVsbCApIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXMsXG5cblx0XHRcdC8vIENoZWNrIHdoZXRoZXIgYSBmb3JtYXQgY2hhcmFjdGVyIGlzIGRvdWJsZWRcblx0XHRcdGxvb2tBaGVhZCA9IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdFx0dmFyIG1hdGNoZXMgPSAoIGlGb3JtYXQgKyAxIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KCBpRm9ybWF0ICsgMSApID09PSBtYXRjaCApO1xuXHRcdFx0XHRpZiAoIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0aUZvcm1hdCsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaGVzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9ybWF0IGEgbnVtYmVyLCB3aXRoIGxlYWRpbmcgemVybyBpZiBuZWNlc3Nhcnlcblx0XHRcdGZvcm1hdE51bWJlciA9IGZ1bmN0aW9uKCBtYXRjaCwgdmFsdWUsIGxlbiApIHtcblx0XHRcdFx0dmFyIG51bSA9IFwiXCIgKyB2YWx1ZTtcblx0XHRcdFx0aWYgKCBsb29rQWhlYWQoIG1hdGNoICkgKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCBudW0ubGVuZ3RoIDwgbGVuICkge1xuXHRcdFx0XHRcdFx0bnVtID0gXCIwXCIgKyBudW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudW07XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3JtYXQgYSBuYW1lLCBzaG9ydCBvciBsb25nIGFzIHJlcXVlc3RlZFxuXHRcdFx0Zm9ybWF0TmFtZSA9IGZ1bmN0aW9uKCBtYXRjaCwgdmFsdWUsIHNob3J0TmFtZXMsIGxvbmdOYW1lcyApIHtcblx0XHRcdFx0cmV0dXJuICggbG9va0FoZWFkKCBtYXRjaCApID8gbG9uZ05hbWVzWyB2YWx1ZSBdIDogc2hvcnROYW1lc1sgdmFsdWUgXSApO1xuXHRcdFx0fSxcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHRsaXRlcmFsID0gZmFsc2U7XG5cblx0XHRpZiAoIGRhdGUgKSB7XG5cdFx0XHRmb3IgKCBpRm9ybWF0ID0gMDsgaUZvcm1hdCA8IGZvcm1hdC5sZW5ndGg7IGlGb3JtYXQrKyApIHtcblx0XHRcdFx0aWYgKCBsaXRlcmFsICkge1xuXHRcdFx0XHRcdGlmICggZm9ybWF0LmNoYXJBdCggaUZvcm1hdCApID09PSBcIidcIiAmJiAhbG9va0FoZWFkKCBcIidcIiApICkge1xuXHRcdFx0XHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0LmNoYXJBdCggaUZvcm1hdCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzd2l0Y2ggKCBmb3JtYXQuY2hhckF0KCBpRm9ybWF0ICkgKSB7XG5cdFx0XHRcdFx0XHRjYXNlIFwiZFwiOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0TnVtYmVyKCBcImRcIiwgZGF0ZS5nZXREYXRlKCksIDIgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiRFwiOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0TmFtZSggXCJEXCIsIGRhdGUuZ2V0RGF5KCksIGRheU5hbWVzU2hvcnQsIGRheU5hbWVzICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIm9cIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE51bWJlciggXCJvXCIsXG5cdFx0XHRcdFx0XHRcdFx0TWF0aC5yb3VuZCggKCBuZXcgRGF0ZSggZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpICkuZ2V0VGltZSgpIC0gbmV3IERhdGUoIGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMCApLmdldFRpbWUoKSApIC8gODY0MDAwMDAgKSwgMyApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJtXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROdW1iZXIoIFwibVwiLCBkYXRlLmdldE1vbnRoKCkgKyAxLCAyICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIk1cIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE5hbWUoIFwiTVwiLCBkYXRlLmdldE1vbnRoKCksIG1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lcyApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJ5XCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSAoIGxvb2tBaGVhZCggXCJ5XCIgKSA/IGRhdGUuZ2V0RnVsbFllYXIoKSA6XG5cdFx0XHRcdFx0XHRcdFx0KCBkYXRlLmdldEZ1bGxZZWFyKCkgJSAxMDAgPCAxMCA/IFwiMFwiIDogXCJcIiApICsgZGF0ZS5nZXRGdWxsWWVhcigpICUgMTAwICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIkBcIjpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGRhdGUuZ2V0VGltZSgpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCIhXCI6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBkYXRlLmdldFRpbWUoKSAqIDEwMDAwICsgdGhpcy5fdGlja3NUbzE5NzA7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0XHRcdFx0aWYgKCBsb29rQWhlYWQoIFwiJ1wiICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IFwiJ1wiO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGxpdGVyYWwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdC5jaGFyQXQoIGlGb3JtYXQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fSxcblxuXHQvKiBFeHRyYWN0IGFsbCBwb3NzaWJsZSBjaGFyYWN0ZXJzIGZyb20gdGhlIGRhdGUgZm9ybWF0LiAqL1xuXHRfcG9zc2libGVDaGFyczogZnVuY3Rpb24oIGZvcm1hdCApIHtcblx0XHR2YXIgaUZvcm1hdCxcblx0XHRcdGNoYXJzID0gXCJcIixcblx0XHRcdGxpdGVyYWwgPSBmYWxzZSxcblxuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciBhIGZvcm1hdCBjaGFyYWN0ZXIgaXMgZG91YmxlZFxuXHRcdFx0bG9va0FoZWFkID0gZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9ICggaUZvcm1hdCArIDEgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdC5jaGFyQXQoIGlGb3JtYXQgKyAxICkgPT09IG1hdGNoICk7XG5cdFx0XHRcdGlmICggbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRpRm9ybWF0Kys7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoZXM7XG5cdFx0XHR9O1xuXG5cdFx0Zm9yICggaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KysgKSB7XG5cdFx0XHRpZiAoIGxpdGVyYWwgKSB7XG5cdFx0XHRcdGlmICggZm9ybWF0LmNoYXJBdCggaUZvcm1hdCApID09PSBcIidcIiAmJiAhbG9va0FoZWFkKCBcIidcIiApICkge1xuXHRcdFx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjaGFycyArPSBmb3JtYXQuY2hhckF0KCBpRm9ybWF0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN3aXRjaCAoIGZvcm1hdC5jaGFyQXQoIGlGb3JtYXQgKSApIHtcblx0XHRcdFx0XHRjYXNlIFwiZFwiOiBjYXNlIFwibVwiOiBjYXNlIFwieVwiOiBjYXNlIFwiQFwiOlxuXHRcdFx0XHRcdFx0Y2hhcnMgKz0gXCIwMTIzNDU2Nzg5XCI7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiRFwiOiBjYXNlIFwiTVwiOlxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7IC8vIEFjY2VwdCBhbnl0aGluZ1xuXHRcdFx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdFx0XHRpZiAoIGxvb2tBaGVhZCggXCInXCIgKSApIHtcblx0XHRcdFx0XHRcdFx0Y2hhcnMgKz0gXCInXCI7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsaXRlcmFsID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjaGFycyArPSBmb3JtYXQuY2hhckF0KCBpRm9ybWF0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNoYXJzO1xuXHR9LFxuXG5cdC8qIEdldCBhIHNldHRpbmcgdmFsdWUsIGRlZmF1bHRpbmcgaWYgbmVjZXNzYXJ5LiAqL1xuXHRfZ2V0OiBmdW5jdGlvbiggaW5zdCwgbmFtZSApIHtcblx0XHRyZXR1cm4gaW5zdC5zZXR0aW5nc1sgbmFtZSBdICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0aW5zdC5zZXR0aW5nc1sgbmFtZSBdIDogdGhpcy5fZGVmYXVsdHNbIG5hbWUgXTtcblx0fSxcblxuXHQvKiBQYXJzZSBleGlzdGluZyBkYXRlIGFuZCBpbml0aWFsaXNlIGRhdGUgcGlja2VyLiAqL1xuXHRfc2V0RGF0ZUZyb21GaWVsZDogZnVuY3Rpb24oIGluc3QsIG5vRGVmYXVsdCApIHtcblx0XHRpZiAoIGluc3QuaW5wdXQudmFsKCkgPT09IGluc3QubGFzdFZhbCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZGF0ZUZvcm1hdCA9IHRoaXMuX2dldCggaW5zdCwgXCJkYXRlRm9ybWF0XCIgKSxcblx0XHRcdGRhdGVzID0gaW5zdC5sYXN0VmFsID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBudWxsLFxuXHRcdFx0ZGVmYXVsdERhdGUgPSB0aGlzLl9nZXREZWZhdWx0RGF0ZSggaW5zdCApLFxuXHRcdFx0ZGF0ZSA9IGRlZmF1bHREYXRlLFxuXHRcdFx0c2V0dGluZ3MgPSB0aGlzLl9nZXRGb3JtYXRDb25maWcoIGluc3QgKTtcblxuXHRcdHRyeSB7XG5cdFx0XHRkYXRlID0gdGhpcy5wYXJzZURhdGUoIGRhdGVGb3JtYXQsIGRhdGVzLCBzZXR0aW5ncyApIHx8IGRlZmF1bHREYXRlO1xuXHRcdH0gY2F0Y2ggKCBldmVudCApIHtcblx0XHRcdGRhdGVzID0gKCBub0RlZmF1bHQgPyBcIlwiIDogZGF0ZXMgKTtcblx0XHR9XG5cdFx0aW5zdC5zZWxlY3RlZERheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuXHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRpbnN0LmN1cnJlbnREYXkgPSAoIGRhdGVzID8gZGF0ZS5nZXREYXRlKCkgOiAwICk7XG5cdFx0aW5zdC5jdXJyZW50TW9udGggPSAoIGRhdGVzID8gZGF0ZS5nZXRNb250aCgpIDogMCApO1xuXHRcdGluc3QuY3VycmVudFllYXIgPSAoIGRhdGVzID8gZGF0ZS5nZXRGdWxsWWVhcigpIDogMCApO1xuXHRcdHRoaXMuX2FkanVzdEluc3REYXRlKCBpbnN0ICk7XG5cdH0sXG5cblx0LyogUmV0cmlldmUgdGhlIGRlZmF1bHQgZGF0ZSBzaG93biBvbiBvcGVuaW5nLiAqL1xuXHRfZ2V0RGVmYXVsdERhdGU6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdHJldHVybiB0aGlzLl9yZXN0cmljdE1pbk1heCggaW5zdCxcblx0XHRcdHRoaXMuX2RldGVybWluZURhdGUoIGluc3QsIHRoaXMuX2dldCggaW5zdCwgXCJkZWZhdWx0RGF0ZVwiICksIG5ldyBEYXRlKCkgKSApO1xuXHR9LFxuXG5cdC8qIEEgZGF0ZSBtYXkgYmUgc3BlY2lmaWVkIGFzIGFuIGV4YWN0IHZhbHVlIG9yIGEgcmVsYXRpdmUgb25lLiAqL1xuXHRfZGV0ZXJtaW5lRGF0ZTogZnVuY3Rpb24oIGluc3QsIGRhdGUsIGRlZmF1bHREYXRlICkge1xuXHRcdHZhciBvZmZzZXROdW1lcmljID0gZnVuY3Rpb24oIG9mZnNldCApIHtcblx0XHRcdFx0dmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRkYXRlLnNldERhdGUoIGRhdGUuZ2V0RGF0ZSgpICsgb2Zmc2V0ICk7XG5cdFx0XHRcdHJldHVybiBkYXRlO1xuXHRcdFx0fSxcblx0XHRcdG9mZnNldFN0cmluZyA9IGZ1bmN0aW9uKCBvZmZzZXQgKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZGF0ZXBpY2tlci5wYXJzZURhdGUoICQuZGF0ZXBpY2tlci5fZ2V0KCBpbnN0LCBcImRhdGVGb3JtYXRcIiApLFxuXHRcdFx0XHRcdFx0b2Zmc2V0LCAkLmRhdGVwaWNrZXIuX2dldEZvcm1hdENvbmZpZyggaW5zdCApICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gSWdub3JlXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZGF0ZSA9ICggb2Zmc2V0LnRvTG93ZXJDYXNlKCkubWF0Y2goIC9eYy8gKSA/XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9nZXREYXRlKCBpbnN0ICkgOiBudWxsICkgfHwgbmV3IERhdGUoKSxcblx0XHRcdFx0XHR5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpLFxuXHRcdFx0XHRcdG1vbnRoID0gZGF0ZS5nZXRNb250aCgpLFxuXHRcdFx0XHRcdGRheSA9IGRhdGUuZ2V0RGF0ZSgpLFxuXHRcdFx0XHRcdHBhdHRlcm4gPSAvKFsrXFwtXT9bMC05XSspXFxzKihkfER8d3xXfG18TXx5fFkpPy9nLFxuXHRcdFx0XHRcdG1hdGNoZXMgPSBwYXR0ZXJuLmV4ZWMoIG9mZnNldCApO1xuXG5cdFx0XHRcdHdoaWxlICggbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRzd2l0Y2ggKCBtYXRjaGVzWyAyIF0gfHwgXCJkXCIgKSB7XG5cdFx0XHRcdFx0XHRjYXNlIFwiZFwiIDogY2FzZSBcIkRcIiA6XG5cdFx0XHRcdFx0XHRcdGRheSArPSBwYXJzZUludCggbWF0Y2hlc1sgMSBdLCAxMCApOyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJ3XCIgOiBjYXNlIFwiV1wiIDpcblx0XHRcdFx0XHRcdFx0ZGF5ICs9IHBhcnNlSW50KCBtYXRjaGVzWyAxIF0sIDEwICkgKiA3OyBicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJtXCIgOiBjYXNlIFwiTVwiIDpcblx0XHRcdFx0XHRcdFx0bW9udGggKz0gcGFyc2VJbnQoIG1hdGNoZXNbIDEgXSwgMTAgKTtcblx0XHRcdFx0XHRcdFx0ZGF5ID0gTWF0aC5taW4oIGRheSwgJC5kYXRlcGlja2VyLl9nZXREYXlzSW5Nb250aCggeWVhciwgbW9udGggKSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgXCJ5XCI6IGNhc2UgXCJZXCIgOlxuXHRcdFx0XHRcdFx0XHR5ZWFyICs9IHBhcnNlSW50KCBtYXRjaGVzWyAxIF0sIDEwICk7XG5cdFx0XHRcdFx0XHRcdGRheSA9IE1hdGgubWluKCBkYXksICQuZGF0ZXBpY2tlci5fZ2V0RGF5c0luTW9udGgoIHllYXIsIG1vbnRoICkgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1hdGNoZXMgPSBwYXR0ZXJuLmV4ZWMoIG9mZnNldCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBuZXcgRGF0ZSggeWVhciwgbW9udGgsIGRheSApO1xuXHRcdFx0fSxcblx0XHRcdG5ld0RhdGUgPSAoIGRhdGUgPT0gbnVsbCB8fCBkYXRlID09PSBcIlwiID8gZGVmYXVsdERhdGUgOiAoIHR5cGVvZiBkYXRlID09PSBcInN0cmluZ1wiID8gb2Zmc2V0U3RyaW5nKCBkYXRlICkgOlxuXHRcdFx0XHQoIHR5cGVvZiBkYXRlID09PSBcIm51bWJlclwiID8gKCBpc05hTiggZGF0ZSApID8gZGVmYXVsdERhdGUgOiBvZmZzZXROdW1lcmljKCBkYXRlICkgKSA6IG5ldyBEYXRlKCBkYXRlLmdldFRpbWUoKSApICkgKSApO1xuXG5cdFx0bmV3RGF0ZSA9ICggbmV3RGF0ZSAmJiBuZXdEYXRlLnRvU3RyaW5nKCkgPT09IFwiSW52YWxpZCBEYXRlXCIgPyBkZWZhdWx0RGF0ZSA6IG5ld0RhdGUgKTtcblx0XHRpZiAoIG5ld0RhdGUgKSB7XG5cdFx0XHRuZXdEYXRlLnNldEhvdXJzKCAwICk7XG5cdFx0XHRuZXdEYXRlLnNldE1pbnV0ZXMoIDAgKTtcblx0XHRcdG5ld0RhdGUuc2V0U2Vjb25kcyggMCApO1xuXHRcdFx0bmV3RGF0ZS5zZXRNaWxsaXNlY29uZHMoIDAgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KCBuZXdEYXRlICk7XG5cdH0sXG5cblx0LyogSGFuZGxlIHN3aXRjaCB0by9mcm9tIGRheWxpZ2h0IHNhdmluZy5cblx0ICogSG91cnMgbWF5IGJlIG5vbi16ZXJvIG9uIGRheWxpZ2h0IHNhdmluZyBjdXQtb3Zlcjpcblx0ICogPiAxMiB3aGVuIG1pZG5pZ2h0IGNoYW5nZW92ZXIsIGJ1dCB0aGVuIGNhbm5vdCBnZW5lcmF0ZVxuXHQgKiBtaWRuaWdodCBkYXRldGltZSwgc28ganVtcCB0byAxQU0sIG90aGVyd2lzZSByZXNldC5cblx0ICogQHBhcmFtICBkYXRlICAoRGF0ZSkgdGhlIGRhdGUgdG8gY2hlY2tcblx0ICogQHJldHVybiAgKERhdGUpIHRoZSBjb3JyZWN0ZWQgZGF0ZVxuXHQgKi9cblx0X2RheWxpZ2h0U2F2aW5nQWRqdXN0OiBmdW5jdGlvbiggZGF0ZSApIHtcblx0XHRpZiAoICFkYXRlICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdGRhdGUuc2V0SG91cnMoIGRhdGUuZ2V0SG91cnMoKSA+IDEyID8gZGF0ZS5nZXRIb3VycygpICsgMiA6IDAgKTtcblx0XHRyZXR1cm4gZGF0ZTtcblx0fSxcblxuXHQvKiBTZXQgdGhlIGRhdGUocykgZGlyZWN0bHkuICovXG5cdF9zZXREYXRlOiBmdW5jdGlvbiggaW5zdCwgZGF0ZSwgbm9DaGFuZ2UgKSB7XG5cdFx0dmFyIGNsZWFyID0gIWRhdGUsXG5cdFx0XHRvcmlnTW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGgsXG5cdFx0XHRvcmlnWWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyLFxuXHRcdFx0bmV3RGF0ZSA9IHRoaXMuX3Jlc3RyaWN0TWluTWF4KCBpbnN0LCB0aGlzLl9kZXRlcm1pbmVEYXRlKCBpbnN0LCBkYXRlLCBuZXcgRGF0ZSgpICkgKTtcblxuXHRcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXkgPSBuZXdEYXRlLmdldERhdGUoKTtcblx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGluc3QuY3VycmVudE1vbnRoID0gbmV3RGF0ZS5nZXRNb250aCgpO1xuXHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGluc3QuY3VycmVudFllYXIgPSBuZXdEYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0aWYgKCAoIG9yaWdNb250aCAhPT0gaW5zdC5zZWxlY3RlZE1vbnRoIHx8IG9yaWdZZWFyICE9PSBpbnN0LnNlbGVjdGVkWWVhciApICYmICFub0NoYW5nZSApIHtcblx0XHRcdHRoaXMuX25vdGlmeUNoYW5nZSggaW5zdCApO1xuXHRcdH1cblx0XHR0aGlzLl9hZGp1c3RJbnN0RGF0ZSggaW5zdCApO1xuXHRcdGlmICggaW5zdC5pbnB1dCApIHtcblx0XHRcdGluc3QuaW5wdXQudmFsKCBjbGVhciA/IFwiXCIgOiB0aGlzLl9mb3JtYXREYXRlKCBpbnN0ICkgKTtcblx0XHR9XG5cdH0sXG5cblx0LyogUmV0cmlldmUgdGhlIGRhdGUocykgZGlyZWN0bHkuICovXG5cdF9nZXREYXRlOiBmdW5jdGlvbiggaW5zdCApIHtcblx0XHR2YXIgc3RhcnREYXRlID0gKCAhaW5zdC5jdXJyZW50WWVhciB8fCAoIGluc3QuaW5wdXQgJiYgaW5zdC5pbnB1dC52YWwoKSA9PT0gXCJcIiApID8gbnVsbCA6XG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3IERhdGUoXG5cdFx0XHRpbnN0LmN1cnJlbnRZZWFyLCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50RGF5ICkgKSApO1xuXHRcdFx0cmV0dXJuIHN0YXJ0RGF0ZTtcblx0fSxcblxuXHQvKiBBdHRhY2ggdGhlIG9ueHh4IGhhbmRsZXJzLiAgVGhlc2UgYXJlIGRlY2xhcmVkIHN0YXRpY2FsbHkgc29cblx0ICogdGhleSB3b3JrIHdpdGggc3RhdGljIGNvZGUgdHJhbnNmb3JtZXJzIGxpa2UgQ2FqYS5cblx0ICovXG5cdF9hdHRhY2hIYW5kbGVyczogZnVuY3Rpb24oIGluc3QgKSB7XG5cdFx0dmFyIHN0ZXBNb250aHMgPSB0aGlzLl9nZXQoIGluc3QsIFwic3RlcE1vbnRoc1wiICksXG5cdFx0XHRpZCA9IFwiI1wiICsgaW5zdC5pZC5yZXBsYWNlKCAvXFxcXFxcXFwvZywgXCJcXFxcXCIgKTtcblx0XHRpbnN0LmRwRGl2LmZpbmQoIFwiW2RhdGEtaGFuZGxlcl1cIiApLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlciA9IHtcblx0XHRcdFx0cHJldjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKCBpZCwgLXN0ZXBNb250aHMsIFwiTVwiICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZSggaWQsICtzdGVwTW9udGhzLCBcIk1cIiApO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRvZGF5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2dvdG9Ub2RheSggaWQgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2VsZWN0RGF5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3NlbGVjdERheSggaWQsICt0aGlzLmdldEF0dHJpYnV0ZSggXCJkYXRhLW1vbnRoXCIgKSwgK3RoaXMuZ2V0QXR0cmlidXRlKCBcImRhdGEteWVhclwiICksIHRoaXMgKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNlbGVjdE1vbnRoOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3NlbGVjdE1vbnRoWWVhciggaWQsIHRoaXMsIFwiTVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3RZZWFyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3NlbGVjdE1vbnRoWWVhciggaWQsIHRoaXMsIFwiWVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0JCggdGhpcyApLm9uKCB0aGlzLmdldEF0dHJpYnV0ZSggXCJkYXRhLWV2ZW50XCIgKSwgaGFuZGxlclsgdGhpcy5nZXRBdHRyaWJ1dGUoIFwiZGF0YS1oYW5kbGVyXCIgKSBdICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdC8qIEdlbmVyYXRlIHRoZSBIVE1MIGZvciB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZGF0ZSBwaWNrZXIuICovXG5cdF9nZW5lcmF0ZUhUTUw6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdHZhciBtYXhEcmF3LCBwcmV2VGV4dCwgcHJldiwgbmV4dFRleHQsIG5leHQsIGN1cnJlbnRUZXh0LCBnb3RvRGF0ZSxcblx0XHRcdGNvbnRyb2xzLCBidXR0b25QYW5lbCwgZmlyc3REYXksIHNob3dXZWVrLCBkYXlOYW1lcywgZGF5TmFtZXNNaW4sXG5cdFx0XHRtb250aE5hbWVzLCBtb250aE5hbWVzU2hvcnQsIGJlZm9yZVNob3dEYXksIHNob3dPdGhlck1vbnRocyxcblx0XHRcdHNlbGVjdE90aGVyTW9udGhzLCBkZWZhdWx0RGF0ZSwgaHRtbCwgZG93LCByb3csIGdyb3VwLCBjb2wsIHNlbGVjdGVkRGF0ZSxcblx0XHRcdGNvcm5lckNsYXNzLCBjYWxlbmRlciwgdGhlYWQsIGRheSwgZGF5c0luTW9udGgsIGxlYWREYXlzLCBjdXJSb3dzLCBudW1Sb3dzLFxuXHRcdFx0cHJpbnREYXRlLCBkUm93LCB0Ym9keSwgZGF5U2V0dGluZ3MsIG90aGVyTW9udGgsIHVuc2VsZWN0YWJsZSxcblx0XHRcdHRlbXBEYXRlID0gbmV3IERhdGUoKSxcblx0XHRcdHRvZGF5ID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoXG5cdFx0XHRcdG5ldyBEYXRlKCB0ZW1wRGF0ZS5nZXRGdWxsWWVhcigpLCB0ZW1wRGF0ZS5nZXRNb250aCgpLCB0ZW1wRGF0ZS5nZXREYXRlKCkgKSApLCAvLyBjbGVhciB0aW1lXG5cdFx0XHRpc1JUTCA9IHRoaXMuX2dldCggaW5zdCwgXCJpc1JUTFwiICksXG5cdFx0XHRzaG93QnV0dG9uUGFuZWwgPSB0aGlzLl9nZXQoIGluc3QsIFwic2hvd0J1dHRvblBhbmVsXCIgKSxcblx0XHRcdGhpZGVJZk5vUHJldk5leHQgPSB0aGlzLl9nZXQoIGluc3QsIFwiaGlkZUlmTm9QcmV2TmV4dFwiICksXG5cdFx0XHRuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID0gdGhpcy5fZ2V0KCBpbnN0LCBcIm5hdmlnYXRpb25Bc0RhdGVGb3JtYXRcIiApLFxuXHRcdFx0bnVtTW9udGhzID0gdGhpcy5fZ2V0TnVtYmVyT2ZNb250aHMoIGluc3QgKSxcblx0XHRcdHNob3dDdXJyZW50QXRQb3MgPSB0aGlzLl9nZXQoIGluc3QsIFwic2hvd0N1cnJlbnRBdFBvc1wiICksXG5cdFx0XHRzdGVwTW9udGhzID0gdGhpcy5fZ2V0KCBpbnN0LCBcInN0ZXBNb250aHNcIiApLFxuXHRcdFx0aXNNdWx0aU1vbnRoID0gKCBudW1Nb250aHNbIDAgXSAhPT0gMSB8fCBudW1Nb250aHNbIDEgXSAhPT0gMSApLFxuXHRcdFx0Y3VycmVudERhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggKCAhaW5zdC5jdXJyZW50RGF5ID8gbmV3IERhdGUoIDk5OTksIDksIDkgKSA6XG5cdFx0XHRcdG5ldyBEYXRlKCBpbnN0LmN1cnJlbnRZZWFyLCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50RGF5ICkgKSApLFxuXHRcdFx0bWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoIGluc3QsIFwibWluXCIgKSxcblx0XHRcdG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKCBpbnN0LCBcIm1heFwiICksXG5cdFx0XHRkcmF3TW9udGggPSBpbnN0LmRyYXdNb250aCAtIHNob3dDdXJyZW50QXRQb3MsXG5cdFx0XHRkcmF3WWVhciA9IGluc3QuZHJhd1llYXI7XG5cblx0XHRpZiAoIGRyYXdNb250aCA8IDAgKSB7XG5cdFx0XHRkcmF3TW9udGggKz0gMTI7XG5cdFx0XHRkcmF3WWVhci0tO1xuXHRcdH1cblx0XHRpZiAoIG1heERhdGUgKSB7XG5cdFx0XHRtYXhEcmF3ID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoIG5ldyBEYXRlKCBtYXhEYXRlLmdldEZ1bGxZZWFyKCksXG5cdFx0XHRcdG1heERhdGUuZ2V0TW9udGgoKSAtICggbnVtTW9udGhzWyAwIF0gKiBudW1Nb250aHNbIDEgXSApICsgMSwgbWF4RGF0ZS5nZXREYXRlKCkgKSApO1xuXHRcdFx0bWF4RHJhdyA9ICggbWluRGF0ZSAmJiBtYXhEcmF3IDwgbWluRGF0ZSA/IG1pbkRhdGUgOiBtYXhEcmF3ICk7XG5cdFx0XHR3aGlsZSAoIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KCBuZXcgRGF0ZSggZHJhd1llYXIsIGRyYXdNb250aCwgMSApICkgPiBtYXhEcmF3ICkge1xuXHRcdFx0XHRkcmF3TW9udGgtLTtcblx0XHRcdFx0aWYgKCBkcmF3TW9udGggPCAwICkge1xuXHRcdFx0XHRcdGRyYXdNb250aCA9IDExO1xuXHRcdFx0XHRcdGRyYXdZZWFyLS07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aW5zdC5kcmF3TW9udGggPSBkcmF3TW9udGg7XG5cdFx0aW5zdC5kcmF3WWVhciA9IGRyYXdZZWFyO1xuXG5cdFx0cHJldlRleHQgPSB0aGlzLl9nZXQoIGluc3QsIFwicHJldlRleHRcIiApO1xuXHRcdHByZXZUZXh0ID0gKCAhbmF2aWdhdGlvbkFzRGF0ZUZvcm1hdCA/IHByZXZUZXh0IDogdGhpcy5mb3JtYXREYXRlKCBwcmV2VGV4dCxcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KCBuZXcgRGF0ZSggZHJhd1llYXIsIGRyYXdNb250aCAtIHN0ZXBNb250aHMsIDEgKSApLFxuXHRcdFx0dGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKCBpbnN0ICkgKSApO1xuXG5cdFx0cHJldiA9ICggdGhpcy5fY2FuQWRqdXN0TW9udGgoIGluc3QsIC0xLCBkcmF3WWVhciwgZHJhd01vbnRoICkgP1xuXHRcdFx0XCI8YSBjbGFzcz0ndWktZGF0ZXBpY2tlci1wcmV2IHVpLWNvcm5lci1hbGwnIGRhdGEtaGFuZGxlcj0ncHJldicgZGF0YS1ldmVudD0nY2xpY2snXCIgK1xuXHRcdFx0XCIgdGl0bGU9J1wiICsgcHJldlRleHQgKyBcIic+PHNwYW4gY2xhc3M9J3VpLWljb24gdWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtXCIgKyAoIGlzUlRMID8gXCJlXCIgOiBcIndcIiApICsgXCInPlwiICsgcHJldlRleHQgKyBcIjwvc3Bhbj48L2E+XCIgOlxuXHRcdFx0KCBoaWRlSWZOb1ByZXZOZXh0ID8gXCJcIiA6IFwiPGEgY2xhc3M9J3VpLWRhdGVwaWNrZXItcHJldiB1aS1jb3JuZXItYWxsIHVpLXN0YXRlLWRpc2FibGVkJyB0aXRsZT0nXCIgKyBwcmV2VGV4dCArIFwiJz48c3BhbiBjbGFzcz0ndWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS1cIiArICggaXNSVEwgPyBcImVcIiA6IFwid1wiICkgKyBcIic+XCIgKyBwcmV2VGV4dCArIFwiPC9zcGFuPjwvYT5cIiApICk7XG5cblx0XHRuZXh0VGV4dCA9IHRoaXMuX2dldCggaW5zdCwgXCJuZXh0VGV4dFwiICk7XG5cdFx0bmV4dFRleHQgPSAoICFuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID8gbmV4dFRleHQgOiB0aGlzLmZvcm1hdERhdGUoIG5leHRUZXh0LFxuXHRcdFx0dGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoIG5ldyBEYXRlKCBkcmF3WWVhciwgZHJhd01vbnRoICsgc3RlcE1vbnRocywgMSApICksXG5cdFx0XHR0aGlzLl9nZXRGb3JtYXRDb25maWcoIGluc3QgKSApICk7XG5cblx0XHRuZXh0ID0gKCB0aGlzLl9jYW5BZGp1c3RNb250aCggaW5zdCwgKzEsIGRyYXdZZWFyLCBkcmF3TW9udGggKSA/XG5cdFx0XHRcIjxhIGNsYXNzPSd1aS1kYXRlcGlja2VyLW5leHQgdWktY29ybmVyLWFsbCcgZGF0YS1oYW5kbGVyPSduZXh0JyBkYXRhLWV2ZW50PSdjbGljaydcIiArXG5cdFx0XHRcIiB0aXRsZT0nXCIgKyBuZXh0VGV4dCArIFwiJz48c3BhbiBjbGFzcz0ndWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS1cIiArICggaXNSVEwgPyBcIndcIiA6IFwiZVwiICkgKyBcIic+XCIgKyBuZXh0VGV4dCArIFwiPC9zcGFuPjwvYT5cIiA6XG5cdFx0XHQoIGhpZGVJZk5vUHJldk5leHQgPyBcIlwiIDogXCI8YSBjbGFzcz0ndWktZGF0ZXBpY2tlci1uZXh0IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGlzYWJsZWQnIHRpdGxlPSdcIiArIG5leHRUZXh0ICsgXCInPjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLVwiICsgKCBpc1JUTCA/IFwid1wiIDogXCJlXCIgKSArIFwiJz5cIiArIG5leHRUZXh0ICsgXCI8L3NwYW4+PC9hPlwiICkgKTtcblxuXHRcdGN1cnJlbnRUZXh0ID0gdGhpcy5fZ2V0KCBpbnN0LCBcImN1cnJlbnRUZXh0XCIgKTtcblx0XHRnb3RvRGF0ZSA9ICggdGhpcy5fZ2V0KCBpbnN0LCBcImdvdG9DdXJyZW50XCIgKSAmJiBpbnN0LmN1cnJlbnREYXkgPyBjdXJyZW50RGF0ZSA6IHRvZGF5ICk7XG5cdFx0Y3VycmVudFRleHQgPSAoICFuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID8gY3VycmVudFRleHQgOlxuXHRcdFx0dGhpcy5mb3JtYXREYXRlKCBjdXJyZW50VGV4dCwgZ290b0RhdGUsIHRoaXMuX2dldEZvcm1hdENvbmZpZyggaW5zdCApICkgKTtcblxuXHRcdGNvbnRyb2xzID0gKCAhaW5zdC5pbmxpbmUgPyBcIjxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0ndWktZGF0ZXBpY2tlci1jbG9zZSB1aS1zdGF0ZS1kZWZhdWx0IHVpLXByaW9yaXR5LXByaW1hcnkgdWktY29ybmVyLWFsbCcgZGF0YS1oYW5kbGVyPSdoaWRlJyBkYXRhLWV2ZW50PSdjbGljayc+XCIgK1xuXHRcdFx0dGhpcy5fZ2V0KCBpbnN0LCBcImNsb3NlVGV4dFwiICkgKyBcIjwvYnV0dG9uPlwiIDogXCJcIiApO1xuXG5cdFx0YnV0dG9uUGFuZWwgPSAoIHNob3dCdXR0b25QYW5lbCApID8gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLWJ1dHRvbnBhbmUgdWktd2lkZ2V0LWNvbnRlbnQnPlwiICsgKCBpc1JUTCA/IGNvbnRyb2xzIDogXCJcIiApICtcblx0XHRcdCggdGhpcy5faXNJblJhbmdlKCBpbnN0LCBnb3RvRGF0ZSApID8gXCI8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J3VpLWRhdGVwaWNrZXItY3VycmVudCB1aS1zdGF0ZS1kZWZhdWx0IHVpLXByaW9yaXR5LXNlY29uZGFyeSB1aS1jb3JuZXItYWxsJyBkYXRhLWhhbmRsZXI9J3RvZGF5JyBkYXRhLWV2ZW50PSdjbGljaydcIiArXG5cdFx0XHRcIj5cIiArIGN1cnJlbnRUZXh0ICsgXCI8L2J1dHRvbj5cIiA6IFwiXCIgKSArICggaXNSVEwgPyBcIlwiIDogY29udHJvbHMgKSArIFwiPC9kaXY+XCIgOiBcIlwiO1xuXG5cdFx0Zmlyc3REYXkgPSBwYXJzZUludCggdGhpcy5fZ2V0KCBpbnN0LCBcImZpcnN0RGF5XCIgKSwgMTAgKTtcblx0XHRmaXJzdERheSA9ICggaXNOYU4oIGZpcnN0RGF5ICkgPyAwIDogZmlyc3REYXkgKTtcblxuXHRcdHNob3dXZWVrID0gdGhpcy5fZ2V0KCBpbnN0LCBcInNob3dXZWVrXCIgKTtcblx0XHRkYXlOYW1lcyA9IHRoaXMuX2dldCggaW5zdCwgXCJkYXlOYW1lc1wiICk7XG5cdFx0ZGF5TmFtZXNNaW4gPSB0aGlzLl9nZXQoIGluc3QsIFwiZGF5TmFtZXNNaW5cIiApO1xuXHRcdG1vbnRoTmFtZXMgPSB0aGlzLl9nZXQoIGluc3QsIFwibW9udGhOYW1lc1wiICk7XG5cdFx0bW9udGhOYW1lc1Nob3J0ID0gdGhpcy5fZ2V0KCBpbnN0LCBcIm1vbnRoTmFtZXNTaG9ydFwiICk7XG5cdFx0YmVmb3JlU2hvd0RheSA9IHRoaXMuX2dldCggaW5zdCwgXCJiZWZvcmVTaG93RGF5XCIgKTtcblx0XHRzaG93T3RoZXJNb250aHMgPSB0aGlzLl9nZXQoIGluc3QsIFwic2hvd090aGVyTW9udGhzXCIgKTtcblx0XHRzZWxlY3RPdGhlck1vbnRocyA9IHRoaXMuX2dldCggaW5zdCwgXCJzZWxlY3RPdGhlck1vbnRoc1wiICk7XG5cdFx0ZGVmYXVsdERhdGUgPSB0aGlzLl9nZXREZWZhdWx0RGF0ZSggaW5zdCApO1xuXHRcdGh0bWwgPSBcIlwiO1xuXG5cdFx0Zm9yICggcm93ID0gMDsgcm93IDwgbnVtTW9udGhzWyAwIF07IHJvdysrICkge1xuXHRcdFx0Z3JvdXAgPSBcIlwiO1xuXHRcdFx0dGhpcy5tYXhSb3dzID0gNDtcblx0XHRcdGZvciAoIGNvbCA9IDA7IGNvbCA8IG51bU1vbnRoc1sgMSBdOyBjb2wrKyApIHtcblx0XHRcdFx0c2VsZWN0ZWREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoIG5ldyBEYXRlKCBkcmF3WWVhciwgZHJhd01vbnRoLCBpbnN0LnNlbGVjdGVkRGF5ICkgKTtcblx0XHRcdFx0Y29ybmVyQ2xhc3MgPSBcIiB1aS1jb3JuZXItYWxsXCI7XG5cdFx0XHRcdGNhbGVuZGVyID0gXCJcIjtcblx0XHRcdFx0aWYgKCBpc011bHRpTW9udGggKSB7XG5cdFx0XHRcdFx0Y2FsZW5kZXIgKz0gXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLWdyb3VwXCI7XG5cdFx0XHRcdFx0aWYgKCBudW1Nb250aHNbIDEgXSA+IDEgKSB7XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKCBjb2wgKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgMDogY2FsZW5kZXIgKz0gXCIgdWktZGF0ZXBpY2tlci1ncm91cC1maXJzdFwiO1xuXHRcdFx0XHRcdFx0XHRcdGNvcm5lckNsYXNzID0gXCIgdWktY29ybmVyLVwiICsgKCBpc1JUTCA/IFwicmlnaHRcIiA6IFwibGVmdFwiICk7IGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIG51bU1vbnRoc1sgMSBdIC0gMTogY2FsZW5kZXIgKz0gXCIgdWktZGF0ZXBpY2tlci1ncm91cC1sYXN0XCI7XG5cdFx0XHRcdFx0XHRcdFx0Y29ybmVyQ2xhc3MgPSBcIiB1aS1jb3JuZXItXCIgKyAoIGlzUlRMID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIgKTsgYnJlYWs7XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHQ6IGNhbGVuZGVyICs9IFwiIHVpLWRhdGVwaWNrZXItZ3JvdXAtbWlkZGxlXCI7IGNvcm5lckNsYXNzID0gXCJcIjsgYnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhbGVuZGVyICs9IFwiJz5cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxlbmRlciArPSBcIjxkaXYgY2xhc3M9J3VpLWRhdGVwaWNrZXItaGVhZGVyIHVpLXdpZGdldC1oZWFkZXIgdWktaGVscGVyLWNsZWFyZml4XCIgKyBjb3JuZXJDbGFzcyArIFwiJz5cIiArXG5cdFx0XHRcdFx0KCAvYWxsfGxlZnQvLnRlc3QoIGNvcm5lckNsYXNzICkgJiYgcm93ID09PSAwID8gKCBpc1JUTCA/IG5leHQgOiBwcmV2ICkgOiBcIlwiICkgK1xuXHRcdFx0XHRcdCggL2FsbHxyaWdodC8udGVzdCggY29ybmVyQ2xhc3MgKSAmJiByb3cgPT09IDAgPyAoIGlzUlRMID8gcHJldiA6IG5leHQgKSA6IFwiXCIgKSArXG5cdFx0XHRcdFx0dGhpcy5fZ2VuZXJhdGVNb250aFllYXJIZWFkZXIoIGluc3QsIGRyYXdNb250aCwgZHJhd1llYXIsIG1pbkRhdGUsIG1heERhdGUsXG5cdFx0XHRcdFx0cm93ID4gMCB8fCBjb2wgPiAwLCBtb250aE5hbWVzLCBtb250aE5hbWVzU2hvcnQgKSArIC8vIGRyYXcgbW9udGggaGVhZGVyc1xuXHRcdFx0XHRcdFwiPC9kaXY+PHRhYmxlIGNsYXNzPSd1aS1kYXRlcGlja2VyLWNhbGVuZGFyJz48dGhlYWQ+XCIgK1xuXHRcdFx0XHRcdFwiPHRyPlwiO1xuXHRcdFx0XHR0aGVhZCA9ICggc2hvd1dlZWsgPyBcIjx0aCBjbGFzcz0ndWktZGF0ZXBpY2tlci13ZWVrLWNvbCc+XCIgKyB0aGlzLl9nZXQoIGluc3QsIFwid2Vla0hlYWRlclwiICkgKyBcIjwvdGg+XCIgOiBcIlwiICk7XG5cdFx0XHRcdGZvciAoIGRvdyA9IDA7IGRvdyA8IDc7IGRvdysrICkgeyAvLyBkYXlzIG9mIHRoZSB3ZWVrXG5cdFx0XHRcdFx0ZGF5ID0gKCBkb3cgKyBmaXJzdERheSApICUgNztcblx0XHRcdFx0XHR0aGVhZCArPSBcIjx0aCBzY29wZT0nY29sJ1wiICsgKCAoIGRvdyArIGZpcnN0RGF5ICsgNiApICUgNyA+PSA1ID8gXCIgY2xhc3M9J3VpLWRhdGVwaWNrZXItd2Vlay1lbmQnXCIgOiBcIlwiICkgKyBcIj5cIiArXG5cdFx0XHRcdFx0XHRcIjxzcGFuIHRpdGxlPSdcIiArIGRheU5hbWVzWyBkYXkgXSArIFwiJz5cIiArIGRheU5hbWVzTWluWyBkYXkgXSArIFwiPC9zcGFuPjwvdGg+XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsZW5kZXIgKz0gdGhlYWQgKyBcIjwvdHI+PC90aGVhZD48dGJvZHk+XCI7XG5cdFx0XHRcdGRheXNJbk1vbnRoID0gdGhpcy5fZ2V0RGF5c0luTW9udGgoIGRyYXdZZWFyLCBkcmF3TW9udGggKTtcblx0XHRcdFx0aWYgKCBkcmF3WWVhciA9PT0gaW5zdC5zZWxlY3RlZFllYXIgJiYgZHJhd01vbnRoID09PSBpbnN0LnNlbGVjdGVkTW9udGggKSB7XG5cdFx0XHRcdFx0aW5zdC5zZWxlY3RlZERheSA9IE1hdGgubWluKCBpbnN0LnNlbGVjdGVkRGF5LCBkYXlzSW5Nb250aCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxlYWREYXlzID0gKCB0aGlzLl9nZXRGaXJzdERheU9mTW9udGgoIGRyYXdZZWFyLCBkcmF3TW9udGggKSAtIGZpcnN0RGF5ICsgNyApICUgNztcblx0XHRcdFx0Y3VyUm93cyA9IE1hdGguY2VpbCggKCBsZWFkRGF5cyArIGRheXNJbk1vbnRoICkgLyA3ICk7IC8vIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHJvd3MgdG8gZ2VuZXJhdGVcblx0XHRcdFx0bnVtUm93cyA9ICggaXNNdWx0aU1vbnRoID8gdGhpcy5tYXhSb3dzID4gY3VyUm93cyA/IHRoaXMubWF4Um93cyA6IGN1clJvd3MgOiBjdXJSb3dzICk7IC8vSWYgbXVsdGlwbGUgbW9udGhzLCB1c2UgdGhlIGhpZ2hlciBudW1iZXIgb2Ygcm93cyAoc2VlICM3MDQzKVxuXHRcdFx0XHR0aGlzLm1heFJvd3MgPSBudW1Sb3dzO1xuXHRcdFx0XHRwcmludERhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3IERhdGUoIGRyYXdZZWFyLCBkcmF3TW9udGgsIDEgLSBsZWFkRGF5cyApICk7XG5cdFx0XHRcdGZvciAoIGRSb3cgPSAwOyBkUm93IDwgbnVtUm93czsgZFJvdysrICkgeyAvLyBjcmVhdGUgZGF0ZSBwaWNrZXIgcm93c1xuXHRcdFx0XHRcdGNhbGVuZGVyICs9IFwiPHRyPlwiO1xuXHRcdFx0XHRcdHRib2R5ID0gKCAhc2hvd1dlZWsgPyBcIlwiIDogXCI8dGQgY2xhc3M9J3VpLWRhdGVwaWNrZXItd2Vlay1jb2wnPlwiICtcblx0XHRcdFx0XHRcdHRoaXMuX2dldCggaW5zdCwgXCJjYWxjdWxhdGVXZWVrXCIgKSggcHJpbnREYXRlICkgKyBcIjwvdGQ+XCIgKTtcblx0XHRcdFx0XHRmb3IgKCBkb3cgPSAwOyBkb3cgPCA3OyBkb3crKyApIHsgLy8gY3JlYXRlIGRhdGUgcGlja2VyIGRheXNcblx0XHRcdFx0XHRcdGRheVNldHRpbmdzID0gKCBiZWZvcmVTaG93RGF5ID9cblx0XHRcdFx0XHRcdFx0YmVmb3JlU2hvd0RheS5hcHBseSggKCBpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFsgMCBdIDogbnVsbCApLCBbIHByaW50RGF0ZSBdICkgOiBbIHRydWUsIFwiXCIgXSApO1xuXHRcdFx0XHRcdFx0b3RoZXJNb250aCA9ICggcHJpbnREYXRlLmdldE1vbnRoKCkgIT09IGRyYXdNb250aCApO1xuXHRcdFx0XHRcdFx0dW5zZWxlY3RhYmxlID0gKCBvdGhlck1vbnRoICYmICFzZWxlY3RPdGhlck1vbnRocyApIHx8ICFkYXlTZXR0aW5nc1sgMCBdIHx8XG5cdFx0XHRcdFx0XHRcdCggbWluRGF0ZSAmJiBwcmludERhdGUgPCBtaW5EYXRlICkgfHwgKCBtYXhEYXRlICYmIHByaW50RGF0ZSA+IG1heERhdGUgKTtcblx0XHRcdFx0XHRcdHRib2R5ICs9IFwiPHRkIGNsYXNzPSdcIiArXG5cdFx0XHRcdFx0XHRcdCggKCBkb3cgKyBmaXJzdERheSArIDYgKSAlIDcgPj0gNSA/IFwiIHVpLWRhdGVwaWNrZXItd2Vlay1lbmRcIiA6IFwiXCIgKSArIC8vIGhpZ2hsaWdodCB3ZWVrZW5kc1xuXHRcdFx0XHRcdFx0XHQoIG90aGVyTW9udGggPyBcIiB1aS1kYXRlcGlja2VyLW90aGVyLW1vbnRoXCIgOiBcIlwiICkgKyAvLyBoaWdobGlnaHQgZGF5cyBmcm9tIG90aGVyIG1vbnRoc1xuXHRcdFx0XHRcdFx0XHQoICggcHJpbnREYXRlLmdldFRpbWUoKSA9PT0gc2VsZWN0ZWREYXRlLmdldFRpbWUoKSAmJiBkcmF3TW9udGggPT09IGluc3Quc2VsZWN0ZWRNb250aCAmJiBpbnN0Ll9rZXlFdmVudCApIHx8IC8vIHVzZXIgcHJlc3NlZCBrZXlcblx0XHRcdFx0XHRcdFx0KCBkZWZhdWx0RGF0ZS5nZXRUaW1lKCkgPT09IHByaW50RGF0ZS5nZXRUaW1lKCkgJiYgZGVmYXVsdERhdGUuZ2V0VGltZSgpID09PSBzZWxlY3RlZERhdGUuZ2V0VGltZSgpICkgP1xuXG5cdFx0XHRcdFx0XHRcdC8vIG9yIGRlZmF1bHREYXRlIGlzIGN1cnJlbnQgcHJpbnRlZERhdGUgYW5kIGRlZmF1bHREYXRlIGlzIHNlbGVjdGVkRGF0ZVxuXHRcdFx0XHRcdFx0XHRcIiBcIiArIHRoaXMuX2RheU92ZXJDbGFzcyA6IFwiXCIgKSArIC8vIGhpZ2hsaWdodCBzZWxlY3RlZCBkYXlcblx0XHRcdFx0XHRcdFx0KCB1bnNlbGVjdGFibGUgPyBcIiBcIiArIHRoaXMuX3Vuc2VsZWN0YWJsZUNsYXNzICsgXCIgdWktc3RhdGUtZGlzYWJsZWRcIiA6IFwiXCIgKSArICAvLyBoaWdobGlnaHQgdW5zZWxlY3RhYmxlIGRheXNcblx0XHRcdFx0XHRcdFx0KCBvdGhlck1vbnRoICYmICFzaG93T3RoZXJNb250aHMgPyBcIlwiIDogXCIgXCIgKyBkYXlTZXR0aW5nc1sgMSBdICsgLy8gaGlnaGxpZ2h0IGN1c3RvbSBkYXRlc1xuXHRcdFx0XHRcdFx0XHQoIHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IGN1cnJlbnREYXRlLmdldFRpbWUoKSA/IFwiIFwiICsgdGhpcy5fY3VycmVudENsYXNzIDogXCJcIiApICsgLy8gaGlnaGxpZ2h0IHNlbGVjdGVkIGRheVxuXHRcdFx0XHRcdFx0XHQoIHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IHRvZGF5LmdldFRpbWUoKSA/IFwiIHVpLWRhdGVwaWNrZXItdG9kYXlcIiA6IFwiXCIgKSApICsgXCInXCIgKyAvLyBoaWdobGlnaHQgdG9kYXkgKGlmIGRpZmZlcmVudClcblx0XHRcdFx0XHRcdFx0KCAoICFvdGhlck1vbnRoIHx8IHNob3dPdGhlck1vbnRocyApICYmIGRheVNldHRpbmdzWyAyIF0gPyBcIiB0aXRsZT0nXCIgKyBkYXlTZXR0aW5nc1sgMiBdLnJlcGxhY2UoIC8nL2csIFwiJiMzOTtcIiApICsgXCInXCIgOiBcIlwiICkgKyAvLyBjZWxsIHRpdGxlXG5cdFx0XHRcdFx0XHRcdCggdW5zZWxlY3RhYmxlID8gXCJcIiA6IFwiIGRhdGEtaGFuZGxlcj0nc2VsZWN0RGF5JyBkYXRhLWV2ZW50PSdjbGljaycgZGF0YS1tb250aD0nXCIgKyBwcmludERhdGUuZ2V0TW9udGgoKSArIFwiJyBkYXRhLXllYXI9J1wiICsgcHJpbnREYXRlLmdldEZ1bGxZZWFyKCkgKyBcIidcIiApICsgXCI+XCIgKyAvLyBhY3Rpb25zXG5cdFx0XHRcdFx0XHRcdCggb3RoZXJNb250aCAmJiAhc2hvd090aGVyTW9udGhzID8gXCImI3hhMDtcIiA6IC8vIGRpc3BsYXkgZm9yIG90aGVyIG1vbnRoc1xuXHRcdFx0XHRcdFx0XHQoIHVuc2VsZWN0YWJsZSA/IFwiPHNwYW4gY2xhc3M9J3VpLXN0YXRlLWRlZmF1bHQnPlwiICsgcHJpbnREYXRlLmdldERhdGUoKSArIFwiPC9zcGFuPlwiIDogXCI8YSBjbGFzcz0ndWktc3RhdGUtZGVmYXVsdFwiICtcblx0XHRcdFx0XHRcdFx0KCBwcmludERhdGUuZ2V0VGltZSgpID09PSB0b2RheS5nZXRUaW1lKCkgPyBcIiB1aS1zdGF0ZS1oaWdobGlnaHRcIiA6IFwiXCIgKSArXG5cdFx0XHRcdFx0XHRcdCggcHJpbnREYXRlLmdldFRpbWUoKSA9PT0gY3VycmVudERhdGUuZ2V0VGltZSgpID8gXCIgdWktc3RhdGUtYWN0aXZlXCIgOiBcIlwiICkgKyAvLyBoaWdobGlnaHQgc2VsZWN0ZWQgZGF5XG5cdFx0XHRcdFx0XHRcdCggb3RoZXJNb250aCA/IFwiIHVpLXByaW9yaXR5LXNlY29uZGFyeVwiIDogXCJcIiApICsgLy8gZGlzdGluZ3Vpc2ggZGF0ZXMgZnJvbSBvdGhlciBtb250aHNcblx0XHRcdFx0XHRcdFx0XCInIGhyZWY9JyMnPlwiICsgcHJpbnREYXRlLmdldERhdGUoKSArIFwiPC9hPlwiICkgKSArIFwiPC90ZD5cIjsgLy8gZGlzcGxheSBzZWxlY3RhYmxlIGRhdGVcblx0XHRcdFx0XHRcdHByaW50RGF0ZS5zZXREYXRlKCBwcmludERhdGUuZ2V0RGF0ZSgpICsgMSApO1xuXHRcdFx0XHRcdFx0cHJpbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoIHByaW50RGF0ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYWxlbmRlciArPSB0Ym9keSArIFwiPC90cj5cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRkcmF3TW9udGgrKztcblx0XHRcdFx0aWYgKCBkcmF3TW9udGggPiAxMSApIHtcblx0XHRcdFx0XHRkcmF3TW9udGggPSAwO1xuXHRcdFx0XHRcdGRyYXdZZWFyKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsZW5kZXIgKz0gXCI8L3Rib2R5PjwvdGFibGU+XCIgKyAoIGlzTXVsdGlNb250aCA/IFwiPC9kaXY+XCIgK1xuXHRcdFx0XHRcdFx0XHQoICggbnVtTW9udGhzWyAwIF0gPiAwICYmIGNvbCA9PT0gbnVtTW9udGhzWyAxIF0gLSAxICkgPyBcIjxkaXYgY2xhc3M9J3VpLWRhdGVwaWNrZXItcm93LWJyZWFrJz48L2Rpdj5cIiA6IFwiXCIgKSA6IFwiXCIgKTtcblx0XHRcdFx0Z3JvdXAgKz0gY2FsZW5kZXI7XG5cdFx0XHR9XG5cdFx0XHRodG1sICs9IGdyb3VwO1xuXHRcdH1cblx0XHRodG1sICs9IGJ1dHRvblBhbmVsO1xuXHRcdGluc3QuX2tleUV2ZW50ID0gZmFsc2U7XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblx0LyogR2VuZXJhdGUgdGhlIG1vbnRoIGFuZCB5ZWFyIGhlYWRlci4gKi9cblx0X2dlbmVyYXRlTW9udGhZZWFySGVhZGVyOiBmdW5jdGlvbiggaW5zdCwgZHJhd01vbnRoLCBkcmF3WWVhciwgbWluRGF0ZSwgbWF4RGF0ZSxcblx0XHRcdHNlY29uZGFyeSwgbW9udGhOYW1lcywgbW9udGhOYW1lc1Nob3J0ICkge1xuXG5cdFx0dmFyIGluTWluWWVhciwgaW5NYXhZZWFyLCBtb250aCwgeWVhcnMsIHRoaXNZZWFyLCBkZXRlcm1pbmVZZWFyLCB5ZWFyLCBlbmRZZWFyLFxuXHRcdFx0Y2hhbmdlTW9udGggPSB0aGlzLl9nZXQoIGluc3QsIFwiY2hhbmdlTW9udGhcIiApLFxuXHRcdFx0Y2hhbmdlWWVhciA9IHRoaXMuX2dldCggaW5zdCwgXCJjaGFuZ2VZZWFyXCIgKSxcblx0XHRcdHNob3dNb250aEFmdGVyWWVhciA9IHRoaXMuX2dldCggaW5zdCwgXCJzaG93TW9udGhBZnRlclllYXJcIiApLFxuXHRcdFx0aHRtbCA9IFwiPGRpdiBjbGFzcz0ndWktZGF0ZXBpY2tlci10aXRsZSc+XCIsXG5cdFx0XHRtb250aEh0bWwgPSBcIlwiO1xuXG5cdFx0Ly8gTW9udGggc2VsZWN0aW9uXG5cdFx0aWYgKCBzZWNvbmRhcnkgfHwgIWNoYW5nZU1vbnRoICkge1xuXHRcdFx0bW9udGhIdG1sICs9IFwiPHNwYW4gY2xhc3M9J3VpLWRhdGVwaWNrZXItbW9udGgnPlwiICsgbW9udGhOYW1lc1sgZHJhd01vbnRoIF0gKyBcIjwvc3Bhbj5cIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5NaW5ZZWFyID0gKCBtaW5EYXRlICYmIG1pbkRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gZHJhd1llYXIgKTtcblx0XHRcdGluTWF4WWVhciA9ICggbWF4RGF0ZSAmJiBtYXhEYXRlLmdldEZ1bGxZZWFyKCkgPT09IGRyYXdZZWFyICk7XG5cdFx0XHRtb250aEh0bWwgKz0gXCI8c2VsZWN0IGNsYXNzPSd1aS1kYXRlcGlja2VyLW1vbnRoJyBkYXRhLWhhbmRsZXI9J3NlbGVjdE1vbnRoJyBkYXRhLWV2ZW50PSdjaGFuZ2UnPlwiO1xuXHRcdFx0Zm9yICggbW9udGggPSAwOyBtb250aCA8IDEyOyBtb250aCsrICkge1xuXHRcdFx0XHRpZiAoICggIWluTWluWWVhciB8fCBtb250aCA+PSBtaW5EYXRlLmdldE1vbnRoKCkgKSAmJiAoICFpbk1heFllYXIgfHwgbW9udGggPD0gbWF4RGF0ZS5nZXRNb250aCgpICkgKSB7XG5cdFx0XHRcdFx0bW9udGhIdG1sICs9IFwiPG9wdGlvbiB2YWx1ZT0nXCIgKyBtb250aCArIFwiJ1wiICtcblx0XHRcdFx0XHRcdCggbW9udGggPT09IGRyYXdNb250aCA/IFwiIHNlbGVjdGVkPSdzZWxlY3RlZCdcIiA6IFwiXCIgKSArXG5cdFx0XHRcdFx0XHRcIj5cIiArIG1vbnRoTmFtZXNTaG9ydFsgbW9udGggXSArIFwiPC9vcHRpb24+XCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1vbnRoSHRtbCArPSBcIjwvc2VsZWN0PlwiO1xuXHRcdH1cblxuXHRcdGlmICggIXNob3dNb250aEFmdGVyWWVhciApIHtcblx0XHRcdGh0bWwgKz0gbW9udGhIdG1sICsgKCBzZWNvbmRhcnkgfHwgISggY2hhbmdlTW9udGggJiYgY2hhbmdlWWVhciApID8gXCImI3hhMDtcIiA6IFwiXCIgKTtcblx0XHR9XG5cblx0XHQvLyBZZWFyIHNlbGVjdGlvblxuXHRcdGlmICggIWluc3QueWVhcnNodG1sICkge1xuXHRcdFx0aW5zdC55ZWFyc2h0bWwgPSBcIlwiO1xuXHRcdFx0aWYgKCBzZWNvbmRhcnkgfHwgIWNoYW5nZVllYXIgKSB7XG5cdFx0XHRcdGh0bWwgKz0gXCI8c3BhbiBjbGFzcz0ndWktZGF0ZXBpY2tlci15ZWFyJz5cIiArIGRyYXdZZWFyICsgXCI8L3NwYW4+XCI7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIGRldGVybWluZSByYW5nZSBvZiB5ZWFycyB0byBkaXNwbGF5XG5cdFx0XHRcdHllYXJzID0gdGhpcy5fZ2V0KCBpbnN0LCBcInllYXJSYW5nZVwiICkuc3BsaXQoIFwiOlwiICk7XG5cdFx0XHRcdHRoaXNZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHRkZXRlcm1pbmVZZWFyID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciB5ZWFyID0gKCB2YWx1ZS5tYXRjaCggL2NbK1xcLV0uKi8gKSA/IGRyYXdZZWFyICsgcGFyc2VJbnQoIHZhbHVlLnN1YnN0cmluZyggMSApLCAxMCApIDpcblx0XHRcdFx0XHRcdCggdmFsdWUubWF0Y2goIC9bK1xcLV0uKi8gKSA/IHRoaXNZZWFyICsgcGFyc2VJbnQoIHZhbHVlLCAxMCApIDpcblx0XHRcdFx0XHRcdHBhcnNlSW50KCB2YWx1ZSwgMTAgKSApICk7XG5cdFx0XHRcdFx0cmV0dXJuICggaXNOYU4oIHllYXIgKSA/IHRoaXNZZWFyIDogeWVhciApO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR5ZWFyID0gZGV0ZXJtaW5lWWVhciggeWVhcnNbIDAgXSApO1xuXHRcdFx0XHRlbmRZZWFyID0gTWF0aC5tYXgoIHllYXIsIGRldGVybWluZVllYXIoIHllYXJzWyAxIF0gfHwgXCJcIiApICk7XG5cdFx0XHRcdHllYXIgPSAoIG1pbkRhdGUgPyBNYXRoLm1heCggeWVhciwgbWluRGF0ZS5nZXRGdWxsWWVhcigpICkgOiB5ZWFyICk7XG5cdFx0XHRcdGVuZFllYXIgPSAoIG1heERhdGUgPyBNYXRoLm1pbiggZW5kWWVhciwgbWF4RGF0ZS5nZXRGdWxsWWVhcigpICkgOiBlbmRZZWFyICk7XG5cdFx0XHRcdGluc3QueWVhcnNodG1sICs9IFwiPHNlbGVjdCBjbGFzcz0ndWktZGF0ZXBpY2tlci15ZWFyJyBkYXRhLWhhbmRsZXI9J3NlbGVjdFllYXInIGRhdGEtZXZlbnQ9J2NoYW5nZSc+XCI7XG5cdFx0XHRcdGZvciAoIDsgeWVhciA8PSBlbmRZZWFyOyB5ZWFyKysgKSB7XG5cdFx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIHllYXIgKyBcIidcIiArXG5cdFx0XHRcdFx0XHQoIHllYXIgPT09IGRyYXdZZWFyID8gXCIgc2VsZWN0ZWQ9J3NlbGVjdGVkJ1wiIDogXCJcIiApICtcblx0XHRcdFx0XHRcdFwiPlwiICsgeWVhciArIFwiPC9vcHRpb24+XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgKz0gXCI8L3NlbGVjdD5cIjtcblxuXHRcdFx0XHRodG1sICs9IGluc3QueWVhcnNodG1sO1xuXHRcdFx0XHRpbnN0LnllYXJzaHRtbCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aHRtbCArPSB0aGlzLl9nZXQoIGluc3QsIFwieWVhclN1ZmZpeFwiICk7XG5cdFx0aWYgKCBzaG93TW9udGhBZnRlclllYXIgKSB7XG5cdFx0XHRodG1sICs9ICggc2Vjb25kYXJ5IHx8ICEoIGNoYW5nZU1vbnRoICYmIGNoYW5nZVllYXIgKSA/IFwiJiN4YTA7XCIgOiBcIlwiICkgKyBtb250aEh0bWw7XG5cdFx0fVxuXHRcdGh0bWwgKz0gXCI8L2Rpdj5cIjsgLy8gQ2xvc2UgZGF0ZXBpY2tlcl9oZWFkZXJcblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXHQvKiBBZGp1c3Qgb25lIG9mIHRoZSBkYXRlIHN1Yi1maWVsZHMuICovXG5cdF9hZGp1c3RJbnN0RGF0ZTogZnVuY3Rpb24oIGluc3QsIG9mZnNldCwgcGVyaW9kICkge1xuXHRcdHZhciB5ZWFyID0gaW5zdC5zZWxlY3RlZFllYXIgKyAoIHBlcmlvZCA9PT0gXCJZXCIgPyBvZmZzZXQgOiAwICksXG5cdFx0XHRtb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCArICggcGVyaW9kID09PSBcIk1cIiA/IG9mZnNldCA6IDAgKSxcblx0XHRcdGRheSA9IE1hdGgubWluKCBpbnN0LnNlbGVjdGVkRGF5LCB0aGlzLl9nZXREYXlzSW5Nb250aCggeWVhciwgbW9udGggKSApICsgKCBwZXJpb2QgPT09IFwiRFwiID8gb2Zmc2V0IDogMCApLFxuXHRcdFx0ZGF0ZSA9IHRoaXMuX3Jlc3RyaWN0TWluTWF4KCBpbnN0LCB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3IERhdGUoIHllYXIsIG1vbnRoLCBkYXkgKSApICk7XG5cblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG5cdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdGlmICggcGVyaW9kID09PSBcIk1cIiB8fCBwZXJpb2QgPT09IFwiWVwiICkge1xuXHRcdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKCBpbnN0ICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEVuc3VyZSBhIGRhdGUgaXMgd2l0aGluIGFueSBtaW4vbWF4IGJvdW5kcy4gKi9cblx0X3Jlc3RyaWN0TWluTWF4OiBmdW5jdGlvbiggaW5zdCwgZGF0ZSApIHtcblx0XHR2YXIgbWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoIGluc3QsIFwibWluXCIgKSxcblx0XHRcdG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKCBpbnN0LCBcIm1heFwiICksXG5cdFx0XHRuZXdEYXRlID0gKCBtaW5EYXRlICYmIGRhdGUgPCBtaW5EYXRlID8gbWluRGF0ZSA6IGRhdGUgKTtcblx0XHRyZXR1cm4gKCBtYXhEYXRlICYmIG5ld0RhdGUgPiBtYXhEYXRlID8gbWF4RGF0ZSA6IG5ld0RhdGUgKTtcblx0fSxcblxuXHQvKiBOb3RpZnkgY2hhbmdlIG9mIG1vbnRoL3llYXIuICovXG5cdF9ub3RpZnlDaGFuZ2U6IGZ1bmN0aW9uKCBpbnN0ICkge1xuXHRcdHZhciBvbkNoYW5nZSA9IHRoaXMuX2dldCggaW5zdCwgXCJvbkNoYW5nZU1vbnRoWWVhclwiICk7XG5cdFx0aWYgKCBvbkNoYW5nZSApIHtcblx0XHRcdG9uQ2hhbmdlLmFwcGx5KCAoIGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WyAwIF0gOiBudWxsICksXG5cdFx0XHRcdFsgaW5zdC5zZWxlY3RlZFllYXIsIGluc3Quc2VsZWN0ZWRNb250aCArIDEsIGluc3QgXSApO1xuXHRcdH1cblx0fSxcblxuXHQvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBtb250aHMgdG8gc2hvdy4gKi9cblx0X2dldE51bWJlck9mTW9udGhzOiBmdW5jdGlvbiggaW5zdCApIHtcblx0XHR2YXIgbnVtTW9udGhzID0gdGhpcy5fZ2V0KCBpbnN0LCBcIm51bWJlck9mTW9udGhzXCIgKTtcblx0XHRyZXR1cm4gKCBudW1Nb250aHMgPT0gbnVsbCA/IFsgMSwgMSBdIDogKCB0eXBlb2YgbnVtTW9udGhzID09PSBcIm51bWJlclwiID8gWyAxLCBudW1Nb250aHMgXSA6IG51bU1vbnRocyApICk7XG5cdH0sXG5cblx0LyogRGV0ZXJtaW5lIHRoZSBjdXJyZW50IG1heGltdW0gZGF0ZSAtIGVuc3VyZSBubyB0aW1lIGNvbXBvbmVudHMgYXJlIHNldC4gKi9cblx0X2dldE1pbk1heERhdGU6IGZ1bmN0aW9uKCBpbnN0LCBtaW5NYXggKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RldGVybWluZURhdGUoIGluc3QsIHRoaXMuX2dldCggaW5zdCwgbWluTWF4ICsgXCJEYXRlXCIgKSwgbnVsbCApO1xuXHR9LFxuXG5cdC8qIEZpbmQgdGhlIG51bWJlciBvZiBkYXlzIGluIGEgZ2l2ZW4gbW9udGguICovXG5cdF9nZXREYXlzSW5Nb250aDogZnVuY3Rpb24oIHllYXIsIG1vbnRoICkge1xuXHRcdHJldHVybiAzMiAtIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KCBuZXcgRGF0ZSggeWVhciwgbW9udGgsIDMyICkgKS5nZXREYXRlKCk7XG5cdH0sXG5cblx0LyogRmluZCB0aGUgZGF5IG9mIHRoZSB3ZWVrIG9mIHRoZSBmaXJzdCBvZiBhIG1vbnRoLiAqL1xuXHRfZ2V0Rmlyc3REYXlPZk1vbnRoOiBmdW5jdGlvbiggeWVhciwgbW9udGggKSB7XG5cdFx0cmV0dXJuIG5ldyBEYXRlKCB5ZWFyLCBtb250aCwgMSApLmdldERheSgpO1xuXHR9LFxuXG5cdC8qIERldGVybWluZXMgaWYgd2Ugc2hvdWxkIGFsbG93IGEgXCJuZXh0L3ByZXZcIiBtb250aCBkaXNwbGF5IGNoYW5nZS4gKi9cblx0X2NhbkFkanVzdE1vbnRoOiBmdW5jdGlvbiggaW5zdCwgb2Zmc2V0LCBjdXJZZWFyLCBjdXJNb250aCApIHtcblx0XHR2YXIgbnVtTW9udGhzID0gdGhpcy5fZ2V0TnVtYmVyT2ZNb250aHMoIGluc3QgKSxcblx0XHRcdGRhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3IERhdGUoIGN1clllYXIsXG5cdFx0XHRjdXJNb250aCArICggb2Zmc2V0IDwgMCA/IG9mZnNldCA6IG51bU1vbnRoc1sgMCBdICogbnVtTW9udGhzWyAxIF0gKSwgMSApICk7XG5cblx0XHRpZiAoIG9mZnNldCA8IDAgKSB7XG5cdFx0XHRkYXRlLnNldERhdGUoIHRoaXMuX2dldERheXNJbk1vbnRoKCBkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSApICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9pc0luUmFuZ2UoIGluc3QsIGRhdGUgKTtcblx0fSxcblxuXHQvKiBJcyB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgYWNjZXB0ZWQgcmFuZ2U/ICovXG5cdF9pc0luUmFuZ2U6IGZ1bmN0aW9uKCBpbnN0LCBkYXRlICkge1xuXHRcdHZhciB5ZWFyU3BsaXQsIGN1cnJlbnRZZWFyLFxuXHRcdFx0bWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoIGluc3QsIFwibWluXCIgKSxcblx0XHRcdG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKCBpbnN0LCBcIm1heFwiICksXG5cdFx0XHRtaW5ZZWFyID0gbnVsbCxcblx0XHRcdG1heFllYXIgPSBudWxsLFxuXHRcdFx0eWVhcnMgPSB0aGlzLl9nZXQoIGluc3QsIFwieWVhclJhbmdlXCIgKTtcblx0XHRcdGlmICggeWVhcnMgKSB7XG5cdFx0XHRcdHllYXJTcGxpdCA9IHllYXJzLnNwbGl0KCBcIjpcIiApO1xuXHRcdFx0XHRjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0bWluWWVhciA9IHBhcnNlSW50KCB5ZWFyU3BsaXRbIDAgXSwgMTAgKTtcblx0XHRcdFx0bWF4WWVhciA9IHBhcnNlSW50KCB5ZWFyU3BsaXRbIDEgXSwgMTAgKTtcblx0XHRcdFx0aWYgKCB5ZWFyU3BsaXRbIDAgXS5tYXRjaCggL1srXFwtXS4qLyApICkge1xuXHRcdFx0XHRcdG1pblllYXIgKz0gY3VycmVudFllYXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB5ZWFyU3BsaXRbIDEgXS5tYXRjaCggL1srXFwtXS4qLyApICkge1xuXHRcdFx0XHRcdG1heFllYXIgKz0gY3VycmVudFllYXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdHJldHVybiAoICggIW1pbkRhdGUgfHwgZGF0ZS5nZXRUaW1lKCkgPj0gbWluRGF0ZS5nZXRUaW1lKCkgKSAmJlxuXHRcdFx0KCAhbWF4RGF0ZSB8fCBkYXRlLmdldFRpbWUoKSA8PSBtYXhEYXRlLmdldFRpbWUoKSApICYmXG5cdFx0XHQoICFtaW5ZZWFyIHx8IGRhdGUuZ2V0RnVsbFllYXIoKSA+PSBtaW5ZZWFyICkgJiZcblx0XHRcdCggIW1heFllYXIgfHwgZGF0ZS5nZXRGdWxsWWVhcigpIDw9IG1heFllYXIgKSApO1xuXHR9LFxuXG5cdC8qIFByb3ZpZGUgdGhlIGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MgZm9yIGZvcm1hdHRpbmcvcGFyc2luZy4gKi9cblx0X2dldEZvcm1hdENvbmZpZzogZnVuY3Rpb24oIGluc3QgKSB7XG5cdFx0dmFyIHNob3J0WWVhckN1dG9mZiA9IHRoaXMuX2dldCggaW5zdCwgXCJzaG9ydFllYXJDdXRvZmZcIiApO1xuXHRcdHNob3J0WWVhckN1dG9mZiA9ICggdHlwZW9mIHNob3J0WWVhckN1dG9mZiAhPT0gXCJzdHJpbmdcIiA/IHNob3J0WWVhckN1dG9mZiA6XG5cdFx0XHRuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgJSAxMDAgKyBwYXJzZUludCggc2hvcnRZZWFyQ3V0b2ZmLCAxMCApICk7XG5cdFx0cmV0dXJuIHsgc2hvcnRZZWFyQ3V0b2ZmOiBzaG9ydFllYXJDdXRvZmYsXG5cdFx0XHRkYXlOYW1lc1Nob3J0OiB0aGlzLl9nZXQoIGluc3QsIFwiZGF5TmFtZXNTaG9ydFwiICksIGRheU5hbWVzOiB0aGlzLl9nZXQoIGluc3QsIFwiZGF5TmFtZXNcIiApLFxuXHRcdFx0bW9udGhOYW1lc1Nob3J0OiB0aGlzLl9nZXQoIGluc3QsIFwibW9udGhOYW1lc1Nob3J0XCIgKSwgbW9udGhOYW1lczogdGhpcy5fZ2V0KCBpbnN0LCBcIm1vbnRoTmFtZXNcIiApIH07XG5cdH0sXG5cblx0LyogRm9ybWF0IHRoZSBnaXZlbiBkYXRlIGZvciBkaXNwbGF5LiAqL1xuXHRfZm9ybWF0RGF0ZTogZnVuY3Rpb24oIGluc3QsIGRheSwgbW9udGgsIHllYXIgKSB7XG5cdFx0aWYgKCAhZGF5ICkge1xuXHRcdFx0aW5zdC5jdXJyZW50RGF5ID0gaW5zdC5zZWxlY3RlZERheTtcblx0XHRcdGluc3QuY3VycmVudE1vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoO1xuXHRcdFx0aW5zdC5jdXJyZW50WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyO1xuXHRcdH1cblx0XHR2YXIgZGF0ZSA9ICggZGF5ID8gKCB0eXBlb2YgZGF5ID09PSBcIm9iamVjdFwiID8gZGF5IDpcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KCBuZXcgRGF0ZSggeWVhciwgbW9udGgsIGRheSApICkgKSA6XG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdCggbmV3IERhdGUoIGluc3QuY3VycmVudFllYXIsIGluc3QuY3VycmVudE1vbnRoLCBpbnN0LmN1cnJlbnREYXkgKSApICk7XG5cdFx0cmV0dXJuIHRoaXMuZm9ybWF0RGF0ZSggdGhpcy5fZ2V0KCBpbnN0LCBcImRhdGVGb3JtYXRcIiApLCBkYXRlLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoIGluc3QgKSApO1xuXHR9XG59ICk7XG5cbi8qXG4gKiBCaW5kIGhvdmVyIGV2ZW50cyBmb3IgZGF0ZXBpY2tlciBlbGVtZW50cy5cbiAqIERvbmUgdmlhIGRlbGVnYXRlIHNvIHRoZSBiaW5kaW5nIG9ubHkgb2NjdXJzIG9uY2UgaW4gdGhlIGxpZmV0aW1lIG9mIHRoZSBwYXJlbnQgZGl2LlxuICogR2xvYmFsIGRhdGVwaWNrZXJfaW5zdEFjdGl2ZSwgc2V0IGJ5IF91cGRhdGVEYXRlcGlja2VyIGFsbG93cyB0aGUgaGFuZGxlcnMgdG8gZmluZCB0aGVpciB3YXkgYmFjayB0byB0aGUgYWN0aXZlIHBpY2tlci5cbiAqL1xuZnVuY3Rpb24gZGF0ZXBpY2tlcl9iaW5kSG92ZXIoIGRwRGl2ICkge1xuXHR2YXIgc2VsZWN0b3IgPSBcImJ1dHRvbiwgLnVpLWRhdGVwaWNrZXItcHJldiwgLnVpLWRhdGVwaWNrZXItbmV4dCwgLnVpLWRhdGVwaWNrZXItY2FsZW5kYXIgdGQgYVwiO1xuXHRyZXR1cm4gZHBEaXYub24oIFwibW91c2VvdXRcIiwgc2VsZWN0b3IsIGZ1bmN0aW9uKCkge1xuXHRcdFx0JCggdGhpcyApLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdGlmICggdGhpcy5jbGFzc05hbWUuaW5kZXhPZiggXCJ1aS1kYXRlcGlja2VyLXByZXZcIiApICE9PSAtMSApIHtcblx0XHRcdFx0JCggdGhpcyApLnJlbW92ZUNsYXNzKCBcInVpLWRhdGVwaWNrZXItcHJldi1ob3ZlclwiICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoIFwidWktZGF0ZXBpY2tlci1uZXh0XCIgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVDbGFzcyggXCJ1aS1kYXRlcGlja2VyLW5leHQtaG92ZXJcIiApO1xuXHRcdFx0fVxuXHRcdH0gKVxuXHRcdC5vbiggXCJtb3VzZW92ZXJcIiwgc2VsZWN0b3IsIGRhdGVwaWNrZXJfaGFuZGxlTW91c2VvdmVyICk7XG59XG5cbmZ1bmN0aW9uIGRhdGVwaWNrZXJfaGFuZGxlTW91c2VvdmVyKCkge1xuXHRpZiAoICEkLmRhdGVwaWNrZXIuX2lzRGlzYWJsZWREYXRlcGlja2VyKCBkYXRlcGlja2VyX2luc3RBY3RpdmUuaW5saW5lID8gZGF0ZXBpY2tlcl9pbnN0QWN0aXZlLmRwRGl2LnBhcmVudCgpWyAwIF0gOiBkYXRlcGlja2VyX2luc3RBY3RpdmUuaW5wdXRbIDAgXSApICkge1xuXHRcdCQoIHRoaXMgKS5wYXJlbnRzKCBcIi51aS1kYXRlcGlja2VyLWNhbGVuZGFyXCIgKS5maW5kKCBcImFcIiApLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHQkKCB0aGlzICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdGlmICggdGhpcy5jbGFzc05hbWUuaW5kZXhPZiggXCJ1aS1kYXRlcGlja2VyLXByZXZcIiApICE9PSAtMSApIHtcblx0XHRcdCQoIHRoaXMgKS5hZGRDbGFzcyggXCJ1aS1kYXRlcGlja2VyLXByZXYtaG92ZXJcIiApO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoIFwidWktZGF0ZXBpY2tlci1uZXh0XCIgKSAhPT0gLTEgKSB7XG5cdFx0XHQkKCB0aGlzICkuYWRkQ2xhc3MoIFwidWktZGF0ZXBpY2tlci1uZXh0LWhvdmVyXCIgKTtcblx0XHR9XG5cdH1cbn1cblxuLyogalF1ZXJ5IGV4dGVuZCBub3cgaWdub3JlcyBudWxscyEgKi9cbmZ1bmN0aW9uIGRhdGVwaWNrZXJfZXh0ZW5kUmVtb3ZlKCB0YXJnZXQsIHByb3BzICkge1xuXHQkLmV4dGVuZCggdGFyZ2V0LCBwcm9wcyApO1xuXHRmb3IgKCB2YXIgbmFtZSBpbiBwcm9wcyApIHtcblx0XHRpZiAoIHByb3BzWyBuYW1lIF0gPT0gbnVsbCApIHtcblx0XHRcdHRhcmdldFsgbmFtZSBdID0gcHJvcHNbIG5hbWUgXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSW52b2tlIHRoZSBkYXRlcGlja2VyIGZ1bmN0aW9uYWxpdHkuXG4gICBAcGFyYW0gIG9wdGlvbnMgIHN0cmluZyAtIGEgY29tbWFuZCwgb3B0aW9uYWxseSBmb2xsb3dlZCBieSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgb3Jcblx0XHRcdFx0XHRPYmplY3QgLSBzZXR0aW5ncyBmb3IgYXR0YWNoaW5nIG5ldyBkYXRlcGlja2VyIGZ1bmN0aW9uYWxpdHlcbiAgIEByZXR1cm4gIGpRdWVyeSBvYmplY3QgKi9cbiQuZm4uZGF0ZXBpY2tlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8qIFZlcmlmeSBhbiBlbXB0eSBjb2xsZWN0aW9uIHdhc24ndCBwYXNzZWQgLSBGaXhlcyAjNjk3NiAqL1xuXHRpZiAoICF0aGlzLmxlbmd0aCApIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qIEluaXRpYWxpc2UgdGhlIGRhdGUgcGlja2VyLiAqL1xuXHRpZiAoICEkLmRhdGVwaWNrZXIuaW5pdGlhbGl6ZWQgKSB7XG5cdFx0JCggZG9jdW1lbnQgKS5vbiggXCJtb3VzZWRvd25cIiwgJC5kYXRlcGlja2VyLl9jaGVja0V4dGVybmFsQ2xpY2sgKTtcblx0XHQkLmRhdGVwaWNrZXIuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHR9XG5cblx0LyogQXBwZW5kIGRhdGVwaWNrZXIgbWFpbiBjb250YWluZXIgdG8gYm9keSBpZiBub3QgZXhpc3QuICovXG5cdGlmICggJCggXCIjXCIgKyAkLmRhdGVwaWNrZXIuX21haW5EaXZJZCApLmxlbmd0aCA9PT0gMCApIHtcblx0XHQkKCBcImJvZHlcIiApLmFwcGVuZCggJC5kYXRlcGlja2VyLmRwRGl2ICk7XG5cdH1cblxuXHR2YXIgb3RoZXJBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiICYmICggb3B0aW9ucyA9PT0gXCJpc0Rpc2FibGVkXCIgfHwgb3B0aW9ucyA9PT0gXCJnZXREYXRlXCIgfHwgb3B0aW9ucyA9PT0gXCJ3aWRnZXRcIiApICkge1xuXHRcdHJldHVybiAkLmRhdGVwaWNrZXJbIFwiX1wiICsgb3B0aW9ucyArIFwiRGF0ZXBpY2tlclwiIF0uXG5cdFx0XHRhcHBseSggJC5kYXRlcGlja2VyLCBbIHRoaXNbIDAgXSBdLmNvbmNhdCggb3RoZXJBcmdzICkgKTtcblx0fVxuXHRpZiAoIG9wdGlvbnMgPT09IFwib3B0aW9uXCIgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJndW1lbnRzWyAxIF0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuICQuZGF0ZXBpY2tlclsgXCJfXCIgKyBvcHRpb25zICsgXCJEYXRlcGlja2VyXCIgXS5cblx0XHRcdGFwcGx5KCAkLmRhdGVwaWNrZXIsIFsgdGhpc1sgMCBdIF0uY29uY2F0KCBvdGhlckFyZ3MgKSApO1xuXHR9XG5cdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRcdCQuZGF0ZXBpY2tlclsgXCJfXCIgKyBvcHRpb25zICsgXCJEYXRlcGlja2VyXCIgXS5cblx0XHRcdFx0YXBwbHkoICQuZGF0ZXBpY2tlciwgWyB0aGlzIF0uY29uY2F0KCBvdGhlckFyZ3MgKSApIDpcblx0XHRcdCQuZGF0ZXBpY2tlci5fYXR0YWNoRGF0ZXBpY2tlciggdGhpcywgb3B0aW9ucyApO1xuXHR9ICk7XG59O1xuXG4kLmRhdGVwaWNrZXIgPSBuZXcgRGF0ZXBpY2tlcigpOyAvLyBzaW5nbGV0b24gaW5zdGFuY2VcbiQuZGF0ZXBpY2tlci5pbml0aWFsaXplZCA9IGZhbHNlO1xuJC5kYXRlcGlja2VyLnV1aWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiQuZGF0ZXBpY2tlci52ZXJzaW9uID0gXCIxLjEyLjFcIjtcblxudmFyIHdpZGdldHNEYXRlcGlja2VyID0gJC5kYXRlcGlja2VyO1xuXG5cblxuXG4vLyBUaGlzIGZpbGUgaXMgZGVwcmVjYXRlZFxudmFyIGllID0gJC51aS5pZSA9ICEhL21zaWUgW1xcdy5dKy8uZXhlYyggbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpICk7XG5cbi8qIVxuICogalF1ZXJ5IFVJIE1vdXNlIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBNb3VzZVxuLy8+Pmdyb3VwOiBXaWRnZXRzXG4vLz4+ZGVzY3JpcHRpb246IEFic3RyYWN0cyBtb3VzZS1iYXNlZCBpbnRlcmFjdGlvbnMgdG8gYXNzaXN0IGluIGNyZWF0aW5nIGNlcnRhaW4gd2lkZ2V0cy5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9tb3VzZS9cblxuXG5cbnZhciBtb3VzZUhhbmRsZWQgPSBmYWxzZTtcbiQoIGRvY3VtZW50ICkub24oIFwibW91c2V1cFwiLCBmdW5jdGlvbigpIHtcblx0bW91c2VIYW5kbGVkID0gZmFsc2U7XG59ICk7XG5cbnZhciB3aWRnZXRzTW91c2UgPSAkLndpZGdldCggXCJ1aS5tb3VzZVwiLCB7XG5cdHZlcnNpb246IFwiMS4xMi4xXCIsXG5cdG9wdGlvbnM6IHtcblx0XHRjYW5jZWw6IFwiaW5wdXQsIHRleHRhcmVhLCBidXR0b24sIHNlbGVjdCwgb3B0aW9uXCIsXG5cdFx0ZGlzdGFuY2U6IDEsXG5cdFx0ZGVsYXk6IDBcblx0fSxcblx0X21vdXNlSW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQub24oIFwibW91c2Vkb3duLlwiICsgdGhpcy53aWRnZXROYW1lLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiB0aGF0Ll9tb3VzZURvd24oIGV2ZW50ICk7XG5cdFx0XHR9IClcblx0XHRcdC5vbiggXCJjbGljay5cIiArIHRoaXMud2lkZ2V0TmFtZSwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIHRydWUgPT09ICQuZGF0YSggZXZlbnQudGFyZ2V0LCB0aGF0LndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiICkgKSB7XG5cdFx0XHRcdFx0JC5yZW1vdmVEYXRhKCBldmVudC50YXJnZXQsIHRoYXQud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIgKTtcblx0XHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblxuXHRcdHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdC8vIFRPRE86IG1ha2Ugc3VyZSBkZXN0cm95aW5nIG9uZSBpbnN0YW5jZSBvZiBtb3VzZSBkb2Vzbid0IG1lc3Mgd2l0aFxuXHQvLyBvdGhlciBpbnN0YW5jZXMgb2YgbW91c2Vcblx0X21vdXNlRGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50Lm9mZiggXCIuXCIgKyB0aGlzLndpZGdldE5hbWUgKTtcblx0XHRpZiAoIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlICkge1xuXHRcdFx0dGhpcy5kb2N1bWVudFxuXHRcdFx0XHQub2ZmKCBcIm1vdXNlbW92ZS5cIiArIHRoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUgKVxuXHRcdFx0XHQub2ZmKCBcIm1vdXNldXAuXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSApO1xuXHRcdH1cblx0fSxcblxuXHRfbW91c2VEb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHQvLyBkb24ndCBsZXQgbW9yZSB0aGFuIG9uZSB3aWRnZXQgaGFuZGxlIG1vdXNlU3RhcnRcblx0XHRpZiAoIG1vdXNlSGFuZGxlZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9tb3VzZU1vdmVkID0gZmFsc2U7XG5cblx0XHQvLyBXZSBtYXkgaGF2ZSBtaXNzZWQgbW91c2V1cCAob3V0IG9mIHdpbmRvdylcblx0XHQoIHRoaXMuX21vdXNlU3RhcnRlZCAmJiB0aGlzLl9tb3VzZVVwKCBldmVudCApICk7XG5cblx0XHR0aGlzLl9tb3VzZURvd25FdmVudCA9IGV2ZW50O1xuXG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0YnRuSXNMZWZ0ID0gKCBldmVudC53aGljaCA9PT0gMSApLFxuXG5cdFx0XHQvLyBldmVudC50YXJnZXQubm9kZU5hbWUgd29ya3MgYXJvdW5kIGEgYnVnIGluIElFIDggd2l0aFxuXHRcdFx0Ly8gZGlzYWJsZWQgaW5wdXRzICgjNzYyMClcblx0XHRcdGVsSXNDYW5jZWwgPSAoIHR5cGVvZiB0aGlzLm9wdGlvbnMuY2FuY2VsID09PSBcInN0cmluZ1wiICYmIGV2ZW50LnRhcmdldC5ub2RlTmFtZSA/XG5cdFx0XHRcdCQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIHRoaXMub3B0aW9ucy5jYW5jZWwgKS5sZW5ndGggOiBmYWxzZSApO1xuXHRcdGlmICggIWJ0bklzTGVmdCB8fCBlbElzQ2FuY2VsIHx8ICF0aGlzLl9tb3VzZUNhcHR1cmUoIGV2ZW50ICkgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHR0aGlzLm1vdXNlRGVsYXlNZXQgPSAhdGhpcy5vcHRpb25zLmRlbGF5O1xuXHRcdGlmICggIXRoaXMubW91c2VEZWxheU1ldCApIHtcblx0XHRcdHRoaXMuX21vdXNlRGVsYXlUaW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGF0Lm1vdXNlRGVsYXlNZXQgPSB0cnVlO1xuXHRcdFx0fSwgdGhpcy5vcHRpb25zLmRlbGF5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9tb3VzZURpc3RhbmNlTWV0KCBldmVudCApICYmIHRoaXMuX21vdXNlRGVsYXlNZXQoIGV2ZW50ICkgKSB7XG5cdFx0XHR0aGlzLl9tb3VzZVN0YXJ0ZWQgPSAoIHRoaXMuX21vdXNlU3RhcnQoIGV2ZW50ICkgIT09IGZhbHNlICk7XG5cdFx0XHRpZiAoICF0aGlzLl9tb3VzZVN0YXJ0ZWQgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENsaWNrIGV2ZW50IG1heSBuZXZlciBoYXZlIGZpcmVkIChHZWNrbyAmIE9wZXJhKVxuXHRcdGlmICggdHJ1ZSA9PT0gJC5kYXRhKCBldmVudC50YXJnZXQsIHRoaXMud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIgKSApIHtcblx0XHRcdCQucmVtb3ZlRGF0YSggZXZlbnQudGFyZ2V0LCB0aGlzLndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlc2UgZGVsZWdhdGVzIGFyZSByZXF1aXJlZCB0byBrZWVwIGNvbnRleHRcblx0XHR0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHJldHVybiB0aGF0Ll9tb3VzZU1vdmUoIGV2ZW50ICk7XG5cdFx0fTtcblx0XHR0aGlzLl9tb3VzZVVwRGVsZWdhdGUgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRyZXR1cm4gdGhhdC5fbW91c2VVcCggZXZlbnQgKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5kb2N1bWVudFxuXHRcdFx0Lm9uKCBcIm1vdXNlbW92ZS5cIiArIHRoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUgKVxuXHRcdFx0Lm9uKCBcIm1vdXNldXAuXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSApO1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdG1vdXNlSGFuZGxlZCA9IHRydWU7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X21vdXNlTW92ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0Ly8gT25seSBjaGVjayBmb3IgbW91c2V1cHMgb3V0c2lkZSB0aGUgZG9jdW1lbnQgaWYgeW91J3ZlIG1vdmVkIGluc2lkZSB0aGUgZG9jdW1lbnRcblx0XHQvLyBhdCBsZWFzdCBvbmNlLiBUaGlzIHByZXZlbnRzIHRoZSBmaXJpbmcgb2YgbW91c2V1cCBpbiB0aGUgY2FzZSBvZiBJRTw5LCB3aGljaCB3aWxsXG5cdFx0Ly8gZmlyZSBhIG1vdXNlbW92ZSBldmVudCBpZiBjb250ZW50IGlzIHBsYWNlZCB1bmRlciB0aGUgY3Vyc29yLiBTZWUgIzc3Nzhcblx0XHQvLyBTdXBwb3J0OiBJRSA8OVxuXHRcdGlmICggdGhpcy5fbW91c2VNb3ZlZCApIHtcblxuXHRcdFx0Ly8gSUUgbW91c2V1cCBjaGVjayAtIG1vdXNldXAgaGFwcGVuZWQgd2hlbiBtb3VzZSB3YXMgb3V0IG9mIHdpbmRvd1xuXHRcdFx0aWYgKCAkLnVpLmllICYmICggIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCA5ICkgJiZcblx0XHRcdFx0XHQhZXZlbnQuYnV0dG9uICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbW91c2VVcCggZXZlbnQgKTtcblxuXHRcdFx0Ly8gSWZyYW1lIG1vdXNldXAgY2hlY2sgLSBtb3VzZXVwIG9jY3VycmVkIGluIGFub3RoZXIgZG9jdW1lbnRcblx0XHRcdH0gZWxzZSBpZiAoICFldmVudC53aGljaCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD04IC0gOVxuXHRcdFx0XHQvLyBTYWZhcmkgc2V0cyB3aGljaCB0byAwIGlmIHlvdSBwcmVzcyBhbnkgb2YgdGhlIGZvbGxvd2luZyBrZXlzXG5cdFx0XHRcdC8vIGR1cmluZyBhIGRyYWcgKCMxNDQ2MSlcblx0XHRcdFx0aWYgKCBldmVudC5vcmlnaW5hbEV2ZW50LmFsdEtleSB8fCBldmVudC5vcmlnaW5hbEV2ZW50LmN0cmxLZXkgfHxcblx0XHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQubWV0YUtleSB8fCBldmVudC5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5ICkge1xuXHRcdFx0XHRcdHRoaXMuaWdub3JlTWlzc2luZ1doaWNoID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggIXRoaXMuaWdub3JlTWlzc2luZ1doaWNoICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9tb3VzZVVwKCBldmVudCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBldmVudC53aGljaCB8fCBldmVudC5idXR0b24gKSB7XG5cdFx0XHR0aGlzLl9tb3VzZU1vdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX21vdXNlU3RhcnRlZCApIHtcblx0XHRcdHRoaXMuX21vdXNlRHJhZyggZXZlbnQgKTtcblx0XHRcdHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fbW91c2VEaXN0YW5jZU1ldCggZXZlbnQgKSAmJiB0aGlzLl9tb3VzZURlbGF5TWV0KCBldmVudCApICkge1xuXHRcdFx0dGhpcy5fbW91c2VTdGFydGVkID1cblx0XHRcdFx0KCB0aGlzLl9tb3VzZVN0YXJ0KCB0aGlzLl9tb3VzZURvd25FdmVudCwgZXZlbnQgKSAhPT0gZmFsc2UgKTtcblx0XHRcdCggdGhpcy5fbW91c2VTdGFydGVkID8gdGhpcy5fbW91c2VEcmFnKCBldmVudCApIDogdGhpcy5fbW91c2VVcCggZXZlbnQgKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiAhdGhpcy5fbW91c2VTdGFydGVkO1xuXHR9LFxuXG5cdF9tb3VzZVVwOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dGhpcy5kb2N1bWVudFxuXHRcdFx0Lm9mZiggXCJtb3VzZW1vdmUuXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlIClcblx0XHRcdC5vZmYoIFwibW91c2V1cC5cIiArIHRoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VVcERlbGVnYXRlICk7XG5cblx0XHRpZiAoIHRoaXMuX21vdXNlU3RhcnRlZCApIHtcblx0XHRcdHRoaXMuX21vdXNlU3RhcnRlZCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIGV2ZW50LnRhcmdldCA9PT0gdGhpcy5fbW91c2VEb3duRXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0XHQkLmRhdGEoIGV2ZW50LnRhcmdldCwgdGhpcy53aWRnZXROYW1lICsgXCIucHJldmVudENsaWNrRXZlbnRcIiwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9tb3VzZVN0b3AoIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9tb3VzZURlbGF5VGltZXIgKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoIHRoaXMuX21vdXNlRGVsYXlUaW1lciApO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX21vdXNlRGVsYXlUaW1lcjtcblx0XHR9XG5cblx0XHR0aGlzLmlnbm9yZU1pc3NpbmdXaGljaCA9IGZhbHNlO1xuXHRcdG1vdXNlSGFuZGxlZCA9IGZhbHNlO1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH0sXG5cblx0X21vdXNlRGlzdGFuY2VNZXQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRyZXR1cm4gKCBNYXRoLm1heChcblx0XHRcdFx0TWF0aC5hYnMoIHRoaXMuX21vdXNlRG93bkV2ZW50LnBhZ2VYIC0gZXZlbnQucGFnZVggKSxcblx0XHRcdFx0TWF0aC5hYnMoIHRoaXMuX21vdXNlRG93bkV2ZW50LnBhZ2VZIC0gZXZlbnQucGFnZVkgKVxuXHRcdFx0KSA+PSB0aGlzLm9wdGlvbnMuZGlzdGFuY2Vcblx0XHQpO1xuXHR9LFxuXG5cdF9tb3VzZURlbGF5TWV0OiBmdW5jdGlvbiggLyogZXZlbnQgKi8gKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VEZWxheU1ldDtcblx0fSxcblxuXHQvLyBUaGVzZSBhcmUgcGxhY2Vob2xkZXIgbWV0aG9kcywgdG8gYmUgb3ZlcnJpZGVuIGJ5IGV4dGVuZGluZyBwbHVnaW5cblx0X21vdXNlU3RhcnQ6IGZ1bmN0aW9uKCAvKiBldmVudCAqLyApIHt9LFxuXHRfbW91c2VEcmFnOiBmdW5jdGlvbiggLyogZXZlbnQgKi8gKSB7fSxcblx0X21vdXNlU3RvcDogZnVuY3Rpb24oIC8qIGV2ZW50ICovICkge30sXG5cdF9tb3VzZUNhcHR1cmU6IGZ1bmN0aW9uKCAvKiBldmVudCAqLyApIHsgcmV0dXJuIHRydWU7IH1cbn0gKTtcblxuXG5cblxuLy8gJC51aS5wbHVnaW4gaXMgZGVwcmVjYXRlZC4gVXNlICQud2lkZ2V0KCkgZXh0ZW5zaW9ucyBpbnN0ZWFkLlxudmFyIHBsdWdpbiA9ICQudWkucGx1Z2luID0ge1xuXHRhZGQ6IGZ1bmN0aW9uKCBtb2R1bGUsIG9wdGlvbiwgc2V0ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0cHJvdG8gPSAkLnVpWyBtb2R1bGUgXS5wcm90b3R5cGU7XG5cdFx0Zm9yICggaSBpbiBzZXQgKSB7XG5cdFx0XHRwcm90by5wbHVnaW5zWyBpIF0gPSBwcm90by5wbHVnaW5zWyBpIF0gfHwgW107XG5cdFx0XHRwcm90by5wbHVnaW5zWyBpIF0ucHVzaCggWyBvcHRpb24sIHNldFsgaSBdIF0gKTtcblx0XHR9XG5cdH0sXG5cdGNhbGw6IGZ1bmN0aW9uKCBpbnN0YW5jZSwgbmFtZSwgYXJncywgYWxsb3dEaXNjb25uZWN0ZWQgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRzZXQgPSBpbnN0YW5jZS5wbHVnaW5zWyBuYW1lIF07XG5cblx0XHRpZiAoICFzZXQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCAhYWxsb3dEaXNjb25uZWN0ZWQgJiYgKCAhaW5zdGFuY2UuZWxlbWVudFsgMCBdLnBhcmVudE5vZGUgfHxcblx0XHRcdFx0aW5zdGFuY2UuZWxlbWVudFsgMCBdLnBhcmVudE5vZGUubm9kZVR5cGUgPT09IDExICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRpZiAoIGluc3RhbmNlLm9wdGlvbnNbIHNldFsgaSBdWyAwIF0gXSApIHtcblx0XHRcdFx0c2V0WyBpIF1bIDEgXS5hcHBseSggaW5zdGFuY2UuZWxlbWVudCwgYXJncyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuXG5cbnZhciBzYWZlQmx1ciA9ICQudWkuc2FmZUJsdXIgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuXHQvLyBTdXBwb3J0OiBJRTkgLSAxMCBvbmx5XG5cdC8vIElmIHRoZSA8Ym9keT4gaXMgYmx1cnJlZCwgSUUgd2lsbCBzd2l0Y2ggd2luZG93cywgc2VlICM5NDIwXG5cdGlmICggZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiYm9keVwiICkge1xuXHRcdCQoIGVsZW1lbnQgKS50cmlnZ2VyKCBcImJsdXJcIiApO1xuXHR9XG59O1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIERyYWdnYWJsZSAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogRHJhZ2dhYmxlXG4vLz4+Z3JvdXA6IEludGVyYWN0aW9uc1xuLy8+PmRlc2NyaXB0aW9uOiBFbmFibGVzIGRyYWdnaW5nIGZ1bmN0aW9uYWxpdHkgZm9yIGFueSBlbGVtZW50LlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2RyYWdnYWJsZS9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9kcmFnZ2FibGUvXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2UvZHJhZ2dhYmxlLmNzc1xuXG5cblxuJC53aWRnZXQoIFwidWkuZHJhZ2dhYmxlXCIsICQudWkubW91c2UsIHtcblx0dmVyc2lvbjogXCIxLjEyLjFcIixcblx0d2lkZ2V0RXZlbnRQcmVmaXg6IFwiZHJhZ1wiLFxuXHRvcHRpb25zOiB7XG5cdFx0YWRkQ2xhc3NlczogdHJ1ZSxcblx0XHRhcHBlbmRUbzogXCJwYXJlbnRcIixcblx0XHRheGlzOiBmYWxzZSxcblx0XHRjb25uZWN0VG9Tb3J0YWJsZTogZmFsc2UsXG5cdFx0Y29udGFpbm1lbnQ6IGZhbHNlLFxuXHRcdGN1cnNvcjogXCJhdXRvXCIsXG5cdFx0Y3Vyc29yQXQ6IGZhbHNlLFxuXHRcdGdyaWQ6IGZhbHNlLFxuXHRcdGhhbmRsZTogZmFsc2UsXG5cdFx0aGVscGVyOiBcIm9yaWdpbmFsXCIsXG5cdFx0aWZyYW1lRml4OiBmYWxzZSxcblx0XHRvcGFjaXR5OiBmYWxzZSxcblx0XHRyZWZyZXNoUG9zaXRpb25zOiBmYWxzZSxcblx0XHRyZXZlcnQ6IGZhbHNlLFxuXHRcdHJldmVydER1cmF0aW9uOiA1MDAsXG5cdFx0c2NvcGU6IFwiZGVmYXVsdFwiLFxuXHRcdHNjcm9sbDogdHJ1ZSxcblx0XHRzY3JvbGxTZW5zaXRpdml0eTogMjAsXG5cdFx0c2Nyb2xsU3BlZWQ6IDIwLFxuXHRcdHNuYXA6IGZhbHNlLFxuXHRcdHNuYXBNb2RlOiBcImJvdGhcIixcblx0XHRzbmFwVG9sZXJhbmNlOiAyMCxcblx0XHRzdGFjazogZmFsc2UsXG5cdFx0ekluZGV4OiBmYWxzZSxcblxuXHRcdC8vIENhbGxiYWNrc1xuXHRcdGRyYWc6IG51bGwsXG5cdFx0c3RhcnQ6IG51bGwsXG5cdFx0c3RvcDogbnVsbFxuXHR9LFxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmhlbHBlciA9PT0gXCJvcmlnaW5hbFwiICkge1xuXHRcdFx0dGhpcy5fc2V0UG9zaXRpb25SZWxhdGl2ZSgpO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5hZGRDbGFzc2VzICkge1xuXHRcdFx0dGhpcy5fYWRkQ2xhc3MoIFwidWktZHJhZ2dhYmxlXCIgKTtcblx0XHR9XG5cdFx0dGhpcy5fc2V0SGFuZGxlQ2xhc3NOYW1lKCk7XG5cblx0XHR0aGlzLl9tb3VzZUluaXQoKTtcblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXHRcdGlmICgga2V5ID09PSBcImhhbmRsZVwiICkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlSGFuZGxlQ2xhc3NOYW1lKCk7XG5cdFx0XHR0aGlzLl9zZXRIYW5kbGVDbGFzc05hbWUoKTtcblx0XHR9XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggKCB0aGlzLmhlbHBlciB8fCB0aGlzLmVsZW1lbnQgKS5pcyggXCIudWktZHJhZ2dhYmxlLWRyYWdnaW5nXCIgKSApIHtcblx0XHRcdHRoaXMuZGVzdHJveU9uQ2xlYXIgPSB0cnVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9yZW1vdmVIYW5kbGVDbGFzc05hbWUoKTtcblx0XHR0aGlzLl9tb3VzZURlc3Ryb3koKTtcblx0fSxcblxuXHRfbW91c2VDYXB0dXJlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnM7XG5cblx0XHQvLyBBbW9uZyBvdGhlcnMsIHByZXZlbnQgYSBkcmFnIG9uIGEgcmVzaXphYmxlLWhhbmRsZVxuXHRcdGlmICggdGhpcy5oZWxwZXIgfHwgby5kaXNhYmxlZCB8fFxuXHRcdFx0XHQkKCBldmVudC50YXJnZXQgKS5jbG9zZXN0KCBcIi51aS1yZXNpemFibGUtaGFuZGxlXCIgKS5sZW5ndGggPiAwICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vUXVpdCBpZiB3ZSdyZSBub3Qgb24gYSB2YWxpZCBoYW5kbGVcblx0XHR0aGlzLmhhbmRsZSA9IHRoaXMuX2dldEhhbmRsZSggZXZlbnQgKTtcblx0XHRpZiAoICF0aGlzLmhhbmRsZSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLl9ibHVyQWN0aXZlRWxlbWVudCggZXZlbnQgKTtcblxuXHRcdHRoaXMuX2Jsb2NrRnJhbWVzKCBvLmlmcmFtZUZpeCA9PT0gdHJ1ZSA/IFwiaWZyYW1lXCIgOiBvLmlmcmFtZUZpeCApO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fSxcblxuXHRfYmxvY2tGcmFtZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLmlmcmFtZUJsb2NrcyA9IHRoaXMuZG9jdW1lbnQuZmluZCggc2VsZWN0b3IgKS5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGlmcmFtZSA9ICQoIHRoaXMgKTtcblxuXHRcdFx0cmV0dXJuICQoIFwiPGRpdj5cIiApXG5cdFx0XHRcdC5jc3MoIFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiIClcblx0XHRcdFx0LmFwcGVuZFRvKCBpZnJhbWUucGFyZW50KCkgKVxuXHRcdFx0XHQub3V0ZXJXaWR0aCggaWZyYW1lLm91dGVyV2lkdGgoKSApXG5cdFx0XHRcdC5vdXRlckhlaWdodCggaWZyYW1lLm91dGVySGVpZ2h0KCkgKVxuXHRcdFx0XHQub2Zmc2V0KCBpZnJhbWUub2Zmc2V0KCkgKVsgMCBdO1xuXHRcdH0gKTtcblx0fSxcblxuXHRfdW5ibG9ja0ZyYW1lczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCB0aGlzLmlmcmFtZUJsb2NrcyApIHtcblx0XHRcdHRoaXMuaWZyYW1lQmxvY2tzLnJlbW92ZSgpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuaWZyYW1lQmxvY2tzO1xuXHRcdH1cblx0fSxcblxuXHRfYmx1ckFjdGl2ZUVsZW1lbnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYWN0aXZlRWxlbWVudCA9ICQudWkuc2FmZUFjdGl2ZUVsZW1lbnQoIHRoaXMuZG9jdW1lbnRbIDAgXSApLFxuXHRcdFx0dGFyZ2V0ID0gJCggZXZlbnQudGFyZ2V0ICk7XG5cblx0XHQvLyBEb24ndCBibHVyIGlmIHRoZSBldmVudCBvY2N1cnJlZCBvbiBhbiBlbGVtZW50IHRoYXQgaXMgd2l0aGluXG5cdFx0Ly8gdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcblx0XHQvLyBTZWUgIzEwNTI3LCAjMTI0NzJcblx0XHRpZiAoIHRhcmdldC5jbG9zZXN0KCBhY3RpdmVFbGVtZW50ICkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEJsdXIgYW55IGVsZW1lbnQgdGhhdCBjdXJyZW50bHkgaGFzIGZvY3VzLCBzZWUgIzQyNjFcblx0XHQkLnVpLnNhZmVCbHVyKCBhY3RpdmVFbGVtZW50ICk7XG5cdH0sXG5cblx0X21vdXNlU3RhcnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0Ly9DcmVhdGUgYW5kIGFwcGVuZCB0aGUgdmlzaWJsZSBoZWxwZXJcblx0XHR0aGlzLmhlbHBlciA9IHRoaXMuX2NyZWF0ZUhlbHBlciggZXZlbnQgKTtcblxuXHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLmhlbHBlciwgXCJ1aS1kcmFnZ2FibGUtZHJhZ2dpbmdcIiApO1xuXG5cdFx0Ly9DYWNoZSB0aGUgaGVscGVyIHNpemVcblx0XHR0aGlzLl9jYWNoZUhlbHBlclByb3BvcnRpb25zKCk7XG5cblx0XHQvL0lmIGRkbWFuYWdlciBpcyB1c2VkIGZvciBkcm9wcGFibGVzLCBzZXQgdGhlIGdsb2JhbCBkcmFnZ2FibGVcblx0XHRpZiAoICQudWkuZGRtYW5hZ2VyICkge1xuXHRcdFx0JC51aS5kZG1hbmFnZXIuY3VycmVudCA9IHRoaXM7XG5cdFx0fVxuXG5cdFx0Lypcblx0XHQgKiAtIFBvc2l0aW9uIGdlbmVyYXRpb24gLVxuXHRcdCAqIFRoaXMgYmxvY2sgZ2VuZXJhdGVzIGV2ZXJ5dGhpbmcgcG9zaXRpb24gcmVsYXRlZCAtIGl0J3MgdGhlIGNvcmUgb2YgZHJhZ2dhYmxlcy5cblx0XHQgKi9cblxuXHRcdC8vQ2FjaGUgdGhlIG1hcmdpbnMgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnRcblx0XHR0aGlzLl9jYWNoZU1hcmdpbnMoKTtcblxuXHRcdC8vU3RvcmUgdGhlIGhlbHBlcidzIGNzcyBwb3NpdGlvblxuXHRcdHRoaXMuY3NzUG9zaXRpb24gPSB0aGlzLmhlbHBlci5jc3MoIFwicG9zaXRpb25cIiApO1xuXHRcdHRoaXMuc2Nyb2xsUGFyZW50ID0gdGhpcy5oZWxwZXIuc2Nyb2xsUGFyZW50KCB0cnVlICk7XG5cdFx0dGhpcy5vZmZzZXRQYXJlbnQgPSB0aGlzLmhlbHBlci5vZmZzZXRQYXJlbnQoKTtcblx0XHR0aGlzLmhhc0ZpeGVkQW5jZXN0b3IgPSB0aGlzLmhlbHBlci5wYXJlbnRzKCkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICQoIHRoaXMgKS5jc3MoIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCI7XG5cdFx0XHR9ICkubGVuZ3RoID4gMDtcblxuXHRcdC8vVGhlIGVsZW1lbnQncyBhYnNvbHV0ZSBwb3NpdGlvbiBvbiB0aGUgcGFnZSBtaW51cyBtYXJnaW5zXG5cdFx0dGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuZWxlbWVudC5vZmZzZXQoKTtcblx0XHR0aGlzLl9yZWZyZXNoT2Zmc2V0cyggZXZlbnQgKTtcblxuXHRcdC8vR2VuZXJhdGUgdGhlIG9yaWdpbmFsIHBvc2l0aW9uXG5cdFx0dGhpcy5vcmlnaW5hbFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oIGV2ZW50LCBmYWxzZSApO1xuXHRcdHRoaXMub3JpZ2luYWxQYWdlWCA9IGV2ZW50LnBhZ2VYO1xuXHRcdHRoaXMub3JpZ2luYWxQYWdlWSA9IGV2ZW50LnBhZ2VZO1xuXG5cdFx0Ly9BZGp1c3QgdGhlIG1vdXNlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgaGVscGVyIGlmIFwiY3Vyc29yQXRcIiBpcyBzdXBwbGllZFxuXHRcdCggby5jdXJzb3JBdCAmJiB0aGlzLl9hZGp1c3RPZmZzZXRGcm9tSGVscGVyKCBvLmN1cnNvckF0ICkgKTtcblxuXHRcdC8vU2V0IGEgY29udGFpbm1lbnQgaWYgZ2l2ZW4gaW4gdGhlIG9wdGlvbnNcblx0XHR0aGlzLl9zZXRDb250YWlubWVudCgpO1xuXG5cdFx0Ly9UcmlnZ2VyIGV2ZW50ICsgY2FsbGJhY2tzXG5cdFx0aWYgKCB0aGlzLl90cmlnZ2VyKCBcInN0YXJ0XCIsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5fY2xlYXIoKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvL1JlY2FjaGUgdGhlIGhlbHBlciBzaXplXG5cdFx0dGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO1xuXG5cdFx0Ly9QcmVwYXJlIHRoZSBkcm9wcGFibGUgb2Zmc2V0c1xuXHRcdGlmICggJC51aS5kZG1hbmFnZXIgJiYgIW8uZHJvcEJlaGF2aW91ciApIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdC8vIEV4ZWN1dGUgdGhlIGRyYWcgb25jZSAtIHRoaXMgY2F1c2VzIHRoZSBoZWxwZXIgbm90IHRvIGJlIHZpc2libGUgYmVmb3JlIGdldHRpbmcgaXRzXG5cdFx0Ly8gY29ycmVjdCBwb3NpdGlvblxuXHRcdHRoaXMuX21vdXNlRHJhZyggZXZlbnQsIHRydWUgKTtcblxuXHRcdC8vIElmIHRoZSBkZG1hbmFnZXIgaXMgdXNlZCBmb3IgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIHRoYXQgZHJhZ2dpbmcgaGFzIHN0YXJ0ZWRcblx0XHQvLyAoc2VlICM1MDAzKVxuXHRcdGlmICggJC51aS5kZG1hbmFnZXIgKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5kcmFnU3RhcnQoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X3JlZnJlc2hPZmZzZXRzOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dGhpcy5vZmZzZXQgPSB7XG5cdFx0XHR0b3A6IHRoaXMucG9zaXRpb25BYnMudG9wIC0gdGhpcy5tYXJnaW5zLnRvcCxcblx0XHRcdGxlZnQ6IHRoaXMucG9zaXRpb25BYnMubGVmdCAtIHRoaXMubWFyZ2lucy5sZWZ0LFxuXHRcdFx0c2Nyb2xsOiBmYWxzZSxcblx0XHRcdHBhcmVudDogdGhpcy5fZ2V0UGFyZW50T2Zmc2V0KCksXG5cdFx0XHRyZWxhdGl2ZTogdGhpcy5fZ2V0UmVsYXRpdmVPZmZzZXQoKVxuXHRcdH07XG5cblx0XHR0aGlzLm9mZnNldC5jbGljayA9IHtcblx0XHRcdGxlZnQ6IGV2ZW50LnBhZ2VYIC0gdGhpcy5vZmZzZXQubGVmdCxcblx0XHRcdHRvcDogZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC50b3Bcblx0XHR9O1xuXHR9LFxuXG5cdF9tb3VzZURyYWc6IGZ1bmN0aW9uKCBldmVudCwgbm9Qcm9wYWdhdGlvbiApIHtcblxuXHRcdC8vIHJlc2V0IGFueSBuZWNlc3NhcnkgY2FjaGVkIHByb3BlcnRpZXMgKHNlZSAjNTAwOSlcblx0XHRpZiAoIHRoaXMuaGFzRml4ZWRBbmNlc3RvciApIHtcblx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudCA9IHRoaXMuX2dldFBhcmVudE9mZnNldCgpO1xuXHRcdH1cblxuXHRcdC8vQ29tcHV0ZSB0aGUgaGVscGVycyBwb3NpdGlvblxuXHRcdHRoaXMucG9zaXRpb24gPSB0aGlzLl9nZW5lcmF0ZVBvc2l0aW9uKCBldmVudCwgdHJ1ZSApO1xuXHRcdHRoaXMucG9zaXRpb25BYnMgPSB0aGlzLl9jb252ZXJ0UG9zaXRpb25UbyggXCJhYnNvbHV0ZVwiICk7XG5cblx0XHQvL0NhbGwgcGx1Z2lucyBhbmQgY2FsbGJhY2tzIGFuZCB1c2UgdGhlIHJlc3VsdGluZyBwb3NpdGlvbiBpZiBzb21ldGhpbmcgaXMgcmV0dXJuZWRcblx0XHRpZiAoICFub1Byb3BhZ2F0aW9uICkge1xuXHRcdFx0dmFyIHVpID0gdGhpcy5fdWlIYXNoKCk7XG5cdFx0XHRpZiAoIHRoaXMuX3RyaWdnZXIoIFwiZHJhZ1wiLCBldmVudCwgdWkgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHRoaXMuX21vdXNlVXAoIG5ldyAkLkV2ZW50KCBcIm1vdXNldXBcIiwgZXZlbnQgKSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBvc2l0aW9uID0gdWkucG9zaXRpb247XG5cdFx0fVxuXG5cdFx0dGhpcy5oZWxwZXJbIDAgXS5zdHlsZS5sZWZ0ID0gdGhpcy5wb3NpdGlvbi5sZWZ0ICsgXCJweFwiO1xuXHRcdHRoaXMuaGVscGVyWyAwIF0uc3R5bGUudG9wID0gdGhpcy5wb3NpdGlvbi50b3AgKyBcInB4XCI7XG5cblx0XHRpZiAoICQudWkuZGRtYW5hZ2VyICkge1xuXHRcdFx0JC51aS5kZG1hbmFnZXIuZHJhZyggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X21vdXNlU3RvcDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0Ly9JZiB3ZSBhcmUgdXNpbmcgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIGFib3V0IHRoZSBkcm9wXG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0ZHJvcHBlZCA9IGZhbHNlO1xuXHRcdGlmICggJC51aS5kZG1hbmFnZXIgJiYgIXRoaXMub3B0aW9ucy5kcm9wQmVoYXZpb3VyICkge1xuXHRcdFx0ZHJvcHBlZCA9ICQudWkuZGRtYW5hZ2VyLmRyb3AoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0Ly9pZiBhIGRyb3AgY29tZXMgZnJvbSBvdXRzaWRlIChhIHNvcnRhYmxlKVxuXHRcdGlmICggdGhpcy5kcm9wcGVkICkge1xuXHRcdFx0ZHJvcHBlZCA9IHRoaXMuZHJvcHBlZDtcblx0XHRcdHRoaXMuZHJvcHBlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICggKCB0aGlzLm9wdGlvbnMucmV2ZXJ0ID09PSBcImludmFsaWRcIiAmJiAhZHJvcHBlZCApIHx8XG5cdFx0XHRcdCggdGhpcy5vcHRpb25zLnJldmVydCA9PT0gXCJ2YWxpZFwiICYmIGRyb3BwZWQgKSB8fFxuXHRcdFx0XHR0aGlzLm9wdGlvbnMucmV2ZXJ0ID09PSB0cnVlIHx8ICggJC5pc0Z1bmN0aW9uKCB0aGlzLm9wdGlvbnMucmV2ZXJ0ICkgJiZcblx0XHRcdFx0dGhpcy5vcHRpb25zLnJldmVydC5jYWxsKCB0aGlzLmVsZW1lbnQsIGRyb3BwZWQgKSApXG5cdFx0KSB7XG5cdFx0XHQkKCB0aGlzLmhlbHBlciApLmFuaW1hdGUoXG5cdFx0XHRcdHRoaXMub3JpZ2luYWxQb3NpdGlvbixcblx0XHRcdFx0cGFyc2VJbnQoIHRoaXMub3B0aW9ucy5yZXZlcnREdXJhdGlvbiwgMTAgKSxcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGF0Ll90cmlnZ2VyKCBcInN0b3BcIiwgZXZlbnQgKSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHR0aGF0Ll9jbGVhcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCB0aGlzLl90cmlnZ2VyKCBcInN0b3BcIiwgZXZlbnQgKSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdHRoaXMuX2NsZWFyKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9tb3VzZVVwOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dGhpcy5fdW5ibG9ja0ZyYW1lcygpO1xuXG5cdFx0Ly8gSWYgdGhlIGRkbWFuYWdlciBpcyB1c2VkIGZvciBkcm9wcGFibGVzLCBpbmZvcm0gdGhlIG1hbmFnZXIgdGhhdCBkcmFnZ2luZyBoYXMgc3RvcHBlZFxuXHRcdC8vIChzZWUgIzUwMDMpXG5cdFx0aWYgKCAkLnVpLmRkbWFuYWdlciApIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLmRyYWdTdG9wKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdC8vIE9ubHkgbmVlZCB0byBmb2N1cyBpZiB0aGUgZXZlbnQgb2NjdXJyZWQgb24gdGhlIGRyYWdnYWJsZSBpdHNlbGYsIHNlZSAjMTA1Mjdcblx0XHRpZiAoIHRoaXMuaGFuZGxlRWxlbWVudC5pcyggZXZlbnQudGFyZ2V0ICkgKSB7XG5cblx0XHRcdC8vIFRoZSBpbnRlcmFjdGlvbiBpcyBvdmVyOyB3aGV0aGVyIG9yIG5vdCB0aGUgY2xpY2sgcmVzdWx0ZWQgaW4gYSBkcmFnLFxuXHRcdFx0Ly8gZm9jdXMgdGhlIGVsZW1lbnRcblx0XHRcdHRoaXMuZWxlbWVudC50cmlnZ2VyKCBcImZvY3VzXCIgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJC51aS5tb3VzZS5wcm90b3R5cGUuX21vdXNlVXAuY2FsbCggdGhpcywgZXZlbnQgKTtcblx0fSxcblxuXHRjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYgKCB0aGlzLmhlbHBlci5pcyggXCIudWktZHJhZ2dhYmxlLWRyYWdnaW5nXCIgKSApIHtcblx0XHRcdHRoaXMuX21vdXNlVXAoIG5ldyAkLkV2ZW50KCBcIm1vdXNldXBcIiwgeyB0YXJnZXQ6IHRoaXMuZWxlbWVudFsgMCBdIH0gKSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jbGVhcigpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0X2dldEhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaGFuZGxlID9cblx0XHRcdCEhJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggdGhpcy5lbGVtZW50LmZpbmQoIHRoaXMub3B0aW9ucy5oYW5kbGUgKSApLmxlbmd0aCA6XG5cdFx0XHR0cnVlO1xuXHR9LFxuXG5cdF9zZXRIYW5kbGVDbGFzc05hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGFuZGxlRWxlbWVudCA9IHRoaXMub3B0aW9ucy5oYW5kbGUgP1xuXHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoIHRoaXMub3B0aW9ucy5oYW5kbGUgKSA6IHRoaXMuZWxlbWVudDtcblx0XHR0aGlzLl9hZGRDbGFzcyggdGhpcy5oYW5kbGVFbGVtZW50LCBcInVpLWRyYWdnYWJsZS1oYW5kbGVcIiApO1xuXHR9LFxuXG5cdF9yZW1vdmVIYW5kbGVDbGFzc05hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmhhbmRsZUVsZW1lbnQsIFwidWktZHJhZ2dhYmxlLWhhbmRsZVwiICk7XG5cdH0sXG5cblx0X2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRoZWxwZXJJc0Z1bmN0aW9uID0gJC5pc0Z1bmN0aW9uKCBvLmhlbHBlciApLFxuXHRcdFx0aGVscGVyID0gaGVscGVySXNGdW5jdGlvbiA/XG5cdFx0XHRcdCQoIG8uaGVscGVyLmFwcGx5KCB0aGlzLmVsZW1lbnRbIDAgXSwgWyBldmVudCBdICkgKSA6XG5cdFx0XHRcdCggby5oZWxwZXIgPT09IFwiY2xvbmVcIiA/XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50LmNsb25lKCkucmVtb3ZlQXR0ciggXCJpZFwiICkgOlxuXHRcdFx0XHRcdHRoaXMuZWxlbWVudCApO1xuXG5cdFx0aWYgKCAhaGVscGVyLnBhcmVudHMoIFwiYm9keVwiICkubGVuZ3RoICkge1xuXHRcdFx0aGVscGVyLmFwcGVuZFRvKCAoIG8uYXBwZW5kVG8gPT09IFwicGFyZW50XCIgP1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlIDpcblx0XHRcdFx0by5hcHBlbmRUbyApICk7XG5cdFx0fVxuXG5cdFx0Ly8gSHR0cDovL2J1Z3MuanF1ZXJ5dWkuY29tL3RpY2tldC85NDQ2XG5cdFx0Ly8gYSBoZWxwZXIgZnVuY3Rpb24gY2FuIHJldHVybiB0aGUgb3JpZ2luYWwgZWxlbWVudFxuXHRcdC8vIHdoaWNoIHdvdWxkbid0IGhhdmUgYmVlbiBzZXQgdG8gcmVsYXRpdmUgaW4gX2NyZWF0ZVxuXHRcdGlmICggaGVscGVySXNGdW5jdGlvbiAmJiBoZWxwZXJbIDAgXSA9PT0gdGhpcy5lbGVtZW50WyAwIF0gKSB7XG5cdFx0XHR0aGlzLl9zZXRQb3NpdGlvblJlbGF0aXZlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCBoZWxwZXJbIDAgXSAhPT0gdGhpcy5lbGVtZW50WyAwIF0gJiZcblx0XHRcdFx0ISggLyhmaXhlZHxhYnNvbHV0ZSkvICkudGVzdCggaGVscGVyLmNzcyggXCJwb3NpdGlvblwiICkgKSApIHtcblx0XHRcdGhlbHBlci5jc3MoIFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhlbHBlcjtcblxuXHR9LFxuXG5cdF9zZXRQb3NpdGlvblJlbGF0aXZlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICEoIC9eKD86cnxhfGYpLyApLnRlc3QoIHRoaXMuZWxlbWVudC5jc3MoIFwicG9zaXRpb25cIiApICkgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnRbIDAgXS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cdH0sXG5cblx0X2FkanVzdE9mZnNldEZyb21IZWxwZXI6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0aWYgKCB0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gb2JqLnNwbGl0KCBcIiBcIiApO1xuXHRcdH1cblx0XHRpZiAoICQuaXNBcnJheSggb2JqICkgKSB7XG5cdFx0XHRvYmogPSB7IGxlZnQ6ICtvYmpbIDAgXSwgdG9wOiArb2JqWyAxIF0gfHwgMCB9O1xuXHRcdH1cblx0XHRpZiAoIFwibGVmdFwiIGluIG9iaiApIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPSBvYmoubGVmdCArIHRoaXMubWFyZ2lucy5sZWZ0O1xuXHRcdH1cblx0XHRpZiAoIFwicmlnaHRcIiBpbiBvYmogKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay5sZWZ0ID0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIG9iai5yaWdodCArIHRoaXMubWFyZ2lucy5sZWZ0O1xuXHRcdH1cblx0XHRpZiAoIFwidG9wXCIgaW4gb2JqICkge1xuXHRcdFx0dGhpcy5vZmZzZXQuY2xpY2sudG9wID0gb2JqLnRvcCArIHRoaXMubWFyZ2lucy50b3A7XG5cdFx0fVxuXHRcdGlmICggXCJib3R0b21cIiBpbiBvYmogKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay50b3AgPSB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtIG9iai5ib3R0b20gKyB0aGlzLm1hcmdpbnMudG9wO1xuXHRcdH1cblx0fSxcblxuXHRfaXNSb290Tm9kZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuICggLyhodG1sfGJvZHkpL2kgKS50ZXN0KCBlbGVtZW50LnRhZ05hbWUgKSB8fCBlbGVtZW50ID09PSB0aGlzLmRvY3VtZW50WyAwIF07XG5cdH0sXG5cblx0X2dldFBhcmVudE9mZnNldDogZnVuY3Rpb24oKSB7XG5cblx0XHQvL0dldCB0aGUgb2Zmc2V0UGFyZW50IGFuZCBjYWNoZSBpdHMgcG9zaXRpb25cblx0XHR2YXIgcG8gPSB0aGlzLm9mZnNldFBhcmVudC5vZmZzZXQoKSxcblx0XHRcdGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudFsgMCBdO1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBuZWVkIHRvIG1vZGlmeSBhIG9mZnNldCBjYWxjdWxhdGVkIG9uIHN0YXJ0LCBzaW5jZSB0aGVcblx0XHQvLyBmb2xsb3dpbmcgaGFwcGVuZWQ6XG5cdFx0Ly8gMS4gVGhlIHBvc2l0aW9uIG9mIHRoZSBoZWxwZXIgaXMgYWJzb2x1dGUsIHNvIGl0J3MgcG9zaXRpb24gaXMgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGVcblx0XHQvLyBuZXh0IHBvc2l0aW9uZWQgcGFyZW50XG5cdFx0Ly8gMi4gVGhlIGFjdHVhbCBvZmZzZXQgcGFyZW50IGlzIGEgY2hpbGQgb2YgdGhlIHNjcm9sbCBwYXJlbnQsIGFuZCB0aGUgc2Nyb2xsIHBhcmVudCBpc24ndFxuXHRcdC8vIHRoZSBkb2N1bWVudCwgd2hpY2ggbWVhbnMgdGhhdCB0aGUgc2Nyb2xsIGlzIGluY2x1ZGVkIGluIHRoZSBpbml0aWFsIGNhbGN1bGF0aW9uIG9mIHRoZVxuXHRcdC8vIG9mZnNldCBvZiB0aGUgcGFyZW50LCBhbmQgbmV2ZXIgcmVjYWxjdWxhdGVkIHVwb24gZHJhZ1xuXHRcdGlmICggdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiICYmIHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0gIT09IGRvY3VtZW50ICYmXG5cdFx0XHRcdCQuY29udGFpbnMoIHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0sIHRoaXMub2Zmc2V0UGFyZW50WyAwIF0gKSApIHtcblx0XHRcdHBvLmxlZnQgKz0gdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpO1xuXHRcdFx0cG8udG9wICs9IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5faXNSb290Tm9kZSggdGhpcy5vZmZzZXRQYXJlbnRbIDAgXSApICkge1xuXHRcdFx0cG8gPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHBvLnRvcCArICggcGFyc2VJbnQoIHRoaXMub2Zmc2V0UGFyZW50LmNzcyggXCJib3JkZXJUb3BXaWR0aFwiICksIDEwICkgfHwgMCApLFxuXHRcdFx0bGVmdDogcG8ubGVmdCArICggcGFyc2VJbnQoIHRoaXMub2Zmc2V0UGFyZW50LmNzcyggXCJib3JkZXJMZWZ0V2lkdGhcIiApLCAxMCApIHx8IDAgKVxuXHRcdH07XG5cblx0fSxcblxuXHRfZ2V0UmVsYXRpdmVPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggdGhpcy5jc3NQb3NpdGlvbiAhPT0gXCJyZWxhdGl2ZVwiICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0dmFyIHAgPSB0aGlzLmVsZW1lbnQucG9zaXRpb24oKSxcblx0XHRcdHNjcm9sbElzUm9vdE5vZGUgPSB0aGlzLl9pc1Jvb3ROb2RlKCB0aGlzLnNjcm9sbFBhcmVudFsgMCBdICk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBwLnRvcCAtICggcGFyc2VJbnQoIHRoaXMuaGVscGVyLmNzcyggXCJ0b3BcIiApLCAxMCApIHx8IDAgKSArXG5cdFx0XHRcdCggIXNjcm9sbElzUm9vdE5vZGUgPyB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSA6IDAgKSxcblx0XHRcdGxlZnQ6IHAubGVmdCAtICggcGFyc2VJbnQoIHRoaXMuaGVscGVyLmNzcyggXCJsZWZ0XCIgKSwgMTAgKSB8fCAwICkgK1xuXHRcdFx0XHQoICFzY3JvbGxJc1Jvb3ROb2RlID8gdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpIDogMCApXG5cdFx0fTtcblxuXHR9LFxuXG5cdF9jYWNoZU1hcmdpbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMubWFyZ2lucyA9IHtcblx0XHRcdGxlZnQ6ICggcGFyc2VJbnQoIHRoaXMuZWxlbWVudC5jc3MoIFwibWFyZ2luTGVmdFwiICksIDEwICkgfHwgMCApLFxuXHRcdFx0dG9wOiAoIHBhcnNlSW50KCB0aGlzLmVsZW1lbnQuY3NzKCBcIm1hcmdpblRvcFwiICksIDEwICkgfHwgMCApLFxuXHRcdFx0cmlnaHQ6ICggcGFyc2VJbnQoIHRoaXMuZWxlbWVudC5jc3MoIFwibWFyZ2luUmlnaHRcIiApLCAxMCApIHx8IDAgKSxcblx0XHRcdGJvdHRvbTogKCBwYXJzZUludCggdGhpcy5lbGVtZW50LmNzcyggXCJtYXJnaW5Cb3R0b21cIiApLCAxMCApIHx8IDAgKVxuXHRcdH07XG5cdH0sXG5cblx0X2NhY2hlSGVscGVyUHJvcG9ydGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVscGVyUHJvcG9ydGlvbnMgPSB7XG5cdFx0XHR3aWR0aDogdGhpcy5oZWxwZXIub3V0ZXJXaWR0aCgpLFxuXHRcdFx0aGVpZ2h0OiB0aGlzLmhlbHBlci5vdXRlckhlaWdodCgpXG5cdFx0fTtcblx0fSxcblxuXHRfc2V0Q29udGFpbm1lbnQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGlzVXNlclNjcm9sbGFibGUsIGMsIGNlLFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudFsgMCBdO1xuXG5cdFx0dGhpcy5yZWxhdGl2ZUNvbnRhaW5lciA9IG51bGw7XG5cblx0XHRpZiAoICFvLmNvbnRhaW5tZW50ICkge1xuXHRcdFx0dGhpcy5jb250YWlubWVudCA9IG51bGw7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBvLmNvbnRhaW5tZW50ID09PSBcIndpbmRvd1wiICkge1xuXHRcdFx0dGhpcy5jb250YWlubWVudCA9IFtcblx0XHRcdFx0JCggd2luZG93ICkuc2Nyb2xsTGVmdCgpIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAtIHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0LFxuXHRcdFx0XHQkKCB3aW5kb3cgKS5zY3JvbGxUb3AoKSAtIHRoaXMub2Zmc2V0LnJlbGF0aXZlLnRvcCAtIHRoaXMub2Zmc2V0LnBhcmVudC50b3AsXG5cdFx0XHRcdCQoIHdpbmRvdyApLnNjcm9sbExlZnQoKSArICQoIHdpbmRvdyApLndpZHRoKCkgLVxuXHRcdFx0XHRcdHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSB0aGlzLm1hcmdpbnMubGVmdCxcblx0XHRcdFx0JCggd2luZG93ICkuc2Nyb2xsVG9wKCkgK1xuXHRcdFx0XHRcdCggJCggd2luZG93ICkuaGVpZ2h0KCkgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbEhlaWdodCApIC1cblx0XHRcdFx0XHR0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtIHRoaXMubWFyZ2lucy50b3Bcblx0XHRcdF07XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBvLmNvbnRhaW5tZW50ID09PSBcImRvY3VtZW50XCIgKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gW1xuXHRcdFx0XHQwLFxuXHRcdFx0XHQwLFxuXHRcdFx0XHQkKCBkb2N1bWVudCApLndpZHRoKCkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC0gdGhpcy5tYXJnaW5zLmxlZnQsXG5cdFx0XHRcdCggJCggZG9jdW1lbnQgKS5oZWlnaHQoKSB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuc2Nyb2xsSGVpZ2h0ICkgLVxuXHRcdFx0XHRcdHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gdGhpcy5tYXJnaW5zLnRvcFxuXHRcdFx0XTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG8uY29udGFpbm1lbnQuY29uc3RydWN0b3IgPT09IEFycmF5ICkge1xuXHRcdFx0dGhpcy5jb250YWlubWVudCA9IG8uY29udGFpbm1lbnQ7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBvLmNvbnRhaW5tZW50ID09PSBcInBhcmVudFwiICkge1xuXHRcdFx0by5jb250YWlubWVudCA9IHRoaXMuaGVscGVyWyAwIF0ucGFyZW50Tm9kZTtcblx0XHR9XG5cblx0XHRjID0gJCggby5jb250YWlubWVudCApO1xuXHRcdGNlID0gY1sgMCBdO1xuXG5cdFx0aWYgKCAhY2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNVc2VyU2Nyb2xsYWJsZSA9IC8oc2Nyb2xsfGF1dG8pLy50ZXN0KCBjLmNzcyggXCJvdmVyZmxvd1wiICkgKTtcblxuXHRcdHRoaXMuY29udGFpbm1lbnQgPSBbXG5cdFx0XHQoIHBhcnNlSW50KCBjLmNzcyggXCJib3JkZXJMZWZ0V2lkdGhcIiApLCAxMCApIHx8IDAgKSArXG5cdFx0XHRcdCggcGFyc2VJbnQoIGMuY3NzKCBcInBhZGRpbmdMZWZ0XCIgKSwgMTAgKSB8fCAwICksXG5cdFx0XHQoIHBhcnNlSW50KCBjLmNzcyggXCJib3JkZXJUb3BXaWR0aFwiICksIDEwICkgfHwgMCApICtcblx0XHRcdFx0KCBwYXJzZUludCggYy5jc3MoIFwicGFkZGluZ1RvcFwiICksIDEwICkgfHwgMCApLFxuXHRcdFx0KCBpc1VzZXJTY3JvbGxhYmxlID8gTWF0aC5tYXgoIGNlLnNjcm9sbFdpZHRoLCBjZS5vZmZzZXRXaWR0aCApIDogY2Uub2Zmc2V0V2lkdGggKSAtXG5cdFx0XHRcdCggcGFyc2VJbnQoIGMuY3NzKCBcImJvcmRlclJpZ2h0V2lkdGhcIiApLCAxMCApIHx8IDAgKSAtXG5cdFx0XHRcdCggcGFyc2VJbnQoIGMuY3NzKCBcInBhZGRpbmdSaWdodFwiICksIDEwICkgfHwgMCApIC1cblx0XHRcdFx0dGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtXG5cdFx0XHRcdHRoaXMubWFyZ2lucy5sZWZ0IC1cblx0XHRcdFx0dGhpcy5tYXJnaW5zLnJpZ2h0LFxuXHRcdFx0KCBpc1VzZXJTY3JvbGxhYmxlID8gTWF0aC5tYXgoIGNlLnNjcm9sbEhlaWdodCwgY2Uub2Zmc2V0SGVpZ2h0ICkgOiBjZS5vZmZzZXRIZWlnaHQgKSAtXG5cdFx0XHRcdCggcGFyc2VJbnQoIGMuY3NzKCBcImJvcmRlckJvdHRvbVdpZHRoXCIgKSwgMTAgKSB8fCAwICkgLVxuXHRcdFx0XHQoIHBhcnNlSW50KCBjLmNzcyggXCJwYWRkaW5nQm90dG9tXCIgKSwgMTAgKSB8fCAwICkgLVxuXHRcdFx0XHR0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtXG5cdFx0XHRcdHRoaXMubWFyZ2lucy50b3AgLVxuXHRcdFx0XHR0aGlzLm1hcmdpbnMuYm90dG9tXG5cdFx0XTtcblx0XHR0aGlzLnJlbGF0aXZlQ29udGFpbmVyID0gYztcblx0fSxcblxuXHRfY29udmVydFBvc2l0aW9uVG86IGZ1bmN0aW9uKCBkLCBwb3MgKSB7XG5cblx0XHRpZiAoICFwb3MgKSB7XG5cdFx0XHRwb3MgPSB0aGlzLnBvc2l0aW9uO1xuXHRcdH1cblxuXHRcdHZhciBtb2QgPSBkID09PSBcImFic29sdXRlXCIgPyAxIDogLTEsXG5cdFx0XHRzY3JvbGxJc1Jvb3ROb2RlID0gdGhpcy5faXNSb290Tm9kZSggdGhpcy5zY3JvbGxQYXJlbnRbIDAgXSApO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogKFxuXG5cdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHRwb3MudG9wXHQrXG5cblx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLnRvcCAqIG1vZCArXG5cblx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0dGhpcy5vZmZzZXQucGFyZW50LnRvcCAqIG1vZCAtXG5cdFx0XHRcdCggKCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgP1xuXHRcdFx0XHRcdC10aGlzLm9mZnNldC5zY3JvbGwudG9wIDpcblx0XHRcdFx0XHQoIHNjcm9sbElzUm9vdE5vZGUgPyAwIDogdGhpcy5vZmZzZXQuc2Nyb2xsLnRvcCApICkgKiBtb2QgKVxuXHRcdFx0KSxcblx0XHRcdGxlZnQ6IChcblxuXHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0cG9zLmxlZnQgK1xuXG5cdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHR0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0ICogbW9kICtcblxuXHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQubGVmdCAqIG1vZFx0LVxuXHRcdFx0XHQoICggdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJmaXhlZFwiID9cblx0XHRcdFx0XHQtdGhpcy5vZmZzZXQuc2Nyb2xsLmxlZnQgOlxuXHRcdFx0XHRcdCggc2Nyb2xsSXNSb290Tm9kZSA/IDAgOiB0aGlzLm9mZnNldC5zY3JvbGwubGVmdCApICkgKiBtb2QgKVxuXHRcdFx0KVxuXHRcdH07XG5cblx0fSxcblxuXHRfZ2VuZXJhdGVQb3NpdGlvbjogZnVuY3Rpb24oIGV2ZW50LCBjb25zdHJhaW5Qb3NpdGlvbiApIHtcblxuXHRcdHZhciBjb250YWlubWVudCwgY28sIHRvcCwgbGVmdCxcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRzY3JvbGxJc1Jvb3ROb2RlID0gdGhpcy5faXNSb290Tm9kZSggdGhpcy5zY3JvbGxQYXJlbnRbIDAgXSApLFxuXHRcdFx0cGFnZVggPSBldmVudC5wYWdlWCxcblx0XHRcdHBhZ2VZID0gZXZlbnQucGFnZVk7XG5cblx0XHQvLyBDYWNoZSB0aGUgc2Nyb2xsXG5cdFx0aWYgKCAhc2Nyb2xsSXNSb290Tm9kZSB8fCAhdGhpcy5vZmZzZXQuc2Nyb2xsICkge1xuXHRcdFx0dGhpcy5vZmZzZXQuc2Nyb2xsID0ge1xuXHRcdFx0XHR0b3A6IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpLFxuXHRcdFx0XHRsZWZ0OiB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KClcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Lypcblx0XHQgKiAtIFBvc2l0aW9uIGNvbnN0cmFpbmluZyAtXG5cdFx0ICogQ29uc3RyYWluIHRoZSBwb3NpdGlvbiB0byBhIG1peCBvZiBncmlkLCBjb250YWlubWVudC5cblx0XHQgKi9cblxuXHRcdC8vIElmIHdlIGFyZSBub3QgZHJhZ2dpbmcgeWV0LCB3ZSB3b24ndCBjaGVjayBmb3Igb3B0aW9uc1xuXHRcdGlmICggY29uc3RyYWluUG9zaXRpb24gKSB7XG5cdFx0XHRpZiAoIHRoaXMuY29udGFpbm1lbnQgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5yZWxhdGl2ZUNvbnRhaW5lciApIHtcblx0XHRcdFx0XHRjbyA9IHRoaXMucmVsYXRpdmVDb250YWluZXIub2Zmc2V0KCk7XG5cdFx0XHRcdFx0Y29udGFpbm1lbnQgPSBbXG5cdFx0XHRcdFx0XHR0aGlzLmNvbnRhaW5tZW50WyAwIF0gKyBjby5sZWZ0LFxuXHRcdFx0XHRcdFx0dGhpcy5jb250YWlubWVudFsgMSBdICsgY28udG9wLFxuXHRcdFx0XHRcdFx0dGhpcy5jb250YWlubWVudFsgMiBdICsgY28ubGVmdCxcblx0XHRcdFx0XHRcdHRoaXMuY29udGFpbm1lbnRbIDMgXSArIGNvLnRvcFxuXHRcdFx0XHRcdF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGFpbm1lbnQgPSB0aGlzLmNvbnRhaW5tZW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPCBjb250YWlubWVudFsgMCBdICkge1xuXHRcdFx0XHRcdHBhZ2VYID0gY29udGFpbm1lbnRbIDAgXSArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA8IGNvbnRhaW5tZW50WyAxIF0gKSB7XG5cdFx0XHRcdFx0cGFnZVkgPSBjb250YWlubWVudFsgMSBdICsgdGhpcy5vZmZzZXQuY2xpY2sudG9wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID4gY29udGFpbm1lbnRbIDIgXSApIHtcblx0XHRcdFx0XHRwYWdlWCA9IGNvbnRhaW5tZW50WyAyIF0gKyB0aGlzLm9mZnNldC5jbGljay5sZWZ0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPiBjb250YWlubWVudFsgMyBdICkge1xuXHRcdFx0XHRcdHBhZ2VZID0gY29udGFpbm1lbnRbIDMgXSArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG8uZ3JpZCApIHtcblxuXHRcdFx0XHQvL0NoZWNrIGZvciBncmlkIGVsZW1lbnRzIHNldCB0byAwIHRvIHByZXZlbnQgZGl2aWRlIGJ5IDAgZXJyb3IgY2F1c2luZyBpbnZhbGlkXG5cdFx0XHRcdC8vIGFyZ3VtZW50IGVycm9ycyBpbiBJRSAoc2VlIHRpY2tldCAjNjk1MClcblx0XHRcdFx0dG9wID0gby5ncmlkWyAxIF0gPyB0aGlzLm9yaWdpbmFsUGFnZVkgKyBNYXRoLnJvdW5kKCAoIHBhZ2VZIC1cblx0XHRcdFx0XHR0aGlzLm9yaWdpbmFsUGFnZVkgKSAvIG8uZ3JpZFsgMSBdICkgKiBvLmdyaWRbIDEgXSA6IHRoaXMub3JpZ2luYWxQYWdlWTtcblx0XHRcdFx0cGFnZVkgPSBjb250YWlubWVudCA/ICggKCB0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPj0gY29udGFpbm1lbnRbIDEgXSB8fFxuXHRcdFx0XHRcdHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+IGNvbnRhaW5tZW50WyAzIF0gKSA/XG5cdFx0XHRcdFx0XHR0b3AgOlxuXHRcdFx0XHRcdFx0KCAoIHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+PSBjb250YWlubWVudFsgMSBdICkgP1xuXHRcdFx0XHRcdFx0XHR0b3AgLSBvLmdyaWRbIDEgXSA6IHRvcCArIG8uZ3JpZFsgMSBdICkgKSA6IHRvcDtcblxuXHRcdFx0XHRsZWZ0ID0gby5ncmlkWyAwIF0gPyB0aGlzLm9yaWdpbmFsUGFnZVggK1xuXHRcdFx0XHRcdE1hdGgucm91bmQoICggcGFnZVggLSB0aGlzLm9yaWdpbmFsUGFnZVggKSAvIG8uZ3JpZFsgMCBdICkgKiBvLmdyaWRbIDAgXSA6XG5cdFx0XHRcdFx0dGhpcy5vcmlnaW5hbFBhZ2VYO1xuXHRcdFx0XHRwYWdlWCA9IGNvbnRhaW5tZW50ID8gKCAoIGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID49IGNvbnRhaW5tZW50WyAwIF0gfHxcblx0XHRcdFx0XHRsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+IGNvbnRhaW5tZW50WyAyIF0gKSA/XG5cdFx0XHRcdFx0XHRsZWZ0IDpcblx0XHRcdFx0XHRcdCggKCBsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+PSBjb250YWlubWVudFsgMCBdICkgP1xuXHRcdFx0XHRcdFx0XHRsZWZ0IC0gby5ncmlkWyAwIF0gOiBsZWZ0ICsgby5ncmlkWyAwIF0gKSApIDogbGVmdDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvLmF4aXMgPT09IFwieVwiICkge1xuXHRcdFx0XHRwYWdlWCA9IHRoaXMub3JpZ2luYWxQYWdlWDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvLmF4aXMgPT09IFwieFwiICkge1xuXHRcdFx0XHRwYWdlWSA9IHRoaXMub3JpZ2luYWxQYWdlWTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiAoXG5cblx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdHBhZ2VZIC1cblxuXHRcdFx0XHQvLyBDbGljayBvZmZzZXQgKHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50KVxuXHRcdFx0XHR0aGlzLm9mZnNldC5jbGljay50b3AgLVxuXG5cdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHR0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3AgLVxuXG5cdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudC50b3AgK1xuXHRcdFx0XHQoIHRoaXMuY3NzUG9zaXRpb24gPT09IFwiZml4ZWRcIiA/XG5cdFx0XHRcdFx0LXRoaXMub2Zmc2V0LnNjcm9sbC50b3AgOlxuXHRcdFx0XHRcdCggc2Nyb2xsSXNSb290Tm9kZSA/IDAgOiB0aGlzLm9mZnNldC5zY3JvbGwudG9wICkgKVxuXHRcdFx0KSxcblx0XHRcdGxlZnQ6IChcblxuXHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0cGFnZVggLVxuXG5cdFx0XHRcdC8vIENsaWNrIG9mZnNldCAocmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQpXG5cdFx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgLVxuXG5cdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHR0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0IC1cblxuXHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQubGVmdCArXG5cdFx0XHRcdCggdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJmaXhlZFwiID9cblx0XHRcdFx0XHQtdGhpcy5vZmZzZXQuc2Nyb2xsLmxlZnQgOlxuXHRcdFx0XHRcdCggc2Nyb2xsSXNSb290Tm9kZSA/IDAgOiB0aGlzLm9mZnNldC5zY3JvbGwubGVmdCApIClcblx0XHRcdClcblx0XHR9O1xuXG5cdH0sXG5cblx0X2NsZWFyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9yZW1vdmVDbGFzcyggdGhpcy5oZWxwZXIsIFwidWktZHJhZ2dhYmxlLWRyYWdnaW5nXCIgKTtcblx0XHRpZiAoIHRoaXMuaGVscGVyWyAwIF0gIT09IHRoaXMuZWxlbWVudFsgMCBdICYmICF0aGlzLmNhbmNlbEhlbHBlclJlbW92YWwgKSB7XG5cdFx0XHR0aGlzLmhlbHBlci5yZW1vdmUoKTtcblx0XHR9XG5cdFx0dGhpcy5oZWxwZXIgPSBudWxsO1xuXHRcdHRoaXMuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IGZhbHNlO1xuXHRcdGlmICggdGhpcy5kZXN0cm95T25DbGVhciApIHtcblx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBGcm9tIG5vdyBvbiBidWxrIHN0dWZmIC0gbWFpbmx5IGhlbHBlcnNcblxuXHRfdHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCB1aSApIHtcblx0XHR1aSA9IHVpIHx8IHRoaXMuX3VpSGFzaCgpO1xuXHRcdCQudWkucGx1Z2luLmNhbGwoIHRoaXMsIHR5cGUsIFsgZXZlbnQsIHVpLCB0aGlzIF0sIHRydWUgKTtcblxuXHRcdC8vIEFic29sdXRlIHBvc2l0aW9uIGFuZCBvZmZzZXQgKHNlZSAjNjg4NCApIGhhdmUgdG8gYmUgcmVjYWxjdWxhdGVkIGFmdGVyIHBsdWdpbnNcblx0XHRpZiAoIC9eKGRyYWd8c3RhcnR8c3RvcCkvLnRlc3QoIHR5cGUgKSApIHtcblx0XHRcdHRoaXMucG9zaXRpb25BYnMgPSB0aGlzLl9jb252ZXJ0UG9zaXRpb25UbyggXCJhYnNvbHV0ZVwiICk7XG5cdFx0XHR1aS5vZmZzZXQgPSB0aGlzLnBvc2l0aW9uQWJzO1xuXHRcdH1cblx0XHRyZXR1cm4gJC5XaWRnZXQucHJvdG90eXBlLl90cmlnZ2VyLmNhbGwoIHRoaXMsIHR5cGUsIGV2ZW50LCB1aSApO1xuXHR9LFxuXG5cdHBsdWdpbnM6IHt9LFxuXG5cdF91aUhhc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRoZWxwZXI6IHRoaXMuaGVscGVyLFxuXHRcdFx0cG9zaXRpb246IHRoaXMucG9zaXRpb24sXG5cdFx0XHRvcmlnaW5hbFBvc2l0aW9uOiB0aGlzLm9yaWdpbmFsUG9zaXRpb24sXG5cdFx0XHRvZmZzZXQ6IHRoaXMucG9zaXRpb25BYnNcblx0XHR9O1xuXHR9XG5cbn0gKTtcblxuJC51aS5wbHVnaW4uYWRkKCBcImRyYWdnYWJsZVwiLCBcImNvbm5lY3RUb1NvcnRhYmxlXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgdWksIGRyYWdnYWJsZSApIHtcblx0XHR2YXIgdWlTb3J0YWJsZSA9ICQuZXh0ZW5kKCB7fSwgdWksIHtcblx0XHRcdGl0ZW06IGRyYWdnYWJsZS5lbGVtZW50XG5cdFx0fSApO1xuXG5cdFx0ZHJhZ2dhYmxlLnNvcnRhYmxlcyA9IFtdO1xuXHRcdCQoIGRyYWdnYWJsZS5vcHRpb25zLmNvbm5lY3RUb1NvcnRhYmxlICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc29ydGFibGUgPSAkKCB0aGlzICkuc29ydGFibGUoIFwiaW5zdGFuY2VcIiApO1xuXG5cdFx0XHRpZiAoIHNvcnRhYmxlICYmICFzb3J0YWJsZS5vcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0XHRkcmFnZ2FibGUuc29ydGFibGVzLnB1c2goIHNvcnRhYmxlICk7XG5cblx0XHRcdFx0Ly8gUmVmcmVzaFBvc2l0aW9ucyBpcyBjYWxsZWQgYXQgZHJhZyBzdGFydCB0byByZWZyZXNoIHRoZSBjb250YWluZXJDYWNoZVxuXHRcdFx0XHQvLyB3aGljaCBpcyB1c2VkIGluIGRyYWcuIFRoaXMgZW5zdXJlcyBpdCdzIGluaXRpYWxpemVkIGFuZCBzeW5jaHJvbml6ZWRcblx0XHRcdFx0Ly8gd2l0aCBhbnkgY2hhbmdlcyB0aGF0IG1pZ2h0IGhhdmUgaGFwcGVuZWQgb24gdGhlIHBhZ2Ugc2luY2UgaW5pdGlhbGl6YXRpb24uXG5cdFx0XHRcdHNvcnRhYmxlLnJlZnJlc2hQb3NpdGlvbnMoKTtcblx0XHRcdFx0c29ydGFibGUuX3RyaWdnZXIoIFwiYWN0aXZhdGVcIiwgZXZlbnQsIHVpU29ydGFibGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCBldmVudCwgdWksIGRyYWdnYWJsZSApIHtcblx0XHR2YXIgdWlTb3J0YWJsZSA9ICQuZXh0ZW5kKCB7fSwgdWksIHtcblx0XHRcdGl0ZW06IGRyYWdnYWJsZS5lbGVtZW50XG5cdFx0fSApO1xuXG5cdFx0ZHJhZ2dhYmxlLmNhbmNlbEhlbHBlclJlbW92YWwgPSBmYWxzZTtcblxuXHRcdCQuZWFjaCggZHJhZ2dhYmxlLnNvcnRhYmxlcywgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc29ydGFibGUgPSB0aGlzO1xuXG5cdFx0XHRpZiAoIHNvcnRhYmxlLmlzT3ZlciApIHtcblx0XHRcdFx0c29ydGFibGUuaXNPdmVyID0gMDtcblxuXHRcdFx0XHQvLyBBbGxvdyB0aGlzIHNvcnRhYmxlIHRvIGhhbmRsZSByZW1vdmluZyB0aGUgaGVscGVyXG5cdFx0XHRcdGRyYWdnYWJsZS5jYW5jZWxIZWxwZXJSZW1vdmFsID0gdHJ1ZTtcblx0XHRcdFx0c29ydGFibGUuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIFVzZSBfc3RvcmVkQ1NTIFRvIHJlc3RvcmUgcHJvcGVydGllcyBpbiB0aGUgc29ydGFibGUsXG5cdFx0XHRcdC8vIGFzIHRoaXMgYWxzbyBoYW5kbGVzIHJldmVydCAoIzk2NzUpIHNpbmNlIHRoZSBkcmFnZ2FibGVcblx0XHRcdFx0Ly8gbWF5IGhhdmUgbW9kaWZpZWQgdGhlbSBpbiB1bmV4cGVjdGVkIHdheXMgKCM4ODA5KVxuXHRcdFx0XHRzb3J0YWJsZS5fc3RvcmVkQ1NTID0ge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBzb3J0YWJsZS5wbGFjZWhvbGRlci5jc3MoIFwicG9zaXRpb25cIiApLFxuXHRcdFx0XHRcdHRvcDogc29ydGFibGUucGxhY2Vob2xkZXIuY3NzKCBcInRvcFwiICksXG5cdFx0XHRcdFx0bGVmdDogc29ydGFibGUucGxhY2Vob2xkZXIuY3NzKCBcImxlZnRcIiApXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0c29ydGFibGUuX21vdXNlU3RvcCggZXZlbnQgKTtcblxuXHRcdFx0XHQvLyBPbmNlIGRyYWcgaGFzIGVuZGVkLCB0aGUgc29ydGFibGUgc2hvdWxkIHJldHVybiB0byB1c2luZ1xuXHRcdFx0XHQvLyBpdHMgb3JpZ2luYWwgaGVscGVyLCBub3QgdGhlIHNoYXJlZCBoZWxwZXIgZnJvbSBkcmFnZ2FibGVcblx0XHRcdFx0c29ydGFibGUub3B0aW9ucy5oZWxwZXIgPSBzb3J0YWJsZS5vcHRpb25zLl9oZWxwZXI7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgdGhpcyBTb3J0YWJsZSBmcm9tIHJlbW92aW5nIHRoZSBoZWxwZXIuXG5cdFx0XHRcdC8vIEhvd2V2ZXIsIGRvbid0IHNldCB0aGUgZHJhZ2dhYmxlIHRvIHJlbW92ZSB0aGUgaGVscGVyXG5cdFx0XHRcdC8vIGVpdGhlciBhcyBhbm90aGVyIGNvbm5lY3RlZCBTb3J0YWJsZSBtYXkgeWV0IGhhbmRsZSB0aGUgcmVtb3ZhbC5cblx0XHRcdFx0c29ydGFibGUuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IHRydWU7XG5cblx0XHRcdFx0c29ydGFibGUuX3RyaWdnZXIoIFwiZGVhY3RpdmF0ZVwiLCBldmVudCwgdWlTb3J0YWJsZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZHJhZzogZnVuY3Rpb24oIGV2ZW50LCB1aSwgZHJhZ2dhYmxlICkge1xuXHRcdCQuZWFjaCggZHJhZ2dhYmxlLnNvcnRhYmxlcywgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gZmFsc2UsXG5cdFx0XHRcdHNvcnRhYmxlID0gdGhpcztcblxuXHRcdFx0Ly8gQ29weSBvdmVyIHZhcmlhYmxlcyB0aGF0IHNvcnRhYmxlJ3MgX2ludGVyc2VjdHNXaXRoIHVzZXNcblx0XHRcdHNvcnRhYmxlLnBvc2l0aW9uQWJzID0gZHJhZ2dhYmxlLnBvc2l0aW9uQWJzO1xuXHRcdFx0c29ydGFibGUuaGVscGVyUHJvcG9ydGlvbnMgPSBkcmFnZ2FibGUuaGVscGVyUHJvcG9ydGlvbnM7XG5cdFx0XHRzb3J0YWJsZS5vZmZzZXQuY2xpY2sgPSBkcmFnZ2FibGUub2Zmc2V0LmNsaWNrO1xuXG5cdFx0XHRpZiAoIHNvcnRhYmxlLl9pbnRlcnNlY3RzV2l0aCggc29ydGFibGUuY29udGFpbmVyQ2FjaGUgKSApIHtcblx0XHRcdFx0aW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gdHJ1ZTtcblxuXHRcdFx0XHQkLmVhY2goIGRyYWdnYWJsZS5zb3J0YWJsZXMsIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0Ly8gQ29weSBvdmVyIHZhcmlhYmxlcyB0aGF0IHNvcnRhYmxlJ3MgX2ludGVyc2VjdHNXaXRoIHVzZXNcblx0XHRcdFx0XHR0aGlzLnBvc2l0aW9uQWJzID0gZHJhZ2dhYmxlLnBvc2l0aW9uQWJzO1xuXHRcdFx0XHRcdHRoaXMuaGVscGVyUHJvcG9ydGlvbnMgPSBkcmFnZ2FibGUuaGVscGVyUHJvcG9ydGlvbnM7XG5cdFx0XHRcdFx0dGhpcy5vZmZzZXQuY2xpY2sgPSBkcmFnZ2FibGUub2Zmc2V0LmNsaWNrO1xuXG5cdFx0XHRcdFx0aWYgKCB0aGlzICE9PSBzb3J0YWJsZSAmJlxuXHRcdFx0XHRcdFx0XHR0aGlzLl9pbnRlcnNlY3RzV2l0aCggdGhpcy5jb250YWluZXJDYWNoZSApICYmXG5cdFx0XHRcdFx0XHRcdCQuY29udGFpbnMoIHNvcnRhYmxlLmVsZW1lbnRbIDAgXSwgdGhpcy5lbGVtZW50WyAwIF0gKSApIHtcblx0XHRcdFx0XHRcdGlubmVybW9zdEludGVyc2VjdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBpbm5lcm1vc3RJbnRlcnNlY3Rpbmc7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpbm5lcm1vc3RJbnRlcnNlY3RpbmcgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaW50ZXJzZWN0cywgd2UgdXNlIGEgbGl0dGxlIGlzT3ZlciB2YXJpYWJsZSBhbmQgc2V0IGl0IG9uY2UsXG5cdFx0XHRcdC8vIHNvIHRoYXQgdGhlIG1vdmUtaW4gc3R1ZmYgZ2V0cyBmaXJlZCBvbmx5IG9uY2UuXG5cdFx0XHRcdGlmICggIXNvcnRhYmxlLmlzT3ZlciApIHtcblx0XHRcdFx0XHRzb3J0YWJsZS5pc092ZXIgPSAxO1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgZHJhZ2dhYmxlJ3MgcGFyZW50IGluIGNhc2Ugd2UgbmVlZCB0byByZWFwcGVuZCB0byBpdCBsYXRlci5cblx0XHRcdFx0XHRkcmFnZ2FibGUuX3BhcmVudCA9IHVpLmhlbHBlci5wYXJlbnQoKTtcblxuXHRcdFx0XHRcdHNvcnRhYmxlLmN1cnJlbnRJdGVtID0gdWkuaGVscGVyXG5cdFx0XHRcdFx0XHQuYXBwZW5kVG8oIHNvcnRhYmxlLmVsZW1lbnQgKVxuXHRcdFx0XHRcdFx0LmRhdGEoIFwidWktc29ydGFibGUtaXRlbVwiLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBoZWxwZXIgb3B0aW9uIHRvIGxhdGVyIHJlc3RvcmUgaXRcblx0XHRcdFx0XHRzb3J0YWJsZS5vcHRpb25zLl9oZWxwZXIgPSBzb3J0YWJsZS5vcHRpb25zLmhlbHBlcjtcblxuXHRcdFx0XHRcdHNvcnRhYmxlLm9wdGlvbnMuaGVscGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdWkuaGVscGVyWyAwIF07XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8vIEZpcmUgdGhlIHN0YXJ0IGV2ZW50cyBvZiB0aGUgc29ydGFibGUgd2l0aCBvdXIgcGFzc2VkIGJyb3dzZXIgZXZlbnQsXG5cdFx0XHRcdFx0Ly8gYW5kIG91ciBvd24gaGVscGVyIChzbyBpdCBkb2Vzbid0IGNyZWF0ZSBhIG5ldyBvbmUpXG5cdFx0XHRcdFx0ZXZlbnQudGFyZ2V0ID0gc29ydGFibGUuY3VycmVudEl0ZW1bIDAgXTtcblx0XHRcdFx0XHRzb3J0YWJsZS5fbW91c2VDYXB0dXJlKCBldmVudCwgdHJ1ZSApO1xuXHRcdFx0XHRcdHNvcnRhYmxlLl9tb3VzZVN0YXJ0KCBldmVudCwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gQmVjYXVzZSB0aGUgYnJvd3NlciBldmVudCBpcyB3YXkgb2ZmIHRoZSBuZXcgYXBwZW5kZWQgcG9ydGxldCxcblx0XHRcdFx0XHQvLyBtb2RpZnkgbmVjZXNzYXJ5IHZhcmlhYmxlcyB0byByZWZsZWN0IHRoZSBjaGFuZ2VzXG5cdFx0XHRcdFx0c29ydGFibGUub2Zmc2V0LmNsaWNrLnRvcCA9IGRyYWdnYWJsZS5vZmZzZXQuY2xpY2sudG9wO1xuXHRcdFx0XHRcdHNvcnRhYmxlLm9mZnNldC5jbGljay5sZWZ0ID0gZHJhZ2dhYmxlLm9mZnNldC5jbGljay5sZWZ0O1xuXHRcdFx0XHRcdHNvcnRhYmxlLm9mZnNldC5wYXJlbnQubGVmdCAtPSBkcmFnZ2FibGUub2Zmc2V0LnBhcmVudC5sZWZ0IC1cblx0XHRcdFx0XHRcdHNvcnRhYmxlLm9mZnNldC5wYXJlbnQubGVmdDtcblx0XHRcdFx0XHRzb3J0YWJsZS5vZmZzZXQucGFyZW50LnRvcCAtPSBkcmFnZ2FibGUub2Zmc2V0LnBhcmVudC50b3AgLVxuXHRcdFx0XHRcdFx0c29ydGFibGUub2Zmc2V0LnBhcmVudC50b3A7XG5cblx0XHRcdFx0XHRkcmFnZ2FibGUuX3RyaWdnZXIoIFwidG9Tb3J0YWJsZVwiLCBldmVudCApO1xuXG5cdFx0XHRcdFx0Ly8gSW5mb3JtIGRyYWdnYWJsZSB0aGF0IHRoZSBoZWxwZXIgaXMgaW4gYSB2YWxpZCBkcm9wIHpvbmUsXG5cdFx0XHRcdFx0Ly8gdXNlZCBzb2xlbHkgaW4gdGhlIHJldmVydCBvcHRpb24gdG8gaGFuZGxlIFwidmFsaWQvaW52YWxpZFwiLlxuXHRcdFx0XHRcdGRyYWdnYWJsZS5kcm9wcGVkID0gc29ydGFibGUuZWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIE5lZWQgdG8gcmVmcmVzaFBvc2l0aW9ucyBvZiBhbGwgc29ydGFibGVzIGluIHRoZSBjYXNlIHRoYXRcblx0XHRcdFx0XHQvLyBhZGRpbmcgdG8gb25lIHNvcnRhYmxlIGNoYW5nZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBvdGhlciBzb3J0YWJsZXMgKCM5Njc1KVxuXHRcdFx0XHRcdCQuZWFjaCggZHJhZ2dhYmxlLnNvcnRhYmxlcywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlZnJlc2hQb3NpdGlvbnMoKTtcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHQvLyBIYWNrIHNvIHJlY2VpdmUvdXBkYXRlIGNhbGxiYWNrcyB3b3JrIChtb3N0bHkpXG5cdFx0XHRcdFx0ZHJhZ2dhYmxlLmN1cnJlbnRJdGVtID0gZHJhZ2dhYmxlLmVsZW1lbnQ7XG5cdFx0XHRcdFx0c29ydGFibGUuZnJvbU91dHNpZGUgPSBkcmFnZ2FibGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNvcnRhYmxlLmN1cnJlbnRJdGVtICkge1xuXHRcdFx0XHRcdHNvcnRhYmxlLl9tb3VzZURyYWcoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHQvLyBDb3B5IHRoZSBzb3J0YWJsZSdzIHBvc2l0aW9uIGJlY2F1c2UgdGhlIGRyYWdnYWJsZSdzIGNhbiBwb3RlbnRpYWxseSByZWZsZWN0XG5cdFx0XHRcdFx0Ly8gYSByZWxhdGl2ZSBwb3NpdGlvbiwgd2hpbGUgc29ydGFibGUgaXMgYWx3YXlzIGFic29sdXRlLCB3aGljaCB0aGUgZHJhZ2dlZFxuXHRcdFx0XHRcdC8vIGVsZW1lbnQgaGFzIG5vdyBiZWNvbWUuICgjODgwOSlcblx0XHRcdFx0XHR1aS5wb3NpdGlvbiA9IHNvcnRhYmxlLnBvc2l0aW9uO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIElmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHdpdGggdGhlIHNvcnRhYmxlLCBhbmQgaXQgaW50ZXJzZWN0ZWQgYmVmb3JlLFxuXHRcdFx0XHQvLyB3ZSBmYWtlIHRoZSBkcmFnIHN0b3Agb2YgdGhlIHNvcnRhYmxlLCBidXQgbWFrZSBzdXJlIGl0IGRvZXNuJ3QgcmVtb3ZlXG5cdFx0XHRcdC8vIHRoZSBoZWxwZXIgYnkgdXNpbmcgY2FuY2VsSGVscGVyUmVtb3ZhbC5cblx0XHRcdFx0aWYgKCBzb3J0YWJsZS5pc092ZXIgKSB7XG5cblx0XHRcdFx0XHRzb3J0YWJsZS5pc092ZXIgPSAwO1xuXHRcdFx0XHRcdHNvcnRhYmxlLmNhbmNlbEhlbHBlclJlbW92YWwgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Ly8gQ2FsbGluZyBzb3J0YWJsZSdzIG1vdXNlU3RvcCB3b3VsZCB0cmlnZ2VyIGEgcmV2ZXJ0LFxuXHRcdFx0XHRcdC8vIHNvIHJldmVydCBtdXN0IGJlIHRlbXBvcmFyaWx5IGZhbHNlIHVudGlsIGFmdGVyIG1vdXNlU3RvcCBpcyBjYWxsZWQuXG5cdFx0XHRcdFx0c29ydGFibGUub3B0aW9ucy5fcmV2ZXJ0ID0gc29ydGFibGUub3B0aW9ucy5yZXZlcnQ7XG5cdFx0XHRcdFx0c29ydGFibGUub3B0aW9ucy5yZXZlcnQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdHNvcnRhYmxlLl90cmlnZ2VyKCBcIm91dFwiLCBldmVudCwgc29ydGFibGUuX3VpSGFzaCggc29ydGFibGUgKSApO1xuXHRcdFx0XHRcdHNvcnRhYmxlLl9tb3VzZVN0b3AoIGV2ZW50LCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBSZXN0b3JlIHNvcnRhYmxlIGJlaGF2aW9ycyB0aGF0IHdlcmUgbW9kZmllZFxuXHRcdFx0XHRcdC8vIHdoZW4gdGhlIGRyYWdnYWJsZSBlbnRlcmVkIHRoZSBzb3J0YWJsZSBhcmVhICgjOTQ4MSlcblx0XHRcdFx0XHRzb3J0YWJsZS5vcHRpb25zLnJldmVydCA9IHNvcnRhYmxlLm9wdGlvbnMuX3JldmVydDtcblx0XHRcdFx0XHRzb3J0YWJsZS5vcHRpb25zLmhlbHBlciA9IHNvcnRhYmxlLm9wdGlvbnMuX2hlbHBlcjtcblxuXHRcdFx0XHRcdGlmICggc29ydGFibGUucGxhY2Vob2xkZXIgKSB7XG5cdFx0XHRcdFx0XHRzb3J0YWJsZS5wbGFjZWhvbGRlci5yZW1vdmUoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBSZXN0b3JlIGFuZCByZWNhbGN1bGF0ZSB0aGUgZHJhZ2dhYmxlJ3Mgb2Zmc2V0IGNvbnNpZGVyaW5nIHRoZSBzb3J0YWJsZVxuXHRcdFx0XHRcdC8vIG1heSBoYXZlIG1vZGlmaWVkIHRoZW0gaW4gdW5leHBlY3RlZCB3YXlzLiAoIzg4MDksICMxMDY2OSlcblx0XHRcdFx0XHR1aS5oZWxwZXIuYXBwZW5kVG8oIGRyYWdnYWJsZS5fcGFyZW50ICk7XG5cdFx0XHRcdFx0ZHJhZ2dhYmxlLl9yZWZyZXNoT2Zmc2V0cyggZXZlbnQgKTtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbiA9IGRyYWdnYWJsZS5fZ2VuZXJhdGVQb3NpdGlvbiggZXZlbnQsIHRydWUgKTtcblxuXHRcdFx0XHRcdGRyYWdnYWJsZS5fdHJpZ2dlciggXCJmcm9tU29ydGFibGVcIiwgZXZlbnQgKTtcblxuXHRcdFx0XHRcdC8vIEluZm9ybSBkcmFnZ2FibGUgdGhhdCB0aGUgaGVscGVyIGlzIG5vIGxvbmdlciBpbiBhIHZhbGlkIGRyb3Agem9uZVxuXHRcdFx0XHRcdGRyYWdnYWJsZS5kcm9wcGVkID0gZmFsc2U7XG5cblx0XHRcdFx0XHQvLyBOZWVkIHRvIHJlZnJlc2hQb3NpdGlvbnMgb2YgYWxsIHNvcnRhYmxlcyBqdXN0IGluIGNhc2UgcmVtb3Zpbmdcblx0XHRcdFx0XHQvLyBmcm9tIG9uZSBzb3J0YWJsZSBjaGFuZ2VzIHRoZSBsb2NhdGlvbiBvZiBvdGhlciBzb3J0YWJsZXMgKCM5Njc1KVxuXHRcdFx0XHRcdCQuZWFjaCggZHJhZ2dhYmxlLnNvcnRhYmxlcywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlZnJlc2hQb3NpdGlvbnMoKTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuJC51aS5wbHVnaW4uYWRkKCBcImRyYWdnYWJsZVwiLCBcImN1cnNvclwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbiggZXZlbnQsIHVpLCBpbnN0YW5jZSApIHtcblx0XHR2YXIgdCA9ICQoIFwiYm9keVwiICksXG5cdFx0XHRvID0gaW5zdGFuY2Uub3B0aW9ucztcblxuXHRcdGlmICggdC5jc3MoIFwiY3Vyc29yXCIgKSApIHtcblx0XHRcdG8uX2N1cnNvciA9IHQuY3NzKCBcImN1cnNvclwiICk7XG5cdFx0fVxuXHRcdHQuY3NzKCBcImN1cnNvclwiLCBvLmN1cnNvciApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggZXZlbnQsIHVpLCBpbnN0YW5jZSApIHtcblx0XHR2YXIgbyA9IGluc3RhbmNlLm9wdGlvbnM7XG5cdFx0aWYgKCBvLl9jdXJzb3IgKSB7XG5cdFx0XHQkKCBcImJvZHlcIiApLmNzcyggXCJjdXJzb3JcIiwgby5fY3Vyc29yICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbiQudWkucGx1Z2luLmFkZCggXCJkcmFnZ2FibGVcIiwgXCJvcGFjaXR5XCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgdWksIGluc3RhbmNlICkge1xuXHRcdHZhciB0ID0gJCggdWkuaGVscGVyICksXG5cdFx0XHRvID0gaW5zdGFuY2Uub3B0aW9ucztcblx0XHRpZiAoIHQuY3NzKCBcIm9wYWNpdHlcIiApICkge1xuXHRcdFx0by5fb3BhY2l0eSA9IHQuY3NzKCBcIm9wYWNpdHlcIiApO1xuXHRcdH1cblx0XHR0LmNzcyggXCJvcGFjaXR5XCIsIG8ub3BhY2l0eSApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggZXZlbnQsIHVpLCBpbnN0YW5jZSApIHtcblx0XHR2YXIgbyA9IGluc3RhbmNlLm9wdGlvbnM7XG5cdFx0aWYgKCBvLl9vcGFjaXR5ICkge1xuXHRcdFx0JCggdWkuaGVscGVyICkuY3NzKCBcIm9wYWNpdHlcIiwgby5fb3BhY2l0eSApO1xuXHRcdH1cblx0fVxufSApO1xuXG4kLnVpLnBsdWdpbi5hZGQoIFwiZHJhZ2dhYmxlXCIsIFwic2Nyb2xsXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgdWksIGkgKSB7XG5cdFx0aWYgKCAhaS5zY3JvbGxQYXJlbnROb3RIaWRkZW4gKSB7XG5cdFx0XHRpLnNjcm9sbFBhcmVudE5vdEhpZGRlbiA9IGkuaGVscGVyLnNjcm9sbFBhcmVudCggZmFsc2UgKTtcblx0XHR9XG5cblx0XHRpZiAoIGkuc2Nyb2xsUGFyZW50Tm90SGlkZGVuWyAwIF0gIT09IGkuZG9jdW1lbnRbIDAgXSAmJlxuXHRcdFx0XHRpLnNjcm9sbFBhcmVudE5vdEhpZGRlblsgMCBdLnRhZ05hbWUgIT09IFwiSFRNTFwiICkge1xuXHRcdFx0aS5vdmVyZmxvd09mZnNldCA9IGkuc2Nyb2xsUGFyZW50Tm90SGlkZGVuLm9mZnNldCgpO1xuXHRcdH1cblx0fSxcblx0ZHJhZzogZnVuY3Rpb24oIGV2ZW50LCB1aSwgaSAgKSB7XG5cblx0XHR2YXIgbyA9IGkub3B0aW9ucyxcblx0XHRcdHNjcm9sbGVkID0gZmFsc2UsXG5cdFx0XHRzY3JvbGxQYXJlbnQgPSBpLnNjcm9sbFBhcmVudE5vdEhpZGRlblsgMCBdLFxuXHRcdFx0ZG9jdW1lbnQgPSBpLmRvY3VtZW50WyAwIF07XG5cblx0XHRpZiAoIHNjcm9sbFBhcmVudCAhPT0gZG9jdW1lbnQgJiYgc2Nyb2xsUGFyZW50LnRhZ05hbWUgIT09IFwiSFRNTFwiICkge1xuXHRcdFx0aWYgKCAhby5heGlzIHx8IG8uYXhpcyAhPT0gXCJ4XCIgKSB7XG5cdFx0XHRcdGlmICggKCBpLm92ZXJmbG93T2Zmc2V0LnRvcCArIHNjcm9sbFBhcmVudC5vZmZzZXRIZWlnaHQgKSAtIGV2ZW50LnBhZ2VZIDxcblx0XHRcdFx0XHRcdG8uc2Nyb2xsU2Vuc2l0aXZpdHkgKSB7XG5cdFx0XHRcdFx0c2Nyb2xsUGFyZW50LnNjcm9sbFRvcCA9IHNjcm9sbGVkID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCArIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGV2ZW50LnBhZ2VZIC0gaS5vdmVyZmxvd09mZnNldC50b3AgPCBvLnNjcm9sbFNlbnNpdGl2aXR5ICkge1xuXHRcdFx0XHRcdHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgPSBzY3JvbGxlZCA9IHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgLSBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggIW8uYXhpcyB8fCBvLmF4aXMgIT09IFwieVwiICkge1xuXHRcdFx0XHRpZiAoICggaS5vdmVyZmxvd09mZnNldC5sZWZ0ICsgc2Nyb2xsUGFyZW50Lm9mZnNldFdpZHRoICkgLSBldmVudC5wYWdlWCA8XG5cdFx0XHRcdFx0XHRvLnNjcm9sbFNlbnNpdGl2aXR5ICkge1xuXHRcdFx0XHRcdHNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsZWQgPSBzY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCArIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGV2ZW50LnBhZ2VYIC0gaS5vdmVyZmxvd09mZnNldC5sZWZ0IDwgby5zY3JvbGxTZW5zaXRpdml0eSApIHtcblx0XHRcdFx0XHRzY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCA9IHNjcm9sbGVkID0gc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQgLSBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoICFvLmF4aXMgfHwgby5heGlzICE9PSBcInhcIiApIHtcblx0XHRcdFx0aWYgKCBldmVudC5wYWdlWSAtICQoIGRvY3VtZW50ICkuc2Nyb2xsVG9wKCkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5ICkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJCggZG9jdW1lbnQgKS5zY3JvbGxUb3AoICQoIGRvY3VtZW50ICkuc2Nyb2xsVG9wKCkgLSBvLnNjcm9sbFNwZWVkICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoICQoIHdpbmRvdyApLmhlaWdodCgpIC0gKCBldmVudC5wYWdlWSAtICQoIGRvY3VtZW50ICkuc2Nyb2xsVG9wKCkgKSA8XG5cdFx0XHRcdFx0XHRvLnNjcm9sbFNlbnNpdGl2aXR5ICkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJCggZG9jdW1lbnQgKS5zY3JvbGxUb3AoICQoIGRvY3VtZW50ICkuc2Nyb2xsVG9wKCkgKyBvLnNjcm9sbFNwZWVkICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhby5heGlzIHx8IG8uYXhpcyAhPT0gXCJ5XCIgKSB7XG5cdFx0XHRcdGlmICggZXZlbnQucGFnZVggLSAkKCBkb2N1bWVudCApLnNjcm9sbExlZnQoKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkgKSB7XG5cdFx0XHRcdFx0c2Nyb2xsZWQgPSAkKCBkb2N1bWVudCApLnNjcm9sbExlZnQoXG5cdFx0XHRcdFx0XHQkKCBkb2N1bWVudCApLnNjcm9sbExlZnQoKSAtIG8uc2Nyb2xsU3BlZWRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCAkKCB3aW5kb3cgKS53aWR0aCgpIC0gKCBldmVudC5wYWdlWCAtICQoIGRvY3VtZW50ICkuc2Nyb2xsTGVmdCgpICkgPFxuXHRcdFx0XHRcdFx0by5zY3JvbGxTZW5zaXRpdml0eSApIHtcblx0XHRcdFx0XHRzY3JvbGxlZCA9ICQoIGRvY3VtZW50ICkuc2Nyb2xsTGVmdChcblx0XHRcdFx0XHRcdCQoIGRvY3VtZW50ICkuc2Nyb2xsTGVmdCgpICsgby5zY3JvbGxTcGVlZFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggc2Nyb2xsZWQgIT09IGZhbHNlICYmICQudWkuZGRtYW5hZ2VyICYmICFvLmRyb3BCZWhhdmlvdXIgKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyggaSwgZXZlbnQgKTtcblx0XHR9XG5cblx0fVxufSApO1xuXG4kLnVpLnBsdWdpbi5hZGQoIFwiZHJhZ2dhYmxlXCIsIFwic25hcFwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbiggZXZlbnQsIHVpLCBpICkge1xuXG5cdFx0dmFyIG8gPSBpLm9wdGlvbnM7XG5cblx0XHRpLnNuYXBFbGVtZW50cyA9IFtdO1xuXG5cdFx0JCggby5zbmFwLmNvbnN0cnVjdG9yICE9PSBTdHJpbmcgPyAoIG8uc25hcC5pdGVtcyB8fCBcIjpkYXRhKHVpLWRyYWdnYWJsZSlcIiApIDogby5zbmFwIClcblx0XHRcdC5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyICR0ID0gJCggdGhpcyApLFxuXHRcdFx0XHRcdCRvID0gJHQub2Zmc2V0KCk7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gaS5lbGVtZW50WyAwIF0gKSB7XG5cdFx0XHRcdFx0aS5zbmFwRWxlbWVudHMucHVzaCgge1xuXHRcdFx0XHRcdFx0aXRlbTogdGhpcyxcblx0XHRcdFx0XHRcdHdpZHRoOiAkdC5vdXRlcldpZHRoKCksIGhlaWdodDogJHQub3V0ZXJIZWlnaHQoKSxcblx0XHRcdFx0XHRcdHRvcDogJG8udG9wLCBsZWZ0OiAkby5sZWZ0XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0fSxcblx0ZHJhZzogZnVuY3Rpb24oIGV2ZW50LCB1aSwgaW5zdCApIHtcblxuXHRcdHZhciB0cywgYnMsIGxzLCBycywgbCwgciwgdCwgYiwgaSwgZmlyc3QsXG5cdFx0XHRvID0gaW5zdC5vcHRpb25zLFxuXHRcdFx0ZCA9IG8uc25hcFRvbGVyYW5jZSxcblx0XHRcdHgxID0gdWkub2Zmc2V0LmxlZnQsIHgyID0geDEgKyBpbnN0LmhlbHBlclByb3BvcnRpb25zLndpZHRoLFxuXHRcdFx0eTEgPSB1aS5vZmZzZXQudG9wLCB5MiA9IHkxICsgaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQ7XG5cblx0XHRmb3IgKCBpID0gaW5zdC5zbmFwRWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG5cblx0XHRcdGwgPSBpbnN0LnNuYXBFbGVtZW50c1sgaSBdLmxlZnQgLSBpbnN0Lm1hcmdpbnMubGVmdDtcblx0XHRcdHIgPSBsICsgaW5zdC5zbmFwRWxlbWVudHNbIGkgXS53aWR0aDtcblx0XHRcdHQgPSBpbnN0LnNuYXBFbGVtZW50c1sgaSBdLnRvcCAtIGluc3QubWFyZ2lucy50b3A7XG5cdFx0XHRiID0gdCArIGluc3Quc25hcEVsZW1lbnRzWyBpIF0uaGVpZ2h0O1xuXG5cdFx0XHRpZiAoIHgyIDwgbCAtIGQgfHwgeDEgPiByICsgZCB8fCB5MiA8IHQgLSBkIHx8IHkxID4gYiArIGQgfHxcblx0XHRcdFx0XHQhJC5jb250YWlucyggaW5zdC5zbmFwRWxlbWVudHNbIGkgXS5pdGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0XHRcdFx0aW5zdC5zbmFwRWxlbWVudHNbIGkgXS5pdGVtICkgKSB7XG5cdFx0XHRcdGlmICggaW5zdC5zbmFwRWxlbWVudHNbIGkgXS5zbmFwcGluZyApIHtcblx0XHRcdFx0XHQoIGluc3Qub3B0aW9ucy5zbmFwLnJlbGVhc2UgJiZcblx0XHRcdFx0XHRcdGluc3Qub3B0aW9ucy5zbmFwLnJlbGVhc2UuY2FsbChcblx0XHRcdFx0XHRcdFx0aW5zdC5lbGVtZW50LFxuXHRcdFx0XHRcdFx0XHRldmVudCxcblx0XHRcdFx0XHRcdFx0JC5leHRlbmQoIGluc3QuX3VpSGFzaCgpLCB7IHNuYXBJdGVtOiBpbnN0LnNuYXBFbGVtZW50c1sgaSBdLml0ZW0gfSApXG5cdFx0XHRcdFx0XHQpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5zdC5zbmFwRWxlbWVudHNbIGkgXS5zbmFwcGluZyA9IGZhbHNlO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvLnNuYXBNb2RlICE9PSBcImlubmVyXCIgKSB7XG5cdFx0XHRcdHRzID0gTWF0aC5hYnMoIHQgLSB5MiApIDw9IGQ7XG5cdFx0XHRcdGJzID0gTWF0aC5hYnMoIGIgLSB5MSApIDw9IGQ7XG5cdFx0XHRcdGxzID0gTWF0aC5hYnMoIGwgLSB4MiApIDw9IGQ7XG5cdFx0XHRcdHJzID0gTWF0aC5hYnMoIHIgLSB4MSApIDw9IGQ7XG5cdFx0XHRcdGlmICggdHMgKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24udG9wID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oIFwicmVsYXRpdmVcIiwge1xuXHRcdFx0XHRcdFx0dG9wOiB0IC0gaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQsXG5cdFx0XHRcdFx0XHRsZWZ0OiAwXG5cdFx0XHRcdFx0fSApLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGJzICkge1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLnRvcCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKCBcInJlbGF0aXZlXCIsIHtcblx0XHRcdFx0XHRcdHRvcDogYixcblx0XHRcdFx0XHRcdGxlZnQ6IDBcblx0XHRcdFx0XHR9ICkudG9wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbHMgKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24ubGVmdCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKCBcInJlbGF0aXZlXCIsIHtcblx0XHRcdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0XHRcdGxlZnQ6IGwgLSBpbnN0LmhlbHBlclByb3BvcnRpb25zLndpZHRoXG5cdFx0XHRcdFx0fSApLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBycyApIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oIFwicmVsYXRpdmVcIiwge1xuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0bGVmdDogclxuXHRcdFx0XHRcdH0gKS5sZWZ0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZpcnN0ID0gKCB0cyB8fCBicyB8fCBscyB8fCBycyApO1xuXG5cdFx0XHRpZiAoIG8uc25hcE1vZGUgIT09IFwib3V0ZXJcIiApIHtcblx0XHRcdFx0dHMgPSBNYXRoLmFicyggdCAtIHkxICkgPD0gZDtcblx0XHRcdFx0YnMgPSBNYXRoLmFicyggYiAtIHkyICkgPD0gZDtcblx0XHRcdFx0bHMgPSBNYXRoLmFicyggbCAtIHgxICkgPD0gZDtcblx0XHRcdFx0cnMgPSBNYXRoLmFicyggciAtIHgyICkgPD0gZDtcblx0XHRcdFx0aWYgKCB0cyApIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi50b3AgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyggXCJyZWxhdGl2ZVwiLCB7XG5cdFx0XHRcdFx0XHR0b3A6IHQsXG5cdFx0XHRcdFx0XHRsZWZ0OiAwXG5cdFx0XHRcdFx0fSApLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGJzICkge1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLnRvcCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKCBcInJlbGF0aXZlXCIsIHtcblx0XHRcdFx0XHRcdHRvcDogYiAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0LFxuXHRcdFx0XHRcdFx0bGVmdDogMFxuXHRcdFx0XHRcdH0gKS50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBscyApIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oIFwicmVsYXRpdmVcIiwge1xuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0bGVmdDogbFxuXHRcdFx0XHRcdH0gKS5sZWZ0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggcnMgKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24ubGVmdCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKCBcInJlbGF0aXZlXCIsIHtcblx0XHRcdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0XHRcdGxlZnQ6IHIgLSBpbnN0LmhlbHBlclByb3BvcnRpb25zLndpZHRoXG5cdFx0XHRcdFx0fSApLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhaW5zdC5zbmFwRWxlbWVudHNbIGkgXS5zbmFwcGluZyAmJiAoIHRzIHx8IGJzIHx8IGxzIHx8IHJzIHx8IGZpcnN0ICkgKSB7XG5cdFx0XHRcdCggaW5zdC5vcHRpb25zLnNuYXAuc25hcCAmJlxuXHRcdFx0XHRcdGluc3Qub3B0aW9ucy5zbmFwLnNuYXAuY2FsbChcblx0XHRcdFx0XHRcdGluc3QuZWxlbWVudCxcblx0XHRcdFx0XHRcdGV2ZW50LFxuXHRcdFx0XHRcdFx0JC5leHRlbmQoIGluc3QuX3VpSGFzaCgpLCB7XG5cdFx0XHRcdFx0XHRcdHNuYXBJdGVtOiBpbnN0LnNuYXBFbGVtZW50c1sgaSBdLml0ZW1cblx0XHRcdFx0XHRcdH0gKSApICk7XG5cdFx0XHR9XG5cdFx0XHRpbnN0LnNuYXBFbGVtZW50c1sgaSBdLnNuYXBwaW5nID0gKCB0cyB8fCBicyB8fCBscyB8fCBycyB8fCBmaXJzdCApO1xuXG5cdFx0fVxuXG5cdH1cbn0gKTtcblxuJC51aS5wbHVnaW4uYWRkKCBcImRyYWdnYWJsZVwiLCBcInN0YWNrXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgdWksIGluc3RhbmNlICkge1xuXHRcdHZhciBtaW4sXG5cdFx0XHRvID0gaW5zdGFuY2Uub3B0aW9ucyxcblx0XHRcdGdyb3VwID0gJC5tYWtlQXJyYXkoICQoIG8uc3RhY2sgKSApLnNvcnQoIGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0XHRyZXR1cm4gKCBwYXJzZUludCggJCggYSApLmNzcyggXCJ6SW5kZXhcIiApLCAxMCApIHx8IDAgKSAtXG5cdFx0XHRcdFx0KCBwYXJzZUludCggJCggYiApLmNzcyggXCJ6SW5kZXhcIiApLCAxMCApIHx8IDAgKTtcblx0XHRcdH0gKTtcblxuXHRcdGlmICggIWdyb3VwLmxlbmd0aCApIHsgcmV0dXJuOyB9XG5cblx0XHRtaW4gPSBwYXJzZUludCggJCggZ3JvdXBbIDAgXSApLmNzcyggXCJ6SW5kZXhcIiApLCAxMCApIHx8IDA7XG5cdFx0JCggZ3JvdXAgKS5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdCQoIHRoaXMgKS5jc3MoIFwiekluZGV4XCIsIG1pbiArIGkgKTtcblx0XHR9ICk7XG5cdFx0dGhpcy5jc3MoIFwiekluZGV4XCIsICggbWluICsgZ3JvdXAubGVuZ3RoICkgKTtcblx0fVxufSApO1xuXG4kLnVpLnBsdWdpbi5hZGQoIFwiZHJhZ2dhYmxlXCIsIFwiekluZGV4XCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgdWksIGluc3RhbmNlICkge1xuXHRcdHZhciB0ID0gJCggdWkuaGVscGVyICksXG5cdFx0XHRvID0gaW5zdGFuY2Uub3B0aW9ucztcblxuXHRcdGlmICggdC5jc3MoIFwiekluZGV4XCIgKSApIHtcblx0XHRcdG8uX3pJbmRleCA9IHQuY3NzKCBcInpJbmRleFwiICk7XG5cdFx0fVxuXHRcdHQuY3NzKCBcInpJbmRleFwiLCBvLnpJbmRleCApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggZXZlbnQsIHVpLCBpbnN0YW5jZSApIHtcblx0XHR2YXIgbyA9IGluc3RhbmNlLm9wdGlvbnM7XG5cblx0XHRpZiAoIG8uX3pJbmRleCApIHtcblx0XHRcdCQoIHVpLmhlbHBlciApLmNzcyggXCJ6SW5kZXhcIiwgby5fekluZGV4ICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbnZhciB3aWRnZXRzRHJhZ2dhYmxlID0gJC51aS5kcmFnZ2FibGU7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgUmVzaXphYmxlIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBSZXNpemFibGVcbi8vPj5ncm91cDogSW50ZXJhY3Rpb25zXG4vLz4+ZGVzY3JpcHRpb246IEVuYWJsZXMgcmVzaXplIGZ1bmN0aW9uYWxpdHkgZm9yIGFueSBlbGVtZW50LlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3Jlc2l6YWJsZS9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9yZXNpemFibGUvXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2UvY29yZS5jc3Ncbi8vPj5jc3Muc3RydWN0dXJlOiAuLi8uLi90aGVtZXMvYmFzZS9yZXNpemFibGUuY3NzXG4vLz4+Y3NzLnRoZW1lOiAuLi8uLi90aGVtZXMvYmFzZS90aGVtZS5jc3NcblxuXG5cbiQud2lkZ2V0KCBcInVpLnJlc2l6YWJsZVwiLCAkLnVpLm1vdXNlLCB7XG5cdHZlcnNpb246IFwiMS4xMi4xXCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcInJlc2l6ZVwiLFxuXHRvcHRpb25zOiB7XG5cdFx0YWxzb1Jlc2l6ZTogZmFsc2UsXG5cdFx0YW5pbWF0ZTogZmFsc2UsXG5cdFx0YW5pbWF0ZUR1cmF0aW9uOiBcInNsb3dcIixcblx0XHRhbmltYXRlRWFzaW5nOiBcInN3aW5nXCIsXG5cdFx0YXNwZWN0UmF0aW86IGZhbHNlLFxuXHRcdGF1dG9IaWRlOiBmYWxzZSxcblx0XHRjbGFzc2VzOiB7XG5cdFx0XHRcInVpLXJlc2l6YWJsZS1zZVwiOiBcInVpLWljb24gdWktaWNvbi1ncmlwc21hbGwtZGlhZ29uYWwtc2VcIlxuXHRcdH0sXG5cdFx0Y29udGFpbm1lbnQ6IGZhbHNlLFxuXHRcdGdob3N0OiBmYWxzZSxcblx0XHRncmlkOiBmYWxzZSxcblx0XHRoYW5kbGVzOiBcImUscyxzZVwiLFxuXHRcdGhlbHBlcjogZmFsc2UsXG5cdFx0bWF4SGVpZ2h0OiBudWxsLFxuXHRcdG1heFdpZHRoOiBudWxsLFxuXHRcdG1pbkhlaWdodDogMTAsXG5cdFx0bWluV2lkdGg6IDEwLFxuXG5cdFx0Ly8gU2VlICM3OTYwXG5cdFx0ekluZGV4OiA5MCxcblxuXHRcdC8vIENhbGxiYWNrc1xuXHRcdHJlc2l6ZTogbnVsbCxcblx0XHRzdGFydDogbnVsbCxcblx0XHRzdG9wOiBudWxsXG5cdH0sXG5cblx0X251bTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBwYXJzZUZsb2F0KCB2YWx1ZSApIHx8IDA7XG5cdH0sXG5cblx0X2lzTnVtYmVyOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuICFpc05hTiggcGFyc2VGbG9hdCggdmFsdWUgKSApO1xuXHR9LFxuXG5cdF9oYXNTY3JvbGw6IGZ1bmN0aW9uKCBlbCwgYSApIHtcblxuXHRcdGlmICggJCggZWwgKS5jc3MoIFwib3ZlcmZsb3dcIiApID09PSBcImhpZGRlblwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBzY3JvbGwgPSAoIGEgJiYgYSA9PT0gXCJsZWZ0XCIgKSA/IFwic2Nyb2xsTGVmdFwiIDogXCJzY3JvbGxUb3BcIixcblx0XHRcdGhhcyA9IGZhbHNlO1xuXG5cdFx0aWYgKCBlbFsgc2Nyb2xsIF0gPiAwICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogZGV0ZXJtaW5lIHdoaWNoIGNhc2VzIGFjdHVhbGx5IGNhdXNlIHRoaXMgdG8gaGFwcGVuXG5cdFx0Ly8gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIHRoZSBzY3JvbGwgc2V0LCBzZWUgaWYgaXQncyBwb3NzaWJsZSB0b1xuXHRcdC8vIHNldCB0aGUgc2Nyb2xsXG5cdFx0ZWxbIHNjcm9sbCBdID0gMTtcblx0XHRoYXMgPSAoIGVsWyBzY3JvbGwgXSA+IDAgKTtcblx0XHRlbFsgc2Nyb2xsIF0gPSAwO1xuXHRcdHJldHVybiBoYXM7XG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbWFyZ2lucyxcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHR0aGF0ID0gdGhpcztcblx0XHR0aGlzLl9hZGRDbGFzcyggXCJ1aS1yZXNpemFibGVcIiApO1xuXG5cdFx0JC5leHRlbmQoIHRoaXMsIHtcblx0XHRcdF9hc3BlY3RSYXRpbzogISEoIG8uYXNwZWN0UmF0aW8gKSxcblx0XHRcdGFzcGVjdFJhdGlvOiBvLmFzcGVjdFJhdGlvLFxuXHRcdFx0b3JpZ2luYWxFbGVtZW50OiB0aGlzLmVsZW1lbnQsXG5cdFx0XHRfcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50czogW10sXG5cdFx0XHRfaGVscGVyOiBvLmhlbHBlciB8fCBvLmdob3N0IHx8IG8uYW5pbWF0ZSA/IG8uaGVscGVyIHx8IFwidWktcmVzaXphYmxlLWhlbHBlclwiIDogbnVsbFxuXHRcdH0gKTtcblxuXHRcdC8vIFdyYXAgdGhlIGVsZW1lbnQgaWYgaXQgY2Fubm90IGhvbGQgY2hpbGQgbm9kZXNcblx0XHRpZiAoIHRoaXMuZWxlbWVudFsgMCBdLm5vZGVOYW1lLm1hdGNoKCAvXihjYW52YXN8dGV4dGFyZWF8aW5wdXR8c2VsZWN0fGJ1dHRvbnxpbWcpJC9pICkgKSB7XG5cblx0XHRcdHRoaXMuZWxlbWVudC53cmFwKFxuXHRcdFx0XHQkKCBcIjxkaXYgY2xhc3M9J3VpLXdyYXBwZXInIHN0eWxlPSdvdmVyZmxvdzogaGlkZGVuOyc+PC9kaXY+XCIgKS5jc3MoIHtcblx0XHRcdFx0XHRwb3NpdGlvbjogdGhpcy5lbGVtZW50LmNzcyggXCJwb3NpdGlvblwiICksXG5cdFx0XHRcdFx0d2lkdGg6IHRoaXMuZWxlbWVudC5vdXRlcldpZHRoKCksXG5cdFx0XHRcdFx0aGVpZ2h0OiB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKSxcblx0XHRcdFx0XHR0b3A6IHRoaXMuZWxlbWVudC5jc3MoIFwidG9wXCIgKSxcblx0XHRcdFx0XHRsZWZ0OiB0aGlzLmVsZW1lbnQuY3NzKCBcImxlZnRcIiApXG5cdFx0XHRcdH0gKVxuXHRcdFx0KTtcblxuXHRcdFx0dGhpcy5lbGVtZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudCgpLmRhdGEoXG5cdFx0XHRcdFwidWktcmVzaXphYmxlXCIsIHRoaXMuZWxlbWVudC5yZXNpemFibGUoIFwiaW5zdGFuY2VcIiApXG5cdFx0XHQpO1xuXG5cdFx0XHR0aGlzLmVsZW1lbnRJc1dyYXBwZXIgPSB0cnVlO1xuXG5cdFx0XHRtYXJnaW5zID0ge1xuXHRcdFx0XHRtYXJnaW5Ub3A6IHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyggXCJtYXJnaW5Ub3BcIiApLFxuXHRcdFx0XHRtYXJnaW5SaWdodDogdGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKCBcIm1hcmdpblJpZ2h0XCIgKSxcblx0XHRcdFx0bWFyZ2luQm90dG9tOiB0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoIFwibWFyZ2luQm90dG9tXCIgKSxcblx0XHRcdFx0bWFyZ2luTGVmdDogdGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKCBcIm1hcmdpbkxlZnRcIiApXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmVsZW1lbnQuY3NzKCBtYXJnaW5zICk7XG5cdFx0XHR0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoIFwibWFyZ2luXCIsIDAgKTtcblxuXHRcdFx0Ly8gc3VwcG9ydDogU2FmYXJpXG5cdFx0XHQvLyBQcmV2ZW50IFNhZmFyaSB0ZXh0YXJlYSByZXNpemVcblx0XHRcdHRoaXMub3JpZ2luYWxSZXNpemVTdHlsZSA9IHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyggXCJyZXNpemVcIiApO1xuXHRcdFx0dGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKCBcInJlc2l6ZVwiLCBcIm5vbmVcIiApO1xuXG5cdFx0XHR0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzLnB1c2goIHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcygge1xuXHRcdFx0XHRwb3NpdGlvbjogXCJzdGF0aWNcIixcblx0XHRcdFx0em9vbTogMSxcblx0XHRcdFx0ZGlzcGxheTogXCJibG9ja1wiXG5cdFx0XHR9ICkgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0XHQvLyBhdm9pZCBJRSBqdW1wIChoYXJkIHNldCB0aGUgbWFyZ2luKVxuXHRcdFx0dGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKCBtYXJnaW5zICk7XG5cblx0XHRcdHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0dXBIYW5kbGVzKCk7XG5cblx0XHRpZiAoIG8uYXV0b0hpZGUgKSB7XG5cdFx0XHQkKCB0aGlzLmVsZW1lbnQgKVxuXHRcdFx0XHQub24oIFwibW91c2VlbnRlclwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIG8uZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoYXQuX3JlbW92ZUNsYXNzKCBcInVpLXJlc2l6YWJsZS1hdXRvaGlkZVwiICk7XG5cdFx0XHRcdFx0dGhhdC5faGFuZGxlcy5zaG93KCk7XG5cdFx0XHRcdH0gKVxuXHRcdFx0XHQub24oIFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIG8uZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIXRoYXQucmVzaXppbmcgKSB7XG5cdFx0XHRcdFx0XHR0aGF0Ll9hZGRDbGFzcyggXCJ1aS1yZXNpemFibGUtYXV0b2hpZGVcIiApO1xuXHRcdFx0XHRcdFx0dGhhdC5faGFuZGxlcy5oaWRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbW91c2VJbml0KCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dGhpcy5fbW91c2VEZXN0cm95KCk7XG5cblx0XHR2YXIgd3JhcHBlcixcblx0XHRcdF9kZXN0cm95ID0gZnVuY3Rpb24oIGV4cCApIHtcblx0XHRcdFx0JCggZXhwIClcblx0XHRcdFx0XHQucmVtb3ZlRGF0YSggXCJyZXNpemFibGVcIiApXG5cdFx0XHRcdFx0LnJlbW92ZURhdGEoIFwidWktcmVzaXphYmxlXCIgKVxuXHRcdFx0XHRcdC5vZmYoIFwiLnJlc2l6YWJsZVwiIClcblx0XHRcdFx0XHQuZmluZCggXCIudWktcmVzaXphYmxlLWhhbmRsZVwiIClcblx0XHRcdFx0XHRcdC5yZW1vdmUoKTtcblx0XHRcdH07XG5cblx0XHQvLyBUT0RPOiBVbndyYXAgYXQgc2FtZSBET00gcG9zaXRpb25cblx0XHRpZiAoIHRoaXMuZWxlbWVudElzV3JhcHBlciApIHtcblx0XHRcdF9kZXN0cm95KCB0aGlzLmVsZW1lbnQgKTtcblx0XHRcdHdyYXBwZXIgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHR0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoIHtcblx0XHRcdFx0cG9zaXRpb246IHdyYXBwZXIuY3NzKCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdFx0d2lkdGg6IHdyYXBwZXIub3V0ZXJXaWR0aCgpLFxuXHRcdFx0XHRoZWlnaHQ6IHdyYXBwZXIub3V0ZXJIZWlnaHQoKSxcblx0XHRcdFx0dG9wOiB3cmFwcGVyLmNzcyggXCJ0b3BcIiApLFxuXHRcdFx0XHRsZWZ0OiB3cmFwcGVyLmNzcyggXCJsZWZ0XCIgKVxuXHRcdFx0fSApLmluc2VydEFmdGVyKCB3cmFwcGVyICk7XG5cdFx0XHR3cmFwcGVyLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyggXCJyZXNpemVcIiwgdGhpcy5vcmlnaW5hbFJlc2l6ZVN0eWxlICk7XG5cdFx0X2Rlc3Ryb3koIHRoaXMub3JpZ2luYWxFbGVtZW50ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXG5cdFx0c3dpdGNoICgga2V5ICkge1xuXHRcdGNhc2UgXCJoYW5kbGVzXCI6XG5cdFx0XHR0aGlzLl9yZW1vdmVIYW5kbGVzKCk7XG5cdFx0XHR0aGlzLl9zZXR1cEhhbmRsZXMoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH0sXG5cblx0X3NldHVwSGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnMsIGhhbmRsZSwgaSwgbiwgaG5hbWUsIGF4aXMsIHRoYXQgPSB0aGlzO1xuXHRcdHRoaXMuaGFuZGxlcyA9IG8uaGFuZGxlcyB8fFxuXHRcdFx0KCAhJCggXCIudWktcmVzaXphYmxlLWhhbmRsZVwiLCB0aGlzLmVsZW1lbnQgKS5sZW5ndGggP1xuXHRcdFx0XHRcImUscyxzZVwiIDoge1xuXHRcdFx0XHRcdG46IFwiLnVpLXJlc2l6YWJsZS1uXCIsXG5cdFx0XHRcdFx0ZTogXCIudWktcmVzaXphYmxlLWVcIixcblx0XHRcdFx0XHRzOiBcIi51aS1yZXNpemFibGUtc1wiLFxuXHRcdFx0XHRcdHc6IFwiLnVpLXJlc2l6YWJsZS13XCIsXG5cdFx0XHRcdFx0c2U6IFwiLnVpLXJlc2l6YWJsZS1zZVwiLFxuXHRcdFx0XHRcdHN3OiBcIi51aS1yZXNpemFibGUtc3dcIixcblx0XHRcdFx0XHRuZTogXCIudWktcmVzaXphYmxlLW5lXCIsXG5cdFx0XHRcdFx0bnc6IFwiLnVpLXJlc2l6YWJsZS1ud1wiXG5cdFx0XHRcdH0gKTtcblxuXHRcdHRoaXMuX2hhbmRsZXMgPSAkKCk7XG5cdFx0aWYgKCB0aGlzLmhhbmRsZXMuY29uc3RydWN0b3IgPT09IFN0cmluZyApIHtcblxuXHRcdFx0aWYgKCB0aGlzLmhhbmRsZXMgPT09IFwiYWxsXCIgKSB7XG5cdFx0XHRcdHRoaXMuaGFuZGxlcyA9IFwibixlLHMsdyxzZSxzdyxuZSxud1wiO1xuXHRcdFx0fVxuXG5cdFx0XHRuID0gdGhpcy5oYW5kbGVzLnNwbGl0KCBcIixcIiApO1xuXHRcdFx0dGhpcy5oYW5kbGVzID0ge307XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbi5sZW5ndGg7IGkrKyApIHtcblxuXHRcdFx0XHRoYW5kbGUgPSAkLnRyaW0oIG5bIGkgXSApO1xuXHRcdFx0XHRobmFtZSA9IFwidWktcmVzaXphYmxlLVwiICsgaGFuZGxlO1xuXHRcdFx0XHRheGlzID0gJCggXCI8ZGl2PlwiICk7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKCBheGlzLCBcInVpLXJlc2l6YWJsZS1oYW5kbGUgXCIgKyBobmFtZSApO1xuXG5cdFx0XHRcdGF4aXMuY3NzKCB7IHpJbmRleDogby56SW5kZXggfSApO1xuXG5cdFx0XHRcdHRoaXMuaGFuZGxlc1sgaGFuZGxlIF0gPSBcIi51aS1yZXNpemFibGUtXCIgKyBoYW5kbGU7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5hcHBlbmQoIGF4aXMgKTtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuX3JlbmRlckF4aXMgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgaSwgYXhpcywgcGFkUG9zLCBwYWRXcmFwcGVyO1xuXG5cdFx0XHR0YXJnZXQgPSB0YXJnZXQgfHwgdGhpcy5lbGVtZW50O1xuXG5cdFx0XHRmb3IgKCBpIGluIHRoaXMuaGFuZGxlcyApIHtcblxuXHRcdFx0XHRpZiAoIHRoaXMuaGFuZGxlc1sgaSBdLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgKSB7XG5cdFx0XHRcdFx0dGhpcy5oYW5kbGVzWyBpIF0gPSB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oIHRoaXMuaGFuZGxlc1sgaSBdICkuZmlyc3QoKS5zaG93KCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuaGFuZGxlc1sgaSBdLmpxdWVyeSB8fCB0aGlzLmhhbmRsZXNbIGkgXS5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHR0aGlzLmhhbmRsZXNbIGkgXSA9ICQoIHRoaXMuaGFuZGxlc1sgaSBdICk7XG5cdFx0XHRcdFx0dGhpcy5fb24oIHRoaXMuaGFuZGxlc1sgaSBdLCB7IFwibW91c2Vkb3duXCI6IHRoYXQuX21vdXNlRG93biB9ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRoaXMuZWxlbWVudElzV3JhcHBlciAmJlxuXHRcdFx0XHRcdFx0dGhpcy5vcmlnaW5hbEVsZW1lbnRbIDAgXVxuXHRcdFx0XHRcdFx0XHQubm9kZU5hbWVcblx0XHRcdFx0XHRcdFx0Lm1hdGNoKCAvXih0ZXh0YXJlYXxpbnB1dHxzZWxlY3R8YnV0dG9uKSQvaSApICkge1xuXHRcdFx0XHRcdGF4aXMgPSAkKCB0aGlzLmhhbmRsZXNbIGkgXSwgdGhpcy5lbGVtZW50ICk7XG5cblx0XHRcdFx0XHRwYWRXcmFwcGVyID0gL3N3fG5lfG53fHNlfG58cy8udGVzdCggaSApID9cblx0XHRcdFx0XHRcdGF4aXMub3V0ZXJIZWlnaHQoKSA6XG5cdFx0XHRcdFx0XHRheGlzLm91dGVyV2lkdGgoKTtcblxuXHRcdFx0XHRcdHBhZFBvcyA9IFsgXCJwYWRkaW5nXCIsXG5cdFx0XHRcdFx0XHQvbmV8bnd8bi8udGVzdCggaSApID8gXCJUb3BcIiA6XG5cdFx0XHRcdFx0XHQvc2V8c3d8cy8udGVzdCggaSApID8gXCJCb3R0b21cIiA6XG5cdFx0XHRcdFx0XHQvXmUkLy50ZXN0KCBpICkgPyBcIlJpZ2h0XCIgOiBcIkxlZnRcIiBdLmpvaW4oIFwiXCIgKTtcblxuXHRcdFx0XHRcdHRhcmdldC5jc3MoIHBhZFBvcywgcGFkV3JhcHBlciApO1xuXG5cdFx0XHRcdFx0dGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemUoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2hhbmRsZXMgPSB0aGlzLl9oYW5kbGVzLmFkZCggdGhpcy5oYW5kbGVzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gVE9ETzogbWFrZSByZW5kZXJBeGlzIGEgcHJvdG90eXBlIGZ1bmN0aW9uXG5cdFx0dGhpcy5fcmVuZGVyQXhpcyggdGhpcy5lbGVtZW50ICk7XG5cblx0XHR0aGlzLl9oYW5kbGVzID0gdGhpcy5faGFuZGxlcy5hZGQoIHRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1yZXNpemFibGUtaGFuZGxlXCIgKSApO1xuXHRcdHRoaXMuX2hhbmRsZXMuZGlzYWJsZVNlbGVjdGlvbigpO1xuXG5cdFx0dGhpcy5faGFuZGxlcy5vbiggXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICF0aGF0LnJlc2l6aW5nICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuY2xhc3NOYW1lICkge1xuXHRcdFx0XHRcdGF4aXMgPSB0aGlzLmNsYXNzTmFtZS5tYXRjaCggL3VpLXJlc2l6YWJsZS0oc2V8c3d8bmV8bnd8bnxlfHN8dykvaSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoYXQuYXhpcyA9IGF4aXMgJiYgYXhpc1sgMSBdID8gYXhpc1sgMSBdIDogXCJzZVwiO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdGlmICggby5hdXRvSGlkZSApIHtcblx0XHRcdHRoaXMuX2hhbmRsZXMuaGlkZSgpO1xuXHRcdFx0dGhpcy5fYWRkQ2xhc3MoIFwidWktcmVzaXphYmxlLWF1dG9oaWRlXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZUhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2hhbmRsZXMucmVtb3ZlKCk7XG5cdH0sXG5cblx0X21vdXNlQ2FwdHVyZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBpLCBoYW5kbGUsXG5cdFx0XHRjYXB0dXJlID0gZmFsc2U7XG5cblx0XHRmb3IgKCBpIGluIHRoaXMuaGFuZGxlcyApIHtcblx0XHRcdGhhbmRsZSA9ICQoIHRoaXMuaGFuZGxlc1sgaSBdIClbIDAgXTtcblx0XHRcdGlmICggaGFuZGxlID09PSBldmVudC50YXJnZXQgfHwgJC5jb250YWlucyggaGFuZGxlLCBldmVudC50YXJnZXQgKSApIHtcblx0XHRcdFx0Y2FwdHVyZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuICF0aGlzLm9wdGlvbnMuZGlzYWJsZWQgJiYgY2FwdHVyZTtcblx0fSxcblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0dmFyIGN1cmxlZnQsIGN1cnRvcCwgY3Vyc29yLFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGVsID0gdGhpcy5lbGVtZW50O1xuXG5cdFx0dGhpcy5yZXNpemluZyA9IHRydWU7XG5cblx0XHR0aGlzLl9yZW5kZXJQcm94eSgpO1xuXG5cdFx0Y3VybGVmdCA9IHRoaXMuX251bSggdGhpcy5oZWxwZXIuY3NzKCBcImxlZnRcIiApICk7XG5cdFx0Y3VydG9wID0gdGhpcy5fbnVtKCB0aGlzLmhlbHBlci5jc3MoIFwidG9wXCIgKSApO1xuXG5cdFx0aWYgKCBvLmNvbnRhaW5tZW50ICkge1xuXHRcdFx0Y3VybGVmdCArPSAkKCBvLmNvbnRhaW5tZW50ICkuc2Nyb2xsTGVmdCgpIHx8IDA7XG5cdFx0XHRjdXJ0b3AgKz0gJCggby5jb250YWlubWVudCApLnNjcm9sbFRvcCgpIHx8IDA7XG5cdFx0fVxuXG5cdFx0dGhpcy5vZmZzZXQgPSB0aGlzLmhlbHBlci5vZmZzZXQoKTtcblx0XHR0aGlzLnBvc2l0aW9uID0geyBsZWZ0OiBjdXJsZWZ0LCB0b3A6IGN1cnRvcCB9O1xuXG5cdFx0dGhpcy5zaXplID0gdGhpcy5faGVscGVyID8ge1xuXHRcdFx0XHR3aWR0aDogdGhpcy5oZWxwZXIud2lkdGgoKSxcblx0XHRcdFx0aGVpZ2h0OiB0aGlzLmhlbHBlci5oZWlnaHQoKVxuXHRcdFx0fSA6IHtcblx0XHRcdFx0d2lkdGg6IGVsLndpZHRoKCksXG5cdFx0XHRcdGhlaWdodDogZWwuaGVpZ2h0KClcblx0XHRcdH07XG5cblx0XHR0aGlzLm9yaWdpbmFsU2l6ZSA9IHRoaXMuX2hlbHBlciA/IHtcblx0XHRcdFx0d2lkdGg6IGVsLm91dGVyV2lkdGgoKSxcblx0XHRcdFx0aGVpZ2h0OiBlbC5vdXRlckhlaWdodCgpXG5cdFx0XHR9IDoge1xuXHRcdFx0XHR3aWR0aDogZWwud2lkdGgoKSxcblx0XHRcdFx0aGVpZ2h0OiBlbC5oZWlnaHQoKVxuXHRcdFx0fTtcblxuXHRcdHRoaXMuc2l6ZURpZmYgPSB7XG5cdFx0XHR3aWR0aDogZWwub3V0ZXJXaWR0aCgpIC0gZWwud2lkdGgoKSxcblx0XHRcdGhlaWdodDogZWwub3V0ZXJIZWlnaHQoKSAtIGVsLmhlaWdodCgpXG5cdFx0fTtcblxuXHRcdHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHsgbGVmdDogY3VybGVmdCwgdG9wOiBjdXJ0b3AgfTtcblx0XHR0aGlzLm9yaWdpbmFsTW91c2VQb3NpdGlvbiA9IHsgbGVmdDogZXZlbnQucGFnZVgsIHRvcDogZXZlbnQucGFnZVkgfTtcblxuXHRcdHRoaXMuYXNwZWN0UmF0aW8gPSAoIHR5cGVvZiBvLmFzcGVjdFJhdGlvID09PSBcIm51bWJlclwiICkgP1xuXHRcdFx0by5hc3BlY3RSYXRpbyA6XG5cdFx0XHQoICggdGhpcy5vcmlnaW5hbFNpemUud2lkdGggLyB0aGlzLm9yaWdpbmFsU2l6ZS5oZWlnaHQgKSB8fCAxICk7XG5cblx0XHRjdXJzb3IgPSAkKCBcIi51aS1yZXNpemFibGUtXCIgKyB0aGlzLmF4aXMgKS5jc3MoIFwiY3Vyc29yXCIgKTtcblx0XHQkKCBcImJvZHlcIiApLmNzcyggXCJjdXJzb3JcIiwgY3Vyc29yID09PSBcImF1dG9cIiA/IHRoaXMuYXhpcyArIFwiLXJlc2l6ZVwiIDogY3Vyc29yICk7XG5cblx0XHR0aGlzLl9hZGRDbGFzcyggXCJ1aS1yZXNpemFibGUtcmVzaXppbmdcIiApO1xuXHRcdHRoaXMuX3Byb3BhZ2F0ZSggXCJzdGFydFwiLCBldmVudCApO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9tb3VzZURyYWc6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdHZhciBkYXRhLCBwcm9wcyxcblx0XHRcdHNtcCA9IHRoaXMub3JpZ2luYWxNb3VzZVBvc2l0aW9uLFxuXHRcdFx0YSA9IHRoaXMuYXhpcyxcblx0XHRcdGR4ID0gKCBldmVudC5wYWdlWCAtIHNtcC5sZWZ0ICkgfHwgMCxcblx0XHRcdGR5ID0gKCBldmVudC5wYWdlWSAtIHNtcC50b3AgKSB8fCAwLFxuXHRcdFx0dHJpZ2dlciA9IHRoaXMuX2NoYW5nZVsgYSBdO1xuXG5cdFx0dGhpcy5fdXBkYXRlUHJldlByb3BlcnRpZXMoKTtcblxuXHRcdGlmICggIXRyaWdnZXIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0ZGF0YSA9IHRyaWdnZXIuYXBwbHkoIHRoaXMsIFsgZXZlbnQsIGR4LCBkeSBdICk7XG5cblx0XHR0aGlzLl91cGRhdGVWaXJ0dWFsQm91bmRhcmllcyggZXZlbnQuc2hpZnRLZXkgKTtcblx0XHRpZiAoIHRoaXMuX2FzcGVjdFJhdGlvIHx8IGV2ZW50LnNoaWZ0S2V5ICkge1xuXHRcdFx0ZGF0YSA9IHRoaXMuX3VwZGF0ZVJhdGlvKCBkYXRhLCBldmVudCApO1xuXHRcdH1cblxuXHRcdGRhdGEgPSB0aGlzLl9yZXNwZWN0U2l6ZSggZGF0YSwgZXZlbnQgKTtcblxuXHRcdHRoaXMuX3VwZGF0ZUNhY2hlKCBkYXRhICk7XG5cblx0XHR0aGlzLl9wcm9wYWdhdGUoIFwicmVzaXplXCIsIGV2ZW50ICk7XG5cblx0XHRwcm9wcyA9IHRoaXMuX2FwcGx5Q2hhbmdlcygpO1xuXG5cdFx0aWYgKCAhdGhpcy5faGVscGVyICYmIHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemUoKTtcblx0XHR9XG5cblx0XHRpZiAoICEkLmlzRW1wdHlPYmplY3QoIHByb3BzICkgKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVQcmV2UHJvcGVydGllcygpO1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJyZXNpemVcIiwgZXZlbnQsIHRoaXMudWkoKSApO1xuXHRcdFx0dGhpcy5fYXBwbHlDaGFuZ2VzKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9tb3VzZVN0b3A6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdHRoaXMucmVzaXppbmcgPSBmYWxzZTtcblx0XHR2YXIgcHIsIGlzdGEsIHNvZmZzZXRoLCBzb2Zmc2V0dywgcywgbGVmdCwgdG9wLFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucywgdGhhdCA9IHRoaXM7XG5cblx0XHRpZiAoIHRoaXMuX2hlbHBlciApIHtcblxuXHRcdFx0cHIgPSB0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzO1xuXHRcdFx0aXN0YSA9IHByLmxlbmd0aCAmJiAoIC90ZXh0YXJlYS9pICkudGVzdCggcHJbIDAgXS5ub2RlTmFtZSApO1xuXHRcdFx0c29mZnNldGggPSBpc3RhICYmIHRoaXMuX2hhc1Njcm9sbCggcHJbIDAgXSwgXCJsZWZ0XCIgKSA/IDAgOiB0aGF0LnNpemVEaWZmLmhlaWdodDtcblx0XHRcdHNvZmZzZXR3ID0gaXN0YSA/IDAgOiB0aGF0LnNpemVEaWZmLndpZHRoO1xuXG5cdFx0XHRzID0ge1xuXHRcdFx0XHR3aWR0aDogKCB0aGF0LmhlbHBlci53aWR0aCgpICAtIHNvZmZzZXR3ICksXG5cdFx0XHRcdGhlaWdodDogKCB0aGF0LmhlbHBlci5oZWlnaHQoKSAtIHNvZmZzZXRoIClcblx0XHRcdH07XG5cdFx0XHRsZWZ0ID0gKCBwYXJzZUZsb2F0KCB0aGF0LmVsZW1lbnQuY3NzKCBcImxlZnRcIiApICkgK1xuXHRcdFx0XHQoIHRoYXQucG9zaXRpb24ubGVmdCAtIHRoYXQub3JpZ2luYWxQb3NpdGlvbi5sZWZ0ICkgKSB8fCBudWxsO1xuXHRcdFx0dG9wID0gKCBwYXJzZUZsb2F0KCB0aGF0LmVsZW1lbnQuY3NzKCBcInRvcFwiICkgKSArXG5cdFx0XHRcdCggdGhhdC5wb3NpdGlvbi50b3AgLSB0aGF0Lm9yaWdpbmFsUG9zaXRpb24udG9wICkgKSB8fCBudWxsO1xuXG5cdFx0XHRpZiAoICFvLmFuaW1hdGUgKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5jc3MoICQuZXh0ZW5kKCBzLCB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0gKSApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGF0LmhlbHBlci5oZWlnaHQoIHRoYXQuc2l6ZS5oZWlnaHQgKTtcblx0XHRcdHRoYXQuaGVscGVyLndpZHRoKCB0aGF0LnNpemUud2lkdGggKTtcblxuXHRcdFx0aWYgKCB0aGlzLl9oZWxwZXIgJiYgIW8uYW5pbWF0ZSApIHtcblx0XHRcdFx0dGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQkKCBcImJvZHlcIiApLmNzcyggXCJjdXJzb3JcIiwgXCJhdXRvXCIgKTtcblxuXHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBcInVpLXJlc2l6YWJsZS1yZXNpemluZ1wiICk7XG5cblx0XHR0aGlzLl9wcm9wYWdhdGUoIFwic3RvcFwiLCBldmVudCApO1xuXG5cdFx0aWYgKCB0aGlzLl9oZWxwZXIgKSB7XG5cdFx0XHR0aGlzLmhlbHBlci5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fSxcblxuXHRfdXBkYXRlUHJldlByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucHJldlBvc2l0aW9uID0ge1xuXHRcdFx0dG9wOiB0aGlzLnBvc2l0aW9uLnRvcCxcblx0XHRcdGxlZnQ6IHRoaXMucG9zaXRpb24ubGVmdFxuXHRcdH07XG5cdFx0dGhpcy5wcmV2U2l6ZSA9IHtcblx0XHRcdHdpZHRoOiB0aGlzLnNpemUud2lkdGgsXG5cdFx0XHRoZWlnaHQ6IHRoaXMuc2l6ZS5oZWlnaHRcblx0XHR9O1xuXHR9LFxuXG5cdF9hcHBseUNoYW5nZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwcm9wcyA9IHt9O1xuXG5cdFx0aWYgKCB0aGlzLnBvc2l0aW9uLnRvcCAhPT0gdGhpcy5wcmV2UG9zaXRpb24udG9wICkge1xuXHRcdFx0cHJvcHMudG9wID0gdGhpcy5wb3NpdGlvbi50b3AgKyBcInB4XCI7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5wb3NpdGlvbi5sZWZ0ICE9PSB0aGlzLnByZXZQb3NpdGlvbi5sZWZ0ICkge1xuXHRcdFx0cHJvcHMubGVmdCA9IHRoaXMucG9zaXRpb24ubGVmdCArIFwicHhcIjtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLnNpemUud2lkdGggIT09IHRoaXMucHJldlNpemUud2lkdGggKSB7XG5cdFx0XHRwcm9wcy53aWR0aCA9IHRoaXMuc2l6ZS53aWR0aCArIFwicHhcIjtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLnNpemUuaGVpZ2h0ICE9PSB0aGlzLnByZXZTaXplLmhlaWdodCApIHtcblx0XHRcdHByb3BzLmhlaWdodCA9IHRoaXMuc2l6ZS5oZWlnaHQgKyBcInB4XCI7XG5cdFx0fVxuXG5cdFx0dGhpcy5oZWxwZXIuY3NzKCBwcm9wcyApO1xuXG5cdFx0cmV0dXJuIHByb3BzO1xuXHR9LFxuXG5cdF91cGRhdGVWaXJ0dWFsQm91bmRhcmllczogZnVuY3Rpb24oIGZvcmNlQXNwZWN0UmF0aW8gKSB7XG5cdFx0dmFyIHBNaW5XaWR0aCwgcE1heFdpZHRoLCBwTWluSGVpZ2h0LCBwTWF4SGVpZ2h0LCBiLFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucztcblxuXHRcdGIgPSB7XG5cdFx0XHRtaW5XaWR0aDogdGhpcy5faXNOdW1iZXIoIG8ubWluV2lkdGggKSA/IG8ubWluV2lkdGggOiAwLFxuXHRcdFx0bWF4V2lkdGg6IHRoaXMuX2lzTnVtYmVyKCBvLm1heFdpZHRoICkgPyBvLm1heFdpZHRoIDogSW5maW5pdHksXG5cdFx0XHRtaW5IZWlnaHQ6IHRoaXMuX2lzTnVtYmVyKCBvLm1pbkhlaWdodCApID8gby5taW5IZWlnaHQgOiAwLFxuXHRcdFx0bWF4SGVpZ2h0OiB0aGlzLl9pc051bWJlciggby5tYXhIZWlnaHQgKSA/IG8ubWF4SGVpZ2h0IDogSW5maW5pdHlcblx0XHR9O1xuXG5cdFx0aWYgKCB0aGlzLl9hc3BlY3RSYXRpbyB8fCBmb3JjZUFzcGVjdFJhdGlvICkge1xuXHRcdFx0cE1pbldpZHRoID0gYi5taW5IZWlnaHQgKiB0aGlzLmFzcGVjdFJhdGlvO1xuXHRcdFx0cE1pbkhlaWdodCA9IGIubWluV2lkdGggLyB0aGlzLmFzcGVjdFJhdGlvO1xuXHRcdFx0cE1heFdpZHRoID0gYi5tYXhIZWlnaHQgKiB0aGlzLmFzcGVjdFJhdGlvO1xuXHRcdFx0cE1heEhlaWdodCA9IGIubWF4V2lkdGggLyB0aGlzLmFzcGVjdFJhdGlvO1xuXG5cdFx0XHRpZiAoIHBNaW5XaWR0aCA+IGIubWluV2lkdGggKSB7XG5cdFx0XHRcdGIubWluV2lkdGggPSBwTWluV2lkdGg7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHBNaW5IZWlnaHQgPiBiLm1pbkhlaWdodCApIHtcblx0XHRcdFx0Yi5taW5IZWlnaHQgPSBwTWluSGVpZ2h0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBwTWF4V2lkdGggPCBiLm1heFdpZHRoICkge1xuXHRcdFx0XHRiLm1heFdpZHRoID0gcE1heFdpZHRoO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBwTWF4SGVpZ2h0IDwgYi5tYXhIZWlnaHQgKSB7XG5cdFx0XHRcdGIubWF4SGVpZ2h0ID0gcE1heEhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fdkJvdW5kYXJpZXMgPSBiO1xuXHR9LFxuXG5cdF91cGRhdGVDYWNoZTogZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0dGhpcy5vZmZzZXQgPSB0aGlzLmhlbHBlci5vZmZzZXQoKTtcblx0XHRpZiAoIHRoaXMuX2lzTnVtYmVyKCBkYXRhLmxlZnQgKSApIHtcblx0XHRcdHRoaXMucG9zaXRpb24ubGVmdCA9IGRhdGEubGVmdDtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLl9pc051bWJlciggZGF0YS50b3AgKSApIHtcblx0XHRcdHRoaXMucG9zaXRpb24udG9wID0gZGF0YS50b3A7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5faXNOdW1iZXIoIGRhdGEuaGVpZ2h0ICkgKSB7XG5cdFx0XHR0aGlzLnNpemUuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5faXNOdW1iZXIoIGRhdGEud2lkdGggKSApIHtcblx0XHRcdHRoaXMuc2l6ZS53aWR0aCA9IGRhdGEud2lkdGg7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVSYXRpbzogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHR2YXIgY3BvcyA9IHRoaXMucG9zaXRpb24sXG5cdFx0XHRjc2l6ZSA9IHRoaXMuc2l6ZSxcblx0XHRcdGEgPSB0aGlzLmF4aXM7XG5cblx0XHRpZiAoIHRoaXMuX2lzTnVtYmVyKCBkYXRhLmhlaWdodCApICkge1xuXHRcdFx0ZGF0YS53aWR0aCA9ICggZGF0YS5oZWlnaHQgKiB0aGlzLmFzcGVjdFJhdGlvICk7XG5cdFx0fSBlbHNlIGlmICggdGhpcy5faXNOdW1iZXIoIGRhdGEud2lkdGggKSApIHtcblx0XHRcdGRhdGEuaGVpZ2h0ID0gKCBkYXRhLndpZHRoIC8gdGhpcy5hc3BlY3RSYXRpbyApO1xuXHRcdH1cblxuXHRcdGlmICggYSA9PT0gXCJzd1wiICkge1xuXHRcdFx0ZGF0YS5sZWZ0ID0gY3Bvcy5sZWZ0ICsgKCBjc2l6ZS53aWR0aCAtIGRhdGEud2lkdGggKTtcblx0XHRcdGRhdGEudG9wID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKCBhID09PSBcIm53XCIgKSB7XG5cdFx0XHRkYXRhLnRvcCA9IGNwb3MudG9wICsgKCBjc2l6ZS5oZWlnaHQgLSBkYXRhLmhlaWdodCApO1xuXHRcdFx0ZGF0YS5sZWZ0ID0gY3Bvcy5sZWZ0ICsgKCBjc2l6ZS53aWR0aCAtIGRhdGEud2lkdGggKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblx0fSxcblxuXHRfcmVzcGVjdFNpemU6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0dmFyIG8gPSB0aGlzLl92Qm91bmRhcmllcyxcblx0XHRcdGEgPSB0aGlzLmF4aXMsXG5cdFx0XHRpc21heHcgPSB0aGlzLl9pc051bWJlciggZGF0YS53aWR0aCApICYmIG8ubWF4V2lkdGggJiYgKCBvLm1heFdpZHRoIDwgZGF0YS53aWR0aCApLFxuXHRcdFx0aXNtYXhoID0gdGhpcy5faXNOdW1iZXIoIGRhdGEuaGVpZ2h0ICkgJiYgby5tYXhIZWlnaHQgJiYgKCBvLm1heEhlaWdodCA8IGRhdGEuaGVpZ2h0ICksXG5cdFx0XHRpc21pbncgPSB0aGlzLl9pc051bWJlciggZGF0YS53aWR0aCApICYmIG8ubWluV2lkdGggJiYgKCBvLm1pbldpZHRoID4gZGF0YS53aWR0aCApLFxuXHRcdFx0aXNtaW5oID0gdGhpcy5faXNOdW1iZXIoIGRhdGEuaGVpZ2h0ICkgJiYgby5taW5IZWlnaHQgJiYgKCBvLm1pbkhlaWdodCA+IGRhdGEuaGVpZ2h0ICksXG5cdFx0XHRkdyA9IHRoaXMub3JpZ2luYWxQb3NpdGlvbi5sZWZ0ICsgdGhpcy5vcmlnaW5hbFNpemUud2lkdGgsXG5cdFx0XHRkaCA9IHRoaXMub3JpZ2luYWxQb3NpdGlvbi50b3AgKyB0aGlzLm9yaWdpbmFsU2l6ZS5oZWlnaHQsXG5cdFx0XHRjdyA9IC9zd3xud3x3Ly50ZXN0KCBhICksIGNoID0gL253fG5lfG4vLnRlc3QoIGEgKTtcblx0XHRpZiAoIGlzbWludyApIHtcblx0XHRcdGRhdGEud2lkdGggPSBvLm1pbldpZHRoO1xuXHRcdH1cblx0XHRpZiAoIGlzbWluaCApIHtcblx0XHRcdGRhdGEuaGVpZ2h0ID0gby5taW5IZWlnaHQ7XG5cdFx0fVxuXHRcdGlmICggaXNtYXh3ICkge1xuXHRcdFx0ZGF0YS53aWR0aCA9IG8ubWF4V2lkdGg7XG5cdFx0fVxuXHRcdGlmICggaXNtYXhoICkge1xuXHRcdFx0ZGF0YS5oZWlnaHQgPSBvLm1heEhlaWdodDtcblx0XHR9XG5cblx0XHRpZiAoIGlzbWludyAmJiBjdyApIHtcblx0XHRcdGRhdGEubGVmdCA9IGR3IC0gby5taW5XaWR0aDtcblx0XHR9XG5cdFx0aWYgKCBpc21heHcgJiYgY3cgKSB7XG5cdFx0XHRkYXRhLmxlZnQgPSBkdyAtIG8ubWF4V2lkdGg7XG5cdFx0fVxuXHRcdGlmICggaXNtaW5oICYmIGNoICkge1xuXHRcdFx0ZGF0YS50b3AgPSBkaCAtIG8ubWluSGVpZ2h0O1xuXHRcdH1cblx0XHRpZiAoIGlzbWF4aCAmJiBjaCApIHtcblx0XHRcdGRhdGEudG9wID0gZGggLSBvLm1heEhlaWdodDtcblx0XHR9XG5cblx0XHQvLyBGaXhpbmcganVtcCBlcnJvciBvbiB0b3AvbGVmdCAtIGJ1ZyAjMjMzMFxuXHRcdGlmICggIWRhdGEud2lkdGggJiYgIWRhdGEuaGVpZ2h0ICYmICFkYXRhLmxlZnQgJiYgZGF0YS50b3AgKSB7XG5cdFx0XHRkYXRhLnRvcCA9IG51bGw7XG5cdFx0fSBlbHNlIGlmICggIWRhdGEud2lkdGggJiYgIWRhdGEuaGVpZ2h0ICYmICFkYXRhLnRvcCAmJiBkYXRhLmxlZnQgKSB7XG5cdFx0XHRkYXRhLmxlZnQgPSBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXHR9LFxuXG5cdF9nZXRQYWRkaW5nUGx1c0JvcmRlckRpbWVuc2lvbnM6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdHdpZHRocyA9IFtdLFxuXHRcdFx0Ym9yZGVycyA9IFtcblx0XHRcdFx0ZWxlbWVudC5jc3MoIFwiYm9yZGVyVG9wV2lkdGhcIiApLFxuXHRcdFx0XHRlbGVtZW50LmNzcyggXCJib3JkZXJSaWdodFdpZHRoXCIgKSxcblx0XHRcdFx0ZWxlbWVudC5jc3MoIFwiYm9yZGVyQm90dG9tV2lkdGhcIiApLFxuXHRcdFx0XHRlbGVtZW50LmNzcyggXCJib3JkZXJMZWZ0V2lkdGhcIiApXG5cdFx0XHRdLFxuXHRcdFx0cGFkZGluZ3MgPSBbXG5cdFx0XHRcdGVsZW1lbnQuY3NzKCBcInBhZGRpbmdUb3BcIiApLFxuXHRcdFx0XHRlbGVtZW50LmNzcyggXCJwYWRkaW5nUmlnaHRcIiApLFxuXHRcdFx0XHRlbGVtZW50LmNzcyggXCJwYWRkaW5nQm90dG9tXCIgKSxcblx0XHRcdFx0ZWxlbWVudC5jc3MoIFwicGFkZGluZ0xlZnRcIiApXG5cdFx0XHRdO1xuXG5cdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0d2lkdGhzWyBpIF0gPSAoIHBhcnNlRmxvYXQoIGJvcmRlcnNbIGkgXSApIHx8IDAgKTtcblx0XHRcdHdpZHRoc1sgaSBdICs9ICggcGFyc2VGbG9hdCggcGFkZGluZ3NbIGkgXSApIHx8IDAgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0aGVpZ2h0OiB3aWR0aHNbIDAgXSArIHdpZHRoc1sgMiBdLFxuXHRcdFx0d2lkdGg6IHdpZHRoc1sgMSBdICsgd2lkdGhzWyAzIF1cblx0XHR9O1xuXHR9LFxuXG5cdF9wcm9wb3J0aW9uYWxseVJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cblx0XHRpZiAoICF0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcHJlbCxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZWxlbWVudCA9IHRoaXMuaGVscGVyIHx8IHRoaXMuZWxlbWVudDtcblxuXHRcdGZvciAoIDsgaSA8IHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHMubGVuZ3RoOyBpKysgKSB7XG5cblx0XHRcdHByZWwgPSB0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzWyBpIF07XG5cblx0XHRcdC8vIFRPRE86IFNlZW1zIGxpa2UgYSBidWcgdG8gY2FjaGUgdGhpcy5vdXRlckRpbWVuc2lvbnNcblx0XHRcdC8vIGNvbnNpZGVyaW5nIHRoYXQgd2UgYXJlIGluIGEgbG9vcC5cblx0XHRcdGlmICggIXRoaXMub3V0ZXJEaW1lbnNpb25zICkge1xuXHRcdFx0XHR0aGlzLm91dGVyRGltZW5zaW9ucyA9IHRoaXMuX2dldFBhZGRpbmdQbHVzQm9yZGVyRGltZW5zaW9ucyggcHJlbCApO1xuXHRcdFx0fVxuXG5cdFx0XHRwcmVsLmNzcygge1xuXHRcdFx0XHRoZWlnaHQ6ICggZWxlbWVudC5oZWlnaHQoKSAtIHRoaXMub3V0ZXJEaW1lbnNpb25zLmhlaWdodCApIHx8IDAsXG5cdFx0XHRcdHdpZHRoOiAoIGVsZW1lbnQud2lkdGgoKSAtIHRoaXMub3V0ZXJEaW1lbnNpb25zLndpZHRoICkgfHwgMFxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0X3JlbmRlclByb3h5OiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBlbCA9IHRoaXMuZWxlbWVudCwgbyA9IHRoaXMub3B0aW9ucztcblx0XHR0aGlzLmVsZW1lbnRPZmZzZXQgPSBlbC5vZmZzZXQoKTtcblxuXHRcdGlmICggdGhpcy5faGVscGVyICkge1xuXG5cdFx0XHR0aGlzLmhlbHBlciA9IHRoaXMuaGVscGVyIHx8ICQoIFwiPGRpdiBzdHlsZT0nb3ZlcmZsb3c6aGlkZGVuOyc+PC9kaXY+XCIgKTtcblxuXHRcdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMuaGVscGVyLCB0aGlzLl9oZWxwZXIgKTtcblx0XHRcdHRoaXMuaGVscGVyLmNzcygge1xuXHRcdFx0XHR3aWR0aDogdGhpcy5lbGVtZW50Lm91dGVyV2lkdGgoKSxcblx0XHRcdFx0aGVpZ2h0OiB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKSxcblx0XHRcdFx0cG9zaXRpb246IFwiYWJzb2x1dGVcIixcblx0XHRcdFx0bGVmdDogdGhpcy5lbGVtZW50T2Zmc2V0LmxlZnQgKyBcInB4XCIsXG5cdFx0XHRcdHRvcDogdGhpcy5lbGVtZW50T2Zmc2V0LnRvcCArIFwicHhcIixcblx0XHRcdFx0ekluZGV4OiArK28uekluZGV4IC8vVE9ETzogRG9uJ3QgbW9kaWZ5IG9wdGlvblxuXHRcdFx0fSApO1xuXG5cdFx0XHR0aGlzLmhlbHBlclxuXHRcdFx0XHQuYXBwZW5kVG8oIFwiYm9keVwiIClcblx0XHRcdFx0LmRpc2FibGVTZWxlY3Rpb24oKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmhlbHBlciA9IHRoaXMuZWxlbWVudDtcblx0XHR9XG5cblx0fSxcblxuXHRfY2hhbmdlOiB7XG5cdFx0ZTogZnVuY3Rpb24oIGV2ZW50LCBkeCApIHtcblx0XHRcdHJldHVybiB7IHdpZHRoOiB0aGlzLm9yaWdpbmFsU2l6ZS53aWR0aCArIGR4IH07XG5cdFx0fSxcblx0XHR3OiBmdW5jdGlvbiggZXZlbnQsIGR4ICkge1xuXHRcdFx0dmFyIGNzID0gdGhpcy5vcmlnaW5hbFNpemUsIHNwID0gdGhpcy5vcmlnaW5hbFBvc2l0aW9uO1xuXHRcdFx0cmV0dXJuIHsgbGVmdDogc3AubGVmdCArIGR4LCB3aWR0aDogY3Mud2lkdGggLSBkeCB9O1xuXHRcdH0sXG5cdFx0bjogZnVuY3Rpb24oIGV2ZW50LCBkeCwgZHkgKSB7XG5cdFx0XHR2YXIgY3MgPSB0aGlzLm9yaWdpbmFsU2l6ZSwgc3AgPSB0aGlzLm9yaWdpbmFsUG9zaXRpb247XG5cdFx0XHRyZXR1cm4geyB0b3A6IHNwLnRvcCArIGR5LCBoZWlnaHQ6IGNzLmhlaWdodCAtIGR5IH07XG5cdFx0fSxcblx0XHRzOiBmdW5jdGlvbiggZXZlbnQsIGR4LCBkeSApIHtcblx0XHRcdHJldHVybiB7IGhlaWdodDogdGhpcy5vcmlnaW5hbFNpemUuaGVpZ2h0ICsgZHkgfTtcblx0XHR9LFxuXHRcdHNlOiBmdW5jdGlvbiggZXZlbnQsIGR4LCBkeSApIHtcblx0XHRcdHJldHVybiAkLmV4dGVuZCggdGhpcy5fY2hhbmdlLnMuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApLFxuXHRcdFx0XHR0aGlzLl9jaGFuZ2UuZS5hcHBseSggdGhpcywgWyBldmVudCwgZHgsIGR5IF0gKSApO1xuXHRcdH0sXG5cdFx0c3c6IGZ1bmN0aW9uKCBldmVudCwgZHgsIGR5ICkge1xuXHRcdFx0cmV0dXJuICQuZXh0ZW5kKCB0aGlzLl9jaGFuZ2Uucy5hcHBseSggdGhpcywgYXJndW1lbnRzICksXG5cdFx0XHRcdHRoaXMuX2NoYW5nZS53LmFwcGx5KCB0aGlzLCBbIGV2ZW50LCBkeCwgZHkgXSApICk7XG5cdFx0fSxcblx0XHRuZTogZnVuY3Rpb24oIGV2ZW50LCBkeCwgZHkgKSB7XG5cdFx0XHRyZXR1cm4gJC5leHRlbmQoIHRoaXMuX2NoYW5nZS5uLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSxcblx0XHRcdFx0dGhpcy5fY2hhbmdlLmUuYXBwbHkoIHRoaXMsIFsgZXZlbnQsIGR4LCBkeSBdICkgKTtcblx0XHR9LFxuXHRcdG53OiBmdW5jdGlvbiggZXZlbnQsIGR4LCBkeSApIHtcblx0XHRcdHJldHVybiAkLmV4dGVuZCggdGhpcy5fY2hhbmdlLm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApLFxuXHRcdFx0XHR0aGlzLl9jaGFuZ2Uudy5hcHBseSggdGhpcywgWyBldmVudCwgZHgsIGR5IF0gKSApO1xuXHRcdH1cblx0fSxcblxuXHRfcHJvcGFnYXRlOiBmdW5jdGlvbiggbiwgZXZlbnQgKSB7XG5cdFx0JC51aS5wbHVnaW4uY2FsbCggdGhpcywgbiwgWyBldmVudCwgdGhpcy51aSgpIF0gKTtcblx0XHQoIG4gIT09IFwicmVzaXplXCIgJiYgdGhpcy5fdHJpZ2dlciggbiwgZXZlbnQsIHRoaXMudWkoKSApICk7XG5cdH0sXG5cblx0cGx1Z2luczoge30sXG5cblx0dWk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRvcmlnaW5hbEVsZW1lbnQ6IHRoaXMub3JpZ2luYWxFbGVtZW50LFxuXHRcdFx0ZWxlbWVudDogdGhpcy5lbGVtZW50LFxuXHRcdFx0aGVscGVyOiB0aGlzLmhlbHBlcixcblx0XHRcdHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLFxuXHRcdFx0c2l6ZTogdGhpcy5zaXplLFxuXHRcdFx0b3JpZ2luYWxTaXplOiB0aGlzLm9yaWdpbmFsU2l6ZSxcblx0XHRcdG9yaWdpbmFsUG9zaXRpb246IHRoaXMub3JpZ2luYWxQb3NpdGlvblxuXHRcdH07XG5cdH1cblxufSApO1xuXG4vKlxuICogUmVzaXphYmxlIEV4dGVuc2lvbnNcbiAqL1xuXG4kLnVpLnBsdWdpbi5hZGQoIFwicmVzaXphYmxlXCIsIFwiYW5pbWF0ZVwiLCB7XG5cblx0c3RvcDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciB0aGF0ID0gJCggdGhpcyApLnJlc2l6YWJsZSggXCJpbnN0YW5jZVwiICksXG5cdFx0XHRvID0gdGhhdC5vcHRpb25zLFxuXHRcdFx0cHIgPSB0aGF0Ll9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzLFxuXHRcdFx0aXN0YSA9IHByLmxlbmd0aCAmJiAoIC90ZXh0YXJlYS9pICkudGVzdCggcHJbIDAgXS5ub2RlTmFtZSApLFxuXHRcdFx0c29mZnNldGggPSBpc3RhICYmIHRoYXQuX2hhc1Njcm9sbCggcHJbIDAgXSwgXCJsZWZ0XCIgKSA/IDAgOiB0aGF0LnNpemVEaWZmLmhlaWdodCxcblx0XHRcdHNvZmZzZXR3ID0gaXN0YSA/IDAgOiB0aGF0LnNpemVEaWZmLndpZHRoLFxuXHRcdFx0c3R5bGUgPSB7XG5cdFx0XHRcdHdpZHRoOiAoIHRoYXQuc2l6ZS53aWR0aCAtIHNvZmZzZXR3ICksXG5cdFx0XHRcdGhlaWdodDogKCB0aGF0LnNpemUuaGVpZ2h0IC0gc29mZnNldGggKVxuXHRcdFx0fSxcblx0XHRcdGxlZnQgPSAoIHBhcnNlRmxvYXQoIHRoYXQuZWxlbWVudC5jc3MoIFwibGVmdFwiICkgKSArXG5cdFx0XHRcdCggdGhhdC5wb3NpdGlvbi5sZWZ0IC0gdGhhdC5vcmlnaW5hbFBvc2l0aW9uLmxlZnQgKSApIHx8IG51bGwsXG5cdFx0XHR0b3AgPSAoIHBhcnNlRmxvYXQoIHRoYXQuZWxlbWVudC5jc3MoIFwidG9wXCIgKSApICtcblx0XHRcdFx0KCB0aGF0LnBvc2l0aW9uLnRvcCAtIHRoYXQub3JpZ2luYWxQb3NpdGlvbi50b3AgKSApIHx8IG51bGw7XG5cblx0XHR0aGF0LmVsZW1lbnQuYW5pbWF0ZShcblx0XHRcdCQuZXh0ZW5kKCBzdHlsZSwgdG9wICYmIGxlZnQgPyB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0gOiB7fSApLCB7XG5cdFx0XHRcdGR1cmF0aW9uOiBvLmFuaW1hdGVEdXJhdGlvbixcblx0XHRcdFx0ZWFzaW5nOiBvLmFuaW1hdGVFYXNpbmcsXG5cdFx0XHRcdHN0ZXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdFx0XHR3aWR0aDogcGFyc2VGbG9hdCggdGhhdC5lbGVtZW50LmNzcyggXCJ3aWR0aFwiICkgKSxcblx0XHRcdFx0XHRcdGhlaWdodDogcGFyc2VGbG9hdCggdGhhdC5lbGVtZW50LmNzcyggXCJoZWlnaHRcIiApICksXG5cdFx0XHRcdFx0XHR0b3A6IHBhcnNlRmxvYXQoIHRoYXQuZWxlbWVudC5jc3MoIFwidG9wXCIgKSApLFxuXHRcdFx0XHRcdFx0bGVmdDogcGFyc2VGbG9hdCggdGhhdC5lbGVtZW50LmNzcyggXCJsZWZ0XCIgKSApXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGlmICggcHIgJiYgcHIubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0JCggcHJbIDAgXSApLmNzcyggeyB3aWR0aDogZGF0YS53aWR0aCwgaGVpZ2h0OiBkYXRhLmhlaWdodCB9ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJvcGFnYXRpbmcgcmVzaXplLCBhbmQgdXBkYXRpbmcgdmFsdWVzIGZvciBlYWNoIGFuaW1hdGlvbiBzdGVwXG5cdFx0XHRcdFx0dGhhdC5fdXBkYXRlQ2FjaGUoIGRhdGEgKTtcblx0XHRcdFx0XHR0aGF0Ll9wcm9wYWdhdGUoIFwicmVzaXplXCIsIGV2ZW50ICk7XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCk7XG5cdH1cblxufSApO1xuXG4kLnVpLnBsdWdpbi5hZGQoIFwicmVzaXphYmxlXCIsIFwiY29udGFpbm1lbnRcIiwge1xuXG5cdHN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbWVudCwgcCwgY28sIGNoLCBjdywgd2lkdGgsIGhlaWdodCxcblx0XHRcdHRoYXQgPSAkKCB0aGlzICkucmVzaXphYmxlKCBcImluc3RhbmNlXCIgKSxcblx0XHRcdG8gPSB0aGF0Lm9wdGlvbnMsXG5cdFx0XHRlbCA9IHRoYXQuZWxlbWVudCxcblx0XHRcdG9jID0gby5jb250YWlubWVudCxcblx0XHRcdGNlID0gKCBvYyBpbnN0YW5jZW9mICQgKSA/XG5cdFx0XHRcdG9jLmdldCggMCApIDpcblx0XHRcdFx0KCAvcGFyZW50Ly50ZXN0KCBvYyApICkgPyBlbC5wYXJlbnQoKS5nZXQoIDAgKSA6IG9jO1xuXG5cdFx0aWYgKCAhY2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhhdC5jb250YWluZXJFbGVtZW50ID0gJCggY2UgKTtcblxuXHRcdGlmICggL2RvY3VtZW50Ly50ZXN0KCBvYyApIHx8IG9jID09PSBkb2N1bWVudCApIHtcblx0XHRcdHRoYXQuY29udGFpbmVyT2Zmc2V0ID0ge1xuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHR0b3A6IDBcblx0XHRcdH07XG5cdFx0XHR0aGF0LmNvbnRhaW5lclBvc2l0aW9uID0ge1xuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHR0b3A6IDBcblx0XHRcdH07XG5cblx0XHRcdHRoYXQucGFyZW50RGF0YSA9IHtcblx0XHRcdFx0ZWxlbWVudDogJCggZG9jdW1lbnQgKSxcblx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHR3aWR0aDogJCggZG9jdW1lbnQgKS53aWR0aCgpLFxuXHRcdFx0XHRoZWlnaHQ6ICQoIGRvY3VtZW50ICkuaGVpZ2h0KCkgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbEhlaWdodFxuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudCA9ICQoIGNlICk7XG5cdFx0XHRwID0gW107XG5cdFx0XHQkKCBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJMZWZ0XCIsIFwiQm90dG9tXCIgXSApLmVhY2goIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRcdFx0XHRwWyBpIF0gPSB0aGF0Ll9udW0oIGVsZW1lbnQuY3NzKCBcInBhZGRpbmdcIiArIG5hbWUgKSApO1xuXHRcdFx0fSApO1xuXG5cdFx0XHR0aGF0LmNvbnRhaW5lck9mZnNldCA9IGVsZW1lbnQub2Zmc2V0KCk7XG5cdFx0XHR0aGF0LmNvbnRhaW5lclBvc2l0aW9uID0gZWxlbWVudC5wb3NpdGlvbigpO1xuXHRcdFx0dGhhdC5jb250YWluZXJTaXplID0ge1xuXHRcdFx0XHRoZWlnaHQ6ICggZWxlbWVudC5pbm5lckhlaWdodCgpIC0gcFsgMyBdICksXG5cdFx0XHRcdHdpZHRoOiAoIGVsZW1lbnQuaW5uZXJXaWR0aCgpIC0gcFsgMSBdIClcblx0XHRcdH07XG5cblx0XHRcdGNvID0gdGhhdC5jb250YWluZXJPZmZzZXQ7XG5cdFx0XHRjaCA9IHRoYXQuY29udGFpbmVyU2l6ZS5oZWlnaHQ7XG5cdFx0XHRjdyA9IHRoYXQuY29udGFpbmVyU2l6ZS53aWR0aDtcblx0XHRcdHdpZHRoID0gKCB0aGF0Ll9oYXNTY3JvbGwgKCBjZSwgXCJsZWZ0XCIgKSA/IGNlLnNjcm9sbFdpZHRoIDogY3cgKTtcblx0XHRcdGhlaWdodCA9ICggdGhhdC5faGFzU2Nyb2xsICggY2UgKSA/IGNlLnNjcm9sbEhlaWdodCA6IGNoICkgO1xuXG5cdFx0XHR0aGF0LnBhcmVudERhdGEgPSB7XG5cdFx0XHRcdGVsZW1lbnQ6IGNlLFxuXHRcdFx0XHRsZWZ0OiBjby5sZWZ0LFxuXHRcdFx0XHR0b3A6IGNvLnRvcCxcblx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGhlaWdodFxuXHRcdFx0fTtcblx0XHR9XG5cdH0sXG5cblx0cmVzaXplOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHdvc2V0LCBob3NldCwgaXNQYXJlbnQsIGlzT2Zmc2V0UmVsYXRpdmUsXG5cdFx0XHR0aGF0ID0gJCggdGhpcyApLnJlc2l6YWJsZSggXCJpbnN0YW5jZVwiICksXG5cdFx0XHRvID0gdGhhdC5vcHRpb25zLFxuXHRcdFx0Y28gPSB0aGF0LmNvbnRhaW5lck9mZnNldCxcblx0XHRcdGNwID0gdGhhdC5wb3NpdGlvbixcblx0XHRcdHBSYXRpbyA9IHRoYXQuX2FzcGVjdFJhdGlvIHx8IGV2ZW50LnNoaWZ0S2V5LFxuXHRcdFx0Y29wID0ge1xuXHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdGxlZnQ6IDBcblx0XHRcdH0sXG5cdFx0XHRjZSA9IHRoYXQuY29udGFpbmVyRWxlbWVudCxcblx0XHRcdGNvbnRpbnVlUmVzaXplID0gdHJ1ZTtcblxuXHRcdGlmICggY2VbIDAgXSAhPT0gZG9jdW1lbnQgJiYgKCAvc3RhdGljLyApLnRlc3QoIGNlLmNzcyggXCJwb3NpdGlvblwiICkgKSApIHtcblx0XHRcdGNvcCA9IGNvO1xuXHRcdH1cblxuXHRcdGlmICggY3AubGVmdCA8ICggdGhhdC5faGVscGVyID8gY28ubGVmdCA6IDAgKSApIHtcblx0XHRcdHRoYXQuc2l6ZS53aWR0aCA9IHRoYXQuc2l6ZS53aWR0aCArXG5cdFx0XHRcdCggdGhhdC5faGVscGVyID9cblx0XHRcdFx0XHQoIHRoYXQucG9zaXRpb24ubGVmdCAtIGNvLmxlZnQgKSA6XG5cdFx0XHRcdFx0KCB0aGF0LnBvc2l0aW9uLmxlZnQgLSBjb3AubGVmdCApICk7XG5cblx0XHRcdGlmICggcFJhdGlvICkge1xuXHRcdFx0XHR0aGF0LnNpemUuaGVpZ2h0ID0gdGhhdC5zaXplLndpZHRoIC8gdGhhdC5hc3BlY3RSYXRpbztcblx0XHRcdFx0Y29udGludWVSZXNpemUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHRoYXQucG9zaXRpb24ubGVmdCA9IG8uaGVscGVyID8gY28ubGVmdCA6IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBjcC50b3AgPCAoIHRoYXQuX2hlbHBlciA/IGNvLnRvcCA6IDAgKSApIHtcblx0XHRcdHRoYXQuc2l6ZS5oZWlnaHQgPSB0aGF0LnNpemUuaGVpZ2h0ICtcblx0XHRcdFx0KCB0aGF0Ll9oZWxwZXIgP1xuXHRcdFx0XHRcdCggdGhhdC5wb3NpdGlvbi50b3AgLSBjby50b3AgKSA6XG5cdFx0XHRcdFx0dGhhdC5wb3NpdGlvbi50b3AgKTtcblxuXHRcdFx0aWYgKCBwUmF0aW8gKSB7XG5cdFx0XHRcdHRoYXQuc2l6ZS53aWR0aCA9IHRoYXQuc2l6ZS5oZWlnaHQgKiB0aGF0LmFzcGVjdFJhdGlvO1xuXHRcdFx0XHRjb250aW51ZVJlc2l6ZSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhhdC5wb3NpdGlvbi50b3AgPSB0aGF0Ll9oZWxwZXIgPyBjby50b3AgOiAwO1xuXHRcdH1cblxuXHRcdGlzUGFyZW50ID0gdGhhdC5jb250YWluZXJFbGVtZW50LmdldCggMCApID09PSB0aGF0LmVsZW1lbnQucGFyZW50KCkuZ2V0KCAwICk7XG5cdFx0aXNPZmZzZXRSZWxhdGl2ZSA9IC9yZWxhdGl2ZXxhYnNvbHV0ZS8udGVzdCggdGhhdC5jb250YWluZXJFbGVtZW50LmNzcyggXCJwb3NpdGlvblwiICkgKTtcblxuXHRcdGlmICggaXNQYXJlbnQgJiYgaXNPZmZzZXRSZWxhdGl2ZSApIHtcblx0XHRcdHRoYXQub2Zmc2V0LmxlZnQgPSB0aGF0LnBhcmVudERhdGEubGVmdCArIHRoYXQucG9zaXRpb24ubGVmdDtcblx0XHRcdHRoYXQub2Zmc2V0LnRvcCA9IHRoYXQucGFyZW50RGF0YS50b3AgKyB0aGF0LnBvc2l0aW9uLnRvcDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhhdC5vZmZzZXQubGVmdCA9IHRoYXQuZWxlbWVudC5vZmZzZXQoKS5sZWZ0O1xuXHRcdFx0dGhhdC5vZmZzZXQudG9wID0gdGhhdC5lbGVtZW50Lm9mZnNldCgpLnRvcDtcblx0XHR9XG5cblx0XHR3b3NldCA9IE1hdGguYWJzKCB0aGF0LnNpemVEaWZmLndpZHRoICtcblx0XHRcdCggdGhhdC5faGVscGVyID9cblx0XHRcdFx0dGhhdC5vZmZzZXQubGVmdCAtIGNvcC5sZWZ0IDpcblx0XHRcdFx0KCB0aGF0Lm9mZnNldC5sZWZ0IC0gY28ubGVmdCApICkgKTtcblxuXHRcdGhvc2V0ID0gTWF0aC5hYnMoIHRoYXQuc2l6ZURpZmYuaGVpZ2h0ICtcblx0XHRcdCggdGhhdC5faGVscGVyID9cblx0XHRcdFx0dGhhdC5vZmZzZXQudG9wIC0gY29wLnRvcCA6XG5cdFx0XHRcdCggdGhhdC5vZmZzZXQudG9wIC0gY28udG9wICkgKSApO1xuXG5cdFx0aWYgKCB3b3NldCArIHRoYXQuc2l6ZS53aWR0aCA+PSB0aGF0LnBhcmVudERhdGEud2lkdGggKSB7XG5cdFx0XHR0aGF0LnNpemUud2lkdGggPSB0aGF0LnBhcmVudERhdGEud2lkdGggLSB3b3NldDtcblx0XHRcdGlmICggcFJhdGlvICkge1xuXHRcdFx0XHR0aGF0LnNpemUuaGVpZ2h0ID0gdGhhdC5zaXplLndpZHRoIC8gdGhhdC5hc3BlY3RSYXRpbztcblx0XHRcdFx0Y29udGludWVSZXNpemUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGhvc2V0ICsgdGhhdC5zaXplLmhlaWdodCA+PSB0aGF0LnBhcmVudERhdGEuaGVpZ2h0ICkge1xuXHRcdFx0dGhhdC5zaXplLmhlaWdodCA9IHRoYXQucGFyZW50RGF0YS5oZWlnaHQgLSBob3NldDtcblx0XHRcdGlmICggcFJhdGlvICkge1xuXHRcdFx0XHR0aGF0LnNpemUud2lkdGggPSB0aGF0LnNpemUuaGVpZ2h0ICogdGhhdC5hc3BlY3RSYXRpbztcblx0XHRcdFx0Y29udGludWVSZXNpemUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFjb250aW51ZVJlc2l6ZSApIHtcblx0XHRcdHRoYXQucG9zaXRpb24ubGVmdCA9IHRoYXQucHJldlBvc2l0aW9uLmxlZnQ7XG5cdFx0XHR0aGF0LnBvc2l0aW9uLnRvcCA9IHRoYXQucHJldlBvc2l0aW9uLnRvcDtcblx0XHRcdHRoYXQuc2l6ZS53aWR0aCA9IHRoYXQucHJldlNpemUud2lkdGg7XG5cdFx0XHR0aGF0LnNpemUuaGVpZ2h0ID0gdGhhdC5wcmV2U2l6ZS5oZWlnaHQ7XG5cdFx0fVxuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gJCggdGhpcyApLnJlc2l6YWJsZSggXCJpbnN0YW5jZVwiICksXG5cdFx0XHRvID0gdGhhdC5vcHRpb25zLFxuXHRcdFx0Y28gPSB0aGF0LmNvbnRhaW5lck9mZnNldCxcblx0XHRcdGNvcCA9IHRoYXQuY29udGFpbmVyUG9zaXRpb24sXG5cdFx0XHRjZSA9IHRoYXQuY29udGFpbmVyRWxlbWVudCxcblx0XHRcdGhlbHBlciA9ICQoIHRoYXQuaGVscGVyICksXG5cdFx0XHRobyA9IGhlbHBlci5vZmZzZXQoKSxcblx0XHRcdHcgPSBoZWxwZXIub3V0ZXJXaWR0aCgpIC0gdGhhdC5zaXplRGlmZi53aWR0aCxcblx0XHRcdGggPSBoZWxwZXIub3V0ZXJIZWlnaHQoKSAtIHRoYXQuc2l6ZURpZmYuaGVpZ2h0O1xuXG5cdFx0aWYgKCB0aGF0Ll9oZWxwZXIgJiYgIW8uYW5pbWF0ZSAmJiAoIC9yZWxhdGl2ZS8gKS50ZXN0KCBjZS5jc3MoIFwicG9zaXRpb25cIiApICkgKSB7XG5cdFx0XHQkKCB0aGlzICkuY3NzKCB7XG5cdFx0XHRcdGxlZnQ6IGhvLmxlZnQgLSBjb3AubGVmdCAtIGNvLmxlZnQsXG5cdFx0XHRcdHdpZHRoOiB3LFxuXHRcdFx0XHRoZWlnaHQ6IGhcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoYXQuX2hlbHBlciAmJiAhby5hbmltYXRlICYmICggL3N0YXRpYy8gKS50ZXN0KCBjZS5jc3MoIFwicG9zaXRpb25cIiApICkgKSB7XG5cdFx0XHQkKCB0aGlzICkuY3NzKCB7XG5cdFx0XHRcdGxlZnQ6IGhvLmxlZnQgLSBjb3AubGVmdCAtIGNvLmxlZnQsXG5cdFx0XHRcdHdpZHRoOiB3LFxuXHRcdFx0XHRoZWlnaHQ6IGhcblx0XHRcdH0gKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuJC51aS5wbHVnaW4uYWRkKCBcInJlc2l6YWJsZVwiLCBcImFsc29SZXNpemVcIiwge1xuXG5cdHN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9ICQoIHRoaXMgKS5yZXNpemFibGUoIFwiaW5zdGFuY2VcIiApLFxuXHRcdFx0byA9IHRoYXQub3B0aW9ucztcblxuXHRcdCQoIG8uYWxzb1Jlc2l6ZSApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsID0gJCggdGhpcyApO1xuXHRcdFx0ZWwuZGF0YSggXCJ1aS1yZXNpemFibGUtYWxzb3Jlc2l6ZVwiLCB7XG5cdFx0XHRcdHdpZHRoOiBwYXJzZUZsb2F0KCBlbC53aWR0aCgpICksIGhlaWdodDogcGFyc2VGbG9hdCggZWwuaGVpZ2h0KCkgKSxcblx0XHRcdFx0bGVmdDogcGFyc2VGbG9hdCggZWwuY3NzKCBcImxlZnRcIiApICksIHRvcDogcGFyc2VGbG9hdCggZWwuY3NzKCBcInRvcFwiICkgKVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRyZXNpemU6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0dmFyIHRoYXQgPSAkKCB0aGlzICkucmVzaXphYmxlKCBcImluc3RhbmNlXCIgKSxcblx0XHRcdG8gPSB0aGF0Lm9wdGlvbnMsXG5cdFx0XHRvcyA9IHRoYXQub3JpZ2luYWxTaXplLFxuXHRcdFx0b3AgPSB0aGF0Lm9yaWdpbmFsUG9zaXRpb24sXG5cdFx0XHRkZWx0YSA9IHtcblx0XHRcdFx0aGVpZ2h0OiAoIHRoYXQuc2l6ZS5oZWlnaHQgLSBvcy5oZWlnaHQgKSB8fCAwLFxuXHRcdFx0XHR3aWR0aDogKCB0aGF0LnNpemUud2lkdGggLSBvcy53aWR0aCApIHx8IDAsXG5cdFx0XHRcdHRvcDogKCB0aGF0LnBvc2l0aW9uLnRvcCAtIG9wLnRvcCApIHx8IDAsXG5cdFx0XHRcdGxlZnQ6ICggdGhhdC5wb3NpdGlvbi5sZWZ0IC0gb3AubGVmdCApIHx8IDBcblx0XHRcdH07XG5cblx0XHRcdCQoIG8uYWxzb1Jlc2l6ZSApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWwgPSAkKCB0aGlzICksIHN0YXJ0ID0gJCggdGhpcyApLmRhdGEoIFwidWktcmVzaXphYmxlLWFsc29yZXNpemVcIiApLCBzdHlsZSA9IHt9LFxuXHRcdFx0XHRcdGNzcyA9IGVsLnBhcmVudHMoIHVpLm9yaWdpbmFsRWxlbWVudFsgMCBdICkubGVuZ3RoID9cblx0XHRcdFx0XHRcdFx0WyBcIndpZHRoXCIsIFwiaGVpZ2h0XCIgXSA6XG5cdFx0XHRcdFx0XHRcdFsgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcInRvcFwiLCBcImxlZnRcIiBdO1xuXG5cdFx0XHRcdCQuZWFjaCggY3NzLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0XHRcdFx0XHR2YXIgc3VtID0gKCBzdGFydFsgcHJvcCBdIHx8IDAgKSArICggZGVsdGFbIHByb3AgXSB8fCAwICk7XG5cdFx0XHRcdFx0aWYgKCBzdW0gJiYgc3VtID49IDAgKSB7XG5cdFx0XHRcdFx0XHRzdHlsZVsgcHJvcCBdID0gc3VtIHx8IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0ZWwuY3NzKCBzdHlsZSApO1xuXHRcdFx0fSApO1xuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdCQoIHRoaXMgKS5yZW1vdmVEYXRhKCBcInVpLXJlc2l6YWJsZS1hbHNvcmVzaXplXCIgKTtcblx0fVxufSApO1xuXG4kLnVpLnBsdWdpbi5hZGQoIFwicmVzaXphYmxlXCIsIFwiZ2hvc3RcIiwge1xuXG5cdHN0YXJ0OiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciB0aGF0ID0gJCggdGhpcyApLnJlc2l6YWJsZSggXCJpbnN0YW5jZVwiICksIGNzID0gdGhhdC5zaXplO1xuXG5cdFx0dGhhdC5naG9zdCA9IHRoYXQub3JpZ2luYWxFbGVtZW50LmNsb25lKCk7XG5cdFx0dGhhdC5naG9zdC5jc3MoIHtcblx0XHRcdG9wYWNpdHk6IDAuMjUsXG5cdFx0XHRkaXNwbGF5OiBcImJsb2NrXCIsXG5cdFx0XHRwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuXHRcdFx0aGVpZ2h0OiBjcy5oZWlnaHQsXG5cdFx0XHR3aWR0aDogY3Mud2lkdGgsXG5cdFx0XHRtYXJnaW46IDAsXG5cdFx0XHRsZWZ0OiAwLFxuXHRcdFx0dG9wOiAwXG5cdFx0fSApO1xuXG5cdFx0dGhhdC5fYWRkQ2xhc3MoIHRoYXQuZ2hvc3QsIFwidWktcmVzaXphYmxlLWdob3N0XCIgKTtcblxuXHRcdC8vIERFUFJFQ0FURURcblx0XHQvLyBUT0RPOiByZW1vdmUgYWZ0ZXIgMS4xMlxuXHRcdGlmICggJC51aUJhY2tDb21wYXQgIT09IGZhbHNlICYmIHR5cGVvZiB0aGF0Lm9wdGlvbnMuZ2hvc3QgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vIEdob3N0IG9wdGlvblxuXHRcdFx0dGhhdC5naG9zdC5hZGRDbGFzcyggdGhpcy5vcHRpb25zLmdob3N0ICk7XG5cdFx0fVxuXG5cdFx0dGhhdC5naG9zdC5hcHBlbmRUbyggdGhhdC5oZWxwZXIgKTtcblxuXHR9LFxuXG5cdHJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSAkKCB0aGlzICkucmVzaXphYmxlKCBcImluc3RhbmNlXCIgKTtcblx0XHRpZiAoIHRoYXQuZ2hvc3QgKSB7XG5cdFx0XHR0aGF0Lmdob3N0LmNzcygge1xuXHRcdFx0XHRwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuXHRcdFx0XHRoZWlnaHQ6IHRoYXQuc2l6ZS5oZWlnaHQsXG5cdFx0XHRcdHdpZHRoOiB0aGF0LnNpemUud2lkdGhcblx0XHRcdH0gKTtcblx0XHR9XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSAkKCB0aGlzICkucmVzaXphYmxlKCBcImluc3RhbmNlXCIgKTtcblx0XHRpZiAoIHRoYXQuZ2hvc3QgJiYgdGhhdC5oZWxwZXIgKSB7XG5cdFx0XHR0aGF0LmhlbHBlci5nZXQoIDAgKS5yZW1vdmVDaGlsZCggdGhhdC5naG9zdC5nZXQoIDAgKSApO1xuXHRcdH1cblx0fVxuXG59ICk7XG5cbiQudWkucGx1Z2luLmFkZCggXCJyZXNpemFibGVcIiwgXCJncmlkXCIsIHtcblxuXHRyZXNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvdXRlckRpbWVuc2lvbnMsXG5cdFx0XHR0aGF0ID0gJCggdGhpcyApLnJlc2l6YWJsZSggXCJpbnN0YW5jZVwiICksXG5cdFx0XHRvID0gdGhhdC5vcHRpb25zLFxuXHRcdFx0Y3MgPSB0aGF0LnNpemUsXG5cdFx0XHRvcyA9IHRoYXQub3JpZ2luYWxTaXplLFxuXHRcdFx0b3AgPSB0aGF0Lm9yaWdpbmFsUG9zaXRpb24sXG5cdFx0XHRhID0gdGhhdC5heGlzLFxuXHRcdFx0Z3JpZCA9IHR5cGVvZiBvLmdyaWQgPT09IFwibnVtYmVyXCIgPyBbIG8uZ3JpZCwgby5ncmlkIF0gOiBvLmdyaWQsXG5cdFx0XHRncmlkWCA9ICggZ3JpZFsgMCBdIHx8IDEgKSxcblx0XHRcdGdyaWRZID0gKCBncmlkWyAxIF0gfHwgMSApLFxuXHRcdFx0b3ggPSBNYXRoLnJvdW5kKCAoIGNzLndpZHRoIC0gb3Mud2lkdGggKSAvIGdyaWRYICkgKiBncmlkWCxcblx0XHRcdG95ID0gTWF0aC5yb3VuZCggKCBjcy5oZWlnaHQgLSBvcy5oZWlnaHQgKSAvIGdyaWRZICkgKiBncmlkWSxcblx0XHRcdG5ld1dpZHRoID0gb3Mud2lkdGggKyBveCxcblx0XHRcdG5ld0hlaWdodCA9IG9zLmhlaWdodCArIG95LFxuXHRcdFx0aXNNYXhXaWR0aCA9IG8ubWF4V2lkdGggJiYgKCBvLm1heFdpZHRoIDwgbmV3V2lkdGggKSxcblx0XHRcdGlzTWF4SGVpZ2h0ID0gby5tYXhIZWlnaHQgJiYgKCBvLm1heEhlaWdodCA8IG5ld0hlaWdodCApLFxuXHRcdFx0aXNNaW5XaWR0aCA9IG8ubWluV2lkdGggJiYgKCBvLm1pbldpZHRoID4gbmV3V2lkdGggKSxcblx0XHRcdGlzTWluSGVpZ2h0ID0gby5taW5IZWlnaHQgJiYgKCBvLm1pbkhlaWdodCA+IG5ld0hlaWdodCApO1xuXG5cdFx0by5ncmlkID0gZ3JpZDtcblxuXHRcdGlmICggaXNNaW5XaWR0aCApIHtcblx0XHRcdG5ld1dpZHRoICs9IGdyaWRYO1xuXHRcdH1cblx0XHRpZiAoIGlzTWluSGVpZ2h0ICkge1xuXHRcdFx0bmV3SGVpZ2h0ICs9IGdyaWRZO1xuXHRcdH1cblx0XHRpZiAoIGlzTWF4V2lkdGggKSB7XG5cdFx0XHRuZXdXaWR0aCAtPSBncmlkWDtcblx0XHR9XG5cdFx0aWYgKCBpc01heEhlaWdodCApIHtcblx0XHRcdG5ld0hlaWdodCAtPSBncmlkWTtcblx0XHR9XG5cblx0XHRpZiAoIC9eKHNlfHN8ZSkkLy50ZXN0KCBhICkgKSB7XG5cdFx0XHR0aGF0LnNpemUud2lkdGggPSBuZXdXaWR0aDtcblx0XHRcdHRoYXQuc2l6ZS5oZWlnaHQgPSBuZXdIZWlnaHQ7XG5cdFx0fSBlbHNlIGlmICggL14obmUpJC8udGVzdCggYSApICkge1xuXHRcdFx0dGhhdC5zaXplLndpZHRoID0gbmV3V2lkdGg7XG5cdFx0XHR0aGF0LnNpemUuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuXHRcdFx0dGhhdC5wb3NpdGlvbi50b3AgPSBvcC50b3AgLSBveTtcblx0XHR9IGVsc2UgaWYgKCAvXihzdykkLy50ZXN0KCBhICkgKSB7XG5cdFx0XHR0aGF0LnNpemUud2lkdGggPSBuZXdXaWR0aDtcblx0XHRcdHRoYXQuc2l6ZS5oZWlnaHQgPSBuZXdIZWlnaHQ7XG5cdFx0XHR0aGF0LnBvc2l0aW9uLmxlZnQgPSBvcC5sZWZ0IC0gb3g7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggbmV3SGVpZ2h0IC0gZ3JpZFkgPD0gMCB8fCBuZXdXaWR0aCAtIGdyaWRYIDw9IDAgKSB7XG5cdFx0XHRcdG91dGVyRGltZW5zaW9ucyA9IHRoYXQuX2dldFBhZGRpbmdQbHVzQm9yZGVyRGltZW5zaW9ucyggdGhpcyApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5ld0hlaWdodCAtIGdyaWRZID4gMCApIHtcblx0XHRcdFx0dGhhdC5zaXplLmhlaWdodCA9IG5ld0hlaWdodDtcblx0XHRcdFx0dGhhdC5wb3NpdGlvbi50b3AgPSBvcC50b3AgLSBveTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld0hlaWdodCA9IGdyaWRZIC0gb3V0ZXJEaW1lbnNpb25zLmhlaWdodDtcblx0XHRcdFx0dGhhdC5zaXplLmhlaWdodCA9IG5ld0hlaWdodDtcblx0XHRcdFx0dGhhdC5wb3NpdGlvbi50b3AgPSBvcC50b3AgKyBvcy5oZWlnaHQgLSBuZXdIZWlnaHQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG5ld1dpZHRoIC0gZ3JpZFggPiAwICkge1xuXHRcdFx0XHR0aGF0LnNpemUud2lkdGggPSBuZXdXaWR0aDtcblx0XHRcdFx0dGhhdC5wb3NpdGlvbi5sZWZ0ID0gb3AubGVmdCAtIG94O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3V2lkdGggPSBncmlkWCAtIG91dGVyRGltZW5zaW9ucy53aWR0aDtcblx0XHRcdFx0dGhhdC5zaXplLndpZHRoID0gbmV3V2lkdGg7XG5cdFx0XHRcdHRoYXQucG9zaXRpb24ubGVmdCA9IG9wLmxlZnQgKyBvcy53aWR0aCAtIG5ld1dpZHRoO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG59ICk7XG5cbnZhciB3aWRnZXRzUmVzaXphYmxlID0gJC51aS5yZXNpemFibGU7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgRGlhbG9nIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBEaWFsb2dcbi8vPj5ncm91cDogV2lkZ2V0c1xuLy8+PmRlc2NyaXB0aW9uOiBEaXNwbGF5cyBjdXN0b21pemFibGUgZGlhbG9nIHdpbmRvd3MuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vZGlhbG9nL1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2RpYWxvZy9cbi8vPj5jc3Muc3RydWN0dXJlOiAuLi8uLi90aGVtZXMvYmFzZS9jb3JlLmNzc1xuLy8+PmNzcy5zdHJ1Y3R1cmU6IC4uLy4uL3RoZW1lcy9iYXNlL2RpYWxvZy5jc3Ncbi8vPj5jc3MudGhlbWU6IC4uLy4uL3RoZW1lcy9iYXNlL3RoZW1lLmNzc1xuXG5cblxuJC53aWRnZXQoIFwidWkuZGlhbG9nXCIsIHtcblx0dmVyc2lvbjogXCIxLjEyLjFcIixcblx0b3B0aW9uczoge1xuXHRcdGFwcGVuZFRvOiBcImJvZHlcIixcblx0XHRhdXRvT3BlbjogdHJ1ZSxcblx0XHRidXR0b25zOiBbXSxcblx0XHRjbGFzc2VzOiB7XG5cdFx0XHRcInVpLWRpYWxvZ1wiOiBcInVpLWNvcm5lci1hbGxcIixcblx0XHRcdFwidWktZGlhbG9nLXRpdGxlYmFyXCI6IFwidWktY29ybmVyLWFsbFwiXG5cdFx0fSxcblx0XHRjbG9zZU9uRXNjYXBlOiB0cnVlLFxuXHRcdGNsb3NlVGV4dDogXCJDbG9zZVwiLFxuXHRcdGRyYWdnYWJsZTogdHJ1ZSxcblx0XHRoaWRlOiBudWxsLFxuXHRcdGhlaWdodDogXCJhdXRvXCIsXG5cdFx0bWF4SGVpZ2h0OiBudWxsLFxuXHRcdG1heFdpZHRoOiBudWxsLFxuXHRcdG1pbkhlaWdodDogMTUwLFxuXHRcdG1pbldpZHRoOiAxNTAsXG5cdFx0bW9kYWw6IGZhbHNlLFxuXHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRteTogXCJjZW50ZXJcIixcblx0XHRcdGF0OiBcImNlbnRlclwiLFxuXHRcdFx0b2Y6IHdpbmRvdyxcblx0XHRcdGNvbGxpc2lvbjogXCJmaXRcIixcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSB0aXRsZWJhciBpcyBhbHdheXMgdmlzaWJsZVxuXHRcdFx0dXNpbmc6IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRcdHZhciB0b3BPZmZzZXQgPSAkKCB0aGlzICkuY3NzKCBwb3MgKS5vZmZzZXQoKS50b3A7XG5cdFx0XHRcdGlmICggdG9wT2Zmc2V0IDwgMCApIHtcblx0XHRcdFx0XHQkKCB0aGlzICkuY3NzKCBcInRvcFwiLCBwb3MudG9wIC0gdG9wT2Zmc2V0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlc2l6YWJsZTogdHJ1ZSxcblx0XHRzaG93OiBudWxsLFxuXHRcdHRpdGxlOiBudWxsLFxuXHRcdHdpZHRoOiAzMDAsXG5cblx0XHQvLyBDYWxsYmFja3Ncblx0XHRiZWZvcmVDbG9zZTogbnVsbCxcblx0XHRjbG9zZTogbnVsbCxcblx0XHRkcmFnOiBudWxsLFxuXHRcdGRyYWdTdGFydDogbnVsbCxcblx0XHRkcmFnU3RvcDogbnVsbCxcblx0XHRmb2N1czogbnVsbCxcblx0XHRvcGVuOiBudWxsLFxuXHRcdHJlc2l6ZTogbnVsbCxcblx0XHRyZXNpemVTdGFydDogbnVsbCxcblx0XHRyZXNpemVTdG9wOiBudWxsXG5cdH0sXG5cblx0c2l6ZVJlbGF0ZWRPcHRpb25zOiB7XG5cdFx0YnV0dG9uczogdHJ1ZSxcblx0XHRoZWlnaHQ6IHRydWUsXG5cdFx0bWF4SGVpZ2h0OiB0cnVlLFxuXHRcdG1heFdpZHRoOiB0cnVlLFxuXHRcdG1pbkhlaWdodDogdHJ1ZSxcblx0XHRtaW5XaWR0aDogdHJ1ZSxcblx0XHR3aWR0aDogdHJ1ZVxuXHR9LFxuXG5cdHJlc2l6YWJsZVJlbGF0ZWRPcHRpb25zOiB7XG5cdFx0bWF4SGVpZ2h0OiB0cnVlLFxuXHRcdG1heFdpZHRoOiB0cnVlLFxuXHRcdG1pbkhlaWdodDogdHJ1ZSxcblx0XHRtaW5XaWR0aDogdHJ1ZVxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMub3JpZ2luYWxDc3MgPSB7XG5cdFx0XHRkaXNwbGF5OiB0aGlzLmVsZW1lbnRbIDAgXS5zdHlsZS5kaXNwbGF5LFxuXHRcdFx0d2lkdGg6IHRoaXMuZWxlbWVudFsgMCBdLnN0eWxlLndpZHRoLFxuXHRcdFx0bWluSGVpZ2h0OiB0aGlzLmVsZW1lbnRbIDAgXS5zdHlsZS5taW5IZWlnaHQsXG5cdFx0XHRtYXhIZWlnaHQ6IHRoaXMuZWxlbWVudFsgMCBdLnN0eWxlLm1heEhlaWdodCxcblx0XHRcdGhlaWdodDogdGhpcy5lbGVtZW50WyAwIF0uc3R5bGUuaGVpZ2h0XG5cdFx0fTtcblx0XHR0aGlzLm9yaWdpbmFsUG9zaXRpb24gPSB7XG5cdFx0XHRwYXJlbnQ6IHRoaXMuZWxlbWVudC5wYXJlbnQoKSxcblx0XHRcdGluZGV4OiB0aGlzLmVsZW1lbnQucGFyZW50KCkuY2hpbGRyZW4oKS5pbmRleCggdGhpcy5lbGVtZW50IClcblx0XHR9O1xuXHRcdHRoaXMub3JpZ2luYWxUaXRsZSA9IHRoaXMuZWxlbWVudC5hdHRyKCBcInRpdGxlXCIgKTtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy50aXRsZSA9PSBudWxsICYmIHRoaXMub3JpZ2luYWxUaXRsZSAhPSBudWxsICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnRpdGxlID0gdGhpcy5vcmlnaW5hbFRpdGxlO1xuXHRcdH1cblxuXHRcdC8vIERpYWxvZ3MgY2FuJ3QgYmUgZGlzYWJsZWRcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5kaXNhYmxlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NyZWF0ZVdyYXBwZXIoKTtcblxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnNob3coKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwidGl0bGVcIiApXG5cdFx0XHQuYXBwZW5kVG8oIHRoaXMudWlEaWFsb2cgKTtcblxuXHRcdHRoaXMuX2FkZENsYXNzKCBcInVpLWRpYWxvZy1jb250ZW50XCIsIFwidWktd2lkZ2V0LWNvbnRlbnRcIiApO1xuXG5cdFx0dGhpcy5fY3JlYXRlVGl0bGViYXIoKTtcblx0XHR0aGlzLl9jcmVhdGVCdXR0b25QYW5lKCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgJiYgJC5mbi5kcmFnZ2FibGUgKSB7XG5cdFx0XHR0aGlzLl9tYWtlRHJhZ2dhYmxlKCk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5vcHRpb25zLnJlc2l6YWJsZSAmJiAkLmZuLnJlc2l6YWJsZSApIHtcblx0XHRcdHRoaXMuX21ha2VSZXNpemFibGUoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9pc09wZW4gPSBmYWxzZTtcblxuXHRcdHRoaXMuX3RyYWNrRm9jdXMoKTtcblx0fSxcblxuXHRfaW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuYXV0b09wZW4gKSB7XG5cdFx0XHR0aGlzLm9wZW4oKTtcblx0XHR9XG5cdH0sXG5cblx0X2FwcGVuZFRvOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMub3B0aW9ucy5hcHBlbmRUbztcblx0XHRpZiAoIGVsZW1lbnQgJiYgKCBlbGVtZW50LmpxdWVyeSB8fCBlbGVtZW50Lm5vZGVUeXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gJCggZWxlbWVudCApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5kb2N1bWVudC5maW5kKCBlbGVtZW50IHx8IFwiYm9keVwiICkuZXEoIDAgKTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5leHQsXG5cdFx0XHRvcmlnaW5hbFBvc2l0aW9uID0gdGhpcy5vcmlnaW5hbFBvc2l0aW9uO1xuXG5cdFx0dGhpcy5fdW50cmFja0luc3RhbmNlKCk7XG5cdFx0dGhpcy5fZGVzdHJveU92ZXJsYXkoKTtcblxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZVVuaXF1ZUlkKClcblx0XHRcdC5jc3MoIHRoaXMub3JpZ2luYWxDc3MgKVxuXG5cdFx0XHQvLyBXaXRob3V0IGRldGFjaGluZyBmaXJzdCwgdGhlIGZvbGxvd2luZyBiZWNvbWVzIHJlYWxseSBzbG93XG5cdFx0XHQuZGV0YWNoKCk7XG5cblx0XHR0aGlzLnVpRGlhbG9nLnJlbW92ZSgpO1xuXG5cdFx0aWYgKCB0aGlzLm9yaWdpbmFsVGl0bGUgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuYXR0ciggXCJ0aXRsZVwiLCB0aGlzLm9yaWdpbmFsVGl0bGUgKTtcblx0XHR9XG5cblx0XHRuZXh0ID0gb3JpZ2luYWxQb3NpdGlvbi5wYXJlbnQuY2hpbGRyZW4oKS5lcSggb3JpZ2luYWxQb3NpdGlvbi5pbmRleCApO1xuXG5cdFx0Ly8gRG9uJ3QgdHJ5IHRvIHBsYWNlIHRoZSBkaWFsb2cgbmV4dCB0byBpdHNlbGYgKCM4NjEzKVxuXHRcdGlmICggbmV4dC5sZW5ndGggJiYgbmV4dFsgMCBdICE9PSB0aGlzLmVsZW1lbnRbIDAgXSApIHtcblx0XHRcdG5leHQuYmVmb3JlKCB0aGlzLmVsZW1lbnQgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3JpZ2luYWxQb3NpdGlvbi5wYXJlbnQuYXBwZW5kKCB0aGlzLmVsZW1lbnQgKTtcblx0XHR9XG5cdH0sXG5cblx0d2lkZ2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy51aURpYWxvZztcblx0fSxcblxuXHRkaXNhYmxlOiAkLm5vb3AsXG5cdGVuYWJsZTogJC5ub29wLFxuXG5cdGNsb3NlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0aWYgKCAhdGhpcy5faXNPcGVuIHx8IHRoaXMuX3RyaWdnZXIoIFwiYmVmb3JlQ2xvc2VcIiwgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5faXNPcGVuID0gZmFsc2U7XG5cdFx0dGhpcy5fZm9jdXNlZEVsZW1lbnQgPSBudWxsO1xuXHRcdHRoaXMuX2Rlc3Ryb3lPdmVybGF5KCk7XG5cdFx0dGhpcy5fdW50cmFja0luc3RhbmNlKCk7XG5cblx0XHRpZiAoICF0aGlzLm9wZW5lci5maWx0ZXIoIFwiOmZvY3VzYWJsZVwiICkudHJpZ2dlciggXCJmb2N1c1wiICkubGVuZ3RoICkge1xuXG5cdFx0XHQvLyBIaWRpbmcgYSBmb2N1c2VkIGVsZW1lbnQgZG9lc24ndCB0cmlnZ2VyIGJsdXIgaW4gV2ViS2l0XG5cdFx0XHQvLyBzbyBpbiBjYXNlIHdlIGhhdmUgbm90aGluZyB0byBmb2N1cyBvbiwgZXhwbGljaXRseSBibHVyIHRoZSBhY3RpdmUgZWxlbWVudFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTQ3MTgyXG5cdFx0XHQkLnVpLnNhZmVCbHVyKCAkLnVpLnNhZmVBY3RpdmVFbGVtZW50KCB0aGlzLmRvY3VtZW50WyAwIF0gKSApO1xuXHRcdH1cblxuXHRcdHRoaXMuX2hpZGUoIHRoaXMudWlEaWFsb2csIHRoaXMub3B0aW9ucy5oaWRlLCBmdW5jdGlvbigpIHtcblx0XHRcdHRoYXQuX3RyaWdnZXIoIFwiY2xvc2VcIiwgZXZlbnQgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aXNPcGVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faXNPcGVuO1xuXHR9LFxuXG5cdG1vdmVUb1RvcDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fbW92ZVRvVG9wKCk7XG5cdH0sXG5cblx0X21vdmVUb1RvcDogZnVuY3Rpb24oIGV2ZW50LCBzaWxlbnQgKSB7XG5cdFx0dmFyIG1vdmVkID0gZmFsc2UsXG5cdFx0XHR6SW5kaWNlcyA9IHRoaXMudWlEaWFsb2cuc2libGluZ3MoIFwiLnVpLWZyb250OnZpc2libGVcIiApLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiArJCggdGhpcyApLmNzcyggXCJ6LWluZGV4XCIgKTtcblx0XHRcdH0gKS5nZXQoKSxcblx0XHRcdHpJbmRleE1heCA9IE1hdGgubWF4LmFwcGx5KCBudWxsLCB6SW5kaWNlcyApO1xuXG5cdFx0aWYgKCB6SW5kZXhNYXggPj0gK3RoaXMudWlEaWFsb2cuY3NzKCBcInotaW5kZXhcIiApICkge1xuXHRcdFx0dGhpcy51aURpYWxvZy5jc3MoIFwiei1pbmRleFwiLCB6SW5kZXhNYXggKyAxICk7XG5cdFx0XHRtb3ZlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBtb3ZlZCAmJiAhc2lsZW50ICkge1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJmb2N1c1wiLCBldmVudCApO1xuXHRcdH1cblx0XHRyZXR1cm4gbW92ZWQ7XG5cdH0sXG5cblx0b3BlbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdGlmICggdGhpcy5faXNPcGVuICkge1xuXHRcdFx0aWYgKCB0aGlzLl9tb3ZlVG9Ub3AoKSApIHtcblx0XHRcdFx0dGhpcy5fZm9jdXNUYWJiYWJsZSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2lzT3BlbiA9IHRydWU7XG5cdFx0dGhpcy5vcGVuZXIgPSAkKCAkLnVpLnNhZmVBY3RpdmVFbGVtZW50KCB0aGlzLmRvY3VtZW50WyAwIF0gKSApO1xuXG5cdFx0dGhpcy5fc2l6ZSgpO1xuXHRcdHRoaXMuX3Bvc2l0aW9uKCk7XG5cdFx0dGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuXHRcdHRoaXMuX21vdmVUb1RvcCggbnVsbCwgdHJ1ZSApO1xuXG5cdFx0Ly8gRW5zdXJlIHRoZSBvdmVybGF5IGlzIG1vdmVkIHRvIHRoZSB0b3Agd2l0aCB0aGUgZGlhbG9nLCBidXQgb25seSB3aGVuXG5cdFx0Ly8gb3BlbmluZy4gVGhlIG92ZXJsYXkgc2hvdWxkbid0IG1vdmUgYWZ0ZXIgdGhlIGRpYWxvZyBpcyBvcGVuIHNvIHRoYXRcblx0XHQvLyBtb2RlbGVzcyBkaWFsb2dzIG9wZW5lZCBhZnRlciB0aGUgbW9kYWwgZGlhbG9nIHN0YWNrIHByb3Blcmx5LlxuXHRcdGlmICggdGhpcy5vdmVybGF5ICkge1xuXHRcdFx0dGhpcy5vdmVybGF5LmNzcyggXCJ6LWluZGV4XCIsIHRoaXMudWlEaWFsb2cuY3NzKCBcInotaW5kZXhcIiApIC0gMSApO1xuXHRcdH1cblxuXHRcdHRoaXMuX3Nob3coIHRoaXMudWlEaWFsb2csIHRoaXMub3B0aW9ucy5zaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdHRoYXQuX2ZvY3VzVGFiYmFibGUoKTtcblx0XHRcdHRoYXQuX3RyaWdnZXIoIFwiZm9jdXNcIiApO1xuXHRcdH0gKTtcblxuXHRcdC8vIFRyYWNrIHRoZSBkaWFsb2cgaW1tZWRpYXRlbHkgdXBvbiBvcGVuZW5pbmcgaW4gY2FzZSBhIGZvY3VzIGV2ZW50XG5cdFx0Ly8gc29tZWhvdyBvY2N1cnMgb3V0c2lkZSBvZiB0aGUgZGlhbG9nIGJlZm9yZSBhbiBlbGVtZW50IGluc2lkZSB0aGVcblx0XHQvLyBkaWFsb2cgaXMgZm9jdXNlZCAoIzEwMTUyKVxuXHRcdHRoaXMuX21ha2VGb2N1c1RhcmdldCgpO1xuXG5cdFx0dGhpcy5fdHJpZ2dlciggXCJvcGVuXCIgKTtcblx0fSxcblxuXHRfZm9jdXNUYWJiYWJsZTogZnVuY3Rpb24oKSB7XG5cblx0XHQvLyBTZXQgZm9jdXMgdG8gdGhlIGZpcnN0IG1hdGNoOlxuXHRcdC8vIDEuIEFuIGVsZW1lbnQgdGhhdCB3YXMgZm9jdXNlZCBwcmV2aW91c2x5XG5cdFx0Ly8gMi4gRmlyc3QgZWxlbWVudCBpbnNpZGUgdGhlIGRpYWxvZyBtYXRjaGluZyBbYXV0b2ZvY3VzXVxuXHRcdC8vIDMuIFRhYmJhYmxlIGVsZW1lbnQgaW5zaWRlIHRoZSBjb250ZW50IGVsZW1lbnRcblx0XHQvLyA0LiBUYWJiYWJsZSBlbGVtZW50IGluc2lkZSB0aGUgYnV0dG9ucGFuZVxuXHRcdC8vIDUuIFRoZSBjbG9zZSBidXR0b25cblx0XHQvLyA2LiBUaGUgZGlhbG9nIGl0c2VsZlxuXHRcdHZhciBoYXNGb2N1cyA9IHRoaXMuX2ZvY3VzZWRFbGVtZW50O1xuXHRcdGlmICggIWhhc0ZvY3VzICkge1xuXHRcdFx0aGFzRm9jdXMgPSB0aGlzLmVsZW1lbnQuZmluZCggXCJbYXV0b2ZvY3VzXVwiICk7XG5cdFx0fVxuXHRcdGlmICggIWhhc0ZvY3VzLmxlbmd0aCApIHtcblx0XHRcdGhhc0ZvY3VzID0gdGhpcy5lbGVtZW50LmZpbmQoIFwiOnRhYmJhYmxlXCIgKTtcblx0XHR9XG5cdFx0aWYgKCAhaGFzRm9jdXMubGVuZ3RoICkge1xuXHRcdFx0aGFzRm9jdXMgPSB0aGlzLnVpRGlhbG9nQnV0dG9uUGFuZS5maW5kKCBcIjp0YWJiYWJsZVwiICk7XG5cdFx0fVxuXHRcdGlmICggIWhhc0ZvY3VzLmxlbmd0aCApIHtcblx0XHRcdGhhc0ZvY3VzID0gdGhpcy51aURpYWxvZ1RpdGxlYmFyQ2xvc2UuZmlsdGVyKCBcIjp0YWJiYWJsZVwiICk7XG5cdFx0fVxuXHRcdGlmICggIWhhc0ZvY3VzLmxlbmd0aCApIHtcblx0XHRcdGhhc0ZvY3VzID0gdGhpcy51aURpYWxvZztcblx0XHR9XG5cdFx0aGFzRm9jdXMuZXEoIDAgKS50cmlnZ2VyKCBcImZvY3VzXCIgKTtcblx0fSxcblxuXHRfa2VlcEZvY3VzOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0ZnVuY3Rpb24gY2hlY2tGb2N1cygpIHtcblx0XHRcdHZhciBhY3RpdmVFbGVtZW50ID0gJC51aS5zYWZlQWN0aXZlRWxlbWVudCggdGhpcy5kb2N1bWVudFsgMCBdICksXG5cdFx0XHRcdGlzQWN0aXZlID0gdGhpcy51aURpYWxvZ1sgMCBdID09PSBhY3RpdmVFbGVtZW50IHx8XG5cdFx0XHRcdFx0JC5jb250YWlucyggdGhpcy51aURpYWxvZ1sgMCBdLCBhY3RpdmVFbGVtZW50ICk7XG5cdFx0XHRpZiAoICFpc0FjdGl2ZSApIHtcblx0XHRcdFx0dGhpcy5fZm9jdXNUYWJiYWJsZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGNoZWNrRm9jdXMuY2FsbCggdGhpcyApO1xuXG5cdFx0Ly8gc3VwcG9ydDogSUVcblx0XHQvLyBJRSA8PSA4IGRvZXNuJ3QgcHJldmVudCBtb3ZpbmcgZm9jdXMgZXZlbiB3aXRoIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblx0XHQvLyBzbyB3ZSBjaGVjayBhZ2FpbiBsYXRlclxuXHRcdHRoaXMuX2RlbGF5KCBjaGVja0ZvY3VzICk7XG5cdH0sXG5cblx0X2NyZWF0ZVdyYXBwZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudWlEaWFsb2cgPSAkKCBcIjxkaXY+XCIgKVxuXHRcdFx0LmhpZGUoKVxuXHRcdFx0LmF0dHIoIHtcblxuXHRcdFx0XHQvLyBTZXR0aW5nIHRhYkluZGV4IG1ha2VzIHRoZSBkaXYgZm9jdXNhYmxlXG5cdFx0XHRcdHRhYkluZGV4OiAtMSxcblx0XHRcdFx0cm9sZTogXCJkaWFsb2dcIlxuXHRcdFx0fSApXG5cdFx0XHQuYXBwZW5kVG8oIHRoaXMuX2FwcGVuZFRvKCkgKTtcblxuXHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLnVpRGlhbG9nLCBcInVpLWRpYWxvZ1wiLCBcInVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1mcm9udFwiICk7XG5cdFx0dGhpcy5fb24oIHRoaXMudWlEaWFsb2csIHtcblx0XHRcdGtleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuY2xvc2VPbkVzY2FwZSAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgJiYgZXZlbnQua2V5Q29kZSAmJlxuXHRcdFx0XHRcdFx0ZXZlbnQua2V5Q29kZSA9PT0gJC51aS5rZXlDb2RlLkVTQ0FQRSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHRoaXMuY2xvc2UoIGV2ZW50ICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJldmVudCB0YWJiaW5nIG91dCBvZiBkaWFsb2dzXG5cdFx0XHRcdGlmICggZXZlbnQua2V5Q29kZSAhPT0gJC51aS5rZXlDb2RlLlRBQiB8fCBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHRhYmJhYmxlcyA9IHRoaXMudWlEaWFsb2cuZmluZCggXCI6dGFiYmFibGVcIiApLFxuXHRcdFx0XHRcdGZpcnN0ID0gdGFiYmFibGVzLmZpbHRlciggXCI6Zmlyc3RcIiApLFxuXHRcdFx0XHRcdGxhc3QgPSB0YWJiYWJsZXMuZmlsdGVyKCBcIjpsYXN0XCIgKTtcblxuXHRcdFx0XHRpZiAoICggZXZlbnQudGFyZ2V0ID09PSBsYXN0WyAwIF0gfHwgZXZlbnQudGFyZ2V0ID09PSB0aGlzLnVpRGlhbG9nWyAwIF0gKSAmJlxuXHRcdFx0XHRcdFx0IWV2ZW50LnNoaWZ0S2V5ICkge1xuXHRcdFx0XHRcdHRoaXMuX2RlbGF5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGZpcnN0LnRyaWdnZXIoIFwiZm9jdXNcIiApO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIGV2ZW50LnRhcmdldCA9PT0gZmlyc3RbIDAgXSB8fFxuXHRcdFx0XHRcdFx0ZXZlbnQudGFyZ2V0ID09PSB0aGlzLnVpRGlhbG9nWyAwIF0gKSAmJiBldmVudC5zaGlmdEtleSApIHtcblx0XHRcdFx0XHR0aGlzLl9kZWxheSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRsYXN0LnRyaWdnZXIoIFwiZm9jdXNcIiApO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0bW91c2Vkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5fbW92ZVRvVG9wKCBldmVudCApICkge1xuXHRcdFx0XHRcdHRoaXMuX2ZvY3VzVGFiYmFibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGFueSBleGlzdGluZyBhcmlhLWRlc2NyaWJlZGJ5IGF0dHJpYnV0ZSBtZWFuc1xuXHRcdC8vIHRoYXQgdGhlIGRpYWxvZyBjb250ZW50IGlzIG1hcmtlZCB1cCBwcm9wZXJseVxuXHRcdC8vIG90aGVyd2lzZSB3ZSBicnV0ZSBmb3JjZSB0aGUgY29udGVudCBhcyB0aGUgZGVzY3JpcHRpb25cblx0XHRpZiAoICF0aGlzLmVsZW1lbnQuZmluZCggXCJbYXJpYS1kZXNjcmliZWRieV1cIiApLmxlbmd0aCApIHtcblx0XHRcdHRoaXMudWlEaWFsb2cuYXR0cigge1xuXHRcdFx0XHRcImFyaWEtZGVzY3JpYmVkYnlcIjogdGhpcy5lbGVtZW50LnVuaXF1ZUlkKCkuYXR0ciggXCJpZFwiIClcblx0XHRcdH0gKTtcblx0XHR9XG5cdH0sXG5cblx0X2NyZWF0ZVRpdGxlYmFyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdWlEaWFsb2dUaXRsZTtcblxuXHRcdHRoaXMudWlEaWFsb2dUaXRsZWJhciA9ICQoIFwiPGRpdj5cIiApO1xuXHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLnVpRGlhbG9nVGl0bGViYXIsXG5cdFx0XHRcInVpLWRpYWxvZy10aXRsZWJhclwiLCBcInVpLXdpZGdldC1oZWFkZXIgdWktaGVscGVyLWNsZWFyZml4XCIgKTtcblx0XHR0aGlzLl9vbiggdGhpcy51aURpYWxvZ1RpdGxlYmFyLCB7XG5cdFx0XHRtb3VzZWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBwcmV2ZW50IGNsaWNrIG9uIGNsb3NlIGJ1dHRvbiAoIzg4MzgpXG5cdFx0XHRcdC8vIEZvY3VzaW5nIGEgZGlhbG9nIHRoYXQgaXMgcGFydGlhbGx5IHNjcm9sbGVkIG91dCBvZiB2aWV3XG5cdFx0XHRcdC8vIGNhdXNlcyB0aGUgYnJvd3NlciB0byBzY3JvbGwgaXQgaW50byB2aWV3LCBwcmV2ZW50aW5nIHRoZSBjbGljayBldmVudFxuXHRcdFx0XHRpZiAoICEkKCBldmVudC50YXJnZXQgKS5jbG9zZXN0KCBcIi51aS1kaWFsb2ctdGl0bGViYXItY2xvc2VcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gRGlhbG9nIGlzbid0IGdldHRpbmcgZm9jdXMgd2hlbiBkcmFnZ2luZyAoIzgwNjMpXG5cdFx0XHRcdFx0dGhpcy51aURpYWxvZy50cmlnZ2VyKCBcImZvY3VzXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0Ly8gVXNlIHR5cGU9XCJidXR0b25cIiB0byBwcmV2ZW50IGVudGVyIGtleXByZXNzZXMgaW4gdGV4dGJveGVzIGZyb20gY2xvc2luZyB0aGVcblx0XHQvLyBkaWFsb2cgaW4gSUUgKCM5MzEyKVxuXHRcdHRoaXMudWlEaWFsb2dUaXRsZWJhckNsb3NlID0gJCggXCI8YnV0dG9uIHR5cGU9J2J1dHRvbic+PC9idXR0b24+XCIgKVxuXHRcdFx0LmJ1dHRvbigge1xuXHRcdFx0XHRsYWJlbDogJCggXCI8YT5cIiApLnRleHQoIHRoaXMub3B0aW9ucy5jbG9zZVRleHQgKS5odG1sKCksXG5cdFx0XHRcdGljb246IFwidWktaWNvbi1jbG9zZXRoaWNrXCIsXG5cdFx0XHRcdHNob3dMYWJlbDogZmFsc2Vcblx0XHRcdH0gKVxuXHRcdFx0LmFwcGVuZFRvKCB0aGlzLnVpRGlhbG9nVGl0bGViYXIgKTtcblxuXHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLnVpRGlhbG9nVGl0bGViYXJDbG9zZSwgXCJ1aS1kaWFsb2ctdGl0bGViYXItY2xvc2VcIiApO1xuXHRcdHRoaXMuX29uKCB0aGlzLnVpRGlhbG9nVGl0bGViYXJDbG9zZSwge1xuXHRcdFx0Y2xpY2s6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0dGhpcy5jbG9zZSggZXZlbnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHR1aURpYWxvZ1RpdGxlID0gJCggXCI8c3Bhbj5cIiApLnVuaXF1ZUlkKCkucHJlcGVuZFRvKCB0aGlzLnVpRGlhbG9nVGl0bGViYXIgKTtcblx0XHR0aGlzLl9hZGRDbGFzcyggdWlEaWFsb2dUaXRsZSwgXCJ1aS1kaWFsb2ctdGl0bGVcIiApO1xuXHRcdHRoaXMuX3RpdGxlKCB1aURpYWxvZ1RpdGxlICk7XG5cblx0XHR0aGlzLnVpRGlhbG9nVGl0bGViYXIucHJlcGVuZFRvKCB0aGlzLnVpRGlhbG9nICk7XG5cblx0XHR0aGlzLnVpRGlhbG9nLmF0dHIoIHtcblx0XHRcdFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHVpRGlhbG9nVGl0bGUuYXR0ciggXCJpZFwiIClcblx0XHR9ICk7XG5cdH0sXG5cblx0X3RpdGxlOiBmdW5jdGlvbiggdGl0bGUgKSB7XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudGl0bGUgKSB7XG5cdFx0XHR0aXRsZS50ZXh0KCB0aGlzLm9wdGlvbnMudGl0bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGl0bGUuaHRtbCggXCImIzE2MDtcIiApO1xuXHRcdH1cblx0fSxcblxuXHRfY3JlYXRlQnV0dG9uUGFuZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51aURpYWxvZ0J1dHRvblBhbmUgPSAkKCBcIjxkaXY+XCIgKTtcblx0XHR0aGlzLl9hZGRDbGFzcyggdGhpcy51aURpYWxvZ0J1dHRvblBhbmUsIFwidWktZGlhbG9nLWJ1dHRvbnBhbmVcIixcblx0XHRcdFwidWktd2lkZ2V0LWNvbnRlbnQgdWktaGVscGVyLWNsZWFyZml4XCIgKTtcblxuXHRcdHRoaXMudWlCdXR0b25TZXQgPSAkKCBcIjxkaXY+XCIgKVxuXHRcdFx0LmFwcGVuZFRvKCB0aGlzLnVpRGlhbG9nQnV0dG9uUGFuZSApO1xuXHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLnVpQnV0dG9uU2V0LCBcInVpLWRpYWxvZy1idXR0b25zZXRcIiApO1xuXG5cdFx0dGhpcy5fY3JlYXRlQnV0dG9ucygpO1xuXHR9LFxuXG5cdF9jcmVhdGVCdXR0b25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRidXR0b25zID0gdGhpcy5vcHRpb25zLmJ1dHRvbnM7XG5cblx0XHQvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgYSBidXR0b24gcGFuZSwgcmVtb3ZlIGl0XG5cdFx0dGhpcy51aURpYWxvZ0J1dHRvblBhbmUucmVtb3ZlKCk7XG5cdFx0dGhpcy51aUJ1dHRvblNldC5lbXB0eSgpO1xuXG5cdFx0aWYgKCAkLmlzRW1wdHlPYmplY3QoIGJ1dHRvbnMgKSB8fCAoICQuaXNBcnJheSggYnV0dG9ucyApICYmICFidXR0b25zLmxlbmd0aCApICkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIHRoaXMudWlEaWFsb2csIFwidWktZGlhbG9nLWJ1dHRvbnNcIiApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdCQuZWFjaCggYnV0dG9ucywgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRcdFx0dmFyIGNsaWNrLCBidXR0b25PcHRpb25zO1xuXHRcdFx0cHJvcHMgPSAkLmlzRnVuY3Rpb24oIHByb3BzICkgP1xuXHRcdFx0XHR7IGNsaWNrOiBwcm9wcywgdGV4dDogbmFtZSB9IDpcblx0XHRcdFx0cHJvcHM7XG5cblx0XHRcdC8vIERlZmF1bHQgdG8gYSBub24tc3VibWl0dGluZyBidXR0b25cblx0XHRcdHByb3BzID0gJC5leHRlbmQoIHsgdHlwZTogXCJidXR0b25cIiB9LCBwcm9wcyApO1xuXG5cdFx0XHQvLyBDaGFuZ2UgdGhlIGNvbnRleHQgZm9yIHRoZSBjbGljayBjYWxsYmFjayB0byBiZSB0aGUgbWFpbiBlbGVtZW50XG5cdFx0XHRjbGljayA9IHByb3BzLmNsaWNrO1xuXHRcdFx0YnV0dG9uT3B0aW9ucyA9IHtcblx0XHRcdFx0aWNvbjogcHJvcHMuaWNvbixcblx0XHRcdFx0aWNvblBvc2l0aW9uOiBwcm9wcy5pY29uUG9zaXRpb24sXG5cdFx0XHRcdHNob3dMYWJlbDogcHJvcHMuc2hvd0xhYmVsLFxuXG5cdFx0XHRcdC8vIERlcHJlY2F0ZWQgb3B0aW9uc1xuXHRcdFx0XHRpY29uczogcHJvcHMuaWNvbnMsXG5cdFx0XHRcdHRleHQ6IHByb3BzLnRleHRcblx0XHRcdH07XG5cblx0XHRcdGRlbGV0ZSBwcm9wcy5jbGljaztcblx0XHRcdGRlbGV0ZSBwcm9wcy5pY29uO1xuXHRcdFx0ZGVsZXRlIHByb3BzLmljb25Qb3NpdGlvbjtcblx0XHRcdGRlbGV0ZSBwcm9wcy5zaG93TGFiZWw7XG5cblx0XHRcdC8vIERlcHJlY2F0ZWQgb3B0aW9uc1xuXHRcdFx0ZGVsZXRlIHByb3BzLmljb25zO1xuXHRcdFx0aWYgKCB0eXBlb2YgcHJvcHMudGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGRlbGV0ZSBwcm9wcy50ZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHQkKCBcIjxidXR0b24+PC9idXR0b24+XCIsIHByb3BzIClcblx0XHRcdFx0LmJ1dHRvbiggYnV0dG9uT3B0aW9ucyApXG5cdFx0XHRcdC5hcHBlbmRUbyggdGhhdC51aUJ1dHRvblNldCApXG5cdFx0XHRcdC5vbiggXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRjbGljay5hcHBseSggdGhhdC5lbGVtZW50WyAwIF0sIGFyZ3VtZW50cyApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fSApO1xuXHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLnVpRGlhbG9nLCBcInVpLWRpYWxvZy1idXR0b25zXCIgKTtcblx0XHR0aGlzLnVpRGlhbG9nQnV0dG9uUGFuZS5hcHBlbmRUbyggdGhpcy51aURpYWxvZyApO1xuXHR9LFxuXG5cdF9tYWtlRHJhZ2dhYmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0ZnVuY3Rpb24gZmlsdGVyZWRVaSggdWkgKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRwb3NpdGlvbjogdWkucG9zaXRpb24sXG5cdFx0XHRcdG9mZnNldDogdWkub2Zmc2V0XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHRoaXMudWlEaWFsb2cuZHJhZ2dhYmxlKCB7XG5cdFx0XHRjYW5jZWw6IFwiLnVpLWRpYWxvZy1jb250ZW50LCAudWktZGlhbG9nLXRpdGxlYmFyLWNsb3NlXCIsXG5cdFx0XHRoYW5kbGU6IFwiLnVpLWRpYWxvZy10aXRsZWJhclwiLFxuXHRcdFx0Y29udGFpbm1lbnQ6IFwiZG9jdW1lbnRcIixcblx0XHRcdHN0YXJ0OiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xuXHRcdFx0XHR0aGF0Ll9hZGRDbGFzcyggJCggdGhpcyApLCBcInVpLWRpYWxvZy1kcmFnZ2luZ1wiICk7XG5cdFx0XHRcdHRoYXQuX2Jsb2NrRnJhbWVzKCk7XG5cdFx0XHRcdHRoYXQuX3RyaWdnZXIoIFwiZHJhZ1N0YXJ0XCIsIGV2ZW50LCBmaWx0ZXJlZFVpKCB1aSApICk7XG5cdFx0XHR9LFxuXHRcdFx0ZHJhZzogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcblx0XHRcdFx0dGhhdC5fdHJpZ2dlciggXCJkcmFnXCIsIGV2ZW50LCBmaWx0ZXJlZFVpKCB1aSApICk7XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcblx0XHRcdFx0dmFyIGxlZnQgPSB1aS5vZmZzZXQubGVmdCAtIHRoYXQuZG9jdW1lbnQuc2Nyb2xsTGVmdCgpLFxuXHRcdFx0XHRcdHRvcCA9IHVpLm9mZnNldC50b3AgLSB0aGF0LmRvY3VtZW50LnNjcm9sbFRvcCgpO1xuXG5cdFx0XHRcdG9wdGlvbnMucG9zaXRpb24gPSB7XG5cdFx0XHRcdFx0bXk6IFwibGVmdCB0b3BcIixcblx0XHRcdFx0XHRhdDogXCJsZWZ0XCIgKyAoIGxlZnQgPj0gMCA/IFwiK1wiIDogXCJcIiApICsgbGVmdCArIFwiIFwiICtcblx0XHRcdFx0XHRcdFwidG9wXCIgKyAoIHRvcCA+PSAwID8gXCIrXCIgOiBcIlwiICkgKyB0b3AsXG5cdFx0XHRcdFx0b2Y6IHRoYXQud2luZG93XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoYXQuX3JlbW92ZUNsYXNzKCAkKCB0aGlzICksIFwidWktZGlhbG9nLWRyYWdnaW5nXCIgKTtcblx0XHRcdFx0dGhhdC5fdW5ibG9ja0ZyYW1lcygpO1xuXHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcImRyYWdTdG9wXCIsIGV2ZW50LCBmaWx0ZXJlZFVpKCB1aSApICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9tYWtlUmVzaXphYmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0aGFuZGxlcyA9IG9wdGlvbnMucmVzaXphYmxlLFxuXG5cdFx0XHQvLyAudWktcmVzaXphYmxlIGhhcyBwb3NpdGlvbjogcmVsYXRpdmUgZGVmaW5lZCBpbiB0aGUgc3R5bGVzaGVldFxuXHRcdFx0Ly8gYnV0IGRpYWxvZ3MgaGF2ZSB0byB1c2UgYWJzb2x1dGUgb3IgZml4ZWQgcG9zaXRpb25pbmdcblx0XHRcdHBvc2l0aW9uID0gdGhpcy51aURpYWxvZy5jc3MoIFwicG9zaXRpb25cIiApLFxuXHRcdFx0cmVzaXplSGFuZGxlcyA9IHR5cGVvZiBoYW5kbGVzID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0aGFuZGxlcyA6XG5cdFx0XHRcdFwibixlLHMsdyxzZSxzdyxuZSxud1wiO1xuXG5cdFx0ZnVuY3Rpb24gZmlsdGVyZWRVaSggdWkgKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRvcmlnaW5hbFBvc2l0aW9uOiB1aS5vcmlnaW5hbFBvc2l0aW9uLFxuXHRcdFx0XHRvcmlnaW5hbFNpemU6IHVpLm9yaWdpbmFsU2l6ZSxcblx0XHRcdFx0cG9zaXRpb246IHVpLnBvc2l0aW9uLFxuXHRcdFx0XHRzaXplOiB1aS5zaXplXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHRoaXMudWlEaWFsb2cucmVzaXphYmxlKCB7XG5cdFx0XHRjYW5jZWw6IFwiLnVpLWRpYWxvZy1jb250ZW50XCIsXG5cdFx0XHRjb250YWlubWVudDogXCJkb2N1bWVudFwiLFxuXHRcdFx0YWxzb1Jlc2l6ZTogdGhpcy5lbGVtZW50LFxuXHRcdFx0bWF4V2lkdGg6IG9wdGlvbnMubWF4V2lkdGgsXG5cdFx0XHRtYXhIZWlnaHQ6IG9wdGlvbnMubWF4SGVpZ2h0LFxuXHRcdFx0bWluV2lkdGg6IG9wdGlvbnMubWluV2lkdGgsXG5cdFx0XHRtaW5IZWlnaHQ6IHRoaXMuX21pbkhlaWdodCgpLFxuXHRcdFx0aGFuZGxlczogcmVzaXplSGFuZGxlcyxcblx0XHRcdHN0YXJ0OiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xuXHRcdFx0XHR0aGF0Ll9hZGRDbGFzcyggJCggdGhpcyApLCBcInVpLWRpYWxvZy1yZXNpemluZ1wiICk7XG5cdFx0XHRcdHRoYXQuX2Jsb2NrRnJhbWVzKCk7XG5cdFx0XHRcdHRoYXQuX3RyaWdnZXIoIFwicmVzaXplU3RhcnRcIiwgZXZlbnQsIGZpbHRlcmVkVWkoIHVpICkgKTtcblx0XHRcdH0sXG5cdFx0XHRyZXNpemU6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0XHRcdHRoYXQuX3RyaWdnZXIoIFwicmVzaXplXCIsIGV2ZW50LCBmaWx0ZXJlZFVpKCB1aSApICk7XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcblx0XHRcdFx0dmFyIG9mZnNldCA9IHRoYXQudWlEaWFsb2cub2Zmc2V0KCksXG5cdFx0XHRcdFx0bGVmdCA9IG9mZnNldC5sZWZ0IC0gdGhhdC5kb2N1bWVudC5zY3JvbGxMZWZ0KCksXG5cdFx0XHRcdFx0dG9wID0gb2Zmc2V0LnRvcCAtIHRoYXQuZG9jdW1lbnQuc2Nyb2xsVG9wKCk7XG5cblx0XHRcdFx0b3B0aW9ucy5oZWlnaHQgPSB0aGF0LnVpRGlhbG9nLmhlaWdodCgpO1xuXHRcdFx0XHRvcHRpb25zLndpZHRoID0gdGhhdC51aURpYWxvZy53aWR0aCgpO1xuXHRcdFx0XHRvcHRpb25zLnBvc2l0aW9uID0ge1xuXHRcdFx0XHRcdG15OiBcImxlZnQgdG9wXCIsXG5cdFx0XHRcdFx0YXQ6IFwibGVmdFwiICsgKCBsZWZ0ID49IDAgPyBcIitcIiA6IFwiXCIgKSArIGxlZnQgKyBcIiBcIiArXG5cdFx0XHRcdFx0XHRcInRvcFwiICsgKCB0b3AgPj0gMCA/IFwiK1wiIDogXCJcIiApICsgdG9wLFxuXHRcdFx0XHRcdG9mOiB0aGF0LndpbmRvd1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGF0Ll9yZW1vdmVDbGFzcyggJCggdGhpcyApLCBcInVpLWRpYWxvZy1yZXNpemluZ1wiICk7XG5cdFx0XHRcdHRoYXQuX3VuYmxvY2tGcmFtZXMoKTtcblx0XHRcdFx0dGhhdC5fdHJpZ2dlciggXCJyZXNpemVTdG9wXCIsIGV2ZW50LCBmaWx0ZXJlZFVpKCB1aSApICk7XG5cdFx0XHR9XG5cdFx0fSApXG5cdFx0XHQuY3NzKCBcInBvc2l0aW9uXCIsIHBvc2l0aW9uICk7XG5cdH0sXG5cblx0X3RyYWNrRm9jdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX29uKCB0aGlzLndpZGdldCgpLCB7XG5cdFx0XHRmb2N1c2luOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX21ha2VGb2N1c1RhcmdldCgpO1xuXHRcdFx0XHR0aGlzLl9mb2N1c2VkRWxlbWVudCA9ICQoIGV2ZW50LnRhcmdldCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRfbWFrZUZvY3VzVGFyZ2V0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl91bnRyYWNrSW5zdGFuY2UoKTtcblx0XHR0aGlzLl90cmFja2luZ0luc3RhbmNlcygpLnVuc2hpZnQoIHRoaXMgKTtcblx0fSxcblxuXHRfdW50cmFja0luc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW5zdGFuY2VzID0gdGhpcy5fdHJhY2tpbmdJbnN0YW5jZXMoKSxcblx0XHRcdGV4aXN0cyA9ICQuaW5BcnJheSggdGhpcywgaW5zdGFuY2VzICk7XG5cdFx0aWYgKCBleGlzdHMgIT09IC0xICkge1xuXHRcdFx0aW5zdGFuY2VzLnNwbGljZSggZXhpc3RzLCAxICk7XG5cdFx0fVxuXHR9LFxuXG5cdF90cmFja2luZ0luc3RhbmNlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGluc3RhbmNlcyA9IHRoaXMuZG9jdW1lbnQuZGF0YSggXCJ1aS1kaWFsb2ctaW5zdGFuY2VzXCIgKTtcblx0XHRpZiAoICFpbnN0YW5jZXMgKSB7XG5cdFx0XHRpbnN0YW5jZXMgPSBbXTtcblx0XHRcdHRoaXMuZG9jdW1lbnQuZGF0YSggXCJ1aS1kaWFsb2ctaW5zdGFuY2VzXCIsIGluc3RhbmNlcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gaW5zdGFuY2VzO1xuXHR9LFxuXG5cdF9taW5IZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0cmV0dXJuIG9wdGlvbnMuaGVpZ2h0ID09PSBcImF1dG9cIiA/XG5cdFx0XHRvcHRpb25zLm1pbkhlaWdodCA6XG5cdFx0XHRNYXRoLm1pbiggb3B0aW9ucy5taW5IZWlnaHQsIG9wdGlvbnMuaGVpZ2h0ICk7XG5cdH0sXG5cblx0X3Bvc2l0aW9uOiBmdW5jdGlvbigpIHtcblxuXHRcdC8vIE5lZWQgdG8gc2hvdyB0aGUgZGlhbG9nIHRvIGdldCB0aGUgYWN0dWFsIG9mZnNldCBpbiB0aGUgcG9zaXRpb24gcGx1Z2luXG5cdFx0dmFyIGlzVmlzaWJsZSA9IHRoaXMudWlEaWFsb2cuaXMoIFwiOnZpc2libGVcIiApO1xuXHRcdGlmICggIWlzVmlzaWJsZSApIHtcblx0XHRcdHRoaXMudWlEaWFsb2cuc2hvdygpO1xuXHRcdH1cblx0XHR0aGlzLnVpRGlhbG9nLnBvc2l0aW9uKCB0aGlzLm9wdGlvbnMucG9zaXRpb24gKTtcblx0XHRpZiAoICFpc1Zpc2libGUgKSB7XG5cdFx0XHR0aGlzLnVpRGlhbG9nLmhpZGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbnM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdHJlc2l6ZSA9IGZhbHNlLFxuXHRcdFx0cmVzaXphYmxlT3B0aW9ucyA9IHt9O1xuXG5cdFx0JC5lYWNoKCBvcHRpb25zLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdHRoYXQuX3NldE9wdGlvbigga2V5LCB2YWx1ZSApO1xuXG5cdFx0XHRpZiAoIGtleSBpbiB0aGF0LnNpemVSZWxhdGVkT3B0aW9ucyApIHtcblx0XHRcdFx0cmVzaXplID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICgga2V5IGluIHRoYXQucmVzaXphYmxlUmVsYXRlZE9wdGlvbnMgKSB7XG5cdFx0XHRcdHJlc2l6YWJsZU9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0aWYgKCByZXNpemUgKSB7XG5cdFx0XHR0aGlzLl9zaXplKCk7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbigpO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMudWlEaWFsb2cuaXMoIFwiOmRhdGEodWktcmVzaXphYmxlKVwiICkgKSB7XG5cdFx0XHR0aGlzLnVpRGlhbG9nLnJlc2l6YWJsZSggXCJvcHRpb25cIiwgcmVzaXphYmxlT3B0aW9ucyApO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaXNEcmFnZ2FibGUsIGlzUmVzaXphYmxlLFxuXHRcdFx0dWlEaWFsb2cgPSB0aGlzLnVpRGlhbG9nO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiYXBwZW5kVG9cIiApIHtcblx0XHRcdHRoaXMudWlEaWFsb2cuYXBwZW5kVG8oIHRoaXMuX2FwcGVuZFRvKCkgKTtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gXCJidXR0b25zXCIgKSB7XG5cdFx0XHR0aGlzLl9jcmVhdGVCdXR0b25zKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwiY2xvc2VUZXh0XCIgKSB7XG5cdFx0XHR0aGlzLnVpRGlhbG9nVGl0bGViYXJDbG9zZS5idXR0b24oIHtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhhdCB3ZSBhbHdheXMgcGFzcyBhIHN0cmluZ1xuXHRcdFx0XHRsYWJlbDogJCggXCI8YT5cIiApLnRleHQoIFwiXCIgKyB0aGlzLm9wdGlvbnMuY2xvc2VUZXh0ICkuaHRtbCgpXG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwiZHJhZ2dhYmxlXCIgKSB7XG5cdFx0XHRpc0RyYWdnYWJsZSA9IHVpRGlhbG9nLmlzKCBcIjpkYXRhKHVpLWRyYWdnYWJsZSlcIiApO1xuXHRcdFx0aWYgKCBpc0RyYWdnYWJsZSAmJiAhdmFsdWUgKSB7XG5cdFx0XHRcdHVpRGlhbG9nLmRyYWdnYWJsZSggXCJkZXN0cm95XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhaXNEcmFnZ2FibGUgJiYgdmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMuX21ha2VEcmFnZ2FibGUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gXCJwb3NpdGlvblwiICkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb24oKTtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gXCJyZXNpemFibGVcIiApIHtcblxuXHRcdFx0Ly8gY3VycmVudGx5IHJlc2l6YWJsZSwgYmVjb21pbmcgbm9uLXJlc2l6YWJsZVxuXHRcdFx0aXNSZXNpemFibGUgPSB1aURpYWxvZy5pcyggXCI6ZGF0YSh1aS1yZXNpemFibGUpXCIgKTtcblx0XHRcdGlmICggaXNSZXNpemFibGUgJiYgIXZhbHVlICkge1xuXHRcdFx0XHR1aURpYWxvZy5yZXNpemFibGUoIFwiZGVzdHJveVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEN1cnJlbnRseSByZXNpemFibGUsIGNoYW5naW5nIGhhbmRsZXNcblx0XHRcdGlmICggaXNSZXNpemFibGUgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHR1aURpYWxvZy5yZXNpemFibGUoIFwib3B0aW9uXCIsIFwiaGFuZGxlc1wiLCB2YWx1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDdXJyZW50bHkgbm9uLXJlc2l6YWJsZSwgYmVjb21pbmcgcmVzaXphYmxlXG5cdFx0XHRpZiAoICFpc1Jlc2l6YWJsZSAmJiB2YWx1ZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdHRoaXMuX21ha2VSZXNpemFibGUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gXCJ0aXRsZVwiICkge1xuXHRcdFx0dGhpcy5fdGl0bGUoIHRoaXMudWlEaWFsb2dUaXRsZWJhci5maW5kKCBcIi51aS1kaWFsb2ctdGl0bGVcIiApICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zaXplOiBmdW5jdGlvbigpIHtcblxuXHRcdC8vIElmIHRoZSB1c2VyIGhhcyByZXNpemVkIHRoZSBkaWFsb2csIHRoZSAudWktZGlhbG9nIGFuZCAudWktZGlhbG9nLWNvbnRlbnRcblx0XHQvLyBkaXZzIHdpbGwgYm90aCBoYXZlIHdpZHRoIGFuZCBoZWlnaHQgc2V0LCBzbyB3ZSBuZWVkIHRvIHJlc2V0IHRoZW1cblx0XHR2YXIgbm9uQ29udGVudEhlaWdodCwgbWluQ29udGVudEhlaWdodCwgbWF4Q29udGVudEhlaWdodCxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHQvLyBSZXNldCBjb250ZW50IHNpemluZ1xuXHRcdHRoaXMuZWxlbWVudC5zaG93KCkuY3NzKCB7XG5cdFx0XHR3aWR0aDogXCJhdXRvXCIsXG5cdFx0XHRtaW5IZWlnaHQ6IDAsXG5cdFx0XHRtYXhIZWlnaHQ6IFwibm9uZVwiLFxuXHRcdFx0aGVpZ2h0OiAwXG5cdFx0fSApO1xuXG5cdFx0aWYgKCBvcHRpb25zLm1pbldpZHRoID4gb3B0aW9ucy53aWR0aCApIHtcblx0XHRcdG9wdGlvbnMud2lkdGggPSBvcHRpb25zLm1pbldpZHRoO1xuXHRcdH1cblxuXHRcdC8vIFJlc2V0IHdyYXBwZXIgc2l6aW5nXG5cdFx0Ly8gZGV0ZXJtaW5lIHRoZSBoZWlnaHQgb2YgYWxsIHRoZSBub24tY29udGVudCBlbGVtZW50c1xuXHRcdG5vbkNvbnRlbnRIZWlnaHQgPSB0aGlzLnVpRGlhbG9nLmNzcygge1xuXHRcdFx0aGVpZ2h0OiBcImF1dG9cIixcblx0XHRcdHdpZHRoOiBvcHRpb25zLndpZHRoXG5cdFx0fSApXG5cdFx0XHQub3V0ZXJIZWlnaHQoKTtcblx0XHRtaW5Db250ZW50SGVpZ2h0ID0gTWF0aC5tYXgoIDAsIG9wdGlvbnMubWluSGVpZ2h0IC0gbm9uQ29udGVudEhlaWdodCApO1xuXHRcdG1heENvbnRlbnRIZWlnaHQgPSB0eXBlb2Ygb3B0aW9ucy5tYXhIZWlnaHQgPT09IFwibnVtYmVyXCIgP1xuXHRcdFx0TWF0aC5tYXgoIDAsIG9wdGlvbnMubWF4SGVpZ2h0IC0gbm9uQ29udGVudEhlaWdodCApIDpcblx0XHRcdFwibm9uZVwiO1xuXG5cdFx0aWYgKCBvcHRpb25zLmhlaWdodCA9PT0gXCJhdXRvXCIgKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuY3NzKCB7XG5cdFx0XHRcdG1pbkhlaWdodDogbWluQ29udGVudEhlaWdodCxcblx0XHRcdFx0bWF4SGVpZ2h0OiBtYXhDb250ZW50SGVpZ2h0LFxuXHRcdFx0XHRoZWlnaHQ6IFwiYXV0b1wiXG5cdFx0XHR9ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZWxlbWVudC5oZWlnaHQoIE1hdGgubWF4KCAwLCBvcHRpb25zLmhlaWdodCAtIG5vbkNvbnRlbnRIZWlnaHQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy51aURpYWxvZy5pcyggXCI6ZGF0YSh1aS1yZXNpemFibGUpXCIgKSApIHtcblx0XHRcdHRoaXMudWlEaWFsb2cucmVzaXphYmxlKCBcIm9wdGlvblwiLCBcIm1pbkhlaWdodFwiLCB0aGlzLl9taW5IZWlnaHQoKSApO1xuXHRcdH1cblx0fSxcblxuXHRfYmxvY2tGcmFtZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaWZyYW1lQmxvY2tzID0gdGhpcy5kb2N1bWVudC5maW5kKCBcImlmcmFtZVwiICkubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpZnJhbWUgPSAkKCB0aGlzICk7XG5cblx0XHRcdHJldHVybiAkKCBcIjxkaXY+XCIgKVxuXHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0cG9zaXRpb246IFwiYWJzb2x1dGVcIixcblx0XHRcdFx0XHR3aWR0aDogaWZyYW1lLm91dGVyV2lkdGgoKSxcblx0XHRcdFx0XHRoZWlnaHQ6IGlmcmFtZS5vdXRlckhlaWdodCgpXG5cdFx0XHRcdH0gKVxuXHRcdFx0XHQuYXBwZW5kVG8oIGlmcmFtZS5wYXJlbnQoKSApXG5cdFx0XHRcdC5vZmZzZXQoIGlmcmFtZS5vZmZzZXQoKSApWyAwIF07XG5cdFx0fSApO1xuXHR9LFxuXG5cdF91bmJsb2NrRnJhbWVzOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMuaWZyYW1lQmxvY2tzICkge1xuXHRcdFx0dGhpcy5pZnJhbWVCbG9ja3MucmVtb3ZlKCk7XG5cdFx0XHRkZWxldGUgdGhpcy5pZnJhbWVCbG9ja3M7XG5cdFx0fVxuXHR9LFxuXG5cdF9hbGxvd0ludGVyYWN0aW9uOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCAkKCBldmVudC50YXJnZXQgKS5jbG9zZXN0KCBcIi51aS1kaWFsb2dcIiApLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFRPRE86IFJlbW92ZSBoYWNrIHdoZW4gZGF0ZXBpY2tlciBpbXBsZW1lbnRzXG5cdFx0Ly8gdGhlIC51aS1mcm9udCBsb2dpYyAoIzg5ODkpXG5cdFx0cmV0dXJuICEhJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggXCIudWktZGF0ZXBpY2tlclwiICkubGVuZ3RoO1xuXHR9LFxuXG5cdF9jcmVhdGVPdmVybGF5OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzLm9wdGlvbnMubW9kYWwgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gV2UgdXNlIGEgZGVsYXkgaW4gY2FzZSB0aGUgb3ZlcmxheSBpcyBjcmVhdGVkIGZyb20gYW5cblx0XHQvLyBldmVudCB0aGF0IHdlJ3JlIGdvaW5nIHRvIGJlIGNhbmNlbGxpbmcgKCMyODA0KVxuXHRcdHZhciBpc09wZW5pbmcgPSB0cnVlO1xuXHRcdHRoaXMuX2RlbGF5KCBmdW5jdGlvbigpIHtcblx0XHRcdGlzT3BlbmluZyA9IGZhbHNlO1xuXHRcdH0gKTtcblxuXHRcdGlmICggIXRoaXMuZG9jdW1lbnQuZGF0YSggXCJ1aS1kaWFsb2ctb3ZlcmxheXNcIiApICkge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHVzZSBvZiBhbmNob3JzIGFuZCBpbnB1dHNcblx0XHRcdC8vIFVzaW5nIF9vbigpIGZvciBhbiBldmVudCBoYW5kbGVyIHNoYXJlZCBhY3Jvc3MgbWFueSBpbnN0YW5jZXMgaXNcblx0XHRcdC8vIHNhZmUgYmVjYXVzZSB0aGUgZGlhbG9ncyBzdGFjayBhbmQgbXVzdCBiZSBjbG9zZWQgaW4gcmV2ZXJzZSBvcmRlclxuXHRcdFx0dGhpcy5fb24oIHRoaXMuZG9jdW1lbnQsIHtcblx0XHRcdFx0Zm9jdXNpbjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdGlmICggaXNPcGVuaW5nICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggIXRoaXMuX2FsbG93SW50ZXJhY3Rpb24oIGV2ZW50ICkgKSB7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0dGhpcy5fdHJhY2tpbmdJbnN0YW5jZXMoKVsgMCBdLl9mb2N1c1RhYmJhYmxlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vdmVybGF5ID0gJCggXCI8ZGl2PlwiIClcblx0XHRcdC5hcHBlbmRUbyggdGhpcy5fYXBwZW5kVG8oKSApO1xuXG5cdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMub3ZlcmxheSwgbnVsbCwgXCJ1aS13aWRnZXQtb3ZlcmxheSB1aS1mcm9udFwiICk7XG5cdFx0dGhpcy5fb24oIHRoaXMub3ZlcmxheSwge1xuXHRcdFx0bW91c2Vkb3duOiBcIl9rZWVwRm9jdXNcIlxuXHRcdH0gKTtcblx0XHR0aGlzLmRvY3VtZW50LmRhdGEoIFwidWktZGlhbG9nLW92ZXJsYXlzXCIsXG5cdFx0XHQoIHRoaXMuZG9jdW1lbnQuZGF0YSggXCJ1aS1kaWFsb2ctb3ZlcmxheXNcIiApIHx8IDAgKSArIDEgKTtcblx0fSxcblxuXHRfZGVzdHJveU92ZXJsYXk6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXMub3B0aW9ucy5tb2RhbCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3ZlcmxheSApIHtcblx0XHRcdHZhciBvdmVybGF5cyA9IHRoaXMuZG9jdW1lbnQuZGF0YSggXCJ1aS1kaWFsb2ctb3ZlcmxheXNcIiApIC0gMTtcblxuXHRcdFx0aWYgKCAhb3ZlcmxheXMgKSB7XG5cdFx0XHRcdHRoaXMuX29mZiggdGhpcy5kb2N1bWVudCwgXCJmb2N1c2luXCIgKTtcblx0XHRcdFx0dGhpcy5kb2N1bWVudC5yZW1vdmVEYXRhKCBcInVpLWRpYWxvZy1vdmVybGF5c1wiICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmRvY3VtZW50LmRhdGEoIFwidWktZGlhbG9nLW92ZXJsYXlzXCIsIG92ZXJsYXlzICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMub3ZlcmxheS5yZW1vdmUoKTtcblx0XHRcdHRoaXMub3ZlcmxheSA9IG51bGw7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIERFUFJFQ0FURURcbi8vIFRPRE86IHN3aXRjaCByZXR1cm4gYmFjayB0byB3aWRnZXQgZGVjbGFyYXRpb24gYXQgdG9wIG9mIGZpbGUgd2hlbiB0aGlzIGlzIHJlbW92ZWRcbmlmICggJC51aUJhY2tDb21wYXQgIT09IGZhbHNlICkge1xuXG5cdC8vIEJhY2tjb21wYXQgZm9yIGRpYWxvZ0NsYXNzIG9wdGlvblxuXHQkLndpZGdldCggXCJ1aS5kaWFsb2dcIiwgJC51aS5kaWFsb2csIHtcblx0XHRvcHRpb25zOiB7XG5cdFx0XHRkaWFsb2dDbGFzczogXCJcIlxuXHRcdH0sXG5cdFx0X2NyZWF0ZVdyYXBwZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHRcdHRoaXMudWlEaWFsb2cuYWRkQ2xhc3MoIHRoaXMub3B0aW9ucy5kaWFsb2dDbGFzcyApO1xuXHRcdH0sXG5cdFx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIGtleSA9PT0gXCJkaWFsb2dDbGFzc1wiICkge1xuXHRcdFx0XHR0aGlzLnVpRGlhbG9nXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCB0aGlzLm9wdGlvbnMuZGlhbG9nQ2xhc3MgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggdmFsdWUgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3N1cGVyQXBwbHkoIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fSApO1xufVxuXG52YXIgd2lkZ2V0c0RpYWxvZyA9ICQudWkuZGlhbG9nO1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIERyb3BwYWJsZSAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogRHJvcHBhYmxlXG4vLz4+Z3JvdXA6IEludGVyYWN0aW9uc1xuLy8+PmRlc2NyaXB0aW9uOiBFbmFibGVzIGRyb3AgdGFyZ2V0cyBmb3IgZHJhZ2dhYmxlIGVsZW1lbnRzLlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2Ryb3BwYWJsZS9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9kcm9wcGFibGUvXG5cblxuXG4kLndpZGdldCggXCJ1aS5kcm9wcGFibGVcIiwge1xuXHR2ZXJzaW9uOiBcIjEuMTIuMVwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJkcm9wXCIsXG5cdG9wdGlvbnM6IHtcblx0XHRhY2NlcHQ6IFwiKlwiLFxuXHRcdGFkZENsYXNzZXM6IHRydWUsXG5cdFx0Z3JlZWR5OiBmYWxzZSxcblx0XHRzY29wZTogXCJkZWZhdWx0XCIsXG5cdFx0dG9sZXJhbmNlOiBcImludGVyc2VjdFwiLFxuXG5cdFx0Ly8gQ2FsbGJhY2tzXG5cdFx0YWN0aXZhdGU6IG51bGwsXG5cdFx0ZGVhY3RpdmF0ZTogbnVsbCxcblx0XHRkcm9wOiBudWxsLFxuXHRcdG91dDogbnVsbCxcblx0XHRvdmVyOiBudWxsXG5cdH0sXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHByb3BvcnRpb25zLFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGFjY2VwdCA9IG8uYWNjZXB0O1xuXG5cdFx0dGhpcy5pc292ZXIgPSBmYWxzZTtcblx0XHR0aGlzLmlzb3V0ID0gdHJ1ZTtcblxuXHRcdHRoaXMuYWNjZXB0ID0gJC5pc0Z1bmN0aW9uKCBhY2NlcHQgKSA/IGFjY2VwdCA6IGZ1bmN0aW9uKCBkICkge1xuXHRcdFx0cmV0dXJuIGQuaXMoIGFjY2VwdCApO1xuXHRcdH07XG5cblx0XHR0aGlzLnByb3BvcnRpb25zID0gZnVuY3Rpb24oIC8qIHZhbHVlVG9Xcml0ZSAqLyApIHtcblx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblxuXHRcdFx0XHQvLyBTdG9yZSB0aGUgZHJvcHBhYmxlJ3MgcHJvcG9ydGlvbnNcblx0XHRcdFx0cHJvcG9ydGlvbnMgPSBhcmd1bWVudHNbIDAgXTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gUmV0cmlldmUgb3IgZGVyaXZlIHRoZSBkcm9wcGFibGUncyBwcm9wb3J0aW9uc1xuXHRcdFx0XHRyZXR1cm4gcHJvcG9ydGlvbnMgP1xuXHRcdFx0XHRcdHByb3BvcnRpb25zIDpcblx0XHRcdFx0XHRwcm9wb3J0aW9ucyA9IHtcblx0XHRcdFx0XHRcdHdpZHRoOiB0aGlzLmVsZW1lbnRbIDAgXS5vZmZzZXRXaWR0aCxcblx0XHRcdFx0XHRcdGhlaWdodDogdGhpcy5lbGVtZW50WyAwIF0ub2Zmc2V0SGVpZ2h0XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5fYWRkVG9NYW5hZ2VyKCBvLnNjb3BlICk7XG5cblx0XHRvLmFkZENsYXNzZXMgJiYgdGhpcy5fYWRkQ2xhc3MoIFwidWktZHJvcHBhYmxlXCIgKTtcblxuXHR9LFxuXG5cdF9hZGRUb01hbmFnZXI6IGZ1bmN0aW9uKCBzY29wZSApIHtcblxuXHRcdC8vIEFkZCB0aGUgcmVmZXJlbmNlIGFuZCBwb3NpdGlvbnMgdG8gdGhlIG1hbmFnZXJcblx0XHQkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzWyBzY29wZSBdID0gJC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1sgc2NvcGUgXSB8fCBbXTtcblx0XHQkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzWyBzY29wZSBdLnB1c2goIHRoaXMgKTtcblx0fSxcblxuXHRfc3BsaWNlOiBmdW5jdGlvbiggZHJvcCApIHtcblx0XHR2YXIgaSA9IDA7XG5cdFx0Zm9yICggOyBpIDwgZHJvcC5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGlmICggZHJvcFsgaSBdID09PSB0aGlzICkge1xuXHRcdFx0XHRkcm9wLnNwbGljZSggaSwgMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRyb3AgPSAkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzWyB0aGlzLm9wdGlvbnMuc2NvcGUgXTtcblxuXHRcdHRoaXMuX3NwbGljZSggZHJvcCApO1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiYWNjZXB0XCIgKSB7XG5cdFx0XHR0aGlzLmFjY2VwdCA9ICQuaXNGdW5jdGlvbiggdmFsdWUgKSA/IHZhbHVlIDogZnVuY3Rpb24oIGQgKSB7XG5cdFx0XHRcdHJldHVybiBkLmlzKCB2YWx1ZSApO1xuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKCBrZXkgPT09IFwic2NvcGVcIiApIHtcblx0XHRcdHZhciBkcm9wID0gJC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1sgdGhpcy5vcHRpb25zLnNjb3BlIF07XG5cblx0XHRcdHRoaXMuX3NwbGljZSggZHJvcCApO1xuXHRcdFx0dGhpcy5fYWRkVG9NYW5hZ2VyKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cdH0sXG5cblx0X2FjdGl2YXRlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGRyYWdnYWJsZSA9ICQudWkuZGRtYW5hZ2VyLmN1cnJlbnQ7XG5cblx0XHR0aGlzLl9hZGRBY3RpdmVDbGFzcygpO1xuXHRcdGlmICggZHJhZ2dhYmxlICkge1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJhY3RpdmF0ZVwiLCBldmVudCwgdGhpcy51aSggZHJhZ2dhYmxlICkgKTtcblx0XHR9XG5cdH0sXG5cblx0X2RlYWN0aXZhdGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgZHJhZ2dhYmxlID0gJC51aS5kZG1hbmFnZXIuY3VycmVudDtcblxuXHRcdHRoaXMuX3JlbW92ZUFjdGl2ZUNsYXNzKCk7XG5cdFx0aWYgKCBkcmFnZ2FibGUgKSB7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCBcImRlYWN0aXZhdGVcIiwgZXZlbnQsIHRoaXMudWkoIGRyYWdnYWJsZSApICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vdmVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHR2YXIgZHJhZ2dhYmxlID0gJC51aS5kZG1hbmFnZXIuY3VycmVudDtcblxuXHRcdC8vIEJhaWwgaWYgZHJhZ2dhYmxlIGFuZCBkcm9wcGFibGUgYXJlIHNhbWUgZWxlbWVudFxuXHRcdGlmICggIWRyYWdnYWJsZSB8fCAoIGRyYWdnYWJsZS5jdXJyZW50SXRlbSB8fFxuXHRcdFx0XHRkcmFnZ2FibGUuZWxlbWVudCApWyAwIF0gPT09IHRoaXMuZWxlbWVudFsgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hY2NlcHQuY2FsbCggdGhpcy5lbGVtZW50WyAwIF0sICggZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8XG5cdFx0XHRcdGRyYWdnYWJsZS5lbGVtZW50ICkgKSApIHtcblx0XHRcdHRoaXMuX2FkZEhvdmVyQ2xhc3MoKTtcblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwib3ZlclwiLCBldmVudCwgdGhpcy51aSggZHJhZ2dhYmxlICkgKTtcblx0XHR9XG5cblx0fSxcblxuXHRfb3V0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHR2YXIgZHJhZ2dhYmxlID0gJC51aS5kZG1hbmFnZXIuY3VycmVudDtcblxuXHRcdC8vIEJhaWwgaWYgZHJhZ2dhYmxlIGFuZCBkcm9wcGFibGUgYXJlIHNhbWUgZWxlbWVudFxuXHRcdGlmICggIWRyYWdnYWJsZSB8fCAoIGRyYWdnYWJsZS5jdXJyZW50SXRlbSB8fFxuXHRcdFx0XHRkcmFnZ2FibGUuZWxlbWVudCApWyAwIF0gPT09IHRoaXMuZWxlbWVudFsgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hY2NlcHQuY2FsbCggdGhpcy5lbGVtZW50WyAwIF0sICggZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8XG5cdFx0XHRcdGRyYWdnYWJsZS5lbGVtZW50ICkgKSApIHtcblx0XHRcdHRoaXMuX3JlbW92ZUhvdmVyQ2xhc3MoKTtcblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwib3V0XCIsIGV2ZW50LCB0aGlzLnVpKCBkcmFnZ2FibGUgKSApO1xuXHRcdH1cblxuXHR9LFxuXG5cdF9kcm9wOiBmdW5jdGlvbiggZXZlbnQsIGN1c3RvbSApIHtcblxuXHRcdHZhciBkcmFnZ2FibGUgPSBjdXN0b20gfHwgJC51aS5kZG1hbmFnZXIuY3VycmVudCxcblx0XHRcdGNoaWxkcmVuSW50ZXJzZWN0aW9uID0gZmFsc2U7XG5cblx0XHQvLyBCYWlsIGlmIGRyYWdnYWJsZSBhbmQgZHJvcHBhYmxlIGFyZSBzYW1lIGVsZW1lbnRcblx0XHRpZiAoICFkcmFnZ2FibGUgfHwgKCBkcmFnZ2FibGUuY3VycmVudEl0ZW0gfHxcblx0XHRcdFx0ZHJhZ2dhYmxlLmVsZW1lbnQgKVsgMCBdID09PSB0aGlzLmVsZW1lbnRbIDAgXSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5maW5kKCBcIjpkYXRhKHVpLWRyb3BwYWJsZSlcIiApXG5cdFx0XHQubm90KCBcIi51aS1kcmFnZ2FibGUtZHJhZ2dpbmdcIiApXG5cdFx0XHQuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbnN0ID0gJCggdGhpcyApLmRyb3BwYWJsZSggXCJpbnN0YW5jZVwiICk7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMuZ3JlZWR5ICYmXG5cdFx0XHRcdFx0IWluc3Qub3B0aW9ucy5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdGluc3Qub3B0aW9ucy5zY29wZSA9PT0gZHJhZ2dhYmxlLm9wdGlvbnMuc2NvcGUgJiZcblx0XHRcdFx0XHRpbnN0LmFjY2VwdC5jYWxsKFxuXHRcdFx0XHRcdFx0aW5zdC5lbGVtZW50WyAwIF0sICggZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8IGRyYWdnYWJsZS5lbGVtZW50IClcblx0XHRcdFx0XHQpICYmXG5cdFx0XHRcdFx0aW50ZXJzZWN0KFxuXHRcdFx0XHRcdFx0ZHJhZ2dhYmxlLFxuXHRcdFx0XHRcdFx0JC5leHRlbmQoIGluc3QsIHsgb2Zmc2V0OiBpbnN0LmVsZW1lbnQub2Zmc2V0KCkgfSApLFxuXHRcdFx0XHRcdFx0aW5zdC5vcHRpb25zLnRvbGVyYW5jZSwgZXZlbnRcblx0XHRcdFx0XHQpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGNoaWxkcmVuSW50ZXJzZWN0aW9uID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IH1cblx0XHRcdH0gKTtcblx0XHRpZiAoIGNoaWxkcmVuSW50ZXJzZWN0aW9uICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hY2NlcHQuY2FsbCggdGhpcy5lbGVtZW50WyAwIF0sXG5cdFx0XHRcdCggZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8IGRyYWdnYWJsZS5lbGVtZW50ICkgKSApIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFjdGl2ZUNsYXNzKCk7XG5cdFx0XHR0aGlzLl9yZW1vdmVIb3ZlckNsYXNzKCk7XG5cblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiZHJvcFwiLCBldmVudCwgdGhpcy51aSggZHJhZ2dhYmxlICkgKTtcblx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH0sXG5cblx0dWk6IGZ1bmN0aW9uKCBjICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRkcmFnZ2FibGU6ICggYy5jdXJyZW50SXRlbSB8fCBjLmVsZW1lbnQgKSxcblx0XHRcdGhlbHBlcjogYy5oZWxwZXIsXG5cdFx0XHRwb3NpdGlvbjogYy5wb3NpdGlvbixcblx0XHRcdG9mZnNldDogYy5wb3NpdGlvbkFic1xuXHRcdH07XG5cdH0sXG5cblx0Ly8gRXh0ZW5zaW9uIHBvaW50cyBqdXN0IHRvIG1ha2UgYmFja2NvbXBhdCBzYW5lIGFuZCBhdm9pZCBkdXBsaWNhdGluZyBsb2dpY1xuXHQvLyBUT0RPOiBSZW1vdmUgaW4gMS4xMyBhbG9uZyB3aXRoIGNhbGwgdG8gaXQgYmVsb3dcblx0X2FkZEhvdmVyQ2xhc3M6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2FkZENsYXNzKCBcInVpLWRyb3BwYWJsZS1ob3ZlclwiICk7XG5cdH0sXG5cblx0X3JlbW92ZUhvdmVyQ2xhc3M6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBcInVpLWRyb3BwYWJsZS1ob3ZlclwiICk7XG5cdH0sXG5cblx0X2FkZEFjdGl2ZUNsYXNzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9hZGRDbGFzcyggXCJ1aS1kcm9wcGFibGUtYWN0aXZlXCIgKTtcblx0fSxcblxuXHRfcmVtb3ZlQWN0aXZlQ2xhc3M6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBcInVpLWRyb3BwYWJsZS1hY3RpdmVcIiApO1xuXHR9XG59ICk7XG5cbnZhciBpbnRlcnNlY3QgPSAkLnVpLmludGVyc2VjdCA9ICggZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGlzT3ZlckF4aXMoIHgsIHJlZmVyZW5jZSwgc2l6ZSApIHtcblx0XHRyZXR1cm4gKCB4ID49IHJlZmVyZW5jZSApICYmICggeCA8ICggcmVmZXJlbmNlICsgc2l6ZSApICk7XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24oIGRyYWdnYWJsZSwgZHJvcHBhYmxlLCB0b2xlcmFuY2VNb2RlLCBldmVudCApIHtcblxuXHRcdGlmICggIWRyb3BwYWJsZS5vZmZzZXQgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHgxID0gKCBkcmFnZ2FibGUucG9zaXRpb25BYnMgfHxcblx0XHRcdFx0ZHJhZ2dhYmxlLnBvc2l0aW9uLmFic29sdXRlICkubGVmdCArIGRyYWdnYWJsZS5tYXJnaW5zLmxlZnQsXG5cdFx0XHR5MSA9ICggZHJhZ2dhYmxlLnBvc2l0aW9uQWJzIHx8XG5cdFx0XHRcdGRyYWdnYWJsZS5wb3NpdGlvbi5hYnNvbHV0ZSApLnRvcCArIGRyYWdnYWJsZS5tYXJnaW5zLnRvcCxcblx0XHRcdHgyID0geDEgKyBkcmFnZ2FibGUuaGVscGVyUHJvcG9ydGlvbnMud2lkdGgsXG5cdFx0XHR5MiA9IHkxICsgZHJhZ2dhYmxlLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCxcblx0XHRcdGwgPSBkcm9wcGFibGUub2Zmc2V0LmxlZnQsXG5cdFx0XHR0ID0gZHJvcHBhYmxlLm9mZnNldC50b3AsXG5cdFx0XHRyID0gbCArIGRyb3BwYWJsZS5wcm9wb3J0aW9ucygpLndpZHRoLFxuXHRcdFx0YiA9IHQgKyBkcm9wcGFibGUucHJvcG9ydGlvbnMoKS5oZWlnaHQ7XG5cblx0XHRzd2l0Y2ggKCB0b2xlcmFuY2VNb2RlICkge1xuXHRcdGNhc2UgXCJmaXRcIjpcblx0XHRcdHJldHVybiAoIGwgPD0geDEgJiYgeDIgPD0gciAmJiB0IDw9IHkxICYmIHkyIDw9IGIgKTtcblx0XHRjYXNlIFwiaW50ZXJzZWN0XCI6XG5cdFx0XHRyZXR1cm4gKCBsIDwgeDEgKyAoIGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAvIDIgKSAmJiAvLyBSaWdodCBIYWxmXG5cdFx0XHRcdHgyIC0gKCBkcmFnZ2FibGUuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLyAyICkgPCByICYmIC8vIExlZnQgSGFsZlxuXHRcdFx0XHR0IDwgeTEgKyAoIGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLyAyICkgJiYgLy8gQm90dG9tIEhhbGZcblx0XHRcdFx0eTIgLSAoIGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLyAyICkgPCBiICk7IC8vIFRvcCBIYWxmXG5cdFx0Y2FzZSBcInBvaW50ZXJcIjpcblx0XHRcdHJldHVybiBpc092ZXJBeGlzKCBldmVudC5wYWdlWSwgdCwgZHJvcHBhYmxlLnByb3BvcnRpb25zKCkuaGVpZ2h0ICkgJiZcblx0XHRcdFx0aXNPdmVyQXhpcyggZXZlbnQucGFnZVgsIGwsIGRyb3BwYWJsZS5wcm9wb3J0aW9ucygpLndpZHRoICk7XG5cdFx0Y2FzZSBcInRvdWNoXCI6XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQoIHkxID49IHQgJiYgeTEgPD0gYiApIHx8IC8vIFRvcCBlZGdlIHRvdWNoaW5nXG5cdFx0XHRcdCggeTIgPj0gdCAmJiB5MiA8PSBiICkgfHwgLy8gQm90dG9tIGVkZ2UgdG91Y2hpbmdcblx0XHRcdFx0KCB5MSA8IHQgJiYgeTIgPiBiICkgLy8gU3Vycm91bmRlZCB2ZXJ0aWNhbGx5XG5cdFx0XHQpICYmIChcblx0XHRcdFx0KCB4MSA+PSBsICYmIHgxIDw9IHIgKSB8fCAvLyBMZWZ0IGVkZ2UgdG91Y2hpbmdcblx0XHRcdFx0KCB4MiA+PSBsICYmIHgyIDw9IHIgKSB8fCAvLyBSaWdodCBlZGdlIHRvdWNoaW5nXG5cdFx0XHRcdCggeDEgPCBsICYmIHgyID4gciApIC8vIFN1cnJvdW5kZWQgaG9yaXpvbnRhbGx5XG5cdFx0XHQpO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xufSApKCk7XG5cbi8qXG5cdFRoaXMgbWFuYWdlciB0cmFja3Mgb2Zmc2V0cyBvZiBkcmFnZ2FibGVzIGFuZCBkcm9wcGFibGVzXG4qL1xuJC51aS5kZG1hbmFnZXIgPSB7XG5cdGN1cnJlbnQ6IG51bGwsXG5cdGRyb3BwYWJsZXM6IHsgXCJkZWZhdWx0XCI6IFtdIH0sXG5cdHByZXBhcmVPZmZzZXRzOiBmdW5jdGlvbiggdCwgZXZlbnQgKSB7XG5cblx0XHR2YXIgaSwgaixcblx0XHRcdG0gPSAkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzWyB0Lm9wdGlvbnMuc2NvcGUgXSB8fCBbXSxcblx0XHRcdHR5cGUgPSBldmVudCA/IGV2ZW50LnR5cGUgOiBudWxsLCAvLyB3b3JrYXJvdW5kIGZvciAjMjMxN1xuXHRcdFx0bGlzdCA9ICggdC5jdXJyZW50SXRlbSB8fCB0LmVsZW1lbnQgKS5maW5kKCBcIjpkYXRhKHVpLWRyb3BwYWJsZSlcIiApLmFkZEJhY2soKTtcblxuXHRcdGRyb3BwYWJsZXNMb29wOiBmb3IgKCBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKysgKSB7XG5cblx0XHRcdC8vIE5vIGRpc2FibGVkIGFuZCBub24tYWNjZXB0ZWRcblx0XHRcdGlmICggbVsgaSBdLm9wdGlvbnMuZGlzYWJsZWQgfHwgKCB0ICYmICFtWyBpIF0uYWNjZXB0LmNhbGwoIG1bIGkgXS5lbGVtZW50WyAwIF0sXG5cdFx0XHRcdFx0KCB0LmN1cnJlbnRJdGVtIHx8IHQuZWxlbWVudCApICkgKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgZWxlbWVudHMgaW4gdGhlIGN1cnJlbnQgZHJhZ2dlZCBpdGVtXG5cdFx0XHRmb3IgKCBqID0gMDsgaiA8IGxpc3QubGVuZ3RoOyBqKysgKSB7XG5cdFx0XHRcdGlmICggbGlzdFsgaiBdID09PSBtWyBpIF0uZWxlbWVudFsgMCBdICkge1xuXHRcdFx0XHRcdG1bIGkgXS5wcm9wb3J0aW9ucygpLmhlaWdodCA9IDA7XG5cdFx0XHRcdFx0Y29udGludWUgZHJvcHBhYmxlc0xvb3A7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bVsgaSBdLnZpc2libGUgPSBtWyBpIF0uZWxlbWVudC5jc3MoIFwiZGlzcGxheVwiICkgIT09IFwibm9uZVwiO1xuXHRcdFx0aWYgKCAhbVsgaSBdLnZpc2libGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY3RpdmF0ZSB0aGUgZHJvcHBhYmxlIGlmIHVzZWQgZGlyZWN0bHkgZnJvbSBkcmFnZ2FibGVzXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibW91c2Vkb3duXCIgKSB7XG5cdFx0XHRcdG1bIGkgXS5fYWN0aXZhdGUuY2FsbCggbVsgaSBdLCBldmVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRtWyBpIF0ub2Zmc2V0ID0gbVsgaSBdLmVsZW1lbnQub2Zmc2V0KCk7XG5cdFx0XHRtWyBpIF0ucHJvcG9ydGlvbnMoIHtcblx0XHRcdFx0d2lkdGg6IG1bIGkgXS5lbGVtZW50WyAwIF0ub2Zmc2V0V2lkdGgsXG5cdFx0XHRcdGhlaWdodDogbVsgaSBdLmVsZW1lbnRbIDAgXS5vZmZzZXRIZWlnaHRcblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHR9LFxuXHRkcm9wOiBmdW5jdGlvbiggZHJhZ2dhYmxlLCBldmVudCApIHtcblxuXHRcdHZhciBkcm9wcGVkID0gZmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBkcm9wcGFibGVzIGluIGNhc2UgdGhlIGxpc3QgY2hhbmdlcyBkdXJpbmcgdGhlIGRyb3AgKCM5MTE2KVxuXHRcdCQuZWFjaCggKCAkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzWyBkcmFnZ2FibGUub3B0aW9ucy5zY29wZSBdIHx8IFtdICkuc2xpY2UoKSwgZnVuY3Rpb24oKSB7XG5cblx0XHRcdGlmICggIXRoaXMub3B0aW9ucyApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVkICYmIHRoaXMudmlzaWJsZSAmJlxuXHRcdFx0XHRcdGludGVyc2VjdCggZHJhZ2dhYmxlLCB0aGlzLCB0aGlzLm9wdGlvbnMudG9sZXJhbmNlLCBldmVudCApICkge1xuXHRcdFx0XHRkcm9wcGVkID0gdGhpcy5fZHJvcC5jYWxsKCB0aGlzLCBldmVudCApIHx8IGRyb3BwZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlZCAmJiB0aGlzLnZpc2libGUgJiYgdGhpcy5hY2NlcHQuY2FsbCggdGhpcy5lbGVtZW50WyAwIF0sXG5cdFx0XHRcdFx0KCBkcmFnZ2FibGUuY3VycmVudEl0ZW0gfHwgZHJhZ2dhYmxlLmVsZW1lbnQgKSApICkge1xuXHRcdFx0XHR0aGlzLmlzb3V0ID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5pc292ZXIgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fZGVhY3RpdmF0ZS5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdFx0fVxuXG5cdFx0fSApO1xuXHRcdHJldHVybiBkcm9wcGVkO1xuXG5cdH0sXG5cdGRyYWdTdGFydDogZnVuY3Rpb24oIGRyYWdnYWJsZSwgZXZlbnQgKSB7XG5cblx0XHQvLyBMaXN0ZW4gZm9yIHNjcm9sbGluZyBzbyB0aGF0IGlmIHRoZSBkcmFnZ2luZyBjYXVzZXMgc2Nyb2xsaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGVcblx0XHQvLyBkcm9wcGFibGVzIGNhbiBiZSByZWNhbGN1bGF0ZWQgKHNlZSAjNTAwMylcblx0XHRkcmFnZ2FibGUuZWxlbWVudC5wYXJlbnRzVW50aWwoIFwiYm9keVwiICkub24oIFwic2Nyb2xsLmRyb3BwYWJsZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIWRyYWdnYWJsZS5vcHRpb25zLnJlZnJlc2hQb3NpdGlvbnMgKSB7XG5cdFx0XHRcdCQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKCBkcmFnZ2FibGUsIGV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRkcmFnOiBmdW5jdGlvbiggZHJhZ2dhYmxlLCBldmVudCApIHtcblxuXHRcdC8vIElmIHlvdSBoYXZlIGEgaGlnaGx5IGR5bmFtaWMgcGFnZSwgeW91IG1pZ2h0IHRyeSB0aGlzIG9wdGlvbi4gSXQgcmVuZGVycyBwb3NpdGlvbnNcblx0XHQvLyBldmVyeSB0aW1lIHlvdSBtb3ZlIHRoZSBtb3VzZS5cblx0XHRpZiAoIGRyYWdnYWJsZS5vcHRpb25zLnJlZnJlc2hQb3NpdGlvbnMgKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyggZHJhZ2dhYmxlLCBldmVudCApO1xuXHRcdH1cblxuXHRcdC8vIFJ1biB0aHJvdWdoIGFsbCBkcm9wcGFibGVzIGFuZCBjaGVjayB0aGVpciBwb3NpdGlvbnMgYmFzZWQgb24gc3BlY2lmaWMgdG9sZXJhbmNlIG9wdGlvbnNcblx0XHQkLmVhY2goICQudWkuZGRtYW5hZ2VyLmRyb3BwYWJsZXNbIGRyYWdnYWJsZS5vcHRpb25zLnNjb3BlIF0gfHwgW10sIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCB8fCB0aGlzLmdyZWVkeUNoaWxkIHx8ICF0aGlzLnZpc2libGUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHBhcmVudEluc3RhbmNlLCBzY29wZSwgcGFyZW50LFxuXHRcdFx0XHRpbnRlcnNlY3RzID0gaW50ZXJzZWN0KCBkcmFnZ2FibGUsIHRoaXMsIHRoaXMub3B0aW9ucy50b2xlcmFuY2UsIGV2ZW50ICksXG5cdFx0XHRcdGMgPSAhaW50ZXJzZWN0cyAmJiB0aGlzLmlzb3ZlciA/XG5cdFx0XHRcdFx0XCJpc291dFwiIDpcblx0XHRcdFx0XHQoIGludGVyc2VjdHMgJiYgIXRoaXMuaXNvdmVyID8gXCJpc292ZXJcIiA6IG51bGwgKTtcblx0XHRcdGlmICggIWMgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuZ3JlZWR5ICkge1xuXG5cdFx0XHRcdC8vIGZpbmQgZHJvcHBhYmxlIHBhcmVudHMgd2l0aCBzYW1lIHNjb3BlXG5cdFx0XHRcdHNjb3BlID0gdGhpcy5vcHRpb25zLnNjb3BlO1xuXHRcdFx0XHRwYXJlbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50cyggXCI6ZGF0YSh1aS1kcm9wcGFibGUpXCIgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiAkKCB0aGlzICkuZHJvcHBhYmxlKCBcImluc3RhbmNlXCIgKS5vcHRpb25zLnNjb3BlID09PSBzY29wZTtcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdGlmICggcGFyZW50Lmxlbmd0aCApIHtcblx0XHRcdFx0XHRwYXJlbnRJbnN0YW5jZSA9ICQoIHBhcmVudFsgMCBdICkuZHJvcHBhYmxlKCBcImluc3RhbmNlXCIgKTtcblx0XHRcdFx0XHRwYXJlbnRJbnN0YW5jZS5ncmVlZHlDaGlsZCA9ICggYyA9PT0gXCJpc292ZXJcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlIGp1c3QgbW92ZWQgaW50byBhIGdyZWVkeSBjaGlsZFxuXHRcdFx0aWYgKCBwYXJlbnRJbnN0YW5jZSAmJiBjID09PSBcImlzb3ZlclwiICkge1xuXHRcdFx0XHRwYXJlbnRJbnN0YW5jZS5pc292ZXIgPSBmYWxzZTtcblx0XHRcdFx0cGFyZW50SW5zdGFuY2UuaXNvdXQgPSB0cnVlO1xuXHRcdFx0XHRwYXJlbnRJbnN0YW5jZS5fb3V0LmNhbGwoIHBhcmVudEluc3RhbmNlLCBldmVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzWyBjIF0gPSB0cnVlO1xuXHRcdFx0dGhpc1sgYyA9PT0gXCJpc291dFwiID8gXCJpc292ZXJcIiA6IFwiaXNvdXRcIiBdID0gZmFsc2U7XG5cdFx0XHR0aGlzWyBjID09PSBcImlzb3ZlclwiID8gXCJfb3ZlclwiIDogXCJfb3V0XCIgXS5jYWxsKCB0aGlzLCBldmVudCApO1xuXG5cdFx0XHQvLyBXZSBqdXN0IG1vdmVkIG91dCBvZiBhIGdyZWVkeSBjaGlsZFxuXHRcdFx0aWYgKCBwYXJlbnRJbnN0YW5jZSAmJiBjID09PSBcImlzb3V0XCIgKSB7XG5cdFx0XHRcdHBhcmVudEluc3RhbmNlLmlzb3V0ID0gZmFsc2U7XG5cdFx0XHRcdHBhcmVudEluc3RhbmNlLmlzb3ZlciA9IHRydWU7XG5cdFx0XHRcdHBhcmVudEluc3RhbmNlLl9vdmVyLmNhbGwoIHBhcmVudEluc3RhbmNlLCBldmVudCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9LFxuXHRkcmFnU3RvcDogZnVuY3Rpb24oIGRyYWdnYWJsZSwgZXZlbnQgKSB7XG5cdFx0ZHJhZ2dhYmxlLmVsZW1lbnQucGFyZW50c1VudGlsKCBcImJvZHlcIiApLm9mZiggXCJzY3JvbGwuZHJvcHBhYmxlXCIgKTtcblxuXHRcdC8vIENhbGwgcHJlcGFyZU9mZnNldHMgb25lIGZpbmFsIHRpbWUgc2luY2UgSUUgZG9lcyBub3QgZmlyZSByZXR1cm4gc2Nyb2xsIGV2ZW50cyB3aGVuXG5cdFx0Ly8gb3ZlcmZsb3cgd2FzIGNhdXNlZCBieSBkcmFnIChzZWUgIzUwMDMpXG5cdFx0aWYgKCAhZHJhZ2dhYmxlLm9wdGlvbnMucmVmcmVzaFBvc2l0aW9ucyApIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKCBkcmFnZ2FibGUsIGV2ZW50ICk7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBERVBSRUNBVEVEXG4vLyBUT0RPOiBzd2l0Y2ggcmV0dXJuIGJhY2sgdG8gd2lkZ2V0IGRlY2xhcmF0aW9uIGF0IHRvcCBvZiBmaWxlIHdoZW4gdGhpcyBpcyByZW1vdmVkXG5pZiAoICQudWlCYWNrQ29tcGF0ICE9PSBmYWxzZSApIHtcblxuXHQvLyBCYWNrY29tcGF0IGZvciBhY3RpdmVDbGFzcyBhbmQgaG92ZXJDbGFzcyBvcHRpb25zXG5cdCQud2lkZ2V0KCBcInVpLmRyb3BwYWJsZVwiLCAkLnVpLmRyb3BwYWJsZSwge1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdGhvdmVyQ2xhc3M6IGZhbHNlLFxuXHRcdFx0YWN0aXZlQ2xhc3M6IGZhbHNlXG5cdFx0fSxcblx0XHRfYWRkQWN0aXZlQ2xhc3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoIHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0X3JlbW92ZUFjdGl2ZUNsYXNzOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyApIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCB0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdF9hZGRIb3ZlckNsYXNzOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoIHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfcmVtb3ZlSG92ZXJDbGFzczogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuaG92ZXJDbGFzcyApIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCB0aGlzLm9wdGlvbnMuaG92ZXJDbGFzcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG52YXIgd2lkZ2V0c0Ryb3BwYWJsZSA9ICQudWkuZHJvcHBhYmxlO1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIFByb2dyZXNzYmFyIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBQcm9ncmVzc2JhclxuLy8+Pmdyb3VwOiBXaWRnZXRzXG4vLyBqc2NzOmRpc2FibGUgbWF4aW11bUxpbmVMZW5ndGhcbi8vPj5kZXNjcmlwdGlvbjogRGlzcGxheXMgYSBzdGF0dXMgaW5kaWNhdG9yIGZvciBsb2FkaW5nIHN0YXRlLCBzdGFuZGFyZCBwZXJjZW50YWdlLCBhbmQgb3RoZXIgcHJvZ3Jlc3MgaW5kaWNhdG9ycy5cbi8vIGpzY3M6ZW5hYmxlIG1heGltdW1MaW5lTGVuZ3RoXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vcHJvZ3Jlc3NiYXIvXG4vLz4+ZGVtb3M6IGh0dHA6Ly9qcXVlcnl1aS5jb20vcHJvZ3Jlc3NiYXIvXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2UvY29yZS5jc3Ncbi8vPj5jc3Muc3RydWN0dXJlOiAuLi8uLi90aGVtZXMvYmFzZS9wcm9ncmVzc2Jhci5jc3Ncbi8vPj5jc3MudGhlbWU6IC4uLy4uL3RoZW1lcy9iYXNlL3RoZW1lLmNzc1xuXG5cblxudmFyIHdpZGdldHNQcm9ncmVzc2JhciA9ICQud2lkZ2V0KCBcInVpLnByb2dyZXNzYmFyXCIsIHtcblx0dmVyc2lvbjogXCIxLjEyLjFcIixcblx0b3B0aW9uczoge1xuXHRcdGNsYXNzZXM6IHtcblx0XHRcdFwidWktcHJvZ3Jlc3NiYXJcIjogXCJ1aS1jb3JuZXItYWxsXCIsXG5cdFx0XHRcInVpLXByb2dyZXNzYmFyLXZhbHVlXCI6IFwidWktY29ybmVyLWxlZnRcIixcblx0XHRcdFwidWktcHJvZ3Jlc3NiYXItY29tcGxldGVcIjogXCJ1aS1jb3JuZXItcmlnaHRcIlxuXHRcdH0sXG5cdFx0bWF4OiAxMDAsXG5cdFx0dmFsdWU6IDAsXG5cblx0XHRjaGFuZ2U6IG51bGwsXG5cdFx0Y29tcGxldGU6IG51bGxcblx0fSxcblxuXHRtaW46IDAsXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cblx0XHQvLyBDb25zdHJhaW4gaW5pdGlhbCB2YWx1ZVxuXHRcdHRoaXMub2xkVmFsdWUgPSB0aGlzLm9wdGlvbnMudmFsdWUgPSB0aGlzLl9jb25zdHJhaW5lZFZhbHVlKCk7XG5cblx0XHR0aGlzLmVsZW1lbnQuYXR0cigge1xuXG5cdFx0XHQvLyBPbmx5IHNldCBzdGF0aWMgdmFsdWVzOyBhcmlhLXZhbHVlbm93IGFuZCBhcmlhLXZhbHVlbWF4IGFyZVxuXHRcdFx0Ly8gc2V0IGluc2lkZSBfcmVmcmVzaFZhbHVlKClcblx0XHRcdHJvbGU6IFwicHJvZ3Jlc3NiYXJcIixcblx0XHRcdFwiYXJpYS12YWx1ZW1pblwiOiB0aGlzLm1pblxuXHRcdH0gKTtcblx0XHR0aGlzLl9hZGRDbGFzcyggXCJ1aS1wcm9ncmVzc2JhclwiLCBcInVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudFwiICk7XG5cblx0XHR0aGlzLnZhbHVlRGl2ID0gJCggXCI8ZGl2PlwiICkuYXBwZW5kVG8oIHRoaXMuZWxlbWVudCApO1xuXHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLnZhbHVlRGl2LCBcInVpLXByb2dyZXNzYmFyLXZhbHVlXCIsIFwidWktd2lkZ2V0LWhlYWRlclwiICk7XG5cdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyKCBcInJvbGUgYXJpYS12YWx1ZW1pbiBhcmlhLXZhbHVlbWF4IGFyaWEtdmFsdWVub3dcIiApO1xuXG5cdFx0dGhpcy52YWx1ZURpdi5yZW1vdmUoKTtcblx0fSxcblxuXHR2YWx1ZTogZnVuY3Rpb24oIG5ld1ZhbHVlICkge1xuXHRcdGlmICggbmV3VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMudmFsdWU7XG5cdFx0fVxuXG5cdFx0dGhpcy5vcHRpb25zLnZhbHVlID0gdGhpcy5fY29uc3RyYWluZWRWYWx1ZSggbmV3VmFsdWUgKTtcblx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0fSxcblxuXHRfY29uc3RyYWluZWRWYWx1ZTogZnVuY3Rpb24oIG5ld1ZhbHVlICkge1xuXHRcdGlmICggbmV3VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG5ld1ZhbHVlID0gdGhpcy5vcHRpb25zLnZhbHVlO1xuXHRcdH1cblxuXHRcdHRoaXMuaW5kZXRlcm1pbmF0ZSA9IG5ld1ZhbHVlID09PSBmYWxzZTtcblxuXHRcdC8vIFNhbml0aXplIHZhbHVlXG5cdFx0aWYgKCB0eXBlb2YgbmV3VmFsdWUgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRuZXdWYWx1ZSA9IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuaW5kZXRlcm1pbmF0ZSA/IGZhbHNlIDpcblx0XHRcdE1hdGgubWluKCB0aGlzLm9wdGlvbnMubWF4LCBNYXRoLm1heCggdGhpcy5taW4sIG5ld1ZhbHVlICkgKTtcblx0fSxcblxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBFbnN1cmUgXCJ2YWx1ZVwiIG9wdGlvbiBpcyBzZXQgYWZ0ZXIgb3RoZXIgdmFsdWVzIChsaWtlIG1heClcblx0XHR2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuXHRcdGRlbGV0ZSBvcHRpb25zLnZhbHVlO1xuXG5cdFx0dGhpcy5fc3VwZXIoIG9wdGlvbnMgKTtcblxuXHRcdHRoaXMub3B0aW9ucy52YWx1ZSA9IHRoaXMuX2NvbnN0cmFpbmVkVmFsdWUoIHZhbHVlICk7XG5cdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0aWYgKCBrZXkgPT09IFwibWF4XCIgKSB7XG5cblx0XHRcdC8vIERvbid0IGFsbG93IGEgbWF4IGxlc3MgdGhhbiBtaW5cblx0XHRcdHZhbHVlID0gTWF0aC5tYXgoIHRoaXMubWluLCB2YWx1ZSApO1xuXHRcdH1cblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXHR9LFxuXG5cdF9zZXRPcHRpb25EaXNhYmxlZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHRoaXMuX3N1cGVyKCB2YWx1ZSApO1xuXG5cdFx0dGhpcy5lbGVtZW50LmF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiLCB2YWx1ZSApO1xuXHRcdHRoaXMuX3RvZ2dsZUNsYXNzKCBudWxsLCBcInVpLXN0YXRlLWRpc2FibGVkXCIsICEhdmFsdWUgKTtcblx0fSxcblxuXHRfcGVyY2VudGFnZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5kZXRlcm1pbmF0ZSA/XG5cdFx0XHQxMDAgOlxuXHRcdFx0MTAwICogKCB0aGlzLm9wdGlvbnMudmFsdWUgLSB0aGlzLm1pbiApIC8gKCB0aGlzLm9wdGlvbnMubWF4IC0gdGhpcy5taW4gKTtcblx0fSxcblxuXHRfcmVmcmVzaFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLm9wdGlvbnMudmFsdWUsXG5cdFx0XHRwZXJjZW50YWdlID0gdGhpcy5fcGVyY2VudGFnZSgpO1xuXG5cdFx0dGhpcy52YWx1ZURpdlxuXHRcdFx0LnRvZ2dsZSggdGhpcy5pbmRldGVybWluYXRlIHx8IHZhbHVlID4gdGhpcy5taW4gKVxuXHRcdFx0LndpZHRoKCBwZXJjZW50YWdlLnRvRml4ZWQoIDAgKSArIFwiJVwiICk7XG5cblx0XHR0aGlzXG5cdFx0XHQuX3RvZ2dsZUNsYXNzKCB0aGlzLnZhbHVlRGl2LCBcInVpLXByb2dyZXNzYmFyLWNvbXBsZXRlXCIsIG51bGwsXG5cdFx0XHRcdHZhbHVlID09PSB0aGlzLm9wdGlvbnMubWF4IClcblx0XHRcdC5fdG9nZ2xlQ2xhc3MoIFwidWktcHJvZ3Jlc3NiYXItaW5kZXRlcm1pbmF0ZVwiLCBudWxsLCB0aGlzLmluZGV0ZXJtaW5hdGUgKTtcblxuXHRcdGlmICggdGhpcy5pbmRldGVybWluYXRlICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUF0dHIoIFwiYXJpYS12YWx1ZW5vd1wiICk7XG5cdFx0XHRpZiAoICF0aGlzLm92ZXJsYXlEaXYgKSB7XG5cdFx0XHRcdHRoaXMub3ZlcmxheURpdiA9ICQoIFwiPGRpdj5cIiApLmFwcGVuZFRvKCB0aGlzLnZhbHVlRGl2ICk7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLm92ZXJsYXlEaXYsIFwidWktcHJvZ3Jlc3NiYXItb3ZlcmxheVwiICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZWxlbWVudC5hdHRyKCB7XG5cdFx0XHRcdFwiYXJpYS12YWx1ZW1heFwiOiB0aGlzLm9wdGlvbnMubWF4LFxuXHRcdFx0XHRcImFyaWEtdmFsdWVub3dcIjogdmFsdWVcblx0XHRcdH0gKTtcblx0XHRcdGlmICggdGhpcy5vdmVybGF5RGl2ICkge1xuXHRcdFx0XHR0aGlzLm92ZXJsYXlEaXYucmVtb3ZlKCk7XG5cdFx0XHRcdHRoaXMub3ZlcmxheURpdiA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9sZFZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdHRoaXMub2xkVmFsdWUgPSB2YWx1ZTtcblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2hhbmdlXCIgKTtcblx0XHR9XG5cdFx0aWYgKCB2YWx1ZSA9PT0gdGhpcy5vcHRpb25zLm1heCApIHtcblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY29tcGxldGVcIiApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIFNlbGVjdGFibGUgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IFNlbGVjdGFibGVcbi8vPj5ncm91cDogSW50ZXJhY3Rpb25zXG4vLz4+ZGVzY3JpcHRpb246IEFsbG93cyBncm91cHMgb2YgZWxlbWVudHMgdG8gYmUgc2VsZWN0ZWQgd2l0aCB0aGUgbW91c2UuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vc2VsZWN0YWJsZS9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9zZWxlY3RhYmxlL1xuLy8+PmNzcy5zdHJ1Y3R1cmU6IC4uLy4uL3RoZW1lcy9iYXNlL3NlbGVjdGFibGUuY3NzXG5cblxuXG52YXIgd2lkZ2V0c1NlbGVjdGFibGUgPSAkLndpZGdldCggXCJ1aS5zZWxlY3RhYmxlXCIsICQudWkubW91c2UsIHtcblx0dmVyc2lvbjogXCIxLjEyLjFcIixcblx0b3B0aW9uczoge1xuXHRcdGFwcGVuZFRvOiBcImJvZHlcIixcblx0XHRhdXRvUmVmcmVzaDogdHJ1ZSxcblx0XHRkaXN0YW5jZTogMCxcblx0XHRmaWx0ZXI6IFwiKlwiLFxuXHRcdHRvbGVyYW5jZTogXCJ0b3VjaFwiLFxuXG5cdFx0Ly8gQ2FsbGJhY2tzXG5cdFx0c2VsZWN0ZWQ6IG51bGwsXG5cdFx0c2VsZWN0aW5nOiBudWxsLFxuXHRcdHN0YXJ0OiBudWxsLFxuXHRcdHN0b3A6IG51bGwsXG5cdFx0dW5zZWxlY3RlZDogbnVsbCxcblx0XHR1bnNlbGVjdGluZzogbnVsbFxuXHR9LFxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLl9hZGRDbGFzcyggXCJ1aS1zZWxlY3RhYmxlXCIgKTtcblxuXHRcdHRoaXMuZHJhZ2dlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ2FjaGUgc2VsZWN0ZWUgY2hpbGRyZW4gYmFzZWQgb24gZmlsdGVyXG5cdFx0dGhpcy5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGF0LmVsZW1lbnRQb3MgPSAkKCB0aGF0LmVsZW1lbnRbIDAgXSApLm9mZnNldCgpO1xuXHRcdFx0dGhhdC5zZWxlY3RlZXMgPSAkKCB0aGF0Lm9wdGlvbnMuZmlsdGVyLCB0aGF0LmVsZW1lbnRbIDAgXSApO1xuXHRcdFx0dGhhdC5fYWRkQ2xhc3MoIHRoYXQuc2VsZWN0ZWVzLCBcInVpLXNlbGVjdGVlXCIgKTtcblx0XHRcdHRoYXQuc2VsZWN0ZWVzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgJHRoaXMgPSAkKCB0aGlzICksXG5cdFx0XHRcdFx0c2VsZWN0ZWVPZmZzZXQgPSAkdGhpcy5vZmZzZXQoKSxcblx0XHRcdFx0XHRwb3MgPSB7XG5cdFx0XHRcdFx0XHRsZWZ0OiBzZWxlY3RlZU9mZnNldC5sZWZ0IC0gdGhhdC5lbGVtZW50UG9zLmxlZnQsXG5cdFx0XHRcdFx0XHR0b3A6IHNlbGVjdGVlT2Zmc2V0LnRvcCAtIHRoYXQuZWxlbWVudFBvcy50b3Bcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHQkLmRhdGEoIHRoaXMsIFwic2VsZWN0YWJsZS1pdGVtXCIsIHtcblx0XHRcdFx0XHRlbGVtZW50OiB0aGlzLFxuXHRcdFx0XHRcdCRlbGVtZW50OiAkdGhpcyxcblx0XHRcdFx0XHRsZWZ0OiBwb3MubGVmdCxcblx0XHRcdFx0XHR0b3A6IHBvcy50b3AsXG5cdFx0XHRcdFx0cmlnaHQ6IHBvcy5sZWZ0ICsgJHRoaXMub3V0ZXJXaWR0aCgpLFxuXHRcdFx0XHRcdGJvdHRvbTogcG9zLnRvcCArICR0aGlzLm91dGVySGVpZ2h0KCksXG5cdFx0XHRcdFx0c3RhcnRzZWxlY3RlZDogZmFsc2UsXG5cdFx0XHRcdFx0c2VsZWN0ZWQ6ICR0aGlzLmhhc0NsYXNzKCBcInVpLXNlbGVjdGVkXCIgKSxcblx0XHRcdFx0XHRzZWxlY3Rpbmc6ICR0aGlzLmhhc0NsYXNzKCBcInVpLXNlbGVjdGluZ1wiICksXG5cdFx0XHRcdFx0dW5zZWxlY3Rpbmc6ICR0aGlzLmhhc0NsYXNzKCBcInVpLXVuc2VsZWN0aW5nXCIgKVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0XHR0aGlzLnJlZnJlc2goKTtcblxuXHRcdHRoaXMuX21vdXNlSW5pdCgpO1xuXG5cdFx0dGhpcy5oZWxwZXIgPSAkKCBcIjxkaXY+XCIgKTtcblx0XHR0aGlzLl9hZGRDbGFzcyggdGhpcy5oZWxwZXIsIFwidWktc2VsZWN0YWJsZS1oZWxwZXJcIiApO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnNlbGVjdGVlcy5yZW1vdmVEYXRhKCBcInNlbGVjdGFibGUtaXRlbVwiICk7XG5cdFx0dGhpcy5fbW91c2VEZXN0cm95KCk7XG5cdH0sXG5cblx0X21vdXNlU3RhcnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5vcG9zID0gWyBldmVudC5wYWdlWCwgZXZlbnQucGFnZVkgXTtcblx0XHR0aGlzLmVsZW1lbnRQb3MgPSAkKCB0aGlzLmVsZW1lbnRbIDAgXSApLm9mZnNldCgpO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5zZWxlY3RlZXMgPSAkKCBvcHRpb25zLmZpbHRlciwgdGhpcy5lbGVtZW50WyAwIF0gKTtcblxuXHRcdHRoaXMuX3RyaWdnZXIoIFwic3RhcnRcIiwgZXZlbnQgKTtcblxuXHRcdCQoIG9wdGlvbnMuYXBwZW5kVG8gKS5hcHBlbmQoIHRoaXMuaGVscGVyICk7XG5cblx0XHQvLyBwb3NpdGlvbiBoZWxwZXIgKGxhc3NvKVxuXHRcdHRoaXMuaGVscGVyLmNzcygge1xuXHRcdFx0XCJsZWZ0XCI6IGV2ZW50LnBhZ2VYLFxuXHRcdFx0XCJ0b3BcIjogZXZlbnQucGFnZVksXG5cdFx0XHRcIndpZHRoXCI6IDAsXG5cdFx0XHRcImhlaWdodFwiOiAwXG5cdFx0fSApO1xuXG5cdFx0aWYgKCBvcHRpb25zLmF1dG9SZWZyZXNoICkge1xuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zZWxlY3RlZXMuZmlsdGVyKCBcIi51aS1zZWxlY3RlZFwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZWN0ZWUgPSAkLmRhdGEoIHRoaXMsIFwic2VsZWN0YWJsZS1pdGVtXCIgKTtcblx0XHRcdHNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCAhZXZlbnQubWV0YUtleSAmJiAhZXZlbnQuY3RybEtleSApIHtcblx0XHRcdFx0dGhhdC5fcmVtb3ZlQ2xhc3MoIHNlbGVjdGVlLiRlbGVtZW50LCBcInVpLXNlbGVjdGVkXCIgKTtcblx0XHRcdFx0c2VsZWN0ZWUuc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dGhhdC5fYWRkQ2xhc3MoIHNlbGVjdGVlLiRlbGVtZW50LCBcInVpLXVuc2VsZWN0aW5nXCIgKTtcblx0XHRcdFx0c2VsZWN0ZWUudW5zZWxlY3RpbmcgPSB0cnVlO1xuXG5cdFx0XHRcdC8vIHNlbGVjdGFibGUgVU5TRUxFQ1RJTkcgY2FsbGJhY2tcblx0XHRcdFx0dGhhdC5fdHJpZ2dlciggXCJ1bnNlbGVjdGluZ1wiLCBldmVudCwge1xuXHRcdFx0XHRcdHVuc2VsZWN0aW5nOiBzZWxlY3RlZS5lbGVtZW50XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHQkKCBldmVudC50YXJnZXQgKS5wYXJlbnRzKCkuYWRkQmFjaygpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRvU2VsZWN0LFxuXHRcdFx0XHRzZWxlY3RlZSA9ICQuZGF0YSggdGhpcywgXCJzZWxlY3RhYmxlLWl0ZW1cIiApO1xuXHRcdFx0aWYgKCBzZWxlY3RlZSApIHtcblx0XHRcdFx0ZG9TZWxlY3QgPSAoICFldmVudC5tZXRhS2V5ICYmICFldmVudC5jdHJsS2V5ICkgfHxcblx0XHRcdFx0XHQhc2VsZWN0ZWUuJGVsZW1lbnQuaGFzQ2xhc3MoIFwidWktc2VsZWN0ZWRcIiApO1xuXHRcdFx0XHR0aGF0Ll9yZW1vdmVDbGFzcyggc2VsZWN0ZWUuJGVsZW1lbnQsIGRvU2VsZWN0ID8gXCJ1aS11bnNlbGVjdGluZ1wiIDogXCJ1aS1zZWxlY3RlZFwiIClcblx0XHRcdFx0XHQuX2FkZENsYXNzKCBzZWxlY3RlZS4kZWxlbWVudCwgZG9TZWxlY3QgPyBcInVpLXNlbGVjdGluZ1wiIDogXCJ1aS11bnNlbGVjdGluZ1wiICk7XG5cdFx0XHRcdHNlbGVjdGVlLnVuc2VsZWN0aW5nID0gIWRvU2VsZWN0O1xuXHRcdFx0XHRzZWxlY3RlZS5zZWxlY3RpbmcgPSBkb1NlbGVjdDtcblx0XHRcdFx0c2VsZWN0ZWUuc2VsZWN0ZWQgPSBkb1NlbGVjdDtcblxuXHRcdFx0XHQvLyBzZWxlY3RhYmxlIChVTilTRUxFQ1RJTkcgY2FsbGJhY2tcblx0XHRcdFx0aWYgKCBkb1NlbGVjdCApIHtcblx0XHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcInNlbGVjdGluZ1wiLCBldmVudCwge1xuXHRcdFx0XHRcdFx0c2VsZWN0aW5nOiBzZWxlY3RlZS5lbGVtZW50XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoYXQuX3RyaWdnZXIoIFwidW5zZWxlY3RpbmdcIiwgZXZlbnQsIHtcblx0XHRcdFx0XHRcdHVuc2VsZWN0aW5nOiBzZWxlY3RlZS5lbGVtZW50XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSxcblxuXHRfbW91c2VEcmFnOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHR0aGlzLmRyYWdnZWQgPSB0cnVlO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRtcCxcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdHgxID0gdGhpcy5vcG9zWyAwIF0sXG5cdFx0XHR5MSA9IHRoaXMub3Bvc1sgMSBdLFxuXHRcdFx0eDIgPSBldmVudC5wYWdlWCxcblx0XHRcdHkyID0gZXZlbnQucGFnZVk7XG5cblx0XHRpZiAoIHgxID4geDIgKSB7IHRtcCA9IHgyOyB4MiA9IHgxOyB4MSA9IHRtcDsgfVxuXHRcdGlmICggeTEgPiB5MiApIHsgdG1wID0geTI7IHkyID0geTE7IHkxID0gdG1wOyB9XG5cdFx0dGhpcy5oZWxwZXIuY3NzKCB7IGxlZnQ6IHgxLCB0b3A6IHkxLCB3aWR0aDogeDIgLSB4MSwgaGVpZ2h0OiB5MiAtIHkxIH0gKTtcblxuXHRcdHRoaXMuc2VsZWN0ZWVzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGVjdGVlID0gJC5kYXRhKCB0aGlzLCBcInNlbGVjdGFibGUtaXRlbVwiICksXG5cdFx0XHRcdGhpdCA9IGZhbHNlLFxuXHRcdFx0XHRvZmZzZXQgPSB7fTtcblxuXHRcdFx0Ly9wcmV2ZW50IGhlbHBlciBmcm9tIGJlaW5nIHNlbGVjdGVkIGlmIGFwcGVuZFRvOiBzZWxlY3RhYmxlXG5cdFx0XHRpZiAoICFzZWxlY3RlZSB8fCBzZWxlY3RlZS5lbGVtZW50ID09PSB0aGF0LmVsZW1lbnRbIDAgXSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRvZmZzZXQubGVmdCAgID0gc2VsZWN0ZWUubGVmdCAgICsgdGhhdC5lbGVtZW50UG9zLmxlZnQ7XG5cdFx0XHRvZmZzZXQucmlnaHQgID0gc2VsZWN0ZWUucmlnaHQgICsgdGhhdC5lbGVtZW50UG9zLmxlZnQ7XG5cdFx0XHRvZmZzZXQudG9wICAgID0gc2VsZWN0ZWUudG9wICAgICsgdGhhdC5lbGVtZW50UG9zLnRvcDtcblx0XHRcdG9mZnNldC5ib3R0b20gPSBzZWxlY3RlZS5ib3R0b20gKyB0aGF0LmVsZW1lbnRQb3MudG9wO1xuXG5cdFx0XHRpZiAoIG9wdGlvbnMudG9sZXJhbmNlID09PSBcInRvdWNoXCIgKSB7XG5cdFx0XHRcdGhpdCA9ICggISggb2Zmc2V0LmxlZnQgPiB4MiB8fCBvZmZzZXQucmlnaHQgPCB4MSB8fCBvZmZzZXQudG9wID4geTIgfHxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LmJvdHRvbSA8IHkxICkgKTtcblx0XHRcdH0gZWxzZSBpZiAoIG9wdGlvbnMudG9sZXJhbmNlID09PSBcImZpdFwiICkge1xuXHRcdFx0XHRoaXQgPSAoIG9mZnNldC5sZWZ0ID4geDEgJiYgb2Zmc2V0LnJpZ2h0IDwgeDIgJiYgb2Zmc2V0LnRvcCA+IHkxICYmXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldC5ib3R0b20gPCB5MiApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhpdCApIHtcblxuXHRcdFx0XHQvLyBTRUxFQ1Rcblx0XHRcdFx0aWYgKCBzZWxlY3RlZS5zZWxlY3RlZCApIHtcblx0XHRcdFx0XHR0aGF0Ll9yZW1vdmVDbGFzcyggc2VsZWN0ZWUuJGVsZW1lbnQsIFwidWktc2VsZWN0ZWRcIiApO1xuXHRcdFx0XHRcdHNlbGVjdGVlLnNlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBzZWxlY3RlZS51bnNlbGVjdGluZyApIHtcblx0XHRcdFx0XHR0aGF0Ll9yZW1vdmVDbGFzcyggc2VsZWN0ZWUuJGVsZW1lbnQsIFwidWktdW5zZWxlY3RpbmdcIiApO1xuXHRcdFx0XHRcdHNlbGVjdGVlLnVuc2VsZWN0aW5nID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhc2VsZWN0ZWUuc2VsZWN0aW5nICkge1xuXHRcdFx0XHRcdHRoYXQuX2FkZENsYXNzKCBzZWxlY3RlZS4kZWxlbWVudCwgXCJ1aS1zZWxlY3RpbmdcIiApO1xuXHRcdFx0XHRcdHNlbGVjdGVlLnNlbGVjdGluZyA9IHRydWU7XG5cblx0XHRcdFx0XHQvLyBzZWxlY3RhYmxlIFNFTEVDVElORyBjYWxsYmFja1xuXHRcdFx0XHRcdHRoYXQuX3RyaWdnZXIoIFwic2VsZWN0aW5nXCIsIGV2ZW50LCB7XG5cdFx0XHRcdFx0XHRzZWxlY3Rpbmc6IHNlbGVjdGVlLmVsZW1lbnRcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gVU5TRUxFQ1Rcblx0XHRcdFx0aWYgKCBzZWxlY3RlZS5zZWxlY3RpbmcgKSB7XG5cdFx0XHRcdFx0aWYgKCAoIGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSApICYmIHNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQgKSB7XG5cdFx0XHRcdFx0XHR0aGF0Ll9yZW1vdmVDbGFzcyggc2VsZWN0ZWUuJGVsZW1lbnQsIFwidWktc2VsZWN0aW5nXCIgKTtcblx0XHRcdFx0XHRcdHNlbGVjdGVlLnNlbGVjdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhhdC5fYWRkQ2xhc3MoIHNlbGVjdGVlLiRlbGVtZW50LCBcInVpLXNlbGVjdGVkXCIgKTtcblx0XHRcdFx0XHRcdHNlbGVjdGVlLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhhdC5fcmVtb3ZlQ2xhc3MoIHNlbGVjdGVlLiRlbGVtZW50LCBcInVpLXNlbGVjdGluZ1wiICk7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZS5zZWxlY3RpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGlmICggc2VsZWN0ZWUuc3RhcnRzZWxlY3RlZCApIHtcblx0XHRcdFx0XHRcdFx0dGhhdC5fYWRkQ2xhc3MoIHNlbGVjdGVlLiRlbGVtZW50LCBcInVpLXVuc2VsZWN0aW5nXCIgKTtcblx0XHRcdFx0XHRcdFx0c2VsZWN0ZWUudW5zZWxlY3RpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBzZWxlY3RhYmxlIFVOU0VMRUNUSU5HIGNhbGxiYWNrXG5cdFx0XHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcInVuc2VsZWN0aW5nXCIsIGV2ZW50LCB7XG5cdFx0XHRcdFx0XHRcdHVuc2VsZWN0aW5nOiBzZWxlY3RlZS5lbGVtZW50XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggc2VsZWN0ZWUuc2VsZWN0ZWQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhZXZlbnQubWV0YUtleSAmJiAhZXZlbnQuY3RybEtleSAmJiAhc2VsZWN0ZWUuc3RhcnRzZWxlY3RlZCApIHtcblx0XHRcdFx0XHRcdHRoYXQuX3JlbW92ZUNsYXNzKCBzZWxlY3RlZS4kZWxlbWVudCwgXCJ1aS1zZWxlY3RlZFwiICk7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZS5zZWxlY3RlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHR0aGF0Ll9hZGRDbGFzcyggc2VsZWN0ZWUuJGVsZW1lbnQsIFwidWktdW5zZWxlY3RpbmdcIiApO1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWUudW5zZWxlY3RpbmcgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHQvLyBzZWxlY3RhYmxlIFVOU0VMRUNUSU5HIGNhbGxiYWNrXG5cdFx0XHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcInVuc2VsZWN0aW5nXCIsIGV2ZW50LCB7XG5cdFx0XHRcdFx0XHRcdHVuc2VsZWN0aW5nOiBzZWxlY3RlZS5lbGVtZW50XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9tb3VzZVN0b3A6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLmRyYWdnZWQgPSBmYWxzZTtcblxuXHRcdCQoIFwiLnVpLXVuc2VsZWN0aW5nXCIsIHRoaXMuZWxlbWVudFsgMCBdICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZWN0ZWUgPSAkLmRhdGEoIHRoaXMsIFwic2VsZWN0YWJsZS1pdGVtXCIgKTtcblx0XHRcdHRoYXQuX3JlbW92ZUNsYXNzKCBzZWxlY3RlZS4kZWxlbWVudCwgXCJ1aS11bnNlbGVjdGluZ1wiICk7XG5cdFx0XHRzZWxlY3RlZS51bnNlbGVjdGluZyA9IGZhbHNlO1xuXHRcdFx0c2VsZWN0ZWUuc3RhcnRzZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0dGhhdC5fdHJpZ2dlciggXCJ1bnNlbGVjdGVkXCIsIGV2ZW50LCB7XG5cdFx0XHRcdHVuc2VsZWN0ZWQ6IHNlbGVjdGVlLmVsZW1lbnRcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdFx0JCggXCIudWktc2VsZWN0aW5nXCIsIHRoaXMuZWxlbWVudFsgMCBdICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZWN0ZWUgPSAkLmRhdGEoIHRoaXMsIFwic2VsZWN0YWJsZS1pdGVtXCIgKTtcblx0XHRcdHRoYXQuX3JlbW92ZUNsYXNzKCBzZWxlY3RlZS4kZWxlbWVudCwgXCJ1aS1zZWxlY3RpbmdcIiApXG5cdFx0XHRcdC5fYWRkQ2xhc3MoIHNlbGVjdGVlLiRlbGVtZW50LCBcInVpLXNlbGVjdGVkXCIgKTtcblx0XHRcdHNlbGVjdGVlLnNlbGVjdGluZyA9IGZhbHNlO1xuXHRcdFx0c2VsZWN0ZWUuc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0c2VsZWN0ZWUuc3RhcnRzZWxlY3RlZCA9IHRydWU7XG5cdFx0XHR0aGF0Ll90cmlnZ2VyKCBcInNlbGVjdGVkXCIsIGV2ZW50LCB7XG5cdFx0XHRcdHNlbGVjdGVkOiBzZWxlY3RlZS5lbGVtZW50XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHRcdHRoaXMuX3RyaWdnZXIoIFwic3RvcFwiLCBldmVudCApO1xuXG5cdFx0dGhpcy5oZWxwZXIucmVtb3ZlKCk7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxufSApO1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIFNlbGVjdG1lbnUgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IFNlbGVjdG1lbnVcbi8vPj5ncm91cDogV2lkZ2V0c1xuLy8ganNjczpkaXNhYmxlIG1heGltdW1MaW5lTGVuZ3RoXG4vLz4+ZGVzY3JpcHRpb246IER1cGxpY2F0ZXMgYW5kIGV4dGVuZHMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYSBuYXRpdmUgSFRNTCBzZWxlY3QgZWxlbWVudCwgYWxsb3dpbmcgaXQgdG8gYmUgY3VzdG9taXphYmxlIGluIGJlaGF2aW9yIGFuZCBhcHBlYXJhbmNlIGZhciBiZXlvbmQgdGhlIGxpbWl0YXRpb25zIG9mIGEgbmF0aXZlIHNlbGVjdC5cbi8vIGpzY3M6ZW5hYmxlIG1heGltdW1MaW5lTGVuZ3RoXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vc2VsZWN0bWVudS9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9zZWxlY3RtZW51L1xuLy8+PmNzcy5zdHJ1Y3R1cmU6IC4uLy4uL3RoZW1lcy9iYXNlL2NvcmUuY3NzXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2Uvc2VsZWN0bWVudS5jc3MsIC4uLy4uL3RoZW1lcy9iYXNlL2J1dHRvbi5jc3Ncbi8vPj5jc3MudGhlbWU6IC4uLy4uL3RoZW1lcy9iYXNlL3RoZW1lLmNzc1xuXG5cblxudmFyIHdpZGdldHNTZWxlY3RtZW51ID0gJC53aWRnZXQoIFwidWkuc2VsZWN0bWVudVwiLCBbICQudWkuZm9ybVJlc2V0TWl4aW4sIHtcblx0dmVyc2lvbjogXCIxLjEyLjFcIixcblx0ZGVmYXVsdEVsZW1lbnQ6IFwiPHNlbGVjdD5cIixcblx0b3B0aW9uczoge1xuXHRcdGFwcGVuZFRvOiBudWxsLFxuXHRcdGNsYXNzZXM6IHtcblx0XHRcdFwidWktc2VsZWN0bWVudS1idXR0b24tb3BlblwiOiBcInVpLWNvcm5lci10b3BcIixcblx0XHRcdFwidWktc2VsZWN0bWVudS1idXR0b24tY2xvc2VkXCI6IFwidWktY29ybmVyLWFsbFwiXG5cdFx0fSxcblx0XHRkaXNhYmxlZDogbnVsbCxcblx0XHRpY29uczoge1xuXHRcdFx0YnV0dG9uOiBcInVpLWljb24tdHJpYW5nbGUtMS1zXCJcblx0XHR9LFxuXHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRteTogXCJsZWZ0IHRvcFwiLFxuXHRcdFx0YXQ6IFwibGVmdCBib3R0b21cIixcblx0XHRcdGNvbGxpc2lvbjogXCJub25lXCJcblx0XHR9LFxuXHRcdHdpZHRoOiBmYWxzZSxcblxuXHRcdC8vIENhbGxiYWNrc1xuXHRcdGNoYW5nZTogbnVsbCxcblx0XHRjbG9zZTogbnVsbCxcblx0XHRmb2N1czogbnVsbCxcblx0XHRvcGVuOiBudWxsLFxuXHRcdHNlbGVjdDogbnVsbFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxlY3RtZW51SWQgPSB0aGlzLmVsZW1lbnQudW5pcXVlSWQoKS5hdHRyKCBcImlkXCIgKTtcblx0XHR0aGlzLmlkcyA9IHtcblx0XHRcdGVsZW1lbnQ6IHNlbGVjdG1lbnVJZCxcblx0XHRcdGJ1dHRvbjogc2VsZWN0bWVudUlkICsgXCItYnV0dG9uXCIsXG5cdFx0XHRtZW51OiBzZWxlY3RtZW51SWQgKyBcIi1tZW51XCJcblx0XHR9O1xuXG5cdFx0dGhpcy5fZHJhd0J1dHRvbigpO1xuXHRcdHRoaXMuX2RyYXdNZW51KCk7XG5cdFx0dGhpcy5fYmluZEZvcm1SZXNldEhhbmRsZXIoKTtcblxuXHRcdHRoaXMuX3JlbmRlcmVkID0gZmFsc2U7XG5cdFx0dGhpcy5tZW51SXRlbXMgPSAkKCk7XG5cdH0sXG5cblx0X2RyYXdCdXR0b246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpY29uLFxuXHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRpdGVtID0gdGhpcy5fcGFyc2VPcHRpb24oXG5cdFx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCBcIm9wdGlvbjpzZWxlY3RlZFwiICksXG5cdFx0XHRcdHRoaXMuZWxlbWVudFsgMCBdLnNlbGVjdGVkSW5kZXhcblx0XHRcdCk7XG5cblx0XHQvLyBBc3NvY2lhdGUgZXhpc3RpbmcgbGFiZWwgd2l0aCB0aGUgbmV3IGJ1dHRvblxuXHRcdHRoaXMubGFiZWxzID0gdGhpcy5lbGVtZW50LmxhYmVscygpLmF0dHIoIFwiZm9yXCIsIHRoaXMuaWRzLmJ1dHRvbiApO1xuXHRcdHRoaXMuX29uKCB0aGlzLmxhYmVscywge1xuXHRcdFx0Y2xpY2s6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dGhpcy5idXR0b24uZm9jdXMoKTtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHQvLyBIaWRlIG9yaWdpbmFsIHNlbGVjdCBlbGVtZW50XG5cdFx0dGhpcy5lbGVtZW50LmhpZGUoKTtcblxuXHRcdC8vIENyZWF0ZSBidXR0b25cblx0XHR0aGlzLmJ1dHRvbiA9ICQoIFwiPHNwYW4+XCIsIHtcblx0XHRcdHRhYmluZGV4OiB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPyAtMSA6IDAsXG5cdFx0XHRpZDogdGhpcy5pZHMuYnV0dG9uLFxuXHRcdFx0cm9sZTogXCJjb21ib2JveFwiLFxuXHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwiZmFsc2VcIixcblx0XHRcdFwiYXJpYS1hdXRvY29tcGxldGVcIjogXCJsaXN0XCIsXG5cdFx0XHRcImFyaWEtb3duc1wiOiB0aGlzLmlkcy5tZW51LFxuXHRcdFx0XCJhcmlhLWhhc3BvcHVwXCI6IFwidHJ1ZVwiLFxuXHRcdFx0dGl0bGU6IHRoaXMuZWxlbWVudC5hdHRyKCBcInRpdGxlXCIgKVxuXHRcdH0gKVxuXHRcdFx0Lmluc2VydEFmdGVyKCB0aGlzLmVsZW1lbnQgKTtcblxuXHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLmJ1dHRvbiwgXCJ1aS1zZWxlY3RtZW51LWJ1dHRvbiB1aS1zZWxlY3RtZW51LWJ1dHRvbi1jbG9zZWRcIixcblx0XHRcdFwidWktYnV0dG9uIHVpLXdpZGdldFwiICk7XG5cblx0XHRpY29uID0gJCggXCI8c3Bhbj5cIiApLmFwcGVuZFRvKCB0aGlzLmJ1dHRvbiApO1xuXHRcdHRoaXMuX2FkZENsYXNzKCBpY29uLCBcInVpLXNlbGVjdG1lbnUtaWNvblwiLCBcInVpLWljb24gXCIgKyB0aGlzLm9wdGlvbnMuaWNvbnMuYnV0dG9uICk7XG5cdFx0dGhpcy5idXR0b25JdGVtID0gdGhpcy5fcmVuZGVyQnV0dG9uSXRlbSggaXRlbSApXG5cdFx0XHQuYXBwZW5kVG8oIHRoaXMuYnV0dG9uICk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy53aWR0aCAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLl9yZXNpemVCdXR0b24oKTtcblx0XHR9XG5cblx0XHR0aGlzLl9vbiggdGhpcy5idXR0b24sIHRoaXMuX2J1dHRvbkV2ZW50cyApO1xuXHRcdHRoaXMuYnV0dG9uLm9uZSggXCJmb2N1c2luXCIsIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEZWxheSByZW5kZXJpbmcgdGhlIG1lbnUgaXRlbXMgdW50aWwgdGhlIGJ1dHRvbiByZWNlaXZlcyBmb2N1cy5cblx0XHRcdC8vIFRoZSBtZW51IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW5kZXJlZCB2aWEgYSBwcm9ncmFtbWF0aWMgb3Blbi5cblx0XHRcdGlmICggIXRoYXQuX3JlbmRlcmVkICkge1xuXHRcdFx0XHR0aGF0Ll9yZWZyZXNoTWVudSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRfZHJhd01lbnU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdC8vIENyZWF0ZSBtZW51XG5cdFx0dGhpcy5tZW51ID0gJCggXCI8dWw+XCIsIHtcblx0XHRcdFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsXG5cdFx0XHRcImFyaWEtbGFiZWxsZWRieVwiOiB0aGlzLmlkcy5idXR0b24sXG5cdFx0XHRpZDogdGhpcy5pZHMubWVudVxuXHRcdH0gKTtcblxuXHRcdC8vIFdyYXAgbWVudVxuXHRcdHRoaXMubWVudVdyYXAgPSAkKCBcIjxkaXY+XCIgKS5hcHBlbmQoIHRoaXMubWVudSApO1xuXHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLm1lbnVXcmFwLCBcInVpLXNlbGVjdG1lbnUtbWVudVwiLCBcInVpLWZyb250XCIgKTtcblx0XHR0aGlzLm1lbnVXcmFwLmFwcGVuZFRvKCB0aGlzLl9hcHBlbmRUbygpICk7XG5cblx0XHQvLyBJbml0aWFsaXplIG1lbnUgd2lkZ2V0XG5cdFx0dGhpcy5tZW51SW5zdGFuY2UgPSB0aGlzLm1lbnVcblx0XHRcdC5tZW51KCB7XG5cdFx0XHRcdGNsYXNzZXM6IHtcblx0XHRcdFx0XHRcInVpLW1lbnVcIjogXCJ1aS1jb3JuZXItYm90dG9tXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0cm9sZTogXCJsaXN0Ym94XCIsXG5cdFx0XHRcdHNlbGVjdDogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGl0ZW0gd2FzIHNlbGVjdGVkIHZpYSBhIGNsaWNrLCB0aGUgdGV4dCBzZWxlY3Rpb25cblx0XHRcdFx0XHQvLyB3aWxsIGJlIGRlc3Ryb3llZCBpbiBJRVxuXHRcdFx0XHRcdHRoYXQuX3NldFNlbGVjdGlvbigpO1xuXG5cdFx0XHRcdFx0dGhhdC5fc2VsZWN0KCB1aS5pdGVtLmRhdGEoIFwidWktc2VsZWN0bWVudS1pdGVtXCIgKSwgZXZlbnQgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Zm9jdXM6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSB1aS5pdGVtLmRhdGEoIFwidWktc2VsZWN0bWVudS1pdGVtXCIgKTtcblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgaW5pdGFsIGZvY3VzIGZyb20gZmlyaW5nIGFuZCBjaGVjayBpZiBpdHMgYSBuZXdseSBmb2N1c2VkIGl0ZW1cblx0XHRcdFx0XHRpZiAoIHRoYXQuZm9jdXNJbmRleCAhPSBudWxsICYmIGl0ZW0uaW5kZXggIT09IHRoYXQuZm9jdXNJbmRleCApIHtcblx0XHRcdFx0XHRcdHRoYXQuX3RyaWdnZXIoIFwiZm9jdXNcIiwgZXZlbnQsIHsgaXRlbTogaXRlbSB9ICk7XG5cdFx0XHRcdFx0XHRpZiAoICF0aGF0LmlzT3BlbiApIHtcblx0XHRcdFx0XHRcdFx0dGhhdC5fc2VsZWN0KCBpdGVtLCBldmVudCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGF0LmZvY3VzSW5kZXggPSBpdGVtLmluZGV4O1xuXG5cdFx0XHRcdFx0dGhhdC5idXR0b24uYXR0ciggXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIixcblx0XHRcdFx0XHRcdHRoYXQubWVudUl0ZW1zLmVxKCBpdGVtLmluZGV4ICkuYXR0ciggXCJpZFwiICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApXG5cdFx0XHQubWVudSggXCJpbnN0YW5jZVwiICk7XG5cblx0XHQvLyBEb24ndCBjbG9zZSB0aGUgbWVudSBvbiBtb3VzZWxlYXZlXG5cdFx0dGhpcy5tZW51SW5zdGFuY2UuX29mZiggdGhpcy5tZW51LCBcIm1vdXNlbGVhdmVcIiApO1xuXG5cdFx0Ly8gQ2FuY2VsIHRoZSBtZW51J3MgY29sbGFwc2VBbGwgb24gZG9jdW1lbnQgY2xpY2tcblx0XHR0aGlzLm1lbnVJbnN0YW5jZS5fY2xvc2VPbkRvY3VtZW50Q2xpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0Ly8gU2VsZWN0cyBvZnRlbiBjb250YWluIGVtcHR5IGl0ZW1zLCBidXQgbmV2ZXIgY29udGFpbiBkaXZpZGVyc1xuXHRcdHRoaXMubWVudUluc3RhbmNlLl9pc0RpdmlkZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3JlZnJlc2hNZW51KCk7XG5cdFx0dGhpcy5idXR0b25JdGVtLnJlcGxhY2VXaXRoKFxuXHRcdFx0dGhpcy5idXR0b25JdGVtID0gdGhpcy5fcmVuZGVyQnV0dG9uSXRlbShcblxuXHRcdFx0XHQvLyBGYWxsIGJhY2sgdG8gYW4gZW1wdHkgb2JqZWN0IGluIGNhc2UgdGhlcmUgYXJlIG5vIG9wdGlvbnNcblx0XHRcdFx0dGhpcy5fZ2V0U2VsZWN0ZWRJdGVtKCkuZGF0YSggXCJ1aS1zZWxlY3RtZW51LWl0ZW1cIiApIHx8IHt9XG5cdFx0XHQpXG5cdFx0KTtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy53aWR0aCA9PT0gbnVsbCApIHtcblx0XHRcdHRoaXMuX3Jlc2l6ZUJ1dHRvbigpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVmcmVzaE1lbnU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpdGVtLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMuZWxlbWVudC5maW5kKCBcIm9wdGlvblwiICk7XG5cblx0XHR0aGlzLm1lbnUuZW1wdHkoKTtcblxuXHRcdHRoaXMuX3BhcnNlT3B0aW9ucyggb3B0aW9ucyApO1xuXHRcdHRoaXMuX3JlbmRlck1lbnUoIHRoaXMubWVudSwgdGhpcy5pdGVtcyApO1xuXG5cdFx0dGhpcy5tZW51SW5zdGFuY2UucmVmcmVzaCgpO1xuXHRcdHRoaXMubWVudUl0ZW1zID0gdGhpcy5tZW51LmZpbmQoIFwibGlcIiApXG5cdFx0XHQubm90KCBcIi51aS1zZWxlY3RtZW51LW9wdGdyb3VwXCIgKVxuXHRcdFx0XHQuZmluZCggXCIudWktbWVudS1pdGVtLXdyYXBwZXJcIiApO1xuXG5cdFx0dGhpcy5fcmVuZGVyZWQgPSB0cnVlO1xuXG5cdFx0aWYgKCAhb3B0aW9ucy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXRlbSA9IHRoaXMuX2dldFNlbGVjdGVkSXRlbSgpO1xuXG5cdFx0Ly8gVXBkYXRlIHRoZSBtZW51IHRvIGhhdmUgdGhlIGNvcnJlY3QgaXRlbSBmb2N1c2VkXG5cdFx0dGhpcy5tZW51SW5zdGFuY2UuZm9jdXMoIG51bGwsIGl0ZW0gKTtcblx0XHR0aGlzLl9zZXRBcmlhKCBpdGVtLmRhdGEoIFwidWktc2VsZWN0bWVudS1pdGVtXCIgKSApO1xuXG5cdFx0Ly8gU2V0IGRpc2FibGVkIHN0YXRlXG5cdFx0dGhpcy5fc2V0T3B0aW9uKCBcImRpc2FibGVkXCIsIHRoaXMuZWxlbWVudC5wcm9wKCBcImRpc2FibGVkXCIgKSApO1xuXHR9LFxuXG5cdG9wZW46IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHRoZSBtZW51IGlzIGJlaW5nIG9wZW5lZCwgcmVuZGVyIHRoZSBpdGVtc1xuXHRcdGlmICggIXRoaXMuX3JlbmRlcmVkICkge1xuXHRcdFx0dGhpcy5fcmVmcmVzaE1lbnUoKTtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBNZW51IGNsZWFycyBmb2N1cyBvbiBjbG9zZSwgcmVzZXQgZm9jdXMgdG8gc2VsZWN0ZWQgaXRlbVxuXHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIHRoaXMubWVudS5maW5kKCBcIi51aS1zdGF0ZS1hY3RpdmVcIiApLCBudWxsLCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHR0aGlzLm1lbnVJbnN0YW5jZS5mb2N1cyggbnVsbCwgdGhpcy5fZ2V0U2VsZWN0ZWRJdGVtKCkgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgbm8gb3B0aW9ucywgZG9uJ3Qgb3BlbiB0aGUgbWVudVxuXHRcdGlmICggIXRoaXMubWVudUl0ZW1zLmxlbmd0aCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLmlzT3BlbiA9IHRydWU7XG5cdFx0dGhpcy5fdG9nZ2xlQXR0cigpO1xuXHRcdHRoaXMuX3Jlc2l6ZU1lbnUoKTtcblx0XHR0aGlzLl9wb3NpdGlvbigpO1xuXG5cdFx0dGhpcy5fb24oIHRoaXMuZG9jdW1lbnQsIHRoaXMuX2RvY3VtZW50Q2xpY2sgKTtcblxuXHRcdHRoaXMuX3RyaWdnZXIoIFwib3BlblwiLCBldmVudCApO1xuXHR9LFxuXG5cdF9wb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5tZW51V3JhcC5wb3NpdGlvbiggJC5leHRlbmQoIHsgb2Y6IHRoaXMuYnV0dG9uIH0sIHRoaXMub3B0aW9ucy5wb3NpdGlvbiApICk7XG5cdH0sXG5cblx0Y2xvc2U6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoICF0aGlzLmlzT3BlbiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLmlzT3BlbiA9IGZhbHNlO1xuXHRcdHRoaXMuX3RvZ2dsZUF0dHIoKTtcblxuXHRcdHRoaXMucmFuZ2UgPSBudWxsO1xuXHRcdHRoaXMuX29mZiggdGhpcy5kb2N1bWVudCApO1xuXG5cdFx0dGhpcy5fdHJpZ2dlciggXCJjbG9zZVwiLCBldmVudCApO1xuXHR9LFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYnV0dG9uO1xuXHR9LFxuXG5cdG1lbnVXaWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1lbnU7XG5cdH0sXG5cblx0X3JlbmRlckJ1dHRvbkl0ZW06IGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdHZhciBidXR0b25JdGVtID0gJCggXCI8c3Bhbj5cIiApO1xuXG5cdFx0dGhpcy5fc2V0VGV4dCggYnV0dG9uSXRlbSwgaXRlbS5sYWJlbCApO1xuXHRcdHRoaXMuX2FkZENsYXNzKCBidXR0b25JdGVtLCBcInVpLXNlbGVjdG1lbnUtdGV4dFwiICk7XG5cblx0XHRyZXR1cm4gYnV0dG9uSXRlbTtcblx0fSxcblxuXHRfcmVuZGVyTWVudTogZnVuY3Rpb24oIHVsLCBpdGVtcyApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRjdXJyZW50T3B0Z3JvdXAgPSBcIlwiO1xuXG5cdFx0JC5lYWNoKCBpdGVtcywgZnVuY3Rpb24oIGluZGV4LCBpdGVtICkge1xuXHRcdFx0dmFyIGxpO1xuXG5cdFx0XHRpZiAoIGl0ZW0ub3B0Z3JvdXAgIT09IGN1cnJlbnRPcHRncm91cCApIHtcblx0XHRcdFx0bGkgPSAkKCBcIjxsaT5cIiwge1xuXHRcdFx0XHRcdHRleHQ6IGl0ZW0ub3B0Z3JvdXBcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0aGF0Ll9hZGRDbGFzcyggbGksIFwidWktc2VsZWN0bWVudS1vcHRncm91cFwiLCBcInVpLW1lbnUtZGl2aWRlclwiICtcblx0XHRcdFx0XHQoIGl0ZW0uZWxlbWVudC5wYXJlbnQoIFwib3B0Z3JvdXBcIiApLnByb3AoIFwiZGlzYWJsZWRcIiApID9cblx0XHRcdFx0XHRcdFwiIHVpLXN0YXRlLWRpc2FibGVkXCIgOlxuXHRcdFx0XHRcdFx0XCJcIiApICk7XG5cblx0XHRcdFx0bGkuYXBwZW5kVG8oIHVsICk7XG5cblx0XHRcdFx0Y3VycmVudE9wdGdyb3VwID0gaXRlbS5vcHRncm91cDtcblx0XHRcdH1cblxuXHRcdFx0dGhhdC5fcmVuZGVySXRlbURhdGEoIHVsLCBpdGVtICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9yZW5kZXJJdGVtRGF0YTogZnVuY3Rpb24oIHVsLCBpdGVtICkge1xuXHRcdHJldHVybiB0aGlzLl9yZW5kZXJJdGVtKCB1bCwgaXRlbSApLmRhdGEoIFwidWktc2VsZWN0bWVudS1pdGVtXCIsIGl0ZW0gKTtcblx0fSxcblxuXHRfcmVuZGVySXRlbTogZnVuY3Rpb24oIHVsLCBpdGVtICkge1xuXHRcdHZhciBsaSA9ICQoIFwiPGxpPlwiICksXG5cdFx0XHR3cmFwcGVyID0gJCggXCI8ZGl2PlwiLCB7XG5cdFx0XHRcdHRpdGxlOiBpdGVtLmVsZW1lbnQuYXR0ciggXCJ0aXRsZVwiIClcblx0XHRcdH0gKTtcblxuXHRcdGlmICggaXRlbS5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX2FkZENsYXNzKCBsaSwgbnVsbCwgXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICk7XG5cdFx0fVxuXHRcdHRoaXMuX3NldFRleHQoIHdyYXBwZXIsIGl0ZW0ubGFiZWwgKTtcblxuXHRcdHJldHVybiBsaS5hcHBlbmQoIHdyYXBwZXIgKS5hcHBlbmRUbyggdWwgKTtcblx0fSxcblxuXHRfc2V0VGV4dDogZnVuY3Rpb24oIGVsZW1lbnQsIHZhbHVlICkge1xuXHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHRlbGVtZW50LnRleHQoIHZhbHVlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW1lbnQuaHRtbCggXCImIzE2MDtcIiApO1xuXHRcdH1cblx0fSxcblxuXHRfbW92ZTogZnVuY3Rpb24oIGRpcmVjdGlvbiwgZXZlbnQgKSB7XG5cdFx0dmFyIGl0ZW0sIG5leHQsXG5cdFx0XHRmaWx0ZXIgPSBcIi51aS1tZW51LWl0ZW1cIjtcblxuXHRcdGlmICggdGhpcy5pc09wZW4gKSB7XG5cdFx0XHRpdGVtID0gdGhpcy5tZW51SXRlbXMuZXEoIHRoaXMuZm9jdXNJbmRleCApLnBhcmVudCggXCJsaVwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGl0ZW0gPSB0aGlzLm1lbnVJdGVtcy5lcSggdGhpcy5lbGVtZW50WyAwIF0uc2VsZWN0ZWRJbmRleCApLnBhcmVudCggXCJsaVwiICk7XG5cdFx0XHRmaWx0ZXIgKz0gXCI6bm90KC51aS1zdGF0ZS1kaXNhYmxlZClcIjtcblx0XHR9XG5cblx0XHRpZiAoIGRpcmVjdGlvbiA9PT0gXCJmaXJzdFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJsYXN0XCIgKSB7XG5cdFx0XHRuZXh0ID0gaXRlbVsgZGlyZWN0aW9uID09PSBcImZpcnN0XCIgPyBcInByZXZBbGxcIiA6IFwibmV4dEFsbFwiIF0oIGZpbHRlciApLmVxKCAtMSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXh0ID0gaXRlbVsgZGlyZWN0aW9uICsgXCJBbGxcIiBdKCBmaWx0ZXIgKS5lcSggMCApO1xuXHRcdH1cblxuXHRcdGlmICggbmV4dC5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLm1lbnVJbnN0YW5jZS5mb2N1cyggZXZlbnQsIG5leHQgKTtcblx0XHR9XG5cdH0sXG5cblx0X2dldFNlbGVjdGVkSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWVudUl0ZW1zLmVxKCB0aGlzLmVsZW1lbnRbIDAgXS5zZWxlY3RlZEluZGV4ICkucGFyZW50KCBcImxpXCIgKTtcblx0fSxcblxuXHRfdG9nZ2xlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dGhpc1sgdGhpcy5pc09wZW4gPyBcImNsb3NlXCIgOiBcIm9wZW5cIiBdKCBldmVudCApO1xuXHR9LFxuXG5cdF9zZXRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxlY3Rpb247XG5cblx0XHRpZiAoICF0aGlzLnJhbmdlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggd2luZG93LmdldFNlbGVjdGlvbiApIHtcblx0XHRcdHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblx0XHRcdHNlbGVjdGlvbi5hZGRSYW5nZSggdGhpcy5yYW5nZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucmFuZ2Uuc2VsZWN0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUVcblx0XHQvLyBTZXR0aW5nIHRoZSB0ZXh0IHNlbGVjdGlvbiBraWxscyB0aGUgYnV0dG9uIGZvY3VzIGluIElFLCBidXRcblx0XHQvLyByZXN0b3JpbmcgdGhlIGZvY3VzIGRvZXNuJ3Qga2lsbCB0aGUgc2VsZWN0aW9uLlxuXHRcdHRoaXMuYnV0dG9uLmZvY3VzKCk7XG5cdH0sXG5cblx0X2RvY3VtZW50Q2xpY2s6IHtcblx0XHRtb3VzZWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGlmICggIXRoaXMuaXNPcGVuICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggISQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIFwiLnVpLXNlbGVjdG1lbnUtbWVudSwgI1wiICtcblx0XHRcdFx0XHQkLnVpLmVzY2FwZVNlbGVjdG9yKCB0aGlzLmlkcy5idXR0b24gKSApLmxlbmd0aCApIHtcblx0XHRcdFx0dGhpcy5jbG9zZSggZXZlbnQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2J1dHRvbkV2ZW50czoge1xuXG5cdFx0Ly8gUHJldmVudCB0ZXh0IHNlbGVjdGlvbiBmcm9tIGJlaW5nIHJlc2V0IHdoZW4gaW50ZXJhY3Rpbmcgd2l0aCB0aGUgc2VsZWN0bWVudSAoIzEwMTQ0KVxuXHRcdG1vdXNlZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZWN0aW9uO1xuXG5cdFx0XHRpZiAoIHdpbmRvdy5nZXRTZWxlY3Rpb24gKSB7XG5cdFx0XHRcdHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdFx0aWYgKCBzZWxlY3Rpb24ucmFuZ2VDb3VudCApIHtcblx0XHRcdFx0XHR0aGlzLnJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoIDAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y2xpY2s6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHRoaXMuX3NldFNlbGVjdGlvbigpO1xuXHRcdFx0dGhpcy5fdG9nZ2xlKCBldmVudCApO1xuXHRcdH0sXG5cblx0XHRrZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuXHRcdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcblx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlRBQjpcblx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkVTQ0FQRTpcblx0XHRcdFx0dGhpcy5jbG9zZSggZXZlbnQgKTtcblx0XHRcdFx0cHJldmVudERlZmF1bHQgPSBmYWxzZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5FTlRFUjpcblx0XHRcdFx0aWYgKCB0aGlzLmlzT3BlbiApIHtcblx0XHRcdFx0XHR0aGlzLl9zZWxlY3RGb2N1c2VkSXRlbSggZXZlbnQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlVQOlxuXHRcdFx0XHRpZiAoIGV2ZW50LmFsdEtleSApIHtcblx0XHRcdFx0XHR0aGlzLl90b2dnbGUoIGV2ZW50ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fbW92ZSggXCJwcmV2XCIsIGV2ZW50ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5ET1dOOlxuXHRcdFx0XHRpZiAoIGV2ZW50LmFsdEtleSApIHtcblx0XHRcdFx0XHR0aGlzLl90b2dnbGUoIGV2ZW50ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fbW92ZSggXCJuZXh0XCIsIGV2ZW50ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5TUEFDRTpcblx0XHRcdFx0aWYgKCB0aGlzLmlzT3BlbiApIHtcblx0XHRcdFx0XHR0aGlzLl9zZWxlY3RGb2N1c2VkSXRlbSggZXZlbnQgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl90b2dnbGUoIGV2ZW50ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5MRUZUOlxuXHRcdFx0XHR0aGlzLl9tb3ZlKCBcInByZXZcIiwgZXZlbnQgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5SSUdIVDpcblx0XHRcdFx0dGhpcy5fbW92ZSggXCJuZXh0XCIsIGV2ZW50ICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuSE9NRTpcblx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlBBR0VfVVA6XG5cdFx0XHRcdHRoaXMuX21vdmUoIFwiZmlyc3RcIiwgZXZlbnQgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5FTkQ6XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5QQUdFX0RPV046XG5cdFx0XHRcdHRoaXMuX21vdmUoIFwibGFzdFwiLCBldmVudCApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRoaXMubWVudS50cmlnZ2VyKCBldmVudCApO1xuXHRcdFx0XHRwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHByZXZlbnREZWZhdWx0ICkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfc2VsZWN0Rm9jdXNlZEl0ZW06IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgaXRlbSA9IHRoaXMubWVudUl0ZW1zLmVxKCB0aGlzLmZvY3VzSW5kZXggKS5wYXJlbnQoIFwibGlcIiApO1xuXHRcdGlmICggIWl0ZW0uaGFzQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApICkge1xuXHRcdFx0dGhpcy5fc2VsZWN0KCBpdGVtLmRhdGEoIFwidWktc2VsZWN0bWVudS1pdGVtXCIgKSwgZXZlbnQgKTtcblx0XHR9XG5cdH0sXG5cblx0X3NlbGVjdDogZnVuY3Rpb24oIGl0ZW0sIGV2ZW50ICkge1xuXHRcdHZhciBvbGRJbmRleCA9IHRoaXMuZWxlbWVudFsgMCBdLnNlbGVjdGVkSW5kZXg7XG5cblx0XHQvLyBDaGFuZ2UgbmF0aXZlIHNlbGVjdCBlbGVtZW50XG5cdFx0dGhpcy5lbGVtZW50WyAwIF0uc2VsZWN0ZWRJbmRleCA9IGl0ZW0uaW5kZXg7XG5cdFx0dGhpcy5idXR0b25JdGVtLnJlcGxhY2VXaXRoKCB0aGlzLmJ1dHRvbkl0ZW0gPSB0aGlzLl9yZW5kZXJCdXR0b25JdGVtKCBpdGVtICkgKTtcblx0XHR0aGlzLl9zZXRBcmlhKCBpdGVtICk7XG5cdFx0dGhpcy5fdHJpZ2dlciggXCJzZWxlY3RcIiwgZXZlbnQsIHsgaXRlbTogaXRlbSB9ICk7XG5cblx0XHRpZiAoIGl0ZW0uaW5kZXggIT09IG9sZEluZGV4ICkge1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJjaGFuZ2VcIiwgZXZlbnQsIHsgaXRlbTogaXRlbSB9ICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jbG9zZSggZXZlbnQgKTtcblx0fSxcblxuXHRfc2V0QXJpYTogZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0dmFyIGlkID0gdGhpcy5tZW51SXRlbXMuZXEoIGl0ZW0uaW5kZXggKS5hdHRyKCBcImlkXCIgKTtcblxuXHRcdHRoaXMuYnV0dG9uLmF0dHIoIHtcblx0XHRcdFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGlkLFxuXHRcdFx0XCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIjogaWRcblx0XHR9ICk7XG5cdFx0dGhpcy5tZW51LmF0dHIoIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIGlkICk7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0aWYgKCBrZXkgPT09IFwiaWNvbnNcIiApIHtcblx0XHRcdHZhciBpY29uID0gdGhpcy5idXR0b24uZmluZCggXCJzcGFuLnVpLWljb25cIiApO1xuXHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIGljb24sIG51bGwsIHRoaXMub3B0aW9ucy5pY29ucy5idXR0b24gKVxuXHRcdFx0XHQuX2FkZENsYXNzKCBpY29uLCBudWxsLCB2YWx1ZS5idXR0b24gKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiYXBwZW5kVG9cIiApIHtcblx0XHRcdHRoaXMubWVudVdyYXAuYXBwZW5kVG8oIHRoaXMuX2FwcGVuZFRvKCkgKTtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gXCJ3aWR0aFwiICkge1xuXHRcdFx0dGhpcy5fcmVzaXplQnV0dG9uKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb25EaXNhYmxlZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHRoaXMuX3N1cGVyKCB2YWx1ZSApO1xuXG5cdFx0dGhpcy5tZW51SW5zdGFuY2Uub3B0aW9uKCBcImRpc2FibGVkXCIsIHZhbHVlICk7XG5cdFx0dGhpcy5idXR0b24uYXR0ciggXCJhcmlhLWRpc2FibGVkXCIsIHZhbHVlICk7XG5cdFx0dGhpcy5fdG9nZ2xlQ2xhc3MoIHRoaXMuYnV0dG9uLCBudWxsLCBcInVpLXN0YXRlLWRpc2FibGVkXCIsIHZhbHVlICk7XG5cblx0XHR0aGlzLmVsZW1lbnQucHJvcCggXCJkaXNhYmxlZFwiLCB2YWx1ZSApO1xuXHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHR0aGlzLmJ1dHRvbi5hdHRyKCBcInRhYmluZGV4XCIsIC0xICk7XG5cdFx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYnV0dG9uLmF0dHIoIFwidGFiaW5kZXhcIiwgMCApO1xuXHRcdH1cblx0fSxcblxuXHRfYXBwZW5kVG86IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5vcHRpb25zLmFwcGVuZFRvO1xuXG5cdFx0aWYgKCBlbGVtZW50ICkge1xuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQuanF1ZXJ5IHx8IGVsZW1lbnQubm9kZVR5cGUgP1xuXHRcdFx0XHQkKCBlbGVtZW50ICkgOlxuXHRcdFx0XHR0aGlzLmRvY3VtZW50LmZpbmQoIGVsZW1lbnQgKS5lcSggMCApO1xuXHRcdH1cblxuXHRcdGlmICggIWVsZW1lbnQgfHwgIWVsZW1lbnRbIDAgXSApIHtcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQuY2xvc2VzdCggXCIudWktZnJvbnQsIGRpYWxvZ1wiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhZWxlbWVudC5sZW5ndGggKSB7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5kb2N1bWVudFsgMCBdLmJvZHk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdH0sXG5cblx0X3RvZ2dsZUF0dHI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuYnV0dG9uLmF0dHIoIFwiYXJpYS1leHBhbmRlZFwiLCB0aGlzLmlzT3BlbiApO1xuXG5cdFx0Ly8gV2UgY2FuJ3QgdXNlIHR3byBfdG9nZ2xlQ2xhc3MoKSBjYWxscyBoZXJlLCBiZWNhdXNlIHdlIG5lZWQgdG8gbWFrZSBzdXJlXG5cdFx0Ly8gd2UgYWx3YXlzIHJlbW92ZSBjbGFzc2VzIGZpcnN0IGFuZCBhZGQgdGhlbSBzZWNvbmQsIG90aGVyd2lzZSBpZiBib3RoIGNsYXNzZXMgaGF2ZSB0aGVcblx0XHQvLyBzYW1lIHRoZW1lIGNsYXNzLCBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgd2UgYWRkIGl0LlxuXHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmJ1dHRvbiwgXCJ1aS1zZWxlY3RtZW51LWJ1dHRvbi1cIiArXG5cdFx0XHQoIHRoaXMuaXNPcGVuID8gXCJjbG9zZWRcIiA6IFwib3BlblwiICkgKVxuXHRcdFx0Ll9hZGRDbGFzcyggdGhpcy5idXR0b24sIFwidWktc2VsZWN0bWVudS1idXR0b24tXCIgK1xuXHRcdFx0XHQoIHRoaXMuaXNPcGVuID8gXCJvcGVuXCIgOiBcImNsb3NlZFwiICkgKVxuXHRcdFx0Ll90b2dnbGVDbGFzcyggdGhpcy5tZW51V3JhcCwgXCJ1aS1zZWxlY3RtZW51LW9wZW5cIiwgbnVsbCwgdGhpcy5pc09wZW4gKTtcblxuXHRcdHRoaXMubWVudS5hdHRyKCBcImFyaWEtaGlkZGVuXCIsICF0aGlzLmlzT3BlbiApO1xuXHR9LFxuXG5cdF9yZXNpemVCdXR0b246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB3aWR0aCA9IHRoaXMub3B0aW9ucy53aWR0aDtcblxuXHRcdC8vIEZvciBgd2lkdGg6IGZhbHNlYCwganVzdCByZW1vdmUgaW5saW5lIHN0eWxlIGFuZCBzdG9wXG5cdFx0aWYgKCB3aWR0aCA9PT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLmJ1dHRvbi5jc3MoIFwid2lkdGhcIiwgXCJcIiApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZvciBgd2lkdGg6IG51bGxgLCBtYXRjaCB0aGUgd2lkdGggb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnRcblx0XHRpZiAoIHdpZHRoID09PSBudWxsICkge1xuXHRcdFx0d2lkdGggPSB0aGlzLmVsZW1lbnQuc2hvdygpLm91dGVyV2lkdGgoKTtcblx0XHRcdHRoaXMuZWxlbWVudC5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5idXR0b24ub3V0ZXJXaWR0aCggd2lkdGggKTtcblx0fSxcblxuXHRfcmVzaXplTWVudTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5tZW51Lm91dGVyV2lkdGgoIE1hdGgubWF4KFxuXHRcdFx0dGhpcy5idXR0b24ub3V0ZXJXaWR0aCgpLFxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTEwXG5cdFx0XHQvLyBJRTEwIHdyYXBzIGxvbmcgdGV4dCAocG9zc2libHkgYSByb3VuZGluZyBidWcpXG5cdFx0XHQvLyBzbyB3ZSBhZGQgMXB4IHRvIGF2b2lkIHRoZSB3cmFwcGluZ1xuXHRcdFx0dGhpcy5tZW51LndpZHRoKCBcIlwiICkub3V0ZXJXaWR0aCgpICsgMVxuXHRcdCkgKTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl9zdXBlcigpO1xuXG5cdFx0b3B0aW9ucy5kaXNhYmxlZCA9IHRoaXMuZWxlbWVudC5wcm9wKCBcImRpc2FibGVkXCIgKTtcblxuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9LFxuXG5cdF9wYXJzZU9wdGlvbnM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdGRhdGEgPSBbXTtcblx0XHRvcHRpb25zLmVhY2goIGZ1bmN0aW9uKCBpbmRleCwgaXRlbSApIHtcblx0XHRcdGRhdGEucHVzaCggdGhhdC5fcGFyc2VPcHRpb24oICQoIGl0ZW0gKSwgaW5kZXggKSApO1xuXHRcdH0gKTtcblx0XHR0aGlzLml0ZW1zID0gZGF0YTtcblx0fSxcblxuXHRfcGFyc2VPcHRpb246IGZ1bmN0aW9uKCBvcHRpb24sIGluZGV4ICkge1xuXHRcdHZhciBvcHRncm91cCA9IG9wdGlvbi5wYXJlbnQoIFwib3B0Z3JvdXBcIiApO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGVsZW1lbnQ6IG9wdGlvbixcblx0XHRcdGluZGV4OiBpbmRleCxcblx0XHRcdHZhbHVlOiBvcHRpb24udmFsKCksXG5cdFx0XHRsYWJlbDogb3B0aW9uLnRleHQoKSxcblx0XHRcdG9wdGdyb3VwOiBvcHRncm91cC5hdHRyKCBcImxhYmVsXCIgKSB8fCBcIlwiLFxuXHRcdFx0ZGlzYWJsZWQ6IG9wdGdyb3VwLnByb3AoIFwiZGlzYWJsZWRcIiApIHx8IG9wdGlvbi5wcm9wKCBcImRpc2FibGVkXCIgKVxuXHRcdH07XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3VuYmluZEZvcm1SZXNldEhhbmRsZXIoKTtcblx0XHR0aGlzLm1lbnVXcmFwLnJlbW92ZSgpO1xuXHRcdHRoaXMuYnV0dG9uLnJlbW92ZSgpO1xuXHRcdHRoaXMuZWxlbWVudC5zaG93KCk7XG5cdFx0dGhpcy5lbGVtZW50LnJlbW92ZVVuaXF1ZUlkKCk7XG5cdFx0dGhpcy5sYWJlbHMuYXR0ciggXCJmb3JcIiwgdGhpcy5pZHMuZWxlbWVudCApO1xuXHR9XG59IF0gKTtcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSBTbGlkZXIgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IFNsaWRlclxuLy8+Pmdyb3VwOiBXaWRnZXRzXG4vLz4+ZGVzY3JpcHRpb246IERpc3BsYXlzIGEgZmxleGlibGUgc2xpZGVyIHdpdGggcmFuZ2VzIGFuZCBhY2Nlc3NpYmlsaXR5IHZpYSBrZXlib2FyZC5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9zbGlkZXIvXG4vLz4+ZGVtb3M6IGh0dHA6Ly9qcXVlcnl1aS5jb20vc2xpZGVyL1xuLy8+PmNzcy5zdHJ1Y3R1cmU6IC4uLy4uL3RoZW1lcy9iYXNlL2NvcmUuY3NzXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2Uvc2xpZGVyLmNzc1xuLy8+PmNzcy50aGVtZTogLi4vLi4vdGhlbWVzL2Jhc2UvdGhlbWUuY3NzXG5cblxuXG52YXIgd2lkZ2V0c1NsaWRlciA9ICQud2lkZ2V0KCBcInVpLnNsaWRlclwiLCAkLnVpLm1vdXNlLCB7XG5cdHZlcnNpb246IFwiMS4xMi4xXCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcInNsaWRlXCIsXG5cblx0b3B0aW9uczoge1xuXHRcdGFuaW1hdGU6IGZhbHNlLFxuXHRcdGNsYXNzZXM6IHtcblx0XHRcdFwidWktc2xpZGVyXCI6IFwidWktY29ybmVyLWFsbFwiLFxuXHRcdFx0XCJ1aS1zbGlkZXItaGFuZGxlXCI6IFwidWktY29ybmVyLWFsbFwiLFxuXG5cdFx0XHQvLyBOb3RlOiB1aS13aWRnZXQtaGVhZGVyIGlzbid0IHRoZSBtb3N0IGZpdHRpbmdseSBzZW1hbnRpYyBmcmFtZXdvcmsgY2xhc3MgZm9yIHRoaXNcblx0XHRcdC8vIGVsZW1lbnQsIGJ1dCB3b3JrZWQgYmVzdCB2aXN1YWxseSB3aXRoIGEgdmFyaWV0eSBvZiB0aGVtZXNcblx0XHRcdFwidWktc2xpZGVyLXJhbmdlXCI6IFwidWktY29ybmVyLWFsbCB1aS13aWRnZXQtaGVhZGVyXCJcblx0XHR9LFxuXHRcdGRpc3RhbmNlOiAwLFxuXHRcdG1heDogMTAwLFxuXHRcdG1pbjogMCxcblx0XHRvcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXG5cdFx0cmFuZ2U6IGZhbHNlLFxuXHRcdHN0ZXA6IDEsXG5cdFx0dmFsdWU6IDAsXG5cdFx0dmFsdWVzOiBudWxsLFxuXG5cdFx0Ly8gQ2FsbGJhY2tzXG5cdFx0Y2hhbmdlOiBudWxsLFxuXHRcdHNsaWRlOiBudWxsLFxuXHRcdHN0YXJ0OiBudWxsLFxuXHRcdHN0b3A6IG51bGxcblx0fSxcblxuXHQvLyBOdW1iZXIgb2YgcGFnZXMgaW4gYSBzbGlkZXJcblx0Ly8gKGhvdyBtYW55IHRpbWVzIGNhbiB5b3UgcGFnZSB1cC9kb3duIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHJhbmdlKVxuXHRudW1QYWdlczogNSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9rZXlTbGlkaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5fbW91c2VTbGlkaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XG5cdFx0dGhpcy5faGFuZGxlSW5kZXggPSBudWxsO1xuXHRcdHRoaXMuX2RldGVjdE9yaWVudGF0aW9uKCk7XG5cdFx0dGhpcy5fbW91c2VJbml0KCk7XG5cdFx0dGhpcy5fY2FsY3VsYXRlTmV3TWF4KCk7XG5cblx0XHR0aGlzLl9hZGRDbGFzcyggXCJ1aS1zbGlkZXIgdWktc2xpZGVyLVwiICsgdGhpcy5vcmllbnRhdGlvbixcblx0XHRcdFwidWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50XCIgKTtcblxuXHRcdHRoaXMuX3JlZnJlc2goKTtcblxuXHRcdHRoaXMuX2FuaW1hdGVPZmYgPSBmYWxzZTtcblx0fSxcblxuXHRfcmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fY3JlYXRlUmFuZ2UoKTtcblx0XHR0aGlzLl9jcmVhdGVIYW5kbGVzKCk7XG5cdFx0dGhpcy5fc2V0dXBFdmVudHMoKTtcblx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0fSxcblxuXHRfY3JlYXRlSGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGksIGhhbmRsZUNvdW50LFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGV4aXN0aW5nSGFuZGxlcyA9IHRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1zbGlkZXItaGFuZGxlXCIgKSxcblx0XHRcdGhhbmRsZSA9IFwiPHNwYW4gdGFiaW5kZXg9JzAnPjwvc3Bhbj5cIixcblx0XHRcdGhhbmRsZXMgPSBbXTtcblxuXHRcdGhhbmRsZUNvdW50ID0gKCBvcHRpb25zLnZhbHVlcyAmJiBvcHRpb25zLnZhbHVlcy5sZW5ndGggKSB8fCAxO1xuXG5cdFx0aWYgKCBleGlzdGluZ0hhbmRsZXMubGVuZ3RoID4gaGFuZGxlQ291bnQgKSB7XG5cdFx0XHRleGlzdGluZ0hhbmRsZXMuc2xpY2UoIGhhbmRsZUNvdW50ICkucmVtb3ZlKCk7XG5cdFx0XHRleGlzdGluZ0hhbmRsZXMgPSBleGlzdGluZ0hhbmRsZXMuc2xpY2UoIDAsIGhhbmRsZUNvdW50ICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IGV4aXN0aW5nSGFuZGxlcy5sZW5ndGg7IGkgPCBoYW5kbGVDb3VudDsgaSsrICkge1xuXHRcdFx0aGFuZGxlcy5wdXNoKCBoYW5kbGUgKTtcblx0XHR9XG5cblx0XHR0aGlzLmhhbmRsZXMgPSBleGlzdGluZ0hhbmRsZXMuYWRkKCAkKCBoYW5kbGVzLmpvaW4oIFwiXCIgKSApLmFwcGVuZFRvKCB0aGlzLmVsZW1lbnQgKSApO1xuXG5cdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMuaGFuZGxlcywgXCJ1aS1zbGlkZXItaGFuZGxlXCIsIFwidWktc3RhdGUtZGVmYXVsdFwiICk7XG5cblx0XHR0aGlzLmhhbmRsZSA9IHRoaXMuaGFuZGxlcy5lcSggMCApO1xuXG5cdFx0dGhpcy5oYW5kbGVzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0JCggdGhpcyApXG5cdFx0XHRcdC5kYXRhKCBcInVpLXNsaWRlci1oYW5kbGUtaW5kZXhcIiwgaSApXG5cdFx0XHRcdC5hdHRyKCBcInRhYkluZGV4XCIsIDAgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0X2NyZWF0ZVJhbmdlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmICggb3B0aW9ucy5yYW5nZSApIHtcblx0XHRcdGlmICggb3B0aW9ucy5yYW5nZSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0aWYgKCAhb3B0aW9ucy52YWx1ZXMgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy52YWx1ZXMgPSBbIHRoaXMuX3ZhbHVlTWluKCksIHRoaXMuX3ZhbHVlTWluKCkgXTtcblx0XHRcdFx0fSBlbHNlIGlmICggb3B0aW9ucy52YWx1ZXMubGVuZ3RoICYmIG9wdGlvbnMudmFsdWVzLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0XHRvcHRpb25zLnZhbHVlcyA9IFsgb3B0aW9ucy52YWx1ZXNbIDAgXSwgb3B0aW9ucy52YWx1ZXNbIDAgXSBdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCAkLmlzQXJyYXkoIG9wdGlvbnMudmFsdWVzICkgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcy5zbGljZSggMCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggIXRoaXMucmFuZ2UgfHwgIXRoaXMucmFuZ2UubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLnJhbmdlID0gJCggXCI8ZGl2PlwiIClcblx0XHRcdFx0XHQuYXBwZW5kVG8oIHRoaXMuZWxlbWVudCApO1xuXG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLnJhbmdlLCBcInVpLXNsaWRlci1yYW5nZVwiICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggdGhpcy5yYW5nZSwgXCJ1aS1zbGlkZXItcmFuZ2UtbWluIHVpLXNsaWRlci1yYW5nZS1tYXhcIiApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSByYW5nZSBzd2l0Y2hpbmcgZnJvbSB0cnVlIHRvIG1pbi9tYXhcblx0XHRcdFx0dGhpcy5yYW5nZS5jc3MoIHtcblx0XHRcdFx0XHRcImxlZnRcIjogXCJcIixcblx0XHRcdFx0XHRcImJvdHRvbVwiOiBcIlwiXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggb3B0aW9ucy5yYW5nZSA9PT0gXCJtaW5cIiB8fCBvcHRpb25zLnJhbmdlID09PSBcIm1heFwiICkge1xuXHRcdFx0XHR0aGlzLl9hZGRDbGFzcyggdGhpcy5yYW5nZSwgXCJ1aS1zbGlkZXItcmFuZ2UtXCIgKyBvcHRpb25zLnJhbmdlICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggdGhpcy5yYW5nZSApIHtcblx0XHRcdFx0dGhpcy5yYW5nZS5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMucmFuZ2UgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0dXBFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX29mZiggdGhpcy5oYW5kbGVzICk7XG5cdFx0dGhpcy5fb24oIHRoaXMuaGFuZGxlcywgdGhpcy5faGFuZGxlRXZlbnRzICk7XG5cdFx0dGhpcy5faG92ZXJhYmxlKCB0aGlzLmhhbmRsZXMgKTtcblx0XHR0aGlzLl9mb2N1c2FibGUoIHRoaXMuaGFuZGxlcyApO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhhbmRsZXMucmVtb3ZlKCk7XG5cdFx0aWYgKCB0aGlzLnJhbmdlICkge1xuXHRcdFx0dGhpcy5yYW5nZS5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9tb3VzZURlc3Ryb3koKTtcblx0fSxcblxuXHRfbW91c2VDYXB0dXJlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHBvc2l0aW9uLCBub3JtVmFsdWUsIGRpc3RhbmNlLCBjbG9zZXN0SGFuZGxlLCBpbmRleCwgYWxsb3dlZCwgb2Zmc2V0LCBtb3VzZU92ZXJIYW5kbGUsXG5cdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAoIG8uZGlzYWJsZWQgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50U2l6ZSA9IHtcblx0XHRcdHdpZHRoOiB0aGlzLmVsZW1lbnQub3V0ZXJXaWR0aCgpLFxuXHRcdFx0aGVpZ2h0OiB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKVxuXHRcdH07XG5cdFx0dGhpcy5lbGVtZW50T2Zmc2V0ID0gdGhpcy5lbGVtZW50Lm9mZnNldCgpO1xuXG5cdFx0cG9zaXRpb24gPSB7IHg6IGV2ZW50LnBhZ2VYLCB5OiBldmVudC5wYWdlWSB9O1xuXHRcdG5vcm1WYWx1ZSA9IHRoaXMuX25vcm1WYWx1ZUZyb21Nb3VzZSggcG9zaXRpb24gKTtcblx0XHRkaXN0YW5jZSA9IHRoaXMuX3ZhbHVlTWF4KCkgLSB0aGlzLl92YWx1ZU1pbigpICsgMTtcblx0XHR0aGlzLmhhbmRsZXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdGhpc0Rpc3RhbmNlID0gTWF0aC5hYnMoIG5vcm1WYWx1ZSAtIHRoYXQudmFsdWVzKCBpICkgKTtcblx0XHRcdGlmICggKCBkaXN0YW5jZSA+IHRoaXNEaXN0YW5jZSApIHx8XG5cdFx0XHRcdCggZGlzdGFuY2UgPT09IHRoaXNEaXN0YW5jZSAmJlxuXHRcdFx0XHRcdCggaSA9PT0gdGhhdC5fbGFzdENoYW5nZWRWYWx1ZSB8fCB0aGF0LnZhbHVlcyggaSApID09PSBvLm1pbiApICkgKSB7XG5cdFx0XHRcdGRpc3RhbmNlID0gdGhpc0Rpc3RhbmNlO1xuXHRcdFx0XHRjbG9zZXN0SGFuZGxlID0gJCggdGhpcyApO1xuXHRcdFx0XHRpbmRleCA9IGk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0YWxsb3dlZCA9IHRoaXMuX3N0YXJ0KCBldmVudCwgaW5kZXggKTtcblx0XHRpZiAoIGFsbG93ZWQgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHR0aGlzLl9tb3VzZVNsaWRpbmcgPSB0cnVlO1xuXG5cdFx0dGhpcy5faGFuZGxlSW5kZXggPSBpbmRleDtcblxuXHRcdHRoaXMuX2FkZENsYXNzKCBjbG9zZXN0SGFuZGxlLCBudWxsLCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0Y2xvc2VzdEhhbmRsZS50cmlnZ2VyKCBcImZvY3VzXCIgKTtcblxuXHRcdG9mZnNldCA9IGNsb3Nlc3RIYW5kbGUub2Zmc2V0KCk7XG5cdFx0bW91c2VPdmVySGFuZGxlID0gISQoIGV2ZW50LnRhcmdldCApLnBhcmVudHMoKS5hZGRCYWNrKCkuaXMoIFwiLnVpLXNsaWRlci1oYW5kbGVcIiApO1xuXHRcdHRoaXMuX2NsaWNrT2Zmc2V0ID0gbW91c2VPdmVySGFuZGxlID8geyBsZWZ0OiAwLCB0b3A6IDAgfSA6IHtcblx0XHRcdGxlZnQ6IGV2ZW50LnBhZ2VYIC0gb2Zmc2V0LmxlZnQgLSAoIGNsb3Nlc3RIYW5kbGUud2lkdGgoKSAvIDIgKSxcblx0XHRcdHRvcDogZXZlbnQucGFnZVkgLSBvZmZzZXQudG9wIC1cblx0XHRcdFx0KCBjbG9zZXN0SGFuZGxlLmhlaWdodCgpIC8gMiApIC1cblx0XHRcdFx0KCBwYXJzZUludCggY2xvc2VzdEhhbmRsZS5jc3MoIFwiYm9yZGVyVG9wV2lkdGhcIiApLCAxMCApIHx8IDAgKSAtXG5cdFx0XHRcdCggcGFyc2VJbnQoIGNsb3Nlc3RIYW5kbGUuY3NzKCBcImJvcmRlckJvdHRvbVdpZHRoXCIgKSwgMTAgKSB8fCAwICkgK1xuXHRcdFx0XHQoIHBhcnNlSW50KCBjbG9zZXN0SGFuZGxlLmNzcyggXCJtYXJnaW5Ub3BcIiApLCAxMCApIHx8IDAgKVxuXHRcdH07XG5cblx0XHRpZiAoICF0aGlzLmhhbmRsZXMuaGFzQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApICkge1xuXHRcdFx0dGhpcy5fc2xpZGUoIGV2ZW50LCBpbmRleCwgbm9ybVZhbHVlICk7XG5cdFx0fVxuXHRcdHRoaXMuX2FuaW1hdGVPZmYgPSB0cnVlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9tb3VzZVN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfbW91c2VEcmFnOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0geyB4OiBldmVudC5wYWdlWCwgeTogZXZlbnQucGFnZVkgfSxcblx0XHRcdG5vcm1WYWx1ZSA9IHRoaXMuX25vcm1WYWx1ZUZyb21Nb3VzZSggcG9zaXRpb24gKTtcblxuXHRcdHRoaXMuX3NsaWRlKCBldmVudCwgdGhpcy5faGFuZGxlSW5kZXgsIG5vcm1WYWx1ZSApO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9tb3VzZVN0b3A6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR0aGlzLl9yZW1vdmVDbGFzcyggdGhpcy5oYW5kbGVzLCBudWxsLCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0dGhpcy5fbW91c2VTbGlkaW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLl9zdG9wKCBldmVudCwgdGhpcy5faGFuZGxlSW5kZXggKTtcblx0XHR0aGlzLl9jaGFuZ2UoIGV2ZW50LCB0aGlzLl9oYW5kbGVJbmRleCApO1xuXG5cdFx0dGhpcy5faGFuZGxlSW5kZXggPSBudWxsO1xuXHRcdHRoaXMuX2NsaWNrT2Zmc2V0ID0gbnVsbDtcblx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X2RldGVjdE9yaWVudGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLm9yaWVudGF0aW9uID0gKCB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiApID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCI7XG5cdH0sXG5cblx0X25vcm1WYWx1ZUZyb21Nb3VzZTogZnVuY3Rpb24oIHBvc2l0aW9uICkge1xuXHRcdHZhciBwaXhlbFRvdGFsLFxuXHRcdFx0cGl4ZWxNb3VzZSxcblx0XHRcdHBlcmNlbnRNb3VzZSxcblx0XHRcdHZhbHVlVG90YWwsXG5cdFx0XHR2YWx1ZU1vdXNlO1xuXG5cdFx0aWYgKCB0aGlzLm9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiApIHtcblx0XHRcdHBpeGVsVG90YWwgPSB0aGlzLmVsZW1lbnRTaXplLndpZHRoO1xuXHRcdFx0cGl4ZWxNb3VzZSA9IHBvc2l0aW9uLnggLSB0aGlzLmVsZW1lbnRPZmZzZXQubGVmdCAtXG5cdFx0XHRcdCggdGhpcy5fY2xpY2tPZmZzZXQgPyB0aGlzLl9jbGlja09mZnNldC5sZWZ0IDogMCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwaXhlbFRvdGFsID0gdGhpcy5lbGVtZW50U2l6ZS5oZWlnaHQ7XG5cdFx0XHRwaXhlbE1vdXNlID0gcG9zaXRpb24ueSAtIHRoaXMuZWxlbWVudE9mZnNldC50b3AgLVxuXHRcdFx0XHQoIHRoaXMuX2NsaWNrT2Zmc2V0ID8gdGhpcy5fY2xpY2tPZmZzZXQudG9wIDogMCApO1xuXHRcdH1cblxuXHRcdHBlcmNlbnRNb3VzZSA9ICggcGl4ZWxNb3VzZSAvIHBpeGVsVG90YWwgKTtcblx0XHRpZiAoIHBlcmNlbnRNb3VzZSA+IDEgKSB7XG5cdFx0XHRwZXJjZW50TW91c2UgPSAxO1xuXHRcdH1cblx0XHRpZiAoIHBlcmNlbnRNb3VzZSA8IDAgKSB7XG5cdFx0XHRwZXJjZW50TW91c2UgPSAwO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMub3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiApIHtcblx0XHRcdHBlcmNlbnRNb3VzZSA9IDEgLSBwZXJjZW50TW91c2U7XG5cdFx0fVxuXG5cdFx0dmFsdWVUb3RhbCA9IHRoaXMuX3ZhbHVlTWF4KCkgLSB0aGlzLl92YWx1ZU1pbigpO1xuXHRcdHZhbHVlTW91c2UgPSB0aGlzLl92YWx1ZU1pbigpICsgcGVyY2VudE1vdXNlICogdmFsdWVUb3RhbDtcblxuXHRcdHJldHVybiB0aGlzLl90cmltQWxpZ25WYWx1ZSggdmFsdWVNb3VzZSApO1xuXHR9LFxuXG5cdF91aUhhc2g6IGZ1bmN0aW9uKCBpbmRleCwgdmFsdWUsIHZhbHVlcyApIHtcblx0XHR2YXIgdWlIYXNoID0ge1xuXHRcdFx0aGFuZGxlOiB0aGlzLmhhbmRsZXNbIGluZGV4IF0sXG5cdFx0XHRoYW5kbGVJbmRleDogaW5kZXgsXG5cdFx0XHR2YWx1ZTogdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDogdGhpcy52YWx1ZSgpXG5cdFx0fTtcblxuXHRcdGlmICggdGhpcy5faGFzTXVsdGlwbGVWYWx1ZXMoKSApIHtcblx0XHRcdHVpSGFzaC52YWx1ZSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHRoaXMudmFsdWVzKCBpbmRleCApO1xuXHRcdFx0dWlIYXNoLnZhbHVlcyA9IHZhbHVlcyB8fCB0aGlzLnZhbHVlcygpO1xuXHRcdH1cblxuXHRcdHJldHVybiB1aUhhc2g7XG5cdH0sXG5cblx0X2hhc011bHRpcGxlVmFsdWVzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlcyAmJiB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aDtcblx0fSxcblxuXHRfc3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgaW5kZXggKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RyaWdnZXIoIFwic3RhcnRcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCggaW5kZXggKSApO1xuXHR9LFxuXG5cdF9zbGlkZTogZnVuY3Rpb24oIGV2ZW50LCBpbmRleCwgbmV3VmFsICkge1xuXHRcdHZhciBhbGxvd2VkLCBvdGhlclZhbCxcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IHRoaXMudmFsdWUoKSxcblx0XHRcdG5ld1ZhbHVlcyA9IHRoaXMudmFsdWVzKCk7XG5cblx0XHRpZiAoIHRoaXMuX2hhc011bHRpcGxlVmFsdWVzKCkgKSB7XG5cdFx0XHRvdGhlclZhbCA9IHRoaXMudmFsdWVzKCBpbmRleCA/IDAgOiAxICk7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSB0aGlzLnZhbHVlcyggaW5kZXggKTtcblxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCA9PT0gMiAmJiB0aGlzLm9wdGlvbnMucmFuZ2UgPT09IHRydWUgKSB7XG5cdFx0XHRcdG5ld1ZhbCA9ICBpbmRleCA9PT0gMCA/IE1hdGgubWluKCBvdGhlclZhbCwgbmV3VmFsICkgOiBNYXRoLm1heCggb3RoZXJWYWwsIG5ld1ZhbCApO1xuXHRcdFx0fVxuXG5cdFx0XHRuZXdWYWx1ZXNbIGluZGV4IF0gPSBuZXdWYWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBuZXdWYWwgPT09IGN1cnJlbnRWYWx1ZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRhbGxvd2VkID0gdGhpcy5fdHJpZ2dlciggXCJzbGlkZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCBpbmRleCwgbmV3VmFsLCBuZXdWYWx1ZXMgKSApO1xuXG5cdFx0Ly8gQSBzbGlkZSBjYW4gYmUgY2FuY2VsZWQgYnkgcmV0dXJuaW5nIGZhbHNlIGZyb20gdGhlIHNsaWRlIGNhbGxiYWNrXG5cdFx0aWYgKCBhbGxvd2VkID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX2hhc011bHRpcGxlVmFsdWVzKCkgKSB7XG5cdFx0XHR0aGlzLnZhbHVlcyggaW5kZXgsIG5ld1ZhbCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnZhbHVlKCBuZXdWYWwgKTtcblx0XHR9XG5cdH0sXG5cblx0X3N0b3A6IGZ1bmN0aW9uKCBldmVudCwgaW5kZXggKSB7XG5cdFx0dGhpcy5fdHJpZ2dlciggXCJzdG9wXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goIGluZGV4ICkgKTtcblx0fSxcblxuXHRfY2hhbmdlOiBmdW5jdGlvbiggZXZlbnQsIGluZGV4ICkge1xuXHRcdGlmICggIXRoaXMuX2tleVNsaWRpbmcgJiYgIXRoaXMuX21vdXNlU2xpZGluZyApIHtcblxuXHRcdFx0Ly9zdG9yZSB0aGUgbGFzdCBjaGFuZ2VkIHZhbHVlIGluZGV4IGZvciByZWZlcmVuY2Ugd2hlbiBoYW5kbGVzIG92ZXJsYXBcblx0XHRcdHRoaXMuX2xhc3RDaGFuZ2VkVmFsdWUgPSBpbmRleDtcblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2hhbmdlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goIGluZGV4ICkgKTtcblx0XHR9XG5cdH0sXG5cblx0dmFsdWU6IGZ1bmN0aW9uKCBuZXdWYWx1ZSApIHtcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMudmFsdWUgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggbmV3VmFsdWUgKTtcblx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHRcdFx0dGhpcy5fY2hhbmdlKCBudWxsLCAwICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlKCk7XG5cdH0sXG5cblx0dmFsdWVzOiBmdW5jdGlvbiggaW5kZXgsIG5ld1ZhbHVlICkge1xuXHRcdHZhciB2YWxzLFxuXHRcdFx0bmV3VmFsdWVzLFxuXHRcdFx0aTtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMudmFsdWVzWyBpbmRleCBdID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIG5ld1ZhbHVlICk7XG5cdFx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0XHRcdHRoaXMuX2NoYW5nZSggbnVsbCwgaW5kZXggKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoICQuaXNBcnJheSggYXJndW1lbnRzWyAwIF0gKSApIHtcblx0XHRcdFx0dmFscyA9IHRoaXMub3B0aW9ucy52YWx1ZXM7XG5cdFx0XHRcdG5ld1ZhbHVlcyA9IGFyZ3VtZW50c1sgMCBdO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0dmFsc1sgaSBdID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIG5ld1ZhbHVlc1sgaSBdICk7XG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlKCBudWxsLCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIHRoaXMuX2hhc011bHRpcGxlVmFsdWVzKCkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3ZhbHVlcyggaW5kZXggKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLl92YWx1ZXMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHR2YWxzTGVuZ3RoID0gMDtcblxuXHRcdGlmICgga2V5ID09PSBcInJhbmdlXCIgJiYgdGhpcy5vcHRpb25zLnJhbmdlID09PSB0cnVlICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJtaW5cIiApIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLnZhbHVlID0gdGhpcy5fdmFsdWVzKCAwICk7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy52YWx1ZXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IFwibWF4XCIgKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy52YWx1ZSA9IHRoaXMuX3ZhbHVlcyggdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGggLSAxICk7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy52YWx1ZXMgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggJC5pc0FycmF5KCB0aGlzLm9wdGlvbnMudmFsdWVzICkgKSB7XG5cdFx0XHR2YWxzTGVuZ3RoID0gdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGg7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblxuXHRcdHN3aXRjaCAoIGtleSApIHtcblx0XHRcdGNhc2UgXCJvcmllbnRhdGlvblwiOlxuXHRcdFx0XHR0aGlzLl9kZXRlY3RPcmllbnRhdGlvbigpO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggXCJ1aS1zbGlkZXItaG9yaXpvbnRhbCB1aS1zbGlkZXItdmVydGljYWxcIiApXG5cdFx0XHRcdFx0Ll9hZGRDbGFzcyggXCJ1aS1zbGlkZXItXCIgKyB0aGlzLm9yaWVudGF0aW9uICk7XG5cdFx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5yYW5nZSApIHtcblx0XHRcdFx0XHR0aGlzLl9yZWZyZXNoUmFuZ2UoIHZhbHVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNldCBwb3NpdGlvbmluZyBmcm9tIHByZXZpb3VzIG9yaWVudGF0aW9uXG5cdFx0XHRcdHRoaXMuaGFuZGxlcy5jc3MoIHZhbHVlID09PSBcImhvcml6b250YWxcIiA/IFwiYm90dG9tXCIgOiBcImxlZnRcIiwgXCJcIiApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJ2YWx1ZVwiOlxuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZSggbnVsbCwgMCApO1xuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInZhbHVlc1wiOlxuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cblx0XHRcdFx0Ly8gU3RhcnQgZnJvbSB0aGUgbGFzdCBoYW5kbGUgdG8gcHJldmVudCB1bnJlYWNoYWJsZSBoYW5kbGVzICgjOTA0Nilcblx0XHRcdFx0Zm9yICggaSA9IHZhbHNMZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcblx0XHRcdFx0XHR0aGlzLl9jaGFuZ2UoIG51bGwsIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInN0ZXBcIjpcblx0XHRcdGNhc2UgXCJtaW5cIjpcblx0XHRcdGNhc2UgXCJtYXhcIjpcblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XG5cdFx0XHRcdHRoaXMuX2NhbGN1bGF0ZU5ld01heCgpO1xuXHRcdFx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJyYW5nZVwiOlxuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0T3B0aW9uRGlzYWJsZWQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zdXBlciggdmFsdWUgKTtcblxuXHRcdHRoaXMuX3RvZ2dsZUNsYXNzKCBudWxsLCBcInVpLXN0YXRlLWRpc2FibGVkXCIsICEhdmFsdWUgKTtcblx0fSxcblxuXHQvL2ludGVybmFsIHZhbHVlIGdldHRlclxuXHQvLyBfdmFsdWUoKSByZXR1cm5zIHZhbHVlIHRyaW1tZWQgYnkgbWluIGFuZCBtYXgsIGFsaWduZWQgYnkgc3RlcFxuXHRfdmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2YWwgPSB0aGlzLm9wdGlvbnMudmFsdWU7XG5cdFx0dmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIHZhbCApO1xuXG5cdFx0cmV0dXJuIHZhbDtcblx0fSxcblxuXHQvL2ludGVybmFsIHZhbHVlcyBnZXR0ZXJcblx0Ly8gX3ZhbHVlcygpIHJldHVybnMgYXJyYXkgb2YgdmFsdWVzIHRyaW1tZWQgYnkgbWluIGFuZCBtYXgsIGFsaWduZWQgYnkgc3RlcFxuXHQvLyBfdmFsdWVzKCBpbmRleCApIHJldHVybnMgc2luZ2xlIHZhbHVlIHRyaW1tZWQgYnkgbWluIGFuZCBtYXgsIGFsaWduZWQgYnkgc3RlcFxuXHRfdmFsdWVzOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0dmFyIHZhbCxcblx0XHRcdHZhbHMsXG5cdFx0XHRpO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0dmFsID0gdGhpcy5vcHRpb25zLnZhbHVlc1sgaW5kZXggXTtcblx0XHRcdHZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCB2YWwgKTtcblxuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLl9oYXNNdWx0aXBsZVZhbHVlcygpICkge1xuXG5cdFx0XHQvLyAuc2xpY2UoKSBjcmVhdGVzIGEgY29weSBvZiB0aGUgYXJyYXlcblx0XHRcdC8vIHRoaXMgY29weSBnZXRzIHRyaW1tZWQgYnkgbWluIGFuZCBtYXggYW5kIHRoZW4gcmV0dXJuZWRcblx0XHRcdHZhbHMgPSB0aGlzLm9wdGlvbnMudmFsdWVzLnNsaWNlKCk7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdHZhbHNbIGkgXSA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCB2YWxzWyBpIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gUmV0dXJucyB0aGUgc3RlcC1hbGlnbmVkIHZhbHVlIHRoYXQgdmFsIGlzIGNsb3Nlc3QgdG8sIGJldHdlZW4gKGluY2x1c2l2ZSkgbWluIGFuZCBtYXhcblx0X3RyaW1BbGlnblZhbHVlOiBmdW5jdGlvbiggdmFsICkge1xuXHRcdGlmICggdmFsIDw9IHRoaXMuX3ZhbHVlTWluKCkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdmFsdWVNaW4oKTtcblx0XHR9XG5cdFx0aWYgKCB2YWwgPj0gdGhpcy5fdmFsdWVNYXgoKSApIHtcblx0XHRcdHJldHVybiB0aGlzLl92YWx1ZU1heCgpO1xuXHRcdH1cblx0XHR2YXIgc3RlcCA9ICggdGhpcy5vcHRpb25zLnN0ZXAgPiAwICkgPyB0aGlzLm9wdGlvbnMuc3RlcCA6IDEsXG5cdFx0XHR2YWxNb2RTdGVwID0gKCB2YWwgLSB0aGlzLl92YWx1ZU1pbigpICkgJSBzdGVwLFxuXHRcdFx0YWxpZ25WYWx1ZSA9IHZhbCAtIHZhbE1vZFN0ZXA7XG5cblx0XHRpZiAoIE1hdGguYWJzKCB2YWxNb2RTdGVwICkgKiAyID49IHN0ZXAgKSB7XG5cdFx0XHRhbGlnblZhbHVlICs9ICggdmFsTW9kU3RlcCA+IDAgKSA/IHN0ZXAgOiAoIC1zdGVwICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2luY2UgSmF2YVNjcmlwdCBoYXMgcHJvYmxlbXMgd2l0aCBsYXJnZSBmbG9hdHMsIHJvdW5kXG5cdFx0Ly8gdGhlIGZpbmFsIHZhbHVlIHRvIDUgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50IChzZWUgIzQxMjQpXG5cdFx0cmV0dXJuIHBhcnNlRmxvYXQoIGFsaWduVmFsdWUudG9GaXhlZCggNSApICk7XG5cdH0sXG5cblx0X2NhbGN1bGF0ZU5ld01heDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1heCA9IHRoaXMub3B0aW9ucy5tYXgsXG5cdFx0XHRtaW4gPSB0aGlzLl92YWx1ZU1pbigpLFxuXHRcdFx0c3RlcCA9IHRoaXMub3B0aW9ucy5zdGVwLFxuXHRcdFx0YWJvdmVNaW4gPSBNYXRoLnJvdW5kKCAoIG1heCAtIG1pbiApIC8gc3RlcCApICogc3RlcDtcblx0XHRtYXggPSBhYm92ZU1pbiArIG1pbjtcblx0XHRpZiAoIG1heCA+IHRoaXMub3B0aW9ucy5tYXggKSB7XG5cblx0XHRcdC8vSWYgbWF4IGlzIG5vdCBkaXZpc2libGUgYnkgc3RlcCwgcm91bmRpbmcgb2ZmIG1heSBpbmNyZWFzZSBpdHMgdmFsdWVcblx0XHRcdG1heCAtPSBzdGVwO1xuXHRcdH1cblx0XHR0aGlzLm1heCA9IHBhcnNlRmxvYXQoIG1heC50b0ZpeGVkKCB0aGlzLl9wcmVjaXNpb24oKSApICk7XG5cdH0sXG5cblx0X3ByZWNpc2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByZWNpc2lvbiA9IHRoaXMuX3ByZWNpc2lvbk9mKCB0aGlzLm9wdGlvbnMuc3RlcCApO1xuXHRcdGlmICggdGhpcy5vcHRpb25zLm1pbiAhPT0gbnVsbCApIHtcblx0XHRcdHByZWNpc2lvbiA9IE1hdGgubWF4KCBwcmVjaXNpb24sIHRoaXMuX3ByZWNpc2lvbk9mKCB0aGlzLm9wdGlvbnMubWluICkgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHByZWNpc2lvbjtcblx0fSxcblxuXHRfcHJlY2lzaW9uT2Y6IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0dmFyIHN0ciA9IG51bS50b1N0cmluZygpLFxuXHRcdFx0ZGVjaW1hbCA9IHN0ci5pbmRleE9mKCBcIi5cIiApO1xuXHRcdHJldHVybiBkZWNpbWFsID09PSAtMSA/IDAgOiBzdHIubGVuZ3RoIC0gZGVjaW1hbCAtIDE7XG5cdH0sXG5cblx0X3ZhbHVlTWluOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pbjtcblx0fSxcblxuXHRfdmFsdWVNYXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1heDtcblx0fSxcblxuXHRfcmVmcmVzaFJhbmdlOiBmdW5jdGlvbiggb3JpZW50YXRpb24gKSB7XG5cdFx0aWYgKCBvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICkge1xuXHRcdFx0dGhpcy5yYW5nZS5jc3MoIHsgXCJ3aWR0aFwiOiBcIlwiLCBcImxlZnRcIjogXCJcIiB9ICk7XG5cdFx0fVxuXHRcdGlmICggb3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICkge1xuXHRcdFx0dGhpcy5yYW5nZS5jc3MoIHsgXCJoZWlnaHRcIjogXCJcIiwgXCJib3R0b21cIjogXCJcIiB9ICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZWZyZXNoVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXN0VmFsUGVyY2VudCwgdmFsUGVyY2VudCwgdmFsdWUsIHZhbHVlTWluLCB2YWx1ZU1heCxcblx0XHRcdG9SYW5nZSA9IHRoaXMub3B0aW9ucy5yYW5nZSxcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdGFuaW1hdGUgPSAoICF0aGlzLl9hbmltYXRlT2ZmICkgPyBvLmFuaW1hdGUgOiBmYWxzZSxcblx0XHRcdF9zZXQgPSB7fTtcblxuXHRcdGlmICggdGhpcy5faGFzTXVsdGlwbGVWYWx1ZXMoKSApIHtcblx0XHRcdHRoaXMuaGFuZGxlcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0dmFsUGVyY2VudCA9ICggdGhhdC52YWx1ZXMoIGkgKSAtIHRoYXQuX3ZhbHVlTWluKCkgKSAvICggdGhhdC5fdmFsdWVNYXgoKSAtXG5cdFx0XHRcdFx0dGhhdC5fdmFsdWVNaW4oKSApICogMTAwO1xuXHRcdFx0XHRfc2V0WyB0aGF0Lm9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IFwibGVmdFwiIDogXCJib3R0b21cIiBdID0gdmFsUGVyY2VudCArIFwiJVwiO1xuXHRcdFx0XHQkKCB0aGlzICkuc3RvcCggMSwgMSApWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIF9zZXQsIG8uYW5pbWF0ZSApO1xuXHRcdFx0XHRpZiAoIHRoYXQub3B0aW9ucy5yYW5nZSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRpZiAoIHRoYXQub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICkge1xuXHRcdFx0XHRcdFx0aWYgKCBpID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHR0aGF0LnJhbmdlLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7XG5cdFx0XHRcdFx0XHRcdFx0bGVmdDogdmFsUGVyY2VudCArIFwiJVwiXG5cdFx0XHRcdFx0XHRcdH0sIG8uYW5pbWF0ZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBpID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHR0aGF0LnJhbmdlWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHtcblx0XHRcdFx0XHRcdFx0XHR3aWR0aDogKCB2YWxQZXJjZW50IC0gbGFzdFZhbFBlcmNlbnQgKSArIFwiJVwiXG5cdFx0XHRcdFx0XHRcdH0sIHtcblx0XHRcdFx0XHRcdFx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFx0ZHVyYXRpb246IG8uYW5pbWF0ZVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICggaSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0dGhhdC5yYW5nZS5zdG9wKCAxLCAxIClbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSgge1xuXHRcdFx0XHRcdFx0XHRcdGJvdHRvbTogKCB2YWxQZXJjZW50ICkgKyBcIiVcIlxuXHRcdFx0XHRcdFx0XHR9LCBvLmFuaW1hdGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggaSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0dGhhdC5yYW5nZVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7XG5cdFx0XHRcdFx0XHRcdFx0aGVpZ2h0OiAoIHZhbFBlcmNlbnQgLSBsYXN0VmFsUGVyY2VudCApICsgXCIlXCJcblx0XHRcdFx0XHRcdFx0fSwge1xuXHRcdFx0XHRcdFx0XHRcdHF1ZXVlOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRkdXJhdGlvbjogby5hbmltYXRlXG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bGFzdFZhbFBlcmNlbnQgPSB2YWxQZXJjZW50O1xuXHRcdFx0fSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMudmFsdWUoKTtcblx0XHRcdHZhbHVlTWluID0gdGhpcy5fdmFsdWVNaW4oKTtcblx0XHRcdHZhbHVlTWF4ID0gdGhpcy5fdmFsdWVNYXgoKTtcblx0XHRcdHZhbFBlcmNlbnQgPSAoIHZhbHVlTWF4ICE9PSB2YWx1ZU1pbiApID9cblx0XHRcdFx0XHQoIHZhbHVlIC0gdmFsdWVNaW4gKSAvICggdmFsdWVNYXggLSB2YWx1ZU1pbiApICogMTAwIDpcblx0XHRcdFx0XHQwO1xuXHRcdFx0X3NldFsgdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcImxlZnRcIiA6IFwiYm90dG9tXCIgXSA9IHZhbFBlcmNlbnQgKyBcIiVcIjtcblx0XHRcdHRoaXMuaGFuZGxlLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCBfc2V0LCBvLmFuaW1hdGUgKTtcblxuXHRcdFx0aWYgKCBvUmFuZ2UgPT09IFwibWluXCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgKSB7XG5cdFx0XHRcdHRoaXMucmFuZ2Uuc3RvcCggMSwgMSApWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHtcblx0XHRcdFx0XHR3aWR0aDogdmFsUGVyY2VudCArIFwiJVwiXG5cdFx0XHRcdH0sIG8uYW5pbWF0ZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvUmFuZ2UgPT09IFwibWF4XCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgKSB7XG5cdFx0XHRcdHRoaXMucmFuZ2Uuc3RvcCggMSwgMSApWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHtcblx0XHRcdFx0XHR3aWR0aDogKCAxMDAgLSB2YWxQZXJjZW50ICkgKyBcIiVcIlxuXHRcdFx0XHR9LCBvLmFuaW1hdGUgKTtcblx0XHRcdH1cblx0XHRcdGlmICggb1JhbmdlID09PSBcIm1pblwiICYmIHRoaXMub3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiApIHtcblx0XHRcdFx0dGhpcy5yYW5nZS5zdG9wKCAxLCAxIClbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSgge1xuXHRcdFx0XHRcdGhlaWdodDogdmFsUGVyY2VudCArIFwiJVwiXG5cdFx0XHRcdH0sIG8uYW5pbWF0ZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvUmFuZ2UgPT09IFwibWF4XCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICkge1xuXHRcdFx0XHR0aGlzLnJhbmdlLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7XG5cdFx0XHRcdFx0aGVpZ2h0OiAoIDEwMCAtIHZhbFBlcmNlbnQgKSArIFwiJVwiXG5cdFx0XHRcdH0sIG8uYW5pbWF0ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlRXZlbnRzOiB7XG5cdFx0a2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIGFsbG93ZWQsIGN1clZhbCwgbmV3VmFsLCBzdGVwLFxuXHRcdFx0XHRpbmRleCA9ICQoIGV2ZW50LnRhcmdldCApLmRhdGEoIFwidWktc2xpZGVyLWhhbmRsZS1pbmRleFwiICk7XG5cblx0XHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkhPTUU6XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkVORDpcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9VUDpcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5VUDpcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUklHSFQ6XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkRPV046XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkxFRlQ6XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRpZiAoICF0aGlzLl9rZXlTbGlkaW5nICkge1xuXHRcdFx0XHRcdFx0dGhpcy5fa2V5U2xpZGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRDbGFzcyggJCggZXZlbnQudGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0XHRcdGFsbG93ZWQgPSB0aGlzLl9zdGFydCggZXZlbnQsIGluZGV4ICk7XG5cdFx0XHRcdFx0XHRpZiAoIGFsbG93ZWQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRzdGVwID0gdGhpcy5vcHRpb25zLnN0ZXA7XG5cdFx0XHRpZiAoIHRoaXMuX2hhc011bHRpcGxlVmFsdWVzKCkgKSB7XG5cdFx0XHRcdGN1clZhbCA9IG5ld1ZhbCA9IHRoaXMudmFsdWVzKCBpbmRleCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VyVmFsID0gbmV3VmFsID0gdGhpcy52YWx1ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5IT01FOlxuXHRcdFx0XHRcdG5ld1ZhbCA9IHRoaXMuX3ZhbHVlTWluKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkVORDpcblx0XHRcdFx0XHRuZXdWYWwgPSB0aGlzLl92YWx1ZU1heCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5QQUdFX1VQOlxuXHRcdFx0XHRcdG5ld1ZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKFxuXHRcdFx0XHRcdFx0Y3VyVmFsICsgKCAoIHRoaXMuX3ZhbHVlTWF4KCkgLSB0aGlzLl92YWx1ZU1pbigpICkgLyB0aGlzLm51bVBhZ2VzIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5QQUdFX0RPV046XG5cdFx0XHRcdFx0bmV3VmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoXG5cdFx0XHRcdFx0XHRjdXJWYWwgLSAoICggdGhpcy5fdmFsdWVNYXgoKSAtIHRoaXMuX3ZhbHVlTWluKCkgKSAvIHRoaXMubnVtUGFnZXMgKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5VUDpcblx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUklHSFQ6XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWwgPT09IHRoaXMuX3ZhbHVlTWF4KCkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1ZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCBjdXJWYWwgKyBzdGVwICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkRPV046XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkxFRlQ6XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWwgPT09IHRoaXMuX3ZhbHVlTWluKCkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1ZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCBjdXJWYWwgLSBzdGVwICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NsaWRlKCBldmVudCwgaW5kZXgsIG5ld1ZhbCApO1xuXHRcdH0sXG5cdFx0a2V5dXA6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBpbmRleCA9ICQoIGV2ZW50LnRhcmdldCApLmRhdGEoIFwidWktc2xpZGVyLWhhbmRsZS1pbmRleFwiICk7XG5cblx0XHRcdGlmICggdGhpcy5fa2V5U2xpZGluZyApIHtcblx0XHRcdFx0dGhpcy5fa2V5U2xpZGluZyA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9zdG9wKCBldmVudCwgaW5kZXggKTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlKCBldmVudCwgaW5kZXggKTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoICQoIGV2ZW50LnRhcmdldCApLCBudWxsLCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgU29ydGFibGUgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IFNvcnRhYmxlXG4vLz4+Z3JvdXA6IEludGVyYWN0aW9uc1xuLy8+PmRlc2NyaXB0aW9uOiBFbmFibGVzIGl0ZW1zIGluIGEgbGlzdCB0byBiZSBzb3J0ZWQgdXNpbmcgdGhlIG1vdXNlLlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3NvcnRhYmxlL1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL3NvcnRhYmxlL1xuLy8+PmNzcy5zdHJ1Y3R1cmU6IC4uLy4uL3RoZW1lcy9iYXNlL3NvcnRhYmxlLmNzc1xuXG5cblxudmFyIHdpZGdldHNTb3J0YWJsZSA9ICQud2lkZ2V0KCBcInVpLnNvcnRhYmxlXCIsICQudWkubW91c2UsIHtcblx0dmVyc2lvbjogXCIxLjEyLjFcIixcblx0d2lkZ2V0RXZlbnRQcmVmaXg6IFwic29ydFwiLFxuXHRyZWFkeTogZmFsc2UsXG5cdG9wdGlvbnM6IHtcblx0XHRhcHBlbmRUbzogXCJwYXJlbnRcIixcblx0XHRheGlzOiBmYWxzZSxcblx0XHRjb25uZWN0V2l0aDogZmFsc2UsXG5cdFx0Y29udGFpbm1lbnQ6IGZhbHNlLFxuXHRcdGN1cnNvcjogXCJhdXRvXCIsXG5cdFx0Y3Vyc29yQXQ6IGZhbHNlLFxuXHRcdGRyb3BPbkVtcHR5OiB0cnVlLFxuXHRcdGZvcmNlUGxhY2Vob2xkZXJTaXplOiBmYWxzZSxcblx0XHRmb3JjZUhlbHBlclNpemU6IGZhbHNlLFxuXHRcdGdyaWQ6IGZhbHNlLFxuXHRcdGhhbmRsZTogZmFsc2UsXG5cdFx0aGVscGVyOiBcIm9yaWdpbmFsXCIsXG5cdFx0aXRlbXM6IFwiPiAqXCIsXG5cdFx0b3BhY2l0eTogZmFsc2UsXG5cdFx0cGxhY2Vob2xkZXI6IGZhbHNlLFxuXHRcdHJldmVydDogZmFsc2UsXG5cdFx0c2Nyb2xsOiB0cnVlLFxuXHRcdHNjcm9sbFNlbnNpdGl2aXR5OiAyMCxcblx0XHRzY3JvbGxTcGVlZDogMjAsXG5cdFx0c2NvcGU6IFwiZGVmYXVsdFwiLFxuXHRcdHRvbGVyYW5jZTogXCJpbnRlcnNlY3RcIixcblx0XHR6SW5kZXg6IDEwMDAsXG5cblx0XHQvLyBDYWxsYmFja3Ncblx0XHRhY3RpdmF0ZTogbnVsbCxcblx0XHRiZWZvcmVTdG9wOiBudWxsLFxuXHRcdGNoYW5nZTogbnVsbCxcblx0XHRkZWFjdGl2YXRlOiBudWxsLFxuXHRcdG91dDogbnVsbCxcblx0XHRvdmVyOiBudWxsLFxuXHRcdHJlY2VpdmU6IG51bGwsXG5cdFx0cmVtb3ZlOiBudWxsLFxuXHRcdHNvcnQ6IG51bGwsXG5cdFx0c3RhcnQ6IG51bGwsXG5cdFx0c3RvcDogbnVsbCxcblx0XHR1cGRhdGU6IG51bGxcblx0fSxcblxuXHRfaXNPdmVyQXhpczogZnVuY3Rpb24oIHgsIHJlZmVyZW5jZSwgc2l6ZSApIHtcblx0XHRyZXR1cm4gKCB4ID49IHJlZmVyZW5jZSApICYmICggeCA8ICggcmVmZXJlbmNlICsgc2l6ZSApICk7XG5cdH0sXG5cblx0X2lzRmxvYXRpbmc6IGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdHJldHVybiAoIC9sZWZ0fHJpZ2h0LyApLnRlc3QoIGl0ZW0uY3NzKCBcImZsb2F0XCIgKSApIHx8XG5cdFx0XHQoIC9pbmxpbmV8dGFibGUtY2VsbC8gKS50ZXN0KCBpdGVtLmNzcyggXCJkaXNwbGF5XCIgKSApO1xuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY29udGFpbmVyQ2FjaGUgPSB7fTtcblx0XHR0aGlzLl9hZGRDbGFzcyggXCJ1aS1zb3J0YWJsZVwiICk7XG5cblx0XHQvL0dldCB0aGUgaXRlbXNcblx0XHR0aGlzLnJlZnJlc2goKTtcblxuXHRcdC8vTGV0J3MgZGV0ZXJtaW5lIHRoZSBwYXJlbnQncyBvZmZzZXRcblx0XHR0aGlzLm9mZnNldCA9IHRoaXMuZWxlbWVudC5vZmZzZXQoKTtcblxuXHRcdC8vSW5pdGlhbGl6ZSBtb3VzZSBldmVudHMgZm9yIGludGVyYWN0aW9uXG5cdFx0dGhpcy5fbW91c2VJbml0KCk7XG5cblx0XHR0aGlzLl9zZXRIYW5kbGVDbGFzc05hbWUoKTtcblxuXHRcdC8vV2UncmUgcmVhZHkgdG8gZ29cblx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcblxuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJoYW5kbGVcIiApIHtcblx0XHRcdHRoaXMuX3NldEhhbmRsZUNsYXNzTmFtZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0SGFuZGxlQ2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIHRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1zb3J0YWJsZS1oYW5kbGVcIiApLCBcInVpLXNvcnRhYmxlLWhhbmRsZVwiICk7XG5cdFx0JC5lYWNoKCB0aGlzLml0ZW1zLCBmdW5jdGlvbigpIHtcblx0XHRcdHRoYXQuX2FkZENsYXNzKFxuXHRcdFx0XHR0aGlzLmluc3RhbmNlLm9wdGlvbnMuaGFuZGxlID9cblx0XHRcdFx0XHR0aGlzLml0ZW0uZmluZCggdGhpcy5pbnN0YW5jZS5vcHRpb25zLmhhbmRsZSApIDpcblx0XHRcdFx0XHR0aGlzLml0ZW0sXG5cdFx0XHRcdFwidWktc29ydGFibGUtaGFuZGxlXCJcblx0XHRcdCk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9tb3VzZURlc3Ryb3koKTtcblxuXHRcdGZvciAoIHZhciBpID0gdGhpcy5pdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcblx0XHRcdHRoaXMuaXRlbXNbIGkgXS5pdGVtLnJlbW92ZURhdGEoIHRoaXMud2lkZ2V0TmFtZSArIFwiLWl0ZW1cIiApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9tb3VzZUNhcHR1cmU6IGZ1bmN0aW9uKCBldmVudCwgb3ZlcnJpZGVIYW5kbGUgKSB7XG5cdFx0dmFyIGN1cnJlbnRJdGVtID0gbnVsbCxcblx0XHRcdHZhbGlkSGFuZGxlID0gZmFsc2UsXG5cdFx0XHR0aGF0ID0gdGhpcztcblxuXHRcdGlmICggdGhpcy5yZXZlcnRpbmcgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy5vcHRpb25zLnR5cGUgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly9XZSBoYXZlIHRvIHJlZnJlc2ggdGhlIGl0ZW1zIGRhdGEgb25jZSBmaXJzdFxuXHRcdHRoaXMuX3JlZnJlc2hJdGVtcyggZXZlbnQgKTtcblxuXHRcdC8vRmluZCBvdXQgaWYgdGhlIGNsaWNrZWQgbm9kZSAob3Igb25lIG9mIGl0cyBwYXJlbnRzKSBpcyBhIGFjdHVhbCBpdGVtIGluIHRoaXMuaXRlbXNcblx0XHQkKCBldmVudC50YXJnZXQgKS5wYXJlbnRzKCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICQuZGF0YSggdGhpcywgdGhhdC53aWRnZXROYW1lICsgXCItaXRlbVwiICkgPT09IHRoYXQgKSB7XG5cdFx0XHRcdGN1cnJlbnRJdGVtID0gJCggdGhpcyApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdGlmICggJC5kYXRhKCBldmVudC50YXJnZXQsIHRoYXQud2lkZ2V0TmFtZSArIFwiLWl0ZW1cIiApID09PSB0aGF0ICkge1xuXHRcdFx0Y3VycmVudEl0ZW0gPSAkKCBldmVudC50YXJnZXQgKTtcblx0XHR9XG5cblx0XHRpZiAoICFjdXJyZW50SXRlbSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuaGFuZGxlICYmICFvdmVycmlkZUhhbmRsZSApIHtcblx0XHRcdCQoIHRoaXMub3B0aW9ucy5oYW5kbGUsIGN1cnJlbnRJdGVtICkuZmluZCggXCIqXCIgKS5hZGRCYWNrKCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0XHRcdHZhbGlkSGFuZGxlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0aWYgKCAhdmFsaWRIYW5kbGUgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmN1cnJlbnRJdGVtID0gY3VycmVudEl0ZW07XG5cdFx0dGhpcy5fcmVtb3ZlQ3VycmVudHNGcm9tSXRlbXMoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdF9tb3VzZVN0YXJ0OiBmdW5jdGlvbiggZXZlbnQsIG92ZXJyaWRlSGFuZGxlLCBub0FjdGl2YXRpb24gKSB7XG5cblx0XHR2YXIgaSwgYm9keSxcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLmN1cnJlbnRDb250YWluZXIgPSB0aGlzO1xuXG5cdFx0Ly9XZSBvbmx5IG5lZWQgdG8gY2FsbCByZWZyZXNoUG9zaXRpb25zLCBiZWNhdXNlIHRoZSByZWZyZXNoSXRlbXMgY2FsbCBoYXMgYmVlbiBtb3ZlZCB0b1xuXHRcdC8vIG1vdXNlQ2FwdHVyZVxuXHRcdHRoaXMucmVmcmVzaFBvc2l0aW9ucygpO1xuXG5cdFx0Ly9DcmVhdGUgYW5kIGFwcGVuZCB0aGUgdmlzaWJsZSBoZWxwZXJcblx0XHR0aGlzLmhlbHBlciA9IHRoaXMuX2NyZWF0ZUhlbHBlciggZXZlbnQgKTtcblxuXHRcdC8vQ2FjaGUgdGhlIGhlbHBlciBzaXplXG5cdFx0dGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO1xuXG5cdFx0Lypcblx0XHQgKiAtIFBvc2l0aW9uIGdlbmVyYXRpb24gLVxuXHRcdCAqIFRoaXMgYmxvY2sgZ2VuZXJhdGVzIGV2ZXJ5dGhpbmcgcG9zaXRpb24gcmVsYXRlZCAtIGl0J3MgdGhlIGNvcmUgb2YgZHJhZ2dhYmxlcy5cblx0XHQgKi9cblxuXHRcdC8vQ2FjaGUgdGhlIG1hcmdpbnMgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnRcblx0XHR0aGlzLl9jYWNoZU1hcmdpbnMoKTtcblxuXHRcdC8vR2V0IHRoZSBuZXh0IHNjcm9sbGluZyBwYXJlbnRcblx0XHR0aGlzLnNjcm9sbFBhcmVudCA9IHRoaXMuaGVscGVyLnNjcm9sbFBhcmVudCgpO1xuXG5cdFx0Ly9UaGUgZWxlbWVudCdzIGFic29sdXRlIHBvc2l0aW9uIG9uIHRoZSBwYWdlIG1pbnVzIG1hcmdpbnNcblx0XHR0aGlzLm9mZnNldCA9IHRoaXMuY3VycmVudEl0ZW0ub2Zmc2V0KCk7XG5cdFx0dGhpcy5vZmZzZXQgPSB7XG5cdFx0XHR0b3A6IHRoaXMub2Zmc2V0LnRvcCAtIHRoaXMubWFyZ2lucy50b3AsXG5cdFx0XHRsZWZ0OiB0aGlzLm9mZnNldC5sZWZ0IC0gdGhpcy5tYXJnaW5zLmxlZnRcblx0XHR9O1xuXG5cdFx0JC5leHRlbmQoIHRoaXMub2Zmc2V0LCB7XG5cdFx0XHRjbGljazogeyAvL1doZXJlIHRoZSBjbGljayBoYXBwZW5lZCwgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnRcblx0XHRcdFx0bGVmdDogZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5sZWZ0LFxuXHRcdFx0XHR0b3A6IGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQudG9wXG5cdFx0XHR9LFxuXHRcdFx0cGFyZW50OiB0aGlzLl9nZXRQYXJlbnRPZmZzZXQoKSxcblxuXHRcdFx0Ly8gVGhpcyBpcyBhIHJlbGF0aXZlIHRvIGFic29sdXRlIHBvc2l0aW9uIG1pbnVzIHRoZSBhY3R1YWwgcG9zaXRpb24gY2FsY3VsYXRpb24gLVxuXHRcdFx0Ly8gb25seSB1c2VkIGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIGhlbHBlclxuXHRcdFx0cmVsYXRpdmU6IHRoaXMuX2dldFJlbGF0aXZlT2Zmc2V0KClcblx0XHR9ICk7XG5cblx0XHQvLyBPbmx5IGFmdGVyIHdlIGdvdCB0aGUgb2Zmc2V0LCB3ZSBjYW4gY2hhbmdlIHRoZSBoZWxwZXIncyBwb3NpdGlvbiB0byBhYnNvbHV0ZVxuXHRcdC8vIFRPRE86IFN0aWxsIG5lZWQgdG8gZmlndXJlIG91dCBhIHdheSB0byBtYWtlIHJlbGF0aXZlIHNvcnRpbmcgcG9zc2libGVcblx0XHR0aGlzLmhlbHBlci5jc3MoIFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiICk7XG5cdFx0dGhpcy5jc3NQb3NpdGlvbiA9IHRoaXMuaGVscGVyLmNzcyggXCJwb3NpdGlvblwiICk7XG5cblx0XHQvL0dlbmVyYXRlIHRoZSBvcmlnaW5hbCBwb3NpdGlvblxuXHRcdHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oIGV2ZW50ICk7XG5cdFx0dGhpcy5vcmlnaW5hbFBhZ2VYID0gZXZlbnQucGFnZVg7XG5cdFx0dGhpcy5vcmlnaW5hbFBhZ2VZID0gZXZlbnQucGFnZVk7XG5cblx0XHQvL0FkanVzdCB0aGUgbW91c2Ugb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBoZWxwZXIgaWYgXCJjdXJzb3JBdFwiIGlzIHN1cHBsaWVkXG5cdFx0KCBvLmN1cnNvckF0ICYmIHRoaXMuX2FkanVzdE9mZnNldEZyb21IZWxwZXIoIG8uY3Vyc29yQXQgKSApO1xuXG5cdFx0Ly9DYWNoZSB0aGUgZm9ybWVyIERPTSBwb3NpdGlvblxuXHRcdHRoaXMuZG9tUG9zaXRpb24gPSB7XG5cdFx0XHRwcmV2OiB0aGlzLmN1cnJlbnRJdGVtLnByZXYoKVsgMCBdLFxuXHRcdFx0cGFyZW50OiB0aGlzLmN1cnJlbnRJdGVtLnBhcmVudCgpWyAwIF1cblx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGhlbHBlciBpcyBub3QgdGhlIG9yaWdpbmFsLCBoaWRlIHRoZSBvcmlnaW5hbCBzbyBpdCdzIG5vdCBwbGF5aW5nIGFueSByb2xlIGR1cmluZ1xuXHRcdC8vIHRoZSBkcmFnLCB3b24ndCBjYXVzZSBhbnl0aGluZyBiYWQgdGhpcyB3YXlcblx0XHRpZiAoIHRoaXMuaGVscGVyWyAwIF0gIT09IHRoaXMuY3VycmVudEl0ZW1bIDAgXSApIHtcblx0XHRcdHRoaXMuY3VycmVudEl0ZW0uaGlkZSgpO1xuXHRcdH1cblxuXHRcdC8vQ3JlYXRlIHRoZSBwbGFjZWhvbGRlclxuXHRcdHRoaXMuX2NyZWF0ZVBsYWNlaG9sZGVyKCk7XG5cblx0XHQvL1NldCBhIGNvbnRhaW5tZW50IGlmIGdpdmVuIGluIHRoZSBvcHRpb25zXG5cdFx0aWYgKCBvLmNvbnRhaW5tZW50ICkge1xuXHRcdFx0dGhpcy5fc2V0Q29udGFpbm1lbnQoKTtcblx0XHR9XG5cblx0XHRpZiAoIG8uY3Vyc29yICYmIG8uY3Vyc29yICE9PSBcImF1dG9cIiApIHsgLy8gY3Vyc29yIG9wdGlvblxuXHRcdFx0Ym9keSA9IHRoaXMuZG9jdW1lbnQuZmluZCggXCJib2R5XCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUVcblx0XHRcdHRoaXMuc3RvcmVkQ3Vyc29yID0gYm9keS5jc3MoIFwiY3Vyc29yXCIgKTtcblx0XHRcdGJvZHkuY3NzKCBcImN1cnNvclwiLCBvLmN1cnNvciApO1xuXG5cdFx0XHR0aGlzLnN0b3JlZFN0eWxlc2hlZXQgPVxuXHRcdFx0XHQkKCBcIjxzdHlsZT4qeyBjdXJzb3I6IFwiICsgby5jdXJzb3IgKyBcIiAhaW1wb3J0YW50OyB9PC9zdHlsZT5cIiApLmFwcGVuZFRvKCBib2R5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvLm9wYWNpdHkgKSB7IC8vIG9wYWNpdHkgb3B0aW9uXG5cdFx0XHRpZiAoIHRoaXMuaGVscGVyLmNzcyggXCJvcGFjaXR5XCIgKSApIHtcblx0XHRcdFx0dGhpcy5fc3RvcmVkT3BhY2l0eSA9IHRoaXMuaGVscGVyLmNzcyggXCJvcGFjaXR5XCIgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaGVscGVyLmNzcyggXCJvcGFjaXR5XCIsIG8ub3BhY2l0eSApO1xuXHRcdH1cblxuXHRcdGlmICggby56SW5kZXggKSB7IC8vIHpJbmRleCBvcHRpb25cblx0XHRcdGlmICggdGhpcy5oZWxwZXIuY3NzKCBcInpJbmRleFwiICkgKSB7XG5cdFx0XHRcdHRoaXMuX3N0b3JlZFpJbmRleCA9IHRoaXMuaGVscGVyLmNzcyggXCJ6SW5kZXhcIiApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5oZWxwZXIuY3NzKCBcInpJbmRleFwiLCBvLnpJbmRleCApO1xuXHRcdH1cblxuXHRcdC8vUHJlcGFyZSBzY3JvbGxpbmdcblx0XHRpZiAoIHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0gIT09IHRoaXMuZG9jdW1lbnRbIDAgXSAmJlxuXHRcdFx0XHR0aGlzLnNjcm9sbFBhcmVudFsgMCBdLnRhZ05hbWUgIT09IFwiSFRNTFwiICkge1xuXHRcdFx0dGhpcy5vdmVyZmxvd09mZnNldCA9IHRoaXMuc2Nyb2xsUGFyZW50Lm9mZnNldCgpO1xuXHRcdH1cblxuXHRcdC8vQ2FsbCBjYWxsYmFja3Ncblx0XHR0aGlzLl90cmlnZ2VyKCBcInN0YXJ0XCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSApO1xuXG5cdFx0Ly9SZWNhY2hlIHRoZSBoZWxwZXIgc2l6ZVxuXHRcdGlmICggIXRoaXMuX3ByZXNlcnZlSGVscGVyUHJvcG9ydGlvbnMgKSB7XG5cdFx0XHR0aGlzLl9jYWNoZUhlbHBlclByb3BvcnRpb25zKCk7XG5cdFx0fVxuXG5cdFx0Ly9Qb3N0IFwiYWN0aXZhdGVcIiBldmVudHMgdG8gcG9zc2libGUgY29udGFpbmVyc1xuXHRcdGlmICggIW5vQWN0aXZhdGlvbiApIHtcblx0XHRcdGZvciAoIGkgPSB0aGlzLmNvbnRhaW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG5cdFx0XHRcdHRoaXMuY29udGFpbmVyc1sgaSBdLl90cmlnZ2VyKCBcImFjdGl2YXRlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goIHRoaXMgKSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vUHJlcGFyZSBwb3NzaWJsZSBkcm9wcGFibGVzXG5cdFx0aWYgKCAkLnVpLmRkbWFuYWdlciApIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLmN1cnJlbnQgPSB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICggJC51aS5kZG1hbmFnZXIgJiYgIW8uZHJvcEJlaGF2aW91ciApIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuXG5cdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMuaGVscGVyLCBcInVpLXNvcnRhYmxlLWhlbHBlclwiICk7XG5cblx0XHQvLyBFeGVjdXRlIHRoZSBkcmFnIG9uY2UgLSB0aGlzIGNhdXNlcyB0aGUgaGVscGVyIG5vdCB0byBiZSB2aXNpYmxlYmVmb3JlIGdldHRpbmcgaXRzXG5cdFx0Ly8gY29ycmVjdCBwb3NpdGlvblxuXHRcdHRoaXMuX21vdXNlRHJhZyggZXZlbnQgKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdF9tb3VzZURyYWc6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgaSwgaXRlbSwgaXRlbUVsZW1lbnQsIGludGVyc2VjdGlvbixcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRzY3JvbGxlZCA9IGZhbHNlO1xuXG5cdFx0Ly9Db21wdXRlIHRoZSBoZWxwZXJzIHBvc2l0aW9uXG5cdFx0dGhpcy5wb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oIGV2ZW50ICk7XG5cdFx0dGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuX2NvbnZlcnRQb3NpdGlvblRvKCBcImFic29sdXRlXCIgKTtcblxuXHRcdGlmICggIXRoaXMubGFzdFBvc2l0aW9uQWJzICkge1xuXHRcdFx0dGhpcy5sYXN0UG9zaXRpb25BYnMgPSB0aGlzLnBvc2l0aW9uQWJzO1xuXHRcdH1cblxuXHRcdC8vRG8gc2Nyb2xsaW5nXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2Nyb2xsICkge1xuXHRcdFx0aWYgKCB0aGlzLnNjcm9sbFBhcmVudFsgMCBdICE9PSB0aGlzLmRvY3VtZW50WyAwIF0gJiZcblx0XHRcdFx0XHR0aGlzLnNjcm9sbFBhcmVudFsgMCBdLnRhZ05hbWUgIT09IFwiSFRNTFwiICkge1xuXG5cdFx0XHRcdGlmICggKCB0aGlzLm92ZXJmbG93T2Zmc2V0LnRvcCArIHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0ub2Zmc2V0SGVpZ2h0ICkgLVxuXHRcdFx0XHRcdFx0ZXZlbnQucGFnZVkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5ICkge1xuXHRcdFx0XHRcdHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0uc2Nyb2xsVG9wID1cblx0XHRcdFx0XHRcdHNjcm9sbGVkID0gdGhpcy5zY3JvbGxQYXJlbnRbIDAgXS5zY3JvbGxUb3AgKyBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBldmVudC5wYWdlWSAtIHRoaXMub3ZlcmZsb3dPZmZzZXQudG9wIDwgby5zY3JvbGxTZW5zaXRpdml0eSApIHtcblx0XHRcdFx0XHR0aGlzLnNjcm9sbFBhcmVudFsgMCBdLnNjcm9sbFRvcCA9XG5cdFx0XHRcdFx0XHRzY3JvbGxlZCA9IHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0uc2Nyb2xsVG9wIC0gby5zY3JvbGxTcGVlZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggKCB0aGlzLm92ZXJmbG93T2Zmc2V0LmxlZnQgKyB0aGlzLnNjcm9sbFBhcmVudFsgMCBdLm9mZnNldFdpZHRoICkgLVxuXHRcdFx0XHRcdFx0ZXZlbnQucGFnZVggPCBvLnNjcm9sbFNlbnNpdGl2aXR5ICkge1xuXHRcdFx0XHRcdHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0uc2Nyb2xsTGVmdCA9IHNjcm9sbGVkID1cblx0XHRcdFx0XHRcdHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0uc2Nyb2xsTGVmdCArIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGV2ZW50LnBhZ2VYIC0gdGhpcy5vdmVyZmxvd09mZnNldC5sZWZ0IDwgby5zY3JvbGxTZW5zaXRpdml0eSApIHtcblx0XHRcdFx0XHR0aGlzLnNjcm9sbFBhcmVudFsgMCBdLnNjcm9sbExlZnQgPSBzY3JvbGxlZCA9XG5cdFx0XHRcdFx0XHR0aGlzLnNjcm9sbFBhcmVudFsgMCBdLnNjcm9sbExlZnQgLSBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBldmVudC5wYWdlWSAtIHRoaXMuZG9jdW1lbnQuc2Nyb2xsVG9wKCkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5ICkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gdGhpcy5kb2N1bWVudC5zY3JvbGxUb3AoIHRoaXMuZG9jdW1lbnQuc2Nyb2xsVG9wKCkgLSBvLnNjcm9sbFNwZWVkICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMud2luZG93LmhlaWdodCgpIC0gKCBldmVudC5wYWdlWSAtIHRoaXMuZG9jdW1lbnQuc2Nyb2xsVG9wKCkgKSA8XG5cdFx0XHRcdFx0XHRvLnNjcm9sbFNlbnNpdGl2aXR5ICkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gdGhpcy5kb2N1bWVudC5zY3JvbGxUb3AoIHRoaXMuZG9jdW1lbnQuc2Nyb2xsVG9wKCkgKyBvLnNjcm9sbFNwZWVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGV2ZW50LnBhZ2VYIC0gdGhpcy5kb2N1bWVudC5zY3JvbGxMZWZ0KCkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5ICkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gdGhpcy5kb2N1bWVudC5zY3JvbGxMZWZ0KFxuXHRcdFx0XHRcdFx0dGhpcy5kb2N1bWVudC5zY3JvbGxMZWZ0KCkgLSBvLnNjcm9sbFNwZWVkXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy53aW5kb3cud2lkdGgoKSAtICggZXZlbnQucGFnZVggLSB0aGlzLmRvY3VtZW50LnNjcm9sbExlZnQoKSApIDxcblx0XHRcdFx0XHRcdG8uc2Nyb2xsU2Vuc2l0aXZpdHkgKSB7XG5cdFx0XHRcdFx0c2Nyb2xsZWQgPSB0aGlzLmRvY3VtZW50LnNjcm9sbExlZnQoXG5cdFx0XHRcdFx0XHR0aGlzLmRvY3VtZW50LnNjcm9sbExlZnQoKSArIG8uc2Nyb2xsU3BlZWRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzY3JvbGxlZCAhPT0gZmFsc2UgJiYgJC51aS5kZG1hbmFnZXIgJiYgIW8uZHJvcEJlaGF2aW91ciApIHtcblx0XHRcdFx0JC51aS5kZG1hbmFnZXIucHJlcGFyZU9mZnNldHMoIHRoaXMsIGV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9SZWdlbmVyYXRlIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiB1c2VkIGZvciBwb3NpdGlvbiBjaGVja3Ncblx0XHR0aGlzLnBvc2l0aW9uQWJzID0gdGhpcy5fY29udmVydFBvc2l0aW9uVG8oIFwiYWJzb2x1dGVcIiApO1xuXG5cdFx0Ly9TZXQgdGhlIGhlbHBlciBwb3NpdGlvblxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5heGlzIHx8IHRoaXMub3B0aW9ucy5heGlzICE9PSBcInlcIiApIHtcblx0XHRcdHRoaXMuaGVscGVyWyAwIF0uc3R5bGUubGVmdCA9IHRoaXMucG9zaXRpb24ubGVmdCArIFwicHhcIjtcblx0XHR9XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmF4aXMgfHwgdGhpcy5vcHRpb25zLmF4aXMgIT09IFwieFwiICkge1xuXHRcdFx0dGhpcy5oZWxwZXJbIDAgXS5zdHlsZS50b3AgPSB0aGlzLnBvc2l0aW9uLnRvcCArIFwicHhcIjtcblx0XHR9XG5cblx0XHQvL1JlYXJyYW5nZVxuXHRcdGZvciAoIGkgPSB0aGlzLml0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuXG5cdFx0XHQvL0NhY2hlIHZhcmlhYmxlcyBhbmQgaW50ZXJzZWN0aW9uLCBjb250aW51ZSBpZiBubyBpbnRlcnNlY3Rpb25cblx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zWyBpIF07XG5cdFx0XHRpdGVtRWxlbWVudCA9IGl0ZW0uaXRlbVsgMCBdO1xuXHRcdFx0aW50ZXJzZWN0aW9uID0gdGhpcy5faW50ZXJzZWN0c1dpdGhQb2ludGVyKCBpdGVtICk7XG5cdFx0XHRpZiAoICFpbnRlcnNlY3Rpb24gKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IHB1dCB0aGUgcGxhY2Vob2xkZXIgaW5zaWRlIHRoZSBjdXJyZW50IENvbnRhaW5lciwgc2tpcCBhbGxcblx0XHRcdC8vIGl0ZW1zIGZyb20gb3RoZXIgY29udGFpbmVycy4gVGhpcyB3b3JrcyBiZWNhdXNlIHdoZW4gbW92aW5nXG5cdFx0XHQvLyBhbiBpdGVtIGZyb20gb25lIGNvbnRhaW5lciB0byBhbm90aGVyIHRoZVxuXHRcdFx0Ly8gY3VycmVudENvbnRhaW5lciBpcyBzd2l0Y2hlZCBiZWZvcmUgdGhlIHBsYWNlaG9sZGVyIGlzIG1vdmVkLlxuXHRcdFx0Ly9cblx0XHRcdC8vIFdpdGhvdXQgdGhpcywgbW92aW5nIGl0ZW1zIGluIFwic3ViLXNvcnRhYmxlc1wiIGNhbiBjYXVzZVxuXHRcdFx0Ly8gdGhlIHBsYWNlaG9sZGVyIHRvIGppdHRlciBiZXR3ZWVuIHRoZSBvdXRlciBhbmQgaW5uZXIgY29udGFpbmVyLlxuXHRcdFx0aWYgKCBpdGVtLmluc3RhbmNlICE9PSB0aGlzLmN1cnJlbnRDb250YWluZXIgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYW5ub3QgaW50ZXJzZWN0IHdpdGggaXRzZWxmXG5cdFx0XHQvLyBubyB1c2VsZXNzIGFjdGlvbnMgdGhhdCBoYXZlIGJlZW4gZG9uZSBiZWZvcmVcblx0XHRcdC8vIG5vIGFjdGlvbiBpZiB0aGUgaXRlbSBtb3ZlZCBpcyB0aGUgcGFyZW50IG9mIHRoZSBpdGVtIGNoZWNrZWRcblx0XHRcdGlmICggaXRlbUVsZW1lbnQgIT09IHRoaXMuY3VycmVudEl0ZW1bIDAgXSAmJlxuXHRcdFx0XHR0aGlzLnBsYWNlaG9sZGVyWyBpbnRlcnNlY3Rpb24gPT09IDEgPyBcIm5leHRcIiA6IFwicHJldlwiIF0oKVsgMCBdICE9PSBpdGVtRWxlbWVudCAmJlxuXHRcdFx0XHQhJC5jb250YWlucyggdGhpcy5wbGFjZWhvbGRlclsgMCBdLCBpdGVtRWxlbWVudCApICYmXG5cdFx0XHRcdCggdGhpcy5vcHRpb25zLnR5cGUgPT09IFwic2VtaS1keW5hbWljXCIgP1xuXHRcdFx0XHRcdCEkLmNvbnRhaW5zKCB0aGlzLmVsZW1lbnRbIDAgXSwgaXRlbUVsZW1lbnQgKSA6XG5cdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHQpXG5cdFx0XHQpIHtcblxuXHRcdFx0XHR0aGlzLmRpcmVjdGlvbiA9IGludGVyc2VjdGlvbiA9PT0gMSA/IFwiZG93blwiIDogXCJ1cFwiO1xuXG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnRvbGVyYW5jZSA9PT0gXCJwb2ludGVyXCIgfHwgdGhpcy5faW50ZXJzZWN0c1dpdGhTaWRlcyggaXRlbSApICkge1xuXHRcdFx0XHRcdHRoaXMuX3JlYXJyYW5nZSggZXZlbnQsIGl0ZW0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2hhbmdlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL1Bvc3QgZXZlbnRzIHRvIGNvbnRhaW5lcnNcblx0XHR0aGlzLl9jb250YWN0Q29udGFpbmVycyggZXZlbnQgKTtcblxuXHRcdC8vSW50ZXJjb25uZWN0IHdpdGggZHJvcHBhYmxlc1xuXHRcdGlmICggJC51aS5kZG1hbmFnZXIgKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5kcmFnKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdC8vQ2FsbCBjYWxsYmFja3Ncblx0XHR0aGlzLl90cmlnZ2VyKCBcInNvcnRcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpICk7XG5cblx0XHR0aGlzLmxhc3RQb3NpdGlvbkFicyA9IHRoaXMucG9zaXRpb25BYnM7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH0sXG5cblx0X21vdXNlU3RvcDogZnVuY3Rpb24oIGV2ZW50LCBub1Byb3BhZ2F0aW9uICkge1xuXG5cdFx0aWYgKCAhZXZlbnQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly9JZiB3ZSBhcmUgdXNpbmcgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIGFib3V0IHRoZSBkcm9wXG5cdFx0aWYgKCAkLnVpLmRkbWFuYWdlciAmJiAhdGhpcy5vcHRpb25zLmRyb3BCZWhhdmlvdXIgKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5kcm9wKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnJldmVydCApIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0Y3VyID0gdGhpcy5wbGFjZWhvbGRlci5vZmZzZXQoKSxcblx0XHRcdFx0YXhpcyA9IHRoaXMub3B0aW9ucy5heGlzLFxuXHRcdFx0XHRhbmltYXRpb24gPSB7fTtcblxuXHRcdFx0aWYgKCAhYXhpcyB8fCBheGlzID09PSBcInhcIiApIHtcblx0XHRcdFx0YW5pbWF0aW9uLmxlZnQgPSBjdXIubGVmdCAtIHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0IC0gdGhpcy5tYXJnaW5zLmxlZnQgK1xuXHRcdFx0XHRcdCggdGhpcy5vZmZzZXRQYXJlbnRbIDAgXSA9PT0gdGhpcy5kb2N1bWVudFsgMCBdLmJvZHkgP1xuXHRcdFx0XHRcdFx0MCA6XG5cdFx0XHRcdFx0XHR0aGlzLm9mZnNldFBhcmVudFsgMCBdLnNjcm9sbExlZnRcblx0XHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhYXhpcyB8fCBheGlzID09PSBcInlcIiApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnRvcCA9IGN1ci50b3AgLSB0aGlzLm9mZnNldC5wYXJlbnQudG9wIC0gdGhpcy5tYXJnaW5zLnRvcCArXG5cdFx0XHRcdFx0KCB0aGlzLm9mZnNldFBhcmVudFsgMCBdID09PSB0aGlzLmRvY3VtZW50WyAwIF0uYm9keSA/XG5cdFx0XHRcdFx0XHQwIDpcblx0XHRcdFx0XHRcdHRoaXMub2Zmc2V0UGFyZW50WyAwIF0uc2Nyb2xsVG9wXG5cdFx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdHRoaXMucmV2ZXJ0aW5nID0gdHJ1ZTtcblx0XHRcdCQoIHRoaXMuaGVscGVyICkuYW5pbWF0ZShcblx0XHRcdFx0YW5pbWF0aW9uLFxuXHRcdFx0XHRwYXJzZUludCggdGhpcy5vcHRpb25zLnJldmVydCwgMTAgKSB8fCA1MDAsXG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoYXQuX2NsZWFyKCBldmVudCApO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jbGVhciggZXZlbnQsIG5vUHJvcGFnYXRpb24gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fSxcblxuXHRjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYgKCB0aGlzLmRyYWdnaW5nICkge1xuXG5cdFx0XHR0aGlzLl9tb3VzZVVwKCBuZXcgJC5FdmVudCggXCJtb3VzZXVwXCIsIHsgdGFyZ2V0OiBudWxsIH0gKSApO1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5oZWxwZXIgPT09IFwib3JpZ2luYWxcIiApIHtcblx0XHRcdFx0dGhpcy5jdXJyZW50SXRlbS5jc3MoIHRoaXMuX3N0b3JlZENTUyApO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggdGhpcy5jdXJyZW50SXRlbSwgXCJ1aS1zb3J0YWJsZS1oZWxwZXJcIiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5jdXJyZW50SXRlbS5zaG93KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vUG9zdCBkZWFjdGl2YXRpbmcgZXZlbnRzIHRvIGNvbnRhaW5lcnNcblx0XHRcdGZvciAoIHZhciBpID0gdGhpcy5jb250YWluZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbIGkgXS5fdHJpZ2dlciggXCJkZWFjdGl2YXRlXCIsIG51bGwsIHRoaXMuX3VpSGFzaCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggdGhpcy5jb250YWluZXJzWyBpIF0uY29udGFpbmVyQ2FjaGUub3ZlciApIHtcblx0XHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbIGkgXS5fdHJpZ2dlciggXCJvdXRcIiwgbnVsbCwgdGhpcy5fdWlIYXNoKCB0aGlzICkgKTtcblx0XHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbIGkgXS5jb250YWluZXJDYWNoZS5vdmVyID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnBsYWNlaG9sZGVyICkge1xuXG5cdFx0XHQvLyQodGhpcy5wbGFjZWhvbGRlclswXSkucmVtb3ZlKCk7IHdvdWxkIGhhdmUgYmVlbiB0aGUgalF1ZXJ5IHdheSAtIHVuZm9ydHVuYXRlbHksXG5cdFx0XHQvLyBpdCB1bmJpbmRzIEFMTCBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgbm9kZSFcblx0XHRcdGlmICggdGhpcy5wbGFjZWhvbGRlclsgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGxhY2Vob2xkZXJbIDAgXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0aGlzLnBsYWNlaG9sZGVyWyAwIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmhlbHBlciAhPT0gXCJvcmlnaW5hbFwiICYmIHRoaXMuaGVscGVyICYmXG5cdFx0XHRcdFx0dGhpcy5oZWxwZXJbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLmhlbHBlci5yZW1vdmUoKTtcblx0XHRcdH1cblxuXHRcdFx0JC5leHRlbmQoIHRoaXMsIHtcblx0XHRcdFx0aGVscGVyOiBudWxsLFxuXHRcdFx0XHRkcmFnZ2luZzogZmFsc2UsXG5cdFx0XHRcdHJldmVydGluZzogZmFsc2UsXG5cdFx0XHRcdF9ub0ZpbmFsU29ydDogbnVsbFxuXHRcdFx0fSApO1xuXG5cdFx0XHRpZiAoIHRoaXMuZG9tUG9zaXRpb24ucHJldiApIHtcblx0XHRcdFx0JCggdGhpcy5kb21Qb3NpdGlvbi5wcmV2ICkuYWZ0ZXIoIHRoaXMuY3VycmVudEl0ZW0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQoIHRoaXMuZG9tUG9zaXRpb24ucGFyZW50ICkucHJlcGVuZCggdGhpcy5jdXJyZW50SXRlbSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2VyaWFsaXplOiBmdW5jdGlvbiggbyApIHtcblxuXHRcdHZhciBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zQXNqUXVlcnkoIG8gJiYgby5jb25uZWN0ZWQgKSxcblx0XHRcdHN0ciA9IFtdO1xuXHRcdG8gPSBvIHx8IHt9O1xuXG5cdFx0JCggaXRlbXMgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZXMgPSAoICQoIG8uaXRlbSB8fCB0aGlzICkuYXR0ciggby5hdHRyaWJ1dGUgfHwgXCJpZFwiICkgfHwgXCJcIiApXG5cdFx0XHRcdC5tYXRjaCggby5leHByZXNzaW9uIHx8ICggLyguKylbXFwtPV9dKC4rKS8gKSApO1xuXHRcdFx0aWYgKCByZXMgKSB7XG5cdFx0XHRcdHN0ci5wdXNoKFxuXHRcdFx0XHRcdCggby5rZXkgfHwgcmVzWyAxIF0gKyBcIltdXCIgKSArXG5cdFx0XHRcdFx0XCI9XCIgKyAoIG8ua2V5ICYmIG8uZXhwcmVzc2lvbiA/IHJlc1sgMSBdIDogcmVzWyAyIF0gKSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdGlmICggIXN0ci5sZW5ndGggJiYgby5rZXkgKSB7XG5cdFx0XHRzdHIucHVzaCggby5rZXkgKyBcIj1cIiApO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdHIuam9pbiggXCImXCIgKTtcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCBvICkge1xuXG5cdFx0dmFyIGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXNBc2pRdWVyeSggbyAmJiBvLmNvbm5lY3RlZCApLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHRvID0gbyB8fCB7fTtcblxuXHRcdGl0ZW1zLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0LnB1c2goICQoIG8uaXRlbSB8fCB0aGlzICkuYXR0ciggby5hdHRyaWJ1dGUgfHwgXCJpZFwiICkgfHwgXCJcIiApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gcmV0O1xuXG5cdH0sXG5cblx0LyogQmUgY2FyZWZ1bCB3aXRoIHRoZSBmb2xsb3dpbmcgY29yZSBmdW5jdGlvbnMgKi9cblx0X2ludGVyc2VjdHNXaXRoOiBmdW5jdGlvbiggaXRlbSApIHtcblxuXHRcdHZhciB4MSA9IHRoaXMucG9zaXRpb25BYnMubGVmdCxcblx0XHRcdHgyID0geDEgKyB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoLFxuXHRcdFx0eTEgPSB0aGlzLnBvc2l0aW9uQWJzLnRvcCxcblx0XHRcdHkyID0geTEgKyB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCxcblx0XHRcdGwgPSBpdGVtLmxlZnQsXG5cdFx0XHRyID0gbCArIGl0ZW0ud2lkdGgsXG5cdFx0XHR0ID0gaXRlbS50b3AsXG5cdFx0XHRiID0gdCArIGl0ZW0uaGVpZ2h0LFxuXHRcdFx0ZHlDbGljayA9IHRoaXMub2Zmc2V0LmNsaWNrLnRvcCxcblx0XHRcdGR4Q2xpY2sgPSB0aGlzLm9mZnNldC5jbGljay5sZWZ0LFxuXHRcdFx0aXNPdmVyRWxlbWVudEhlaWdodCA9ICggdGhpcy5vcHRpb25zLmF4aXMgPT09IFwieFwiICkgfHwgKCAoIHkxICsgZHlDbGljayApID4gdCAmJlxuXHRcdFx0XHQoIHkxICsgZHlDbGljayApIDwgYiApLFxuXHRcdFx0aXNPdmVyRWxlbWVudFdpZHRoID0gKCB0aGlzLm9wdGlvbnMuYXhpcyA9PT0gXCJ5XCIgKSB8fCAoICggeDEgKyBkeENsaWNrICkgPiBsICYmXG5cdFx0XHRcdCggeDEgKyBkeENsaWNrICkgPCByICksXG5cdFx0XHRpc092ZXJFbGVtZW50ID0gaXNPdmVyRWxlbWVudEhlaWdodCAmJiBpc092ZXJFbGVtZW50V2lkdGg7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy50b2xlcmFuY2UgPT09IFwicG9pbnRlclwiIHx8XG5cdFx0XHR0aGlzLm9wdGlvbnMuZm9yY2VQb2ludGVyRm9yQ29udGFpbmVycyB8fFxuXHRcdFx0KCB0aGlzLm9wdGlvbnMudG9sZXJhbmNlICE9PSBcInBvaW50ZXJcIiAmJlxuXHRcdFx0XHR0aGlzLmhlbHBlclByb3BvcnRpb25zWyB0aGlzLmZsb2F0aW5nID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIiBdID5cblx0XHRcdFx0aXRlbVsgdGhpcy5mbG9hdGluZyA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIgXSApXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gaXNPdmVyRWxlbWVudDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gKCBsIDwgeDEgKyAoIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLyAyICkgJiYgLy8gUmlnaHQgSGFsZlxuXHRcdFx0XHR4MiAtICggdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAvIDIgKSA8IHIgJiYgLy8gTGVmdCBIYWxmXG5cdFx0XHRcdHQgPCB5MSArICggdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLyAyICkgJiYgLy8gQm90dG9tIEhhbGZcblx0XHRcdFx0eTIgLSAoIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC8gMiApIDwgYiApOyAvLyBUb3AgSGFsZlxuXG5cdFx0fVxuXHR9LFxuXG5cdF9pbnRlcnNlY3RzV2l0aFBvaW50ZXI6IGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdHZhciB2ZXJ0aWNhbERpcmVjdGlvbiwgaG9yaXpvbnRhbERpcmVjdGlvbixcblx0XHRcdGlzT3ZlckVsZW1lbnRIZWlnaHQgPSAoIHRoaXMub3B0aW9ucy5heGlzID09PSBcInhcIiApIHx8XG5cdFx0XHRcdHRoaXMuX2lzT3ZlckF4aXMoXG5cdFx0XHRcdFx0dGhpcy5wb3NpdGlvbkFicy50b3AgKyB0aGlzLm9mZnNldC5jbGljay50b3AsIGl0ZW0udG9wLCBpdGVtLmhlaWdodCApLFxuXHRcdFx0aXNPdmVyRWxlbWVudFdpZHRoID0gKCB0aGlzLm9wdGlvbnMuYXhpcyA9PT0gXCJ5XCIgKSB8fFxuXHRcdFx0XHR0aGlzLl9pc092ZXJBeGlzKFxuXHRcdFx0XHRcdHRoaXMucG9zaXRpb25BYnMubGVmdCArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQsIGl0ZW0ubGVmdCwgaXRlbS53aWR0aCApLFxuXHRcdFx0aXNPdmVyRWxlbWVudCA9IGlzT3ZlckVsZW1lbnRIZWlnaHQgJiYgaXNPdmVyRWxlbWVudFdpZHRoO1xuXG5cdFx0aWYgKCAhaXNPdmVyRWxlbWVudCApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2ZXJ0aWNhbERpcmVjdGlvbiA9IHRoaXMuX2dldERyYWdWZXJ0aWNhbERpcmVjdGlvbigpO1xuXHRcdGhvcml6b250YWxEaXJlY3Rpb24gPSB0aGlzLl9nZXREcmFnSG9yaXpvbnRhbERpcmVjdGlvbigpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmxvYXRpbmcgP1xuXHRcdFx0KCAoIGhvcml6b250YWxEaXJlY3Rpb24gPT09IFwicmlnaHRcIiB8fCB2ZXJ0aWNhbERpcmVjdGlvbiA9PT0gXCJkb3duXCIgKSA/IDIgOiAxIClcblx0XHRcdDogKCB2ZXJ0aWNhbERpcmVjdGlvbiAmJiAoIHZlcnRpY2FsRGlyZWN0aW9uID09PSBcImRvd25cIiA/IDIgOiAxICkgKTtcblxuXHR9LFxuXG5cdF9pbnRlcnNlY3RzV2l0aFNpZGVzOiBmdW5jdGlvbiggaXRlbSApIHtcblxuXHRcdHZhciBpc092ZXJCb3R0b21IYWxmID0gdGhpcy5faXNPdmVyQXhpcyggdGhpcy5wb3NpdGlvbkFicy50b3AgK1xuXHRcdFx0XHR0aGlzLm9mZnNldC5jbGljay50b3AsIGl0ZW0udG9wICsgKCBpdGVtLmhlaWdodCAvIDIgKSwgaXRlbS5oZWlnaHQgKSxcblx0XHRcdGlzT3ZlclJpZ2h0SGFsZiA9IHRoaXMuX2lzT3ZlckF4aXMoIHRoaXMucG9zaXRpb25BYnMubGVmdCArXG5cdFx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQsIGl0ZW0ubGVmdCArICggaXRlbS53aWR0aCAvIDIgKSwgaXRlbS53aWR0aCApLFxuXHRcdFx0dmVydGljYWxEaXJlY3Rpb24gPSB0aGlzLl9nZXREcmFnVmVydGljYWxEaXJlY3Rpb24oKSxcblx0XHRcdGhvcml6b250YWxEaXJlY3Rpb24gPSB0aGlzLl9nZXREcmFnSG9yaXpvbnRhbERpcmVjdGlvbigpO1xuXG5cdFx0aWYgKCB0aGlzLmZsb2F0aW5nICYmIGhvcml6b250YWxEaXJlY3Rpb24gKSB7XG5cdFx0XHRyZXR1cm4gKCAoIGhvcml6b250YWxEaXJlY3Rpb24gPT09IFwicmlnaHRcIiAmJiBpc092ZXJSaWdodEhhbGYgKSB8fFxuXHRcdFx0XHQoIGhvcml6b250YWxEaXJlY3Rpb24gPT09IFwibGVmdFwiICYmICFpc092ZXJSaWdodEhhbGYgKSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdmVydGljYWxEaXJlY3Rpb24gJiYgKCAoIHZlcnRpY2FsRGlyZWN0aW9uID09PSBcImRvd25cIiAmJiBpc092ZXJCb3R0b21IYWxmICkgfHxcblx0XHRcdFx0KCB2ZXJ0aWNhbERpcmVjdGlvbiA9PT0gXCJ1cFwiICYmICFpc092ZXJCb3R0b21IYWxmICkgKTtcblx0XHR9XG5cblx0fSxcblxuXHRfZ2V0RHJhZ1ZlcnRpY2FsRGlyZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVsdGEgPSB0aGlzLnBvc2l0aW9uQWJzLnRvcCAtIHRoaXMubGFzdFBvc2l0aW9uQWJzLnRvcDtcblx0XHRyZXR1cm4gZGVsdGEgIT09IDAgJiYgKCBkZWx0YSA+IDAgPyBcImRvd25cIiA6IFwidXBcIiApO1xuXHR9LFxuXG5cdF9nZXREcmFnSG9yaXpvbnRhbERpcmVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlbHRhID0gdGhpcy5wb3NpdGlvbkFicy5sZWZ0IC0gdGhpcy5sYXN0UG9zaXRpb25BYnMubGVmdDtcblx0XHRyZXR1cm4gZGVsdGEgIT09IDAgJiYgKCBkZWx0YSA+IDAgPyBcInJpZ2h0XCIgOiBcImxlZnRcIiApO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR0aGlzLl9yZWZyZXNoSXRlbXMoIGV2ZW50ICk7XG5cdFx0dGhpcy5fc2V0SGFuZGxlQ2xhc3NOYW1lKCk7XG5cdFx0dGhpcy5yZWZyZXNoUG9zaXRpb25zKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2Nvbm5lY3RXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHRyZXR1cm4gb3B0aW9ucy5jb25uZWN0V2l0aC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nID9cblx0XHRcdFsgb3B0aW9ucy5jb25uZWN0V2l0aCBdIDpcblx0XHRcdG9wdGlvbnMuY29ubmVjdFdpdGg7XG5cdH0sXG5cblx0X2dldEl0ZW1zQXNqUXVlcnk6IGZ1bmN0aW9uKCBjb25uZWN0ZWQgKSB7XG5cblx0XHR2YXIgaSwgaiwgY3VyLCBpbnN0LFxuXHRcdFx0aXRlbXMgPSBbXSxcblx0XHRcdHF1ZXJpZXMgPSBbXSxcblx0XHRcdGNvbm5lY3RXaXRoID0gdGhpcy5fY29ubmVjdFdpdGgoKTtcblxuXHRcdGlmICggY29ubmVjdFdpdGggJiYgY29ubmVjdGVkICkge1xuXHRcdFx0Zm9yICggaSA9IGNvbm5lY3RXaXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuXHRcdFx0XHRjdXIgPSAkKCBjb25uZWN0V2l0aFsgaSBdLCB0aGlzLmRvY3VtZW50WyAwIF0gKTtcblx0XHRcdFx0Zm9yICggaiA9IGN1ci5sZW5ndGggLSAxOyBqID49IDA7IGotLSApIHtcblx0XHRcdFx0XHRpbnN0ID0gJC5kYXRhKCBjdXJbIGogXSwgdGhpcy53aWRnZXRGdWxsTmFtZSApO1xuXHRcdFx0XHRcdGlmICggaW5zdCAmJiBpbnN0ICE9PSB0aGlzICYmICFpbnN0Lm9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0XHRxdWVyaWVzLnB1c2goIFsgJC5pc0Z1bmN0aW9uKCBpbnN0Lm9wdGlvbnMuaXRlbXMgKSA/XG5cdFx0XHRcdFx0XHRcdGluc3Qub3B0aW9ucy5pdGVtcy5jYWxsKCBpbnN0LmVsZW1lbnQgKSA6XG5cdFx0XHRcdFx0XHRcdCQoIGluc3Qub3B0aW9ucy5pdGVtcywgaW5zdC5lbGVtZW50IClcblx0XHRcdFx0XHRcdFx0XHQubm90KCBcIi51aS1zb3J0YWJsZS1oZWxwZXJcIiApXG5cdFx0XHRcdFx0XHRcdFx0Lm5vdCggXCIudWktc29ydGFibGUtcGxhY2Vob2xkZXJcIiApLCBpbnN0IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRxdWVyaWVzLnB1c2goIFsgJC5pc0Z1bmN0aW9uKCB0aGlzLm9wdGlvbnMuaXRlbXMgKSA/XG5cdFx0XHR0aGlzLm9wdGlvbnMuaXRlbXNcblx0XHRcdFx0LmNhbGwoIHRoaXMuZWxlbWVudCwgbnVsbCwgeyBvcHRpb25zOiB0aGlzLm9wdGlvbnMsIGl0ZW06IHRoaXMuY3VycmVudEl0ZW0gfSApIDpcblx0XHRcdCQoIHRoaXMub3B0aW9ucy5pdGVtcywgdGhpcy5lbGVtZW50IClcblx0XHRcdFx0Lm5vdCggXCIudWktc29ydGFibGUtaGVscGVyXCIgKVxuXHRcdFx0XHQubm90KCBcIi51aS1zb3J0YWJsZS1wbGFjZWhvbGRlclwiICksIHRoaXMgXSApO1xuXG5cdFx0ZnVuY3Rpb24gYWRkSXRlbXMoKSB7XG5cdFx0XHRpdGVtcy5wdXNoKCB0aGlzICk7XG5cdFx0fVxuXHRcdGZvciAoIGkgPSBxdWVyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuXHRcdFx0cXVlcmllc1sgaSBdWyAwIF0uZWFjaCggYWRkSXRlbXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJCggaXRlbXMgKTtcblxuXHR9LFxuXG5cdF9yZW1vdmVDdXJyZW50c0Zyb21JdGVtczogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbGlzdCA9IHRoaXMuY3VycmVudEl0ZW0uZmluZCggXCI6ZGF0YShcIiArIHRoaXMud2lkZ2V0TmFtZSArIFwiLWl0ZW0pXCIgKTtcblxuXHRcdHRoaXMuaXRlbXMgPSAkLmdyZXAoIHRoaXMuaXRlbXMsIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgbGlzdC5sZW5ndGg7IGorKyApIHtcblx0XHRcdFx0aWYgKCBsaXN0WyBqIF0gPT09IGl0ZW0uaXRlbVsgMCBdICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSApO1xuXG5cdH0sXG5cblx0X3JlZnJlc2hJdGVtczogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0dGhpcy5pdGVtcyA9IFtdO1xuXHRcdHRoaXMuY29udGFpbmVycyA9IFsgdGhpcyBdO1xuXG5cdFx0dmFyIGksIGosIGN1ciwgaW5zdCwgdGFyZ2V0RGF0YSwgX3F1ZXJpZXMsIGl0ZW0sIHF1ZXJpZXNMZW5ndGgsXG5cdFx0XHRpdGVtcyA9IHRoaXMuaXRlbXMsXG5cdFx0XHRxdWVyaWVzID0gWyBbICQuaXNGdW5jdGlvbiggdGhpcy5vcHRpb25zLml0ZW1zICkgP1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMuaXRlbXMuY2FsbCggdGhpcy5lbGVtZW50WyAwIF0sIGV2ZW50LCB7IGl0ZW06IHRoaXMuY3VycmVudEl0ZW0gfSApIDpcblx0XHRcdFx0JCggdGhpcy5vcHRpb25zLml0ZW1zLCB0aGlzLmVsZW1lbnQgKSwgdGhpcyBdIF0sXG5cdFx0XHRjb25uZWN0V2l0aCA9IHRoaXMuX2Nvbm5lY3RXaXRoKCk7XG5cblx0XHQvL1Nob3VsZG4ndCBiZSBydW4gdGhlIGZpcnN0IHRpbWUgdGhyb3VnaCBkdWUgdG8gbWFzc2l2ZSBzbG93LWRvd25cblx0XHRpZiAoIGNvbm5lY3RXaXRoICYmIHRoaXMucmVhZHkgKSB7XG5cdFx0XHRmb3IgKCBpID0gY29ubmVjdFdpdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG5cdFx0XHRcdGN1ciA9ICQoIGNvbm5lY3RXaXRoWyBpIF0sIHRoaXMuZG9jdW1lbnRbIDAgXSApO1xuXHRcdFx0XHRmb3IgKCBqID0gY3VyLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tICkge1xuXHRcdFx0XHRcdGluc3QgPSAkLmRhdGEoIGN1clsgaiBdLCB0aGlzLndpZGdldEZ1bGxOYW1lICk7XG5cdFx0XHRcdFx0aWYgKCBpbnN0ICYmIGluc3QgIT09IHRoaXMgJiYgIWluc3Qub3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdFx0XHRcdHF1ZXJpZXMucHVzaCggWyAkLmlzRnVuY3Rpb24oIGluc3Qub3B0aW9ucy5pdGVtcyApID9cblx0XHRcdFx0XHRcdFx0aW5zdC5vcHRpb25zLml0ZW1zXG5cdFx0XHRcdFx0XHRcdFx0LmNhbGwoIGluc3QuZWxlbWVudFsgMCBdLCBldmVudCwgeyBpdGVtOiB0aGlzLmN1cnJlbnRJdGVtIH0gKSA6XG5cdFx0XHRcdFx0XHRcdCQoIGluc3Qub3B0aW9ucy5pdGVtcywgaW5zdC5lbGVtZW50ICksIGluc3QgXSApO1xuXHRcdFx0XHRcdFx0dGhpcy5jb250YWluZXJzLnB1c2goIGluc3QgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKCBpID0gcXVlcmllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcblx0XHRcdHRhcmdldERhdGEgPSBxdWVyaWVzWyBpIF1bIDEgXTtcblx0XHRcdF9xdWVyaWVzID0gcXVlcmllc1sgaSBdWyAwIF07XG5cblx0XHRcdGZvciAoIGogPSAwLCBxdWVyaWVzTGVuZ3RoID0gX3F1ZXJpZXMubGVuZ3RoOyBqIDwgcXVlcmllc0xlbmd0aDsgaisrICkge1xuXHRcdFx0XHRpdGVtID0gJCggX3F1ZXJpZXNbIGogXSApO1xuXG5cdFx0XHRcdC8vIERhdGEgZm9yIHRhcmdldCBjaGVja2luZyAobW91c2UgbWFuYWdlcilcblx0XHRcdFx0aXRlbS5kYXRhKCB0aGlzLndpZGdldE5hbWUgKyBcIi1pdGVtXCIsIHRhcmdldERhdGEgKTtcblxuXHRcdFx0XHRpdGVtcy5wdXNoKCB7XG5cdFx0XHRcdFx0aXRlbTogaXRlbSxcblx0XHRcdFx0XHRpbnN0YW5jZTogdGFyZ2V0RGF0YSxcblx0XHRcdFx0XHR3aWR0aDogMCwgaGVpZ2h0OiAwLFxuXHRcdFx0XHRcdGxlZnQ6IDAsIHRvcDogMFxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0sXG5cblx0cmVmcmVzaFBvc2l0aW9uczogZnVuY3Rpb24oIGZhc3QgKSB7XG5cblx0XHQvLyBEZXRlcm1pbmUgd2hldGhlciBpdGVtcyBhcmUgYmVpbmcgZGlzcGxheWVkIGhvcml6b250YWxseVxuXHRcdHRoaXMuZmxvYXRpbmcgPSB0aGlzLml0ZW1zLmxlbmd0aCA/XG5cdFx0XHR0aGlzLm9wdGlvbnMuYXhpcyA9PT0gXCJ4XCIgfHwgdGhpcy5faXNGbG9hdGluZyggdGhpcy5pdGVtc1sgMCBdLml0ZW0gKSA6XG5cdFx0XHRmYWxzZTtcblxuXHRcdC8vVGhpcyBoYXMgdG8gYmUgcmVkb25lIGJlY2F1c2UgZHVlIHRvIHRoZSBpdGVtIGJlaW5nIG1vdmVkIG91dC9pbnRvIHRoZSBvZmZzZXRQYXJlbnQsXG5cdFx0Ly8gdGhlIG9mZnNldFBhcmVudCdzIHBvc2l0aW9uIHdpbGwgY2hhbmdlXG5cdFx0aWYgKCB0aGlzLm9mZnNldFBhcmVudCAmJiB0aGlzLmhlbHBlciApIHtcblx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudCA9IHRoaXMuX2dldFBhcmVudE9mZnNldCgpO1xuXHRcdH1cblxuXHRcdHZhciBpLCBpdGVtLCB0LCBwO1xuXG5cdFx0Zm9yICggaSA9IHRoaXMuaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG5cdFx0XHRpdGVtID0gdGhpcy5pdGVtc1sgaSBdO1xuXG5cdFx0XHQvL1dlIGlnbm9yZSBjYWxjdWxhdGluZyBwb3NpdGlvbnMgb2YgYWxsIGNvbm5lY3RlZCBjb250YWluZXJzIHdoZW4gd2UncmUgbm90IG92ZXIgdGhlbVxuXHRcdFx0aWYgKCBpdGVtLmluc3RhbmNlICE9PSB0aGlzLmN1cnJlbnRDb250YWluZXIgJiYgdGhpcy5jdXJyZW50Q29udGFpbmVyICYmXG5cdFx0XHRcdFx0aXRlbS5pdGVtWyAwIF0gIT09IHRoaXMuY3VycmVudEl0ZW1bIDAgXSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHQgPSB0aGlzLm9wdGlvbnMudG9sZXJhbmNlRWxlbWVudCA/XG5cdFx0XHRcdCQoIHRoaXMub3B0aW9ucy50b2xlcmFuY2VFbGVtZW50LCBpdGVtLml0ZW0gKSA6XG5cdFx0XHRcdGl0ZW0uaXRlbTtcblxuXHRcdFx0aWYgKCAhZmFzdCApIHtcblx0XHRcdFx0aXRlbS53aWR0aCA9IHQub3V0ZXJXaWR0aCgpO1xuXHRcdFx0XHRpdGVtLmhlaWdodCA9IHQub3V0ZXJIZWlnaHQoKTtcblx0XHRcdH1cblxuXHRcdFx0cCA9IHQub2Zmc2V0KCk7XG5cdFx0XHRpdGVtLmxlZnQgPSBwLmxlZnQ7XG5cdFx0XHRpdGVtLnRvcCA9IHAudG9wO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmN1c3RvbSAmJiB0aGlzLm9wdGlvbnMuY3VzdG9tLnJlZnJlc2hDb250YWluZXJzICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLmN1c3RvbS5yZWZyZXNoQ29udGFpbmVycy5jYWxsKCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgPSB0aGlzLmNvbnRhaW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG5cdFx0XHRcdHAgPSB0aGlzLmNvbnRhaW5lcnNbIGkgXS5lbGVtZW50Lm9mZnNldCgpO1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbIGkgXS5jb250YWluZXJDYWNoZS5sZWZ0ID0gcC5sZWZ0O1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbIGkgXS5jb250YWluZXJDYWNoZS50b3AgPSBwLnRvcDtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzWyBpIF0uY29udGFpbmVyQ2FjaGUud2lkdGggPVxuXHRcdFx0XHRcdHRoaXMuY29udGFpbmVyc1sgaSBdLmVsZW1lbnQub3V0ZXJXaWR0aCgpO1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbIGkgXS5jb250YWluZXJDYWNoZS5oZWlnaHQgPVxuXHRcdFx0XHRcdHRoaXMuY29udGFpbmVyc1sgaSBdLmVsZW1lbnQub3V0ZXJIZWlnaHQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfY3JlYXRlUGxhY2Vob2xkZXI6IGZ1bmN0aW9uKCB0aGF0ICkge1xuXHRcdHRoYXQgPSB0aGF0IHx8IHRoaXM7XG5cdFx0dmFyIGNsYXNzTmFtZSxcblx0XHRcdG8gPSB0aGF0Lm9wdGlvbnM7XG5cblx0XHRpZiAoICFvLnBsYWNlaG9sZGVyIHx8IG8ucGxhY2Vob2xkZXIuY29uc3RydWN0b3IgPT09IFN0cmluZyApIHtcblx0XHRcdGNsYXNzTmFtZSA9IG8ucGxhY2Vob2xkZXI7XG5cdFx0XHRvLnBsYWNlaG9sZGVyID0ge1xuXHRcdFx0XHRlbGVtZW50OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdHZhciBub2RlTmFtZSA9IHRoYXQuY3VycmVudEl0ZW1bIDAgXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0ZWxlbWVudCA9ICQoIFwiPFwiICsgbm9kZU5hbWUgKyBcIj5cIiwgdGhhdC5kb2N1bWVudFsgMCBdICk7XG5cblx0XHRcdFx0XHRcdHRoYXQuX2FkZENsYXNzKCBlbGVtZW50LCBcInVpLXNvcnRhYmxlLXBsYWNlaG9sZGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHRoYXQuY3VycmVudEl0ZW1bIDAgXS5jbGFzc05hbWUgKVxuXHRcdFx0XHRcdFx0XHQuX3JlbW92ZUNsYXNzKCBlbGVtZW50LCBcInVpLXNvcnRhYmxlLWhlbHBlclwiICk7XG5cblx0XHRcdFx0XHRpZiAoIG5vZGVOYW1lID09PSBcInRib2R5XCIgKSB7XG5cdFx0XHRcdFx0XHR0aGF0Ll9jcmVhdGVUclBsYWNlaG9sZGVyKFxuXHRcdFx0XHRcdFx0XHR0aGF0LmN1cnJlbnRJdGVtLmZpbmQoIFwidHJcIiApLmVxKCAwICksXG5cdFx0XHRcdFx0XHRcdCQoIFwiPHRyPlwiLCB0aGF0LmRvY3VtZW50WyAwIF0gKS5hcHBlbmRUbyggZWxlbWVudCApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcInRyXCIgKSB7XG5cdFx0XHRcdFx0XHR0aGF0Ll9jcmVhdGVUclBsYWNlaG9sZGVyKCB0aGF0LmN1cnJlbnRJdGVtLCBlbGVtZW50ICk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW1nXCIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtZW50LmF0dHIoIFwic3JjXCIsIHRoYXQuY3VycmVudEl0ZW0uYXR0ciggXCJzcmNcIiApICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhY2xhc3NOYW1lICkge1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5jc3MoIFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oIGNvbnRhaW5lciwgcCApIHtcblxuXHRcdFx0XHRcdC8vIDEuIElmIGEgY2xhc3NOYW1lIGlzIHNldCBhcyAncGxhY2Vob2xkZXIgb3B0aW9uLCB3ZSBkb24ndCBmb3JjZSBzaXplcyAtXG5cdFx0XHRcdFx0Ly8gdGhlIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0aGF0XG5cdFx0XHRcdFx0Ly8gMi4gVGhlIG9wdGlvbiAnZm9yY2VQbGFjZWhvbGRlclNpemUgY2FuIGJlIGVuYWJsZWQgdG8gZm9yY2UgaXQgZXZlbiBpZiBhXG5cdFx0XHRcdFx0Ly8gY2xhc3MgbmFtZSBpcyBzcGVjaWZpZWRcblx0XHRcdFx0XHRpZiAoIGNsYXNzTmFtZSAmJiAhby5mb3JjZVBsYWNlaG9sZGVyU2l6ZSApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvL0lmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhIGFjdHVhbCBoZWlnaHQgYnkgaXRzZWxmICh3aXRob3V0IHN0eWxlcyBjb21pbmdcblx0XHRcdFx0XHQvLyBmcm9tIGEgc3R5bGVzaGVldCksIGl0IHJlY2VpdmVzIHRoZSBpbmxpbmUgaGVpZ2h0IGZyb20gdGhlIGRyYWdnZWQgaXRlbVxuXHRcdFx0XHRcdGlmICggIXAuaGVpZ2h0KCkgKSB7XG5cdFx0XHRcdFx0XHRwLmhlaWdodChcblx0XHRcdFx0XHRcdFx0dGhhdC5jdXJyZW50SXRlbS5pbm5lckhlaWdodCgpIC1cblx0XHRcdFx0XHRcdFx0cGFyc2VJbnQoIHRoYXQuY3VycmVudEl0ZW0uY3NzKCBcInBhZGRpbmdUb3BcIiApIHx8IDAsIDEwICkgLVxuXHRcdFx0XHRcdFx0XHRwYXJzZUludCggdGhhdC5jdXJyZW50SXRlbS5jc3MoIFwicGFkZGluZ0JvdHRvbVwiICkgfHwgMCwgMTAgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICFwLndpZHRoKCkgKSB7XG5cdFx0XHRcdFx0XHRwLndpZHRoKFxuXHRcdFx0XHRcdFx0XHR0aGF0LmN1cnJlbnRJdGVtLmlubmVyV2lkdGgoKSAtXG5cdFx0XHRcdFx0XHRcdHBhcnNlSW50KCB0aGF0LmN1cnJlbnRJdGVtLmNzcyggXCJwYWRkaW5nTGVmdFwiICkgfHwgMCwgMTAgKSAtXG5cdFx0XHRcdFx0XHRcdHBhcnNlSW50KCB0aGF0LmN1cnJlbnRJdGVtLmNzcyggXCJwYWRkaW5nUmlnaHRcIiApIHx8IDAsIDEwICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly9DcmVhdGUgdGhlIHBsYWNlaG9sZGVyXG5cdFx0dGhhdC5wbGFjZWhvbGRlciA9ICQoIG8ucGxhY2Vob2xkZXIuZWxlbWVudC5jYWxsKCB0aGF0LmVsZW1lbnQsIHRoYXQuY3VycmVudEl0ZW0gKSApO1xuXG5cdFx0Ly9BcHBlbmQgaXQgYWZ0ZXIgdGhlIGFjdHVhbCBjdXJyZW50IGl0ZW1cblx0XHR0aGF0LmN1cnJlbnRJdGVtLmFmdGVyKCB0aGF0LnBsYWNlaG9sZGVyICk7XG5cblx0XHQvL1VwZGF0ZSB0aGUgc2l6ZSBvZiB0aGUgcGxhY2Vob2xkZXIgKFRPRE86IExvZ2ljIHRvIGZ1enp5LCBzZWUgbGluZSAzMTYvMzE3KVxuXHRcdG8ucGxhY2Vob2xkZXIudXBkYXRlKCB0aGF0LCB0aGF0LnBsYWNlaG9sZGVyICk7XG5cblx0fSxcblxuXHRfY3JlYXRlVHJQbGFjZWhvbGRlcjogZnVuY3Rpb24oIHNvdXJjZVRyLCB0YXJnZXRUciApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHRzb3VyY2VUci5jaGlsZHJlbigpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0JCggXCI8dGQ+JiMxNjA7PC90ZD5cIiwgdGhhdC5kb2N1bWVudFsgMCBdIClcblx0XHRcdFx0LmF0dHIoIFwiY29sc3BhblwiLCAkKCB0aGlzICkuYXR0ciggXCJjb2xzcGFuXCIgKSB8fCAxIClcblx0XHRcdFx0LmFwcGVuZFRvKCB0YXJnZXRUciApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRfY29udGFjdENvbnRhaW5lcnM6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgaSwgaiwgZGlzdCwgaXRlbVdpdGhMZWFzdERpc3RhbmNlLCBwb3NQcm9wZXJ0eSwgc2l6ZVByb3BlcnR5LCBjdXIsIG5lYXJCb3R0b20sXG5cdFx0XHRmbG9hdGluZywgYXhpcyxcblx0XHRcdGlubmVybW9zdENvbnRhaW5lciA9IG51bGwsXG5cdFx0XHRpbm5lcm1vc3RJbmRleCA9IG51bGw7XG5cblx0XHQvLyBHZXQgaW5uZXJtb3N0IGNvbnRhaW5lciB0aGF0IGludGVyc2VjdHMgd2l0aCBpdGVtXG5cdFx0Zm9yICggaSA9IHRoaXMuY29udGFpbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcblxuXHRcdFx0Ly8gTmV2ZXIgY29uc2lkZXIgYSBjb250YWluZXIgdGhhdCdzIGxvY2F0ZWQgd2l0aGluIHRoZSBpdGVtIGl0c2VsZlxuXHRcdFx0aWYgKCAkLmNvbnRhaW5zKCB0aGlzLmN1cnJlbnRJdGVtWyAwIF0sIHRoaXMuY29udGFpbmVyc1sgaSBdLmVsZW1lbnRbIDAgXSApICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLl9pbnRlcnNlY3RzV2l0aCggdGhpcy5jb250YWluZXJzWyBpIF0uY29udGFpbmVyQ2FjaGUgKSApIHtcblxuXHRcdFx0XHQvLyBJZiB3ZSd2ZSBhbHJlYWR5IGZvdW5kIGEgY29udGFpbmVyIGFuZCBpdCdzIG1vcmUgXCJpbm5lclwiIHRoYW4gdGhpcywgdGhlbiBjb250aW51ZVxuXHRcdFx0XHRpZiAoIGlubmVybW9zdENvbnRhaW5lciAmJlxuXHRcdFx0XHRcdFx0JC5jb250YWlucyhcblx0XHRcdFx0XHRcdFx0dGhpcy5jb250YWluZXJzWyBpIF0uZWxlbWVudFsgMCBdLFxuXHRcdFx0XHRcdFx0XHRpbm5lcm1vc3RDb250YWluZXIuZWxlbWVudFsgMCBdICkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbm5lcm1vc3RDb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcnNbIGkgXTtcblx0XHRcdFx0aW5uZXJtb3N0SW5kZXggPSBpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIGNvbnRhaW5lciBkb2Vzbid0IGludGVyc2VjdC4gdHJpZ2dlciBcIm91dFwiIGV2ZW50IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRpZiAoIHRoaXMuY29udGFpbmVyc1sgaSBdLmNvbnRhaW5lckNhY2hlLm92ZXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5jb250YWluZXJzWyBpIF0uX3RyaWdnZXIoIFwib3V0XCIsIGV2ZW50LCB0aGlzLl91aUhhc2goIHRoaXMgKSApO1xuXHRcdFx0XHRcdHRoaXMuY29udGFpbmVyc1sgaSBdLmNvbnRhaW5lckNhY2hlLm92ZXIgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBJZiBubyBpbnRlcnNlY3RpbmcgY29udGFpbmVycyBmb3VuZCwgcmV0dXJuXG5cdFx0aWYgKCAhaW5uZXJtb3N0Q29udGFpbmVyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1vdmUgdGhlIGl0ZW0gaW50byB0aGUgY29udGFpbmVyIGlmIGl0J3Mgbm90IHRoZXJlIGFscmVhZHlcblx0XHRpZiAoIHRoaXMuY29udGFpbmVycy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRpZiAoICF0aGlzLmNvbnRhaW5lcnNbIGlubmVybW9zdEluZGV4IF0uY29udGFpbmVyQ2FjaGUub3ZlciApIHtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzWyBpbm5lcm1vc3RJbmRleCBdLl90cmlnZ2VyKCBcIm92ZXJcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCggdGhpcyApICk7XG5cdFx0XHRcdHRoaXMuY29udGFpbmVyc1sgaW5uZXJtb3N0SW5kZXggXS5jb250YWluZXJDYWNoZS5vdmVyID0gMTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBXaGVuIGVudGVyaW5nIGEgbmV3IGNvbnRhaW5lciwgd2Ugd2lsbCBmaW5kIHRoZSBpdGVtIHdpdGggdGhlIGxlYXN0IGRpc3RhbmNlIGFuZFxuXHRcdFx0Ly8gYXBwZW5kIG91ciBpdGVtIG5lYXIgaXRcblx0XHRcdGRpc3QgPSAxMDAwMDtcblx0XHRcdGl0ZW1XaXRoTGVhc3REaXN0YW5jZSA9IG51bGw7XG5cdFx0XHRmbG9hdGluZyA9IGlubmVybW9zdENvbnRhaW5lci5mbG9hdGluZyB8fCB0aGlzLl9pc0Zsb2F0aW5nKCB0aGlzLmN1cnJlbnRJdGVtICk7XG5cdFx0XHRwb3NQcm9wZXJ0eSA9IGZsb2F0aW5nID8gXCJsZWZ0XCIgOiBcInRvcFwiO1xuXHRcdFx0c2l6ZVByb3BlcnR5ID0gZmxvYXRpbmcgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiO1xuXHRcdFx0YXhpcyA9IGZsb2F0aW5nID8gXCJwYWdlWFwiIDogXCJwYWdlWVwiO1xuXG5cdFx0XHRmb3IgKCBqID0gdGhpcy5pdGVtcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSApIHtcblx0XHRcdFx0aWYgKCAhJC5jb250YWlucyhcblx0XHRcdFx0XHRcdHRoaXMuY29udGFpbmVyc1sgaW5uZXJtb3N0SW5kZXggXS5lbGVtZW50WyAwIF0sIHRoaXMuaXRlbXNbIGogXS5pdGVtWyAwIF0gKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRoaXMuaXRlbXNbIGogXS5pdGVtWyAwIF0gPT09IHRoaXMuY3VycmVudEl0ZW1bIDAgXSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN1ciA9IHRoaXMuaXRlbXNbIGogXS5pdGVtLm9mZnNldCgpWyBwb3NQcm9wZXJ0eSBdO1xuXHRcdFx0XHRuZWFyQm90dG9tID0gZmFsc2U7XG5cdFx0XHRcdGlmICggZXZlbnRbIGF4aXMgXSAtIGN1ciA+IHRoaXMuaXRlbXNbIGogXVsgc2l6ZVByb3BlcnR5IF0gLyAyICkge1xuXHRcdFx0XHRcdG5lYXJCb3R0b20gPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggZXZlbnRbIGF4aXMgXSAtIGN1ciApIDwgZGlzdCApIHtcblx0XHRcdFx0XHRkaXN0ID0gTWF0aC5hYnMoIGV2ZW50WyBheGlzIF0gLSBjdXIgKTtcblx0XHRcdFx0XHRpdGVtV2l0aExlYXN0RGlzdGFuY2UgPSB0aGlzLml0ZW1zWyBqIF07XG5cdFx0XHRcdFx0dGhpcy5kaXJlY3Rpb24gPSBuZWFyQm90dG9tID8gXCJ1cFwiIDogXCJkb3duXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly9DaGVjayBpZiBkcm9wT25FbXB0eSBpcyBlbmFibGVkXG5cdFx0XHRpZiAoICFpdGVtV2l0aExlYXN0RGlzdGFuY2UgJiYgIXRoaXMub3B0aW9ucy5kcm9wT25FbXB0eSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuY3VycmVudENvbnRhaW5lciA9PT0gdGhpcy5jb250YWluZXJzWyBpbm5lcm1vc3RJbmRleCBdICkge1xuXHRcdFx0XHRpZiAoICF0aGlzLmN1cnJlbnRDb250YWluZXIuY29udGFpbmVyQ2FjaGUub3ZlciApIHtcblx0XHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbIGlubmVybW9zdEluZGV4IF0uX3RyaWdnZXIoIFwib3ZlclwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkgKTtcblx0XHRcdFx0XHR0aGlzLmN1cnJlbnRDb250YWluZXIuY29udGFpbmVyQ2FjaGUub3ZlciA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpdGVtV2l0aExlYXN0RGlzdGFuY2UgP1xuXHRcdFx0XHR0aGlzLl9yZWFycmFuZ2UoIGV2ZW50LCBpdGVtV2l0aExlYXN0RGlzdGFuY2UsIG51bGwsIHRydWUgKSA6XG5cdFx0XHRcdHRoaXMuX3JlYXJyYW5nZSggZXZlbnQsIG51bGwsIHRoaXMuY29udGFpbmVyc1sgaW5uZXJtb3N0SW5kZXggXS5lbGVtZW50LCB0cnVlICk7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCBcImNoYW5nZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkgKTtcblx0XHRcdHRoaXMuY29udGFpbmVyc1sgaW5uZXJtb3N0SW5kZXggXS5fdHJpZ2dlciggXCJjaGFuZ2VcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCggdGhpcyApICk7XG5cdFx0XHR0aGlzLmN1cnJlbnRDb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcnNbIGlubmVybW9zdEluZGV4IF07XG5cblx0XHRcdC8vVXBkYXRlIHRoZSBwbGFjZWhvbGRlclxuXHRcdFx0dGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyLnVwZGF0ZSggdGhpcy5jdXJyZW50Q29udGFpbmVyLCB0aGlzLnBsYWNlaG9sZGVyICk7XG5cblx0XHRcdHRoaXMuY29udGFpbmVyc1sgaW5uZXJtb3N0SW5kZXggXS5fdHJpZ2dlciggXCJvdmVyXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goIHRoaXMgKSApO1xuXHRcdFx0dGhpcy5jb250YWluZXJzWyBpbm5lcm1vc3RJbmRleCBdLmNvbnRhaW5lckNhY2hlLm92ZXIgPSAxO1xuXHRcdH1cblxuXHR9LFxuXG5cdF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0aGVscGVyID0gJC5pc0Z1bmN0aW9uKCBvLmhlbHBlciApID9cblx0XHRcdFx0JCggby5oZWxwZXIuYXBwbHkoIHRoaXMuZWxlbWVudFsgMCBdLCBbIGV2ZW50LCB0aGlzLmN1cnJlbnRJdGVtIF0gKSApIDpcblx0XHRcdFx0KCBvLmhlbHBlciA9PT0gXCJjbG9uZVwiID8gdGhpcy5jdXJyZW50SXRlbS5jbG9uZSgpIDogdGhpcy5jdXJyZW50SXRlbSApO1xuXG5cdFx0Ly9BZGQgdGhlIGhlbHBlciB0byB0aGUgRE9NIGlmIHRoYXQgZGlkbid0IGhhcHBlbiBhbHJlYWR5XG5cdFx0aWYgKCAhaGVscGVyLnBhcmVudHMoIFwiYm9keVwiICkubGVuZ3RoICkge1xuXHRcdFx0JCggby5hcHBlbmRUbyAhPT0gXCJwYXJlbnRcIiA/XG5cdFx0XHRcdG8uYXBwZW5kVG8gOlxuXHRcdFx0XHR0aGlzLmN1cnJlbnRJdGVtWyAwIF0ucGFyZW50Tm9kZSApWyAwIF0uYXBwZW5kQ2hpbGQoIGhlbHBlclsgMCBdICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBoZWxwZXJbIDAgXSA9PT0gdGhpcy5jdXJyZW50SXRlbVsgMCBdICkge1xuXHRcdFx0dGhpcy5fc3RvcmVkQ1NTID0ge1xuXHRcdFx0XHR3aWR0aDogdGhpcy5jdXJyZW50SXRlbVsgMCBdLnN0eWxlLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IHRoaXMuY3VycmVudEl0ZW1bIDAgXS5zdHlsZS5oZWlnaHQsXG5cdFx0XHRcdHBvc2l0aW9uOiB0aGlzLmN1cnJlbnRJdGVtLmNzcyggXCJwb3NpdGlvblwiICksXG5cdFx0XHRcdHRvcDogdGhpcy5jdXJyZW50SXRlbS5jc3MoIFwidG9wXCIgKSxcblx0XHRcdFx0bGVmdDogdGhpcy5jdXJyZW50SXRlbS5jc3MoIFwibGVmdFwiIClcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aWYgKCAhaGVscGVyWyAwIF0uc3R5bGUud2lkdGggfHwgby5mb3JjZUhlbHBlclNpemUgKSB7XG5cdFx0XHRoZWxwZXIud2lkdGgoIHRoaXMuY3VycmVudEl0ZW0ud2lkdGgoKSApO1xuXHRcdH1cblx0XHRpZiAoICFoZWxwZXJbIDAgXS5zdHlsZS5oZWlnaHQgfHwgby5mb3JjZUhlbHBlclNpemUgKSB7XG5cdFx0XHRoZWxwZXIuaGVpZ2h0KCB0aGlzLmN1cnJlbnRJdGVtLmhlaWdodCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhlbHBlcjtcblxuXHR9LFxuXG5cdF9hZGp1c3RPZmZzZXRGcm9tSGVscGVyOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggdHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IG9iai5zcGxpdCggXCIgXCIgKTtcblx0XHR9XG5cdFx0aWYgKCAkLmlzQXJyYXkoIG9iaiApICkge1xuXHRcdFx0b2JqID0geyBsZWZ0OiArb2JqWyAwIF0sIHRvcDogK29ialsgMSBdIHx8IDAgfTtcblx0XHR9XG5cdFx0aWYgKCBcImxlZnRcIiBpbiBvYmogKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay5sZWZ0ID0gb2JqLmxlZnQgKyB0aGlzLm1hcmdpbnMubGVmdDtcblx0XHR9XG5cdFx0aWYgKCBcInJpZ2h0XCIgaW4gb2JqICkge1xuXHRcdFx0dGhpcy5vZmZzZXQuY2xpY2subGVmdCA9IHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSBvYmoucmlnaHQgKyB0aGlzLm1hcmdpbnMubGVmdDtcblx0XHR9XG5cdFx0aWYgKCBcInRvcFwiIGluIG9iaiApIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA9IG9iai50b3AgKyB0aGlzLm1hcmdpbnMudG9wO1xuXHRcdH1cblx0XHRpZiAoIFwiYm90dG9tXCIgaW4gb2JqICkge1xuXHRcdFx0dGhpcy5vZmZzZXQuY2xpY2sudG9wID0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSBvYmouYm90dG9tICsgdGhpcy5tYXJnaW5zLnRvcDtcblx0XHR9XG5cdH0sXG5cblx0X2dldFBhcmVudE9mZnNldDogZnVuY3Rpb24oKSB7XG5cblx0XHQvL0dldCB0aGUgb2Zmc2V0UGFyZW50IGFuZCBjYWNoZSBpdHMgcG9zaXRpb25cblx0XHR0aGlzLm9mZnNldFBhcmVudCA9IHRoaXMuaGVscGVyLm9mZnNldFBhcmVudCgpO1xuXHRcdHZhciBwbyA9IHRoaXMub2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBuZWVkIHRvIG1vZGlmeSBhIG9mZnNldCBjYWxjdWxhdGVkIG9uIHN0YXJ0LCBzaW5jZSB0aGVcblx0XHQvLyBmb2xsb3dpbmcgaGFwcGVuZWQ6XG5cdFx0Ly8gMS4gVGhlIHBvc2l0aW9uIG9mIHRoZSBoZWxwZXIgaXMgYWJzb2x1dGUsIHNvIGl0J3MgcG9zaXRpb24gaXMgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGVcblx0XHQvLyBuZXh0IHBvc2l0aW9uZWQgcGFyZW50XG5cdFx0Ly8gMi4gVGhlIGFjdHVhbCBvZmZzZXQgcGFyZW50IGlzIGEgY2hpbGQgb2YgdGhlIHNjcm9sbCBwYXJlbnQsIGFuZCB0aGUgc2Nyb2xsIHBhcmVudCBpc24ndFxuXHRcdC8vIHRoZSBkb2N1bWVudCwgd2hpY2ggbWVhbnMgdGhhdCB0aGUgc2Nyb2xsIGlzIGluY2x1ZGVkIGluIHRoZSBpbml0aWFsIGNhbGN1bGF0aW9uIG9mIHRoZVxuXHRcdC8vIG9mZnNldCBvZiB0aGUgcGFyZW50LCBhbmQgbmV2ZXIgcmVjYWxjdWxhdGVkIHVwb24gZHJhZ1xuXHRcdGlmICggdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiICYmIHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0gIT09IHRoaXMuZG9jdW1lbnRbIDAgXSAmJlxuXHRcdFx0XHQkLmNvbnRhaW5zKCB0aGlzLnNjcm9sbFBhcmVudFsgMCBdLCB0aGlzLm9mZnNldFBhcmVudFsgMCBdICkgKSB7XG5cdFx0XHRwby5sZWZ0ICs9IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKTtcblx0XHRcdHBvLnRvcCArPSB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKTtcblx0XHR9XG5cblx0XHQvLyBUaGlzIG5lZWRzIHRvIGJlIGFjdHVhbGx5IGRvbmUgZm9yIGFsbCBicm93c2Vycywgc2luY2UgcGFnZVgvcGFnZVkgaW5jbHVkZXMgdGhpc1xuXHRcdC8vIGluZm9ybWF0aW9uIHdpdGggYW4gdWdseSBJRSBmaXhcblx0XHRpZiAoIHRoaXMub2Zmc2V0UGFyZW50WyAwIF0gPT09IHRoaXMuZG9jdW1lbnRbIDAgXS5ib2R5IHx8XG5cdFx0XHRcdCggdGhpcy5vZmZzZXRQYXJlbnRbIDAgXS50YWdOYW1lICYmXG5cdFx0XHRcdHRoaXMub2Zmc2V0UGFyZW50WyAwIF0udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImh0bWxcIiAmJiAkLnVpLmllICkgKSB7XG5cdFx0XHRwbyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcG8udG9wICsgKCBwYXJzZUludCggdGhpcy5vZmZzZXRQYXJlbnQuY3NzKCBcImJvcmRlclRvcFdpZHRoXCIgKSwgMTAgKSB8fCAwICksXG5cdFx0XHRsZWZ0OiBwby5sZWZ0ICsgKCBwYXJzZUludCggdGhpcy5vZmZzZXRQYXJlbnQuY3NzKCBcImJvcmRlckxlZnRXaWR0aFwiICksIDEwICkgfHwgMCApXG5cdFx0fTtcblxuXHR9LFxuXG5cdF9nZXRSZWxhdGl2ZU9mZnNldDogZnVuY3Rpb24oKSB7XG5cblx0XHRpZiAoIHRoaXMuY3NzUG9zaXRpb24gPT09IFwicmVsYXRpdmVcIiApIHtcblx0XHRcdHZhciBwID0gdGhpcy5jdXJyZW50SXRlbS5wb3NpdGlvbigpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dG9wOiBwLnRvcCAtICggcGFyc2VJbnQoIHRoaXMuaGVscGVyLmNzcyggXCJ0b3BcIiApLCAxMCApIHx8IDAgKSArXG5cdFx0XHRcdFx0dGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCksXG5cdFx0XHRcdGxlZnQ6IHAubGVmdCAtICggcGFyc2VJbnQoIHRoaXMuaGVscGVyLmNzcyggXCJsZWZ0XCIgKSwgMTAgKSB8fCAwICkgK1xuXHRcdFx0XHRcdHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKVxuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdH0sXG5cblx0X2NhY2hlTWFyZ2luczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5tYXJnaW5zID0ge1xuXHRcdFx0bGVmdDogKCBwYXJzZUludCggdGhpcy5jdXJyZW50SXRlbS5jc3MoIFwibWFyZ2luTGVmdFwiICksIDEwICkgfHwgMCApLFxuXHRcdFx0dG9wOiAoIHBhcnNlSW50KCB0aGlzLmN1cnJlbnRJdGVtLmNzcyggXCJtYXJnaW5Ub3BcIiApLCAxMCApIHx8IDAgKVxuXHRcdH07XG5cdH0sXG5cblx0X2NhY2hlSGVscGVyUHJvcG9ydGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVscGVyUHJvcG9ydGlvbnMgPSB7XG5cdFx0XHR3aWR0aDogdGhpcy5oZWxwZXIub3V0ZXJXaWR0aCgpLFxuXHRcdFx0aGVpZ2h0OiB0aGlzLmhlbHBlci5vdXRlckhlaWdodCgpXG5cdFx0fTtcblx0fSxcblxuXHRfc2V0Q29udGFpbm1lbnQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGNlLCBjbywgb3Zlcixcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnM7XG5cdFx0aWYgKCBvLmNvbnRhaW5tZW50ID09PSBcInBhcmVudFwiICkge1xuXHRcdFx0by5jb250YWlubWVudCA9IHRoaXMuaGVscGVyWyAwIF0ucGFyZW50Tm9kZTtcblx0XHR9XG5cdFx0aWYgKCBvLmNvbnRhaW5tZW50ID09PSBcImRvY3VtZW50XCIgfHwgby5jb250YWlubWVudCA9PT0gXCJ3aW5kb3dcIiApIHtcblx0XHRcdHRoaXMuY29udGFpbm1lbnQgPSBbXG5cdFx0XHRcdDAgLSB0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0IC0gdGhpcy5vZmZzZXQucGFyZW50LmxlZnQsXG5cdFx0XHRcdDAgLSB0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3AgLSB0aGlzLm9mZnNldC5wYXJlbnQudG9wLFxuXHRcdFx0XHRvLmNvbnRhaW5tZW50ID09PSBcImRvY3VtZW50XCIgP1xuXHRcdFx0XHRcdHRoaXMuZG9jdW1lbnQud2lkdGgoKSA6XG5cdFx0XHRcdFx0dGhpcy53aW5kb3cud2lkdGgoKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSB0aGlzLm1hcmdpbnMubGVmdCxcblx0XHRcdFx0KCBvLmNvbnRhaW5tZW50ID09PSBcImRvY3VtZW50XCIgP1xuXHRcdFx0XHRcdCggdGhpcy5kb2N1bWVudC5oZWlnaHQoKSB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuc2Nyb2xsSGVpZ2h0ICkgOlxuXHRcdFx0XHRcdHRoaXMud2luZG93LmhlaWdodCgpIHx8IHRoaXMuZG9jdW1lbnRbIDAgXS5ib2R5LnBhcmVudE5vZGUuc2Nyb2xsSGVpZ2h0XG5cdFx0XHRcdCkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtIHRoaXMubWFyZ2lucy50b3Bcblx0XHRcdF07XG5cdFx0fVxuXG5cdFx0aWYgKCAhKCAvXihkb2N1bWVudHx3aW5kb3d8cGFyZW50KSQvICkudGVzdCggby5jb250YWlubWVudCApICkge1xuXHRcdFx0Y2UgPSAkKCBvLmNvbnRhaW5tZW50IClbIDAgXTtcblx0XHRcdGNvID0gJCggby5jb250YWlubWVudCApLm9mZnNldCgpO1xuXHRcdFx0b3ZlciA9ICggJCggY2UgKS5jc3MoIFwib3ZlcmZsb3dcIiApICE9PSBcImhpZGRlblwiICk7XG5cblx0XHRcdHRoaXMuY29udGFpbm1lbnQgPSBbXG5cdFx0XHRcdGNvLmxlZnQgKyAoIHBhcnNlSW50KCAkKCBjZSApLmNzcyggXCJib3JkZXJMZWZ0V2lkdGhcIiApLCAxMCApIHx8IDAgKSArXG5cdFx0XHRcdFx0KCBwYXJzZUludCggJCggY2UgKS5jc3MoIFwicGFkZGluZ0xlZnRcIiApLCAxMCApIHx8IDAgKSAtIHRoaXMubWFyZ2lucy5sZWZ0LFxuXHRcdFx0XHRjby50b3AgKyAoIHBhcnNlSW50KCAkKCBjZSApLmNzcyggXCJib3JkZXJUb3BXaWR0aFwiICksIDEwICkgfHwgMCApICtcblx0XHRcdFx0XHQoIHBhcnNlSW50KCAkKCBjZSApLmNzcyggXCJwYWRkaW5nVG9wXCIgKSwgMTAgKSB8fCAwICkgLSB0aGlzLm1hcmdpbnMudG9wLFxuXHRcdFx0XHRjby5sZWZ0ICsgKCBvdmVyID8gTWF0aC5tYXgoIGNlLnNjcm9sbFdpZHRoLCBjZS5vZmZzZXRXaWR0aCApIDogY2Uub2Zmc2V0V2lkdGggKSAtXG5cdFx0XHRcdFx0KCBwYXJzZUludCggJCggY2UgKS5jc3MoIFwiYm9yZGVyTGVmdFdpZHRoXCIgKSwgMTAgKSB8fCAwICkgLVxuXHRcdFx0XHRcdCggcGFyc2VJbnQoICQoIGNlICkuY3NzKCBcInBhZGRpbmdSaWdodFwiICksIDEwICkgfHwgMCApIC1cblx0XHRcdFx0XHR0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC0gdGhpcy5tYXJnaW5zLmxlZnQsXG5cdFx0XHRcdGNvLnRvcCArICggb3ZlciA/IE1hdGgubWF4KCBjZS5zY3JvbGxIZWlnaHQsIGNlLm9mZnNldEhlaWdodCApIDogY2Uub2Zmc2V0SGVpZ2h0ICkgLVxuXHRcdFx0XHRcdCggcGFyc2VJbnQoICQoIGNlICkuY3NzKCBcImJvcmRlclRvcFdpZHRoXCIgKSwgMTAgKSB8fCAwICkgLVxuXHRcdFx0XHRcdCggcGFyc2VJbnQoICQoIGNlICkuY3NzKCBcInBhZGRpbmdCb3R0b21cIiApLCAxMCApIHx8IDAgKSAtXG5cdFx0XHRcdFx0dGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXG5cdFx0XHRdO1xuXHRcdH1cblxuXHR9LFxuXG5cdF9jb252ZXJ0UG9zaXRpb25UbzogZnVuY3Rpb24oIGQsIHBvcyApIHtcblxuXHRcdGlmICggIXBvcyApIHtcblx0XHRcdHBvcyA9IHRoaXMucG9zaXRpb247XG5cdFx0fVxuXHRcdHZhciBtb2QgPSBkID09PSBcImFic29sdXRlXCIgPyAxIDogLTEsXG5cdFx0XHRzY3JvbGwgPSB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImFic29sdXRlXCIgJiZcblx0XHRcdFx0ISggdGhpcy5zY3JvbGxQYXJlbnRbIDAgXSAhPT0gdGhpcy5kb2N1bWVudFsgMCBdICYmXG5cdFx0XHRcdCQuY29udGFpbnMoIHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0sIHRoaXMub2Zmc2V0UGFyZW50WyAwIF0gKSApID9cblx0XHRcdFx0XHR0aGlzLm9mZnNldFBhcmVudCA6XG5cdFx0XHRcdFx0dGhpcy5zY3JvbGxQYXJlbnQsXG5cdFx0XHRzY3JvbGxJc1Jvb3ROb2RlID0gKCAvKGh0bWx8Ym9keSkvaSApLnRlc3QoIHNjcm9sbFsgMCBdLnRhZ05hbWUgKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IChcblxuXHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0cG9zLnRvcFx0K1xuXG5cdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHR0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3AgKiBtb2QgK1xuXG5cdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudC50b3AgKiBtb2QgLVxuXHRcdFx0XHQoICggdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJmaXhlZFwiID9cblx0XHRcdFx0XHQtdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCkgOlxuXHRcdFx0XHRcdCggc2Nyb2xsSXNSb290Tm9kZSA/IDAgOiBzY3JvbGwuc2Nyb2xsVG9wKCkgKSApICogbW9kIClcblx0XHRcdCksXG5cdFx0XHRsZWZ0OiAoXG5cblx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdHBvcy5sZWZ0ICtcblxuXHRcdFx0XHQvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcblx0XHRcdFx0dGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAqIG1vZCArXG5cblx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0dGhpcy5vZmZzZXQucGFyZW50LmxlZnQgKiBtb2RcdC1cblx0XHRcdFx0KCAoIHRoaXMuY3NzUG9zaXRpb24gPT09IFwiZml4ZWRcIiA/XG5cdFx0XHRcdFx0LXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKSA6IHNjcm9sbElzUm9vdE5vZGUgPyAwIDpcblx0XHRcdFx0XHRzY3JvbGwuc2Nyb2xsTGVmdCgpICkgKiBtb2QgKVxuXHRcdFx0KVxuXHRcdH07XG5cblx0fSxcblxuXHRfZ2VuZXJhdGVQb3NpdGlvbjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0dmFyIHRvcCwgbGVmdCxcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRwYWdlWCA9IGV2ZW50LnBhZ2VYLFxuXHRcdFx0cGFnZVkgPSBldmVudC5wYWdlWSxcblx0XHRcdHNjcm9sbCA9IHRoaXMuY3NzUG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiAmJlxuXHRcdFx0XHQhKCB0aGlzLnNjcm9sbFBhcmVudFsgMCBdICE9PSB0aGlzLmRvY3VtZW50WyAwIF0gJiZcblx0XHRcdFx0JC5jb250YWlucyggdGhpcy5zY3JvbGxQYXJlbnRbIDAgXSwgdGhpcy5vZmZzZXRQYXJlbnRbIDAgXSApICkgP1xuXHRcdFx0XHRcdHRoaXMub2Zmc2V0UGFyZW50IDpcblx0XHRcdFx0XHR0aGlzLnNjcm9sbFBhcmVudCxcblx0XHRcdFx0c2Nyb2xsSXNSb290Tm9kZSA9ICggLyhodG1sfGJvZHkpL2kgKS50ZXN0KCBzY3JvbGxbIDAgXS50YWdOYW1lICk7XG5cblx0XHQvLyBUaGlzIGlzIGFub3RoZXIgdmVyeSB3ZWlyZCBzcGVjaWFsIGNhc2UgdGhhdCBvbmx5IGhhcHBlbnMgZm9yIHJlbGF0aXZlIGVsZW1lbnRzOlxuXHRcdC8vIDEuIElmIHRoZSBjc3MgcG9zaXRpb24gaXMgcmVsYXRpdmVcblx0XHQvLyAyLiBhbmQgdGhlIHNjcm9sbCBwYXJlbnQgaXMgdGhlIGRvY3VtZW50IG9yIHNpbWlsYXIgdG8gdGhlIG9mZnNldCBwYXJlbnRcblx0XHQvLyB3ZSBoYXZlIHRvIHJlZnJlc2ggdGhlIHJlbGF0aXZlIG9mZnNldCBkdXJpbmcgdGhlIHNjcm9sbCBzbyB0aGVyZSBhcmUgbm8ganVtcHNcblx0XHRpZiAoIHRoaXMuY3NzUG9zaXRpb24gPT09IFwicmVsYXRpdmVcIiAmJiAhKCB0aGlzLnNjcm9sbFBhcmVudFsgMCBdICE9PSB0aGlzLmRvY3VtZW50WyAwIF0gJiZcblx0XHRcdFx0dGhpcy5zY3JvbGxQYXJlbnRbIDAgXSAhPT0gdGhpcy5vZmZzZXRQYXJlbnRbIDAgXSApICkge1xuXHRcdFx0dGhpcy5vZmZzZXQucmVsYXRpdmUgPSB0aGlzLl9nZXRSZWxhdGl2ZU9mZnNldCgpO1xuXHRcdH1cblxuXHRcdC8qXG5cdFx0ICogLSBQb3NpdGlvbiBjb25zdHJhaW5pbmcgLVxuXHRcdCAqIENvbnN0cmFpbiB0aGUgcG9zaXRpb24gdG8gYSBtaXggb2YgZ3JpZCwgY29udGFpbm1lbnQuXG5cdFx0ICovXG5cblx0XHRpZiAoIHRoaXMub3JpZ2luYWxQb3NpdGlvbiApIHsgLy9JZiB3ZSBhcmUgbm90IGRyYWdnaW5nIHlldCwgd2Ugd29uJ3QgY2hlY2sgZm9yIG9wdGlvbnNcblxuXHRcdFx0aWYgKCB0aGlzLmNvbnRhaW5tZW50ICkge1xuXHRcdFx0XHRpZiAoIGV2ZW50LnBhZ2VYIC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA8IHRoaXMuY29udGFpbm1lbnRbIDAgXSApIHtcblx0XHRcdFx0XHRwYWdlWCA9IHRoaXMuY29udGFpbm1lbnRbIDAgXSArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA8IHRoaXMuY29udGFpbm1lbnRbIDEgXSApIHtcblx0XHRcdFx0XHRwYWdlWSA9IHRoaXMuY29udGFpbm1lbnRbIDEgXSArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGV2ZW50LnBhZ2VYIC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+IHRoaXMuY29udGFpbm1lbnRbIDIgXSApIHtcblx0XHRcdFx0XHRwYWdlWCA9IHRoaXMuY29udGFpbm1lbnRbIDIgXSArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+IHRoaXMuY29udGFpbm1lbnRbIDMgXSApIHtcblx0XHRcdFx0XHRwYWdlWSA9IHRoaXMuY29udGFpbm1lbnRbIDMgXSArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG8uZ3JpZCApIHtcblx0XHRcdFx0dG9wID0gdGhpcy5vcmlnaW5hbFBhZ2VZICsgTWF0aC5yb3VuZCggKCBwYWdlWSAtIHRoaXMub3JpZ2luYWxQYWdlWSApIC9cblx0XHRcdFx0XHRvLmdyaWRbIDEgXSApICogby5ncmlkWyAxIF07XG5cdFx0XHRcdHBhZ2VZID0gdGhpcy5jb250YWlubWVudCA/XG5cdFx0XHRcdFx0KCAoIHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+PSB0aGlzLmNvbnRhaW5tZW50WyAxIF0gJiZcblx0XHRcdFx0XHRcdHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA8PSB0aGlzLmNvbnRhaW5tZW50WyAzIF0gKSA/XG5cdFx0XHRcdFx0XHRcdHRvcCA6XG5cdFx0XHRcdFx0XHRcdCggKCB0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPj0gdGhpcy5jb250YWlubWVudFsgMSBdICkgP1xuXHRcdFx0XHRcdFx0XHRcdHRvcCAtIG8uZ3JpZFsgMSBdIDogdG9wICsgby5ncmlkWyAxIF0gKSApIDpcblx0XHRcdFx0XHRcdFx0XHR0b3A7XG5cblx0XHRcdFx0bGVmdCA9IHRoaXMub3JpZ2luYWxQYWdlWCArIE1hdGgucm91bmQoICggcGFnZVggLSB0aGlzLm9yaWdpbmFsUGFnZVggKSAvXG5cdFx0XHRcdFx0by5ncmlkWyAwIF0gKSAqIG8uZ3JpZFsgMCBdO1xuXHRcdFx0XHRwYWdlWCA9IHRoaXMuY29udGFpbm1lbnQgP1xuXHRcdFx0XHRcdCggKCBsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+PSB0aGlzLmNvbnRhaW5tZW50WyAwIF0gJiZcblx0XHRcdFx0XHRcdGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0IDw9IHRoaXMuY29udGFpbm1lbnRbIDIgXSApID9cblx0XHRcdFx0XHRcdFx0bGVmdCA6XG5cdFx0XHRcdFx0XHRcdCggKCBsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+PSB0aGlzLmNvbnRhaW5tZW50WyAwIF0gKSA/XG5cdFx0XHRcdFx0XHRcdFx0bGVmdCAtIG8uZ3JpZFsgMCBdIDogbGVmdCArIG8uZ3JpZFsgMCBdICkgKSA6XG5cdFx0XHRcdFx0XHRcdFx0bGVmdDtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IChcblxuXHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0cGFnZVkgLVxuXG5cdFx0XHRcdC8vIENsaWNrIG9mZnNldCAocmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQpXG5cdFx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCAtXG5cblx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLnRvcCAtXG5cblx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0dGhpcy5vZmZzZXQucGFyZW50LnRvcCArXG5cdFx0XHRcdCggKCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgP1xuXHRcdFx0XHRcdC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSA6XG5cdFx0XHRcdFx0KCBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHNjcm9sbC5zY3JvbGxUb3AoKSApICkgKVxuXHRcdFx0KSxcblx0XHRcdGxlZnQ6IChcblxuXHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0cGFnZVggLVxuXG5cdFx0XHRcdC8vIENsaWNrIG9mZnNldCAocmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQpXG5cdFx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgLVxuXG5cdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHR0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0IC1cblxuXHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQubGVmdCArXG5cdFx0XHRcdCggKCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgP1xuXHRcdFx0XHRcdC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCkgOlxuXHRcdFx0XHRcdHNjcm9sbElzUm9vdE5vZGUgPyAwIDogc2Nyb2xsLnNjcm9sbExlZnQoKSApIClcblx0XHRcdClcblx0XHR9O1xuXG5cdH0sXG5cblx0X3JlYXJyYW5nZTogZnVuY3Rpb24oIGV2ZW50LCBpLCBhLCBoYXJkUmVmcmVzaCApIHtcblxuXHRcdGEgPyBhWyAwIF0uYXBwZW5kQ2hpbGQoIHRoaXMucGxhY2Vob2xkZXJbIDAgXSApIDpcblx0XHRcdGkuaXRlbVsgMCBdLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCB0aGlzLnBsYWNlaG9sZGVyWyAwIF0sXG5cdFx0XHRcdCggdGhpcy5kaXJlY3Rpb24gPT09IFwiZG93blwiID8gaS5pdGVtWyAwIF0gOiBpLml0ZW1bIDAgXS5uZXh0U2libGluZyApICk7XG5cblx0XHQvL1ZhcmlvdXMgdGhpbmdzIGRvbmUgaGVyZSB0byBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZTpcblx0XHQvLyAxLiB3ZSBjcmVhdGUgYSBzZXRUaW1lb3V0LCB0aGF0IGNhbGxzIHJlZnJlc2hQb3NpdGlvbnNcblx0XHQvLyAyLiBvbiB0aGUgaW5zdGFuY2UsIHdlIGhhdmUgYSBjb3VudGVyIHZhcmlhYmxlLCB0aGF0IGdldCdzIGhpZ2hlciBhZnRlciBldmVyeSBhcHBlbmRcblx0XHQvLyAzLiBvbiB0aGUgbG9jYWwgc2NvcGUsIHdlIGNvcHkgdGhlIGNvdW50ZXIgdmFyaWFibGUsIGFuZCBjaGVjayBpbiB0aGUgdGltZW91dCxcblx0XHQvLyBpZiBpdCdzIHN0aWxsIHRoZSBzYW1lXG5cdFx0Ly8gNC4gdGhpcyBsZXRzIG9ubHkgdGhlIGxhc3QgYWRkaXRpb24gdG8gdGhlIHRpbWVvdXQgc3RhY2sgdGhyb3VnaFxuXHRcdHRoaXMuY291bnRlciA9IHRoaXMuY291bnRlciA/ICsrdGhpcy5jb3VudGVyIDogMTtcblx0XHR2YXIgY291bnRlciA9IHRoaXMuY291bnRlcjtcblxuXHRcdHRoaXMuX2RlbGF5KCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY291bnRlciA9PT0gdGhpcy5jb3VudGVyICkge1xuXG5cdFx0XHRcdC8vUHJlY29tcHV0ZSBhZnRlciBlYWNoIERPTSBpbnNlcnRpb24sIE5PVCBvbiBtb3VzZW1vdmVcblx0XHRcdFx0dGhpcy5yZWZyZXNoUG9zaXRpb25zKCAhaGFyZFJlZnJlc2ggKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSxcblxuXHRfY2xlYXI6IGZ1bmN0aW9uKCBldmVudCwgbm9Qcm9wYWdhdGlvbiApIHtcblxuXHRcdHRoaXMucmV2ZXJ0aW5nID0gZmFsc2U7XG5cblx0XHQvLyBXZSBkZWxheSBhbGwgZXZlbnRzIHRoYXQgaGF2ZSB0byBiZSB0cmlnZ2VyZWQgdG8gYWZ0ZXIgdGhlIHBvaW50IHdoZXJlIHRoZSBwbGFjZWhvbGRlclxuXHRcdC8vIGhhcyBiZWVuIHJlbW92ZWQgYW5kIGV2ZXJ5dGhpbmcgZWxzZSBub3JtYWxpemVkIGFnYWluXG5cdFx0dmFyIGksXG5cdFx0XHRkZWxheWVkVHJpZ2dlcnMgPSBbXTtcblxuXHRcdC8vIFdlIGZpcnN0IGhhdmUgdG8gdXBkYXRlIHRoZSBkb20gcG9zaXRpb24gb2YgdGhlIGFjdHVhbCBjdXJyZW50SXRlbVxuXHRcdC8vIE5vdGU6IGRvbid0IGRvIGl0IGlmIHRoZSBjdXJyZW50IGl0ZW0gaXMgYWxyZWFkeSByZW1vdmVkIChieSBhIHVzZXIpLCBvciBpdCBnZXRzXG5cdFx0Ly8gcmVhcHBlbmRlZCAoc2VlICM0MDg4KVxuXHRcdGlmICggIXRoaXMuX25vRmluYWxTb3J0ICYmIHRoaXMuY3VycmVudEl0ZW0ucGFyZW50KCkubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5wbGFjZWhvbGRlci5iZWZvcmUoIHRoaXMuY3VycmVudEl0ZW0gKTtcblx0XHR9XG5cdFx0dGhpcy5fbm9GaW5hbFNvcnQgPSBudWxsO1xuXG5cdFx0aWYgKCB0aGlzLmhlbHBlclsgMCBdID09PSB0aGlzLmN1cnJlbnRJdGVtWyAwIF0gKSB7XG5cdFx0XHRmb3IgKCBpIGluIHRoaXMuX3N0b3JlZENTUyApIHtcblx0XHRcdFx0aWYgKCB0aGlzLl9zdG9yZWRDU1NbIGkgXSA9PT0gXCJhdXRvXCIgfHwgdGhpcy5fc3RvcmVkQ1NTWyBpIF0gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RvcmVkQ1NTWyBpIF0gPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmN1cnJlbnRJdGVtLmNzcyggdGhpcy5fc3RvcmVkQ1NTICk7XG5cdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggdGhpcy5jdXJyZW50SXRlbSwgXCJ1aS1zb3J0YWJsZS1oZWxwZXJcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRJdGVtLnNob3coKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuZnJvbU91dHNpZGUgJiYgIW5vUHJvcGFnYXRpb24gKSB7XG5cdFx0XHRkZWxheWVkVHJpZ2dlcnMucHVzaCggZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKCBcInJlY2VpdmVcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCggdGhpcy5mcm9tT3V0c2lkZSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdGlmICggKCB0aGlzLmZyb21PdXRzaWRlIHx8XG5cdFx0XHRcdHRoaXMuZG9tUG9zaXRpb24ucHJldiAhPT1cblx0XHRcdFx0dGhpcy5jdXJyZW50SXRlbS5wcmV2KCkubm90KCBcIi51aS1zb3J0YWJsZS1oZWxwZXJcIiApWyAwIF0gfHxcblx0XHRcdFx0dGhpcy5kb21Qb3NpdGlvbi5wYXJlbnQgIT09IHRoaXMuY3VycmVudEl0ZW0ucGFyZW50KClbIDAgXSApICYmICFub1Byb3BhZ2F0aW9uICkge1xuXG5cdFx0XHQvLyBUcmlnZ2VyIHVwZGF0ZSBjYWxsYmFjayBpZiB0aGUgRE9NIHBvc2l0aW9uIGhhcyBjaGFuZ2VkXG5cdFx0XHRkZWxheWVkVHJpZ2dlcnMucHVzaCggZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKCBcInVwZGF0ZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgaXRlbXMgQ29udGFpbmVyIGhhcyBDaGFuZ2VkIGFuZCB0cmlnZ2VyIGFwcHJvcHJpYXRlXG5cdFx0Ly8gZXZlbnRzLlxuXHRcdGlmICggdGhpcyAhPT0gdGhpcy5jdXJyZW50Q29udGFpbmVyICkge1xuXHRcdFx0aWYgKCAhbm9Qcm9wYWdhdGlvbiApIHtcblx0XHRcdFx0ZGVsYXllZFRyaWdnZXJzLnB1c2goIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCBcInJlbW92ZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRkZWxheWVkVHJpZ2dlcnMucHVzaCggKCBmdW5jdGlvbiggYyApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0Yy5fdHJpZ2dlciggXCJyZWNlaXZlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goIHRoaXMgKSApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gKS5jYWxsKCB0aGlzLCB0aGlzLmN1cnJlbnRDb250YWluZXIgKSApO1xuXHRcdFx0XHRkZWxheWVkVHJpZ2dlcnMucHVzaCggKCBmdW5jdGlvbiggYyApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0Yy5fdHJpZ2dlciggXCJ1cGRhdGVcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCggdGhpcyApICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSApLmNhbGwoIHRoaXMsIHRoaXMuY3VycmVudENvbnRhaW5lciApICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9Qb3N0IGV2ZW50cyB0byBjb250YWluZXJzXG5cdFx0ZnVuY3Rpb24gZGVsYXlFdmVudCggdHlwZSwgaW5zdGFuY2UsIGNvbnRhaW5lciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGNvbnRhaW5lci5fdHJpZ2dlciggdHlwZSwgZXZlbnQsIGluc3RhbmNlLl91aUhhc2goIGluc3RhbmNlICkgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGZvciAoIGkgPSB0aGlzLmNvbnRhaW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG5cdFx0XHRpZiAoICFub1Byb3BhZ2F0aW9uICkge1xuXHRcdFx0XHRkZWxheWVkVHJpZ2dlcnMucHVzaCggZGVsYXlFdmVudCggXCJkZWFjdGl2YXRlXCIsIHRoaXMsIHRoaXMuY29udGFpbmVyc1sgaSBdICkgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5jb250YWluZXJzWyBpIF0uY29udGFpbmVyQ2FjaGUub3ZlciApIHtcblx0XHRcdFx0ZGVsYXllZFRyaWdnZXJzLnB1c2goIGRlbGF5RXZlbnQoIFwib3V0XCIsIHRoaXMsIHRoaXMuY29udGFpbmVyc1sgaSBdICkgKTtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzWyBpIF0uY29udGFpbmVyQ2FjaGUub3ZlciA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9EbyB3aGF0IHdhcyBvcmlnaW5hbGx5IGluIHBsdWdpbnNcblx0XHRpZiAoIHRoaXMuc3RvcmVkQ3Vyc29yICkge1xuXHRcdFx0dGhpcy5kb2N1bWVudC5maW5kKCBcImJvZHlcIiApLmNzcyggXCJjdXJzb3JcIiwgdGhpcy5zdG9yZWRDdXJzb3IgKTtcblx0XHRcdHRoaXMuc3RvcmVkU3R5bGVzaGVldC5yZW1vdmUoKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLl9zdG9yZWRPcGFjaXR5ICkge1xuXHRcdFx0dGhpcy5oZWxwZXIuY3NzKCBcIm9wYWNpdHlcIiwgdGhpcy5fc3RvcmVkT3BhY2l0eSApO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuX3N0b3JlZFpJbmRleCApIHtcblx0XHRcdHRoaXMuaGVscGVyLmNzcyggXCJ6SW5kZXhcIiwgdGhpcy5fc3RvcmVkWkluZGV4ID09PSBcImF1dG9cIiA/IFwiXCIgOiB0aGlzLl9zdG9yZWRaSW5kZXggKTtcblx0XHR9XG5cblx0XHR0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cblx0XHRpZiAoICFub1Byb3BhZ2F0aW9uICkge1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJiZWZvcmVTdG9wXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSApO1xuXHRcdH1cblxuXHRcdC8vJCh0aGlzLnBsYWNlaG9sZGVyWzBdKS5yZW1vdmUoKTsgd291bGQgaGF2ZSBiZWVuIHRoZSBqUXVlcnkgd2F5IC0gdW5mb3J0dW5hdGVseSxcblx0XHQvLyBpdCB1bmJpbmRzIEFMTCBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgbm9kZSFcblx0XHR0aGlzLnBsYWNlaG9sZGVyWyAwIF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGhpcy5wbGFjZWhvbGRlclsgMCBdICk7XG5cblx0XHRpZiAoICF0aGlzLmNhbmNlbEhlbHBlclJlbW92YWwgKSB7XG5cdFx0XHRpZiAoIHRoaXMuaGVscGVyWyAwIF0gIT09IHRoaXMuY3VycmVudEl0ZW1bIDAgXSApIHtcblx0XHRcdFx0dGhpcy5oZWxwZXIucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmhlbHBlciA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKCAhbm9Qcm9wYWdhdGlvbiApIHtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsYXllZFRyaWdnZXJzLmxlbmd0aDsgaSsrICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXIgYWxsIGRlbGF5ZWQgZXZlbnRzXG5cdFx0XHRcdGRlbGF5ZWRUcmlnZ2Vyc1sgaSBdLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCBcInN0b3BcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5mcm9tT3V0c2lkZSA9IGZhbHNlO1xuXHRcdHJldHVybiAhdGhpcy5jYW5jZWxIZWxwZXJSZW1vdmFsO1xuXG5cdH0sXG5cblx0X3RyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggJC5XaWRnZXQucHJvdG90eXBlLl90cmlnZ2VyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLmNhbmNlbCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdWlIYXNoOiBmdW5jdGlvbiggX2luc3QgKSB7XG5cdFx0dmFyIGluc3QgPSBfaW5zdCB8fCB0aGlzO1xuXHRcdHJldHVybiB7XG5cdFx0XHRoZWxwZXI6IGluc3QuaGVscGVyLFxuXHRcdFx0cGxhY2Vob2xkZXI6IGluc3QucGxhY2Vob2xkZXIgfHwgJCggW10gKSxcblx0XHRcdHBvc2l0aW9uOiBpbnN0LnBvc2l0aW9uLFxuXHRcdFx0b3JpZ2luYWxQb3NpdGlvbjogaW5zdC5vcmlnaW5hbFBvc2l0aW9uLFxuXHRcdFx0b2Zmc2V0OiBpbnN0LnBvc2l0aW9uQWJzLFxuXHRcdFx0aXRlbTogaW5zdC5jdXJyZW50SXRlbSxcblx0XHRcdHNlbmRlcjogX2luc3QgPyBfaW5zdC5lbGVtZW50IDogbnVsbFxuXHRcdH07XG5cdH1cblxufSApO1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIFNwaW5uZXIgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IFNwaW5uZXJcbi8vPj5ncm91cDogV2lkZ2V0c1xuLy8+PmRlc2NyaXB0aW9uOiBEaXNwbGF5cyBidXR0b25zIHRvIGVhc2lseSBpbnB1dCBudW1iZXJzIHZpYSB0aGUga2V5Ym9hcmQgb3IgbW91c2UuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vc3Bpbm5lci9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9zcGlubmVyL1xuLy8+PmNzcy5zdHJ1Y3R1cmU6IC4uLy4uL3RoZW1lcy9iYXNlL2NvcmUuY3NzXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2Uvc3Bpbm5lci5jc3Ncbi8vPj5jc3MudGhlbWU6IC4uLy4uL3RoZW1lcy9iYXNlL3RoZW1lLmNzc1xuXG5cblxuZnVuY3Rpb24gc3Bpbm5lck1vZGlmZXIoIGZuICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByZXZpb3VzID0gdGhpcy5lbGVtZW50LnZhbCgpO1xuXHRcdGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdFx0aWYgKCBwcmV2aW91cyAhPT0gdGhpcy5lbGVtZW50LnZhbCgpICkge1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJjaGFuZ2VcIiApO1xuXHRcdH1cblx0fTtcbn1cblxuJC53aWRnZXQoIFwidWkuc3Bpbm5lclwiLCB7XG5cdHZlcnNpb246IFwiMS4xMi4xXCIsXG5cdGRlZmF1bHRFbGVtZW50OiBcIjxpbnB1dD5cIixcblx0d2lkZ2V0RXZlbnRQcmVmaXg6IFwic3BpblwiLFxuXHRvcHRpb25zOiB7XG5cdFx0Y2xhc3Nlczoge1xuXHRcdFx0XCJ1aS1zcGlubmVyXCI6IFwidWktY29ybmVyLWFsbFwiLFxuXHRcdFx0XCJ1aS1zcGlubmVyLWRvd25cIjogXCJ1aS1jb3JuZXItYnJcIixcblx0XHRcdFwidWktc3Bpbm5lci11cFwiOiBcInVpLWNvcm5lci10clwiXG5cdFx0fSxcblx0XHRjdWx0dXJlOiBudWxsLFxuXHRcdGljb25zOiB7XG5cdFx0XHRkb3duOiBcInVpLWljb24tdHJpYW5nbGUtMS1zXCIsXG5cdFx0XHR1cDogXCJ1aS1pY29uLXRyaWFuZ2xlLTEtblwiXG5cdFx0fSxcblx0XHRpbmNyZW1lbnRhbDogdHJ1ZSxcblx0XHRtYXg6IG51bGwsXG5cdFx0bWluOiBudWxsLFxuXHRcdG51bWJlckZvcm1hdDogbnVsbCxcblx0XHRwYWdlOiAxMCxcblx0XHRzdGVwOiAxLFxuXG5cdFx0Y2hhbmdlOiBudWxsLFxuXHRcdHNwaW46IG51bGwsXG5cdFx0c3RhcnQ6IG51bGwsXG5cdFx0c3RvcDogbnVsbFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gaGFuZGxlIHN0cmluZyB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHBhcnNlZFxuXHRcdHRoaXMuX3NldE9wdGlvbiggXCJtYXhcIiwgdGhpcy5vcHRpb25zLm1heCApO1xuXHRcdHRoaXMuX3NldE9wdGlvbiggXCJtaW5cIiwgdGhpcy5vcHRpb25zLm1pbiApO1xuXHRcdHRoaXMuX3NldE9wdGlvbiggXCJzdGVwXCIsIHRoaXMub3B0aW9ucy5zdGVwICk7XG5cblx0XHQvLyBPbmx5IGZvcm1hdCBpZiB0aGVyZSBpcyBhIHZhbHVlLCBwcmV2ZW50cyB0aGUgZmllbGQgZnJvbSBiZWluZyBtYXJrZWRcblx0XHQvLyBhcyBpbnZhbGlkIGluIEZpcmVmb3gsIHNlZSAjOTU3My5cblx0XHRpZiAoIHRoaXMudmFsdWUoKSAhPT0gXCJcIiApIHtcblxuXHRcdFx0Ly8gRm9ybWF0IHRoZSB2YWx1ZSwgYnV0IGRvbid0IGNvbnN0cmFpbi5cblx0XHRcdHRoaXMuX3ZhbHVlKCB0aGlzLmVsZW1lbnQudmFsKCksIHRydWUgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9kcmF3KCk7XG5cdFx0dGhpcy5fb24oIHRoaXMuX2V2ZW50cyApO1xuXHRcdHRoaXMuX3JlZnJlc2goKTtcblxuXHRcdC8vIFR1cm5pbmcgb2ZmIGF1dG9jb21wbGV0ZSBwcmV2ZW50cyB0aGUgYnJvd3NlciBmcm9tIHJlbWVtYmVyaW5nIHRoZVxuXHRcdC8vIHZhbHVlIHdoZW4gbmF2aWdhdGluZyB0aHJvdWdoIGhpc3RvcnksIHNvIHdlIHJlLWVuYWJsZSBhdXRvY29tcGxldGVcblx0XHQvLyBpZiB0aGUgcGFnZSBpcyB1bmxvYWRlZCBiZWZvcmUgdGhlIHdpZGdldCBpcyBkZXN0cm95ZWQuICM3NzkwXG5cdFx0dGhpcy5fb24oIHRoaXMud2luZG93LCB7XG5cdFx0XHRiZWZvcmV1bmxvYWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQXR0ciggXCJhdXRvY29tcGxldGVcIiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl9zdXBlcigpO1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG5cdFx0JC5lYWNoKCBbIFwibWluXCIsIFwibWF4XCIsIFwic3RlcFwiIF0sIGZ1bmN0aW9uKCBpLCBvcHRpb24gKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBlbGVtZW50LmF0dHIoIG9wdGlvbiApO1xuXHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICYmIHZhbHVlLmxlbmd0aCApIHtcblx0XHRcdFx0b3B0aW9uc1sgb3B0aW9uIF0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fSxcblxuXHRfZXZlbnRzOiB7XG5cdFx0a2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0aWYgKCB0aGlzLl9zdGFydCggZXZlbnQgKSAmJiB0aGlzLl9rZXlkb3duKCBldmVudCApICkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0a2V5dXA6IFwiX3N0b3BcIixcblx0XHRmb2N1czogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnByZXZpb3VzID0gdGhpcy5lbGVtZW50LnZhbCgpO1xuXHRcdH0sXG5cdFx0Ymx1cjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0aWYgKCB0aGlzLmNhbmNlbEJsdXIgKSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmNhbmNlbEJsdXI7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc3RvcCgpO1xuXHRcdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHRcdFx0aWYgKCB0aGlzLnByZXZpb3VzICE9PSB0aGlzLmVsZW1lbnQudmFsKCkgKSB7XG5cdFx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2hhbmdlXCIsIGV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRtb3VzZXdoZWVsOiBmdW5jdGlvbiggZXZlbnQsIGRlbHRhICkge1xuXHRcdFx0aWYgKCAhZGVsdGEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggIXRoaXMuc3Bpbm5pbmcgJiYgIXRoaXMuX3N0YXJ0KCBldmVudCApICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NwaW4oICggZGVsdGEgPiAwID8gMSA6IC0xICkgKiB0aGlzLm9wdGlvbnMuc3RlcCwgZXZlbnQgKTtcblx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5tb3VzZXdoZWVsVGltZXIgKTtcblx0XHRcdHRoaXMubW91c2V3aGVlbFRpbWVyID0gdGhpcy5fZGVsYXkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMuc3Bpbm5pbmcgKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RvcCggZXZlbnQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMTAwICk7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH0sXG5cdFx0XCJtb3VzZWRvd24gLnVpLXNwaW5uZXItYnV0dG9uXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBwcmV2aW91cztcblxuXHRcdFx0Ly8gV2UgbmV2ZXIgd2FudCB0aGUgYnV0dG9ucyB0byBoYXZlIGZvY3VzOyB3aGVuZXZlciB0aGUgdXNlciBpc1xuXHRcdFx0Ly8gaW50ZXJhY3Rpbmcgd2l0aCB0aGUgc3Bpbm5lciwgdGhlIGZvY3VzIHNob3VsZCBiZSBvbiB0aGUgaW5wdXQuXG5cdFx0XHQvLyBJZiB0aGUgaW5wdXQgaXMgZm9jdXNlZCB0aGVuIHRoaXMucHJldmlvdXMgaXMgcHJvcGVybHkgc2V0IGZyb21cblx0XHRcdC8vIHdoZW4gdGhlIGlucHV0IGZpcnN0IHJlY2VpdmVkIGZvY3VzLiBJZiB0aGUgaW5wdXQgaXMgbm90IGZvY3VzZWRcblx0XHRcdC8vIHRoZW4gd2UgbmVlZCB0byBzZXQgdGhpcy5wcmV2aW91cyBiYXNlZCBvbiB0aGUgdmFsdWUgYmVmb3JlIHNwaW5uaW5nLlxuXHRcdFx0cHJldmlvdXMgPSB0aGlzLmVsZW1lbnRbIDAgXSA9PT0gJC51aS5zYWZlQWN0aXZlRWxlbWVudCggdGhpcy5kb2N1bWVudFsgMCBdICkgP1xuXHRcdFx0XHR0aGlzLnByZXZpb3VzIDogdGhpcy5lbGVtZW50LnZhbCgpO1xuXHRcdFx0ZnVuY3Rpb24gY2hlY2tGb2N1cygpIHtcblx0XHRcdFx0dmFyIGlzQWN0aXZlID0gdGhpcy5lbGVtZW50WyAwIF0gPT09ICQudWkuc2FmZUFjdGl2ZUVsZW1lbnQoIHRoaXMuZG9jdW1lbnRbIDAgXSApO1xuXHRcdFx0XHRpZiAoICFpc0FjdGl2ZSApIHtcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQudHJpZ2dlciggXCJmb2N1c1wiICk7XG5cdFx0XHRcdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydDogSUVcblx0XHRcdFx0XHQvLyBJRSBzZXRzIGZvY3VzIGFzeW5jaHJvbm91c2x5LCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGlmIGZvY3VzXG5cdFx0XHRcdFx0Ly8gbW92ZWQgb2ZmIG9mIHRoZSBpbnB1dCBiZWNhdXNlIHRoZSB1c2VyIGNsaWNrZWQgb24gdGhlIGJ1dHRvbi5cblx0XHRcdFx0XHR0aGlzLl9kZWxheSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEVuc3VyZSBmb2N1cyBpcyBvbiAob3Igc3RheXMgb24pIHRoZSB0ZXh0IGZpZWxkXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0Y2hlY2tGb2N1cy5jYWxsKCB0aGlzICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0XHQvLyBJRSBkb2Vzbid0IHByZXZlbnQgbW92aW5nIGZvY3VzIGV2ZW4gd2l0aCBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHQvLyBzbyB3ZSBzZXQgYSBmbGFnIHRvIGtub3cgd2hlbiB3ZSBzaG91bGQgaWdub3JlIHRoZSBibHVyIGV2ZW50XG5cdFx0XHQvLyBhbmQgY2hlY2sgKGFnYWluKSBpZiBmb2N1cyBtb3ZlZCBvZmYgb2YgdGhlIGlucHV0LlxuXHRcdFx0dGhpcy5jYW5jZWxCbHVyID0gdHJ1ZTtcblx0XHRcdHRoaXMuX2RlbGF5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuY2FuY2VsQmx1cjtcblx0XHRcdFx0Y2hlY2tGb2N1cy5jYWxsKCB0aGlzICk7XG5cdFx0XHR9ICk7XG5cblx0XHRcdGlmICggdGhpcy5fc3RhcnQoIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3JlcGVhdCggbnVsbCwgJCggZXZlbnQuY3VycmVudFRhcmdldCApXG5cdFx0XHRcdC5oYXNDbGFzcyggXCJ1aS1zcGlubmVyLXVwXCIgKSA/IDEgOiAtMSwgZXZlbnQgKTtcblx0XHR9LFxuXHRcdFwibW91c2V1cCAudWktc3Bpbm5lci1idXR0b25cIjogXCJfc3RvcFwiLFxuXHRcdFwibW91c2VlbnRlciAudWktc3Bpbm5lci1idXR0b25cIjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBidXR0b24gd2lsbCBhZGQgdWktc3RhdGUtYWN0aXZlIGlmIG1vdXNlIHdhcyBkb3duIHdoaWxlIG1vdXNlbGVhdmUgYW5kIGtlcHQgZG93blxuXHRcdFx0aWYgKCAhJCggZXZlbnQuY3VycmVudFRhcmdldCApLmhhc0NsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLl9zdGFydCggZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlcGVhdCggbnVsbCwgJCggZXZlbnQuY3VycmVudFRhcmdldCApXG5cdFx0XHRcdC5oYXNDbGFzcyggXCJ1aS1zcGlubmVyLXVwXCIgKSA/IDEgOiAtMSwgZXZlbnQgKTtcblx0XHR9LFxuXG5cdFx0Ly8gVE9ETzogZG8gd2UgcmVhbGx5IHdhbnQgdG8gY29uc2lkZXIgdGhpcyBhIHN0b3A/XG5cdFx0Ly8gc2hvdWxkbid0IHdlIGp1c3Qgc3RvcCB0aGUgcmVwZWF0ZXIgYW5kIHdhaXQgdW50aWwgbW91c2V1cCBiZWZvcmVcblx0XHQvLyB3ZSB0cmlnZ2VyIHRoZSBzdG9wIGV2ZW50P1xuXHRcdFwibW91c2VsZWF2ZSAudWktc3Bpbm5lci1idXR0b25cIjogXCJfc3RvcFwiXG5cdH0sXG5cblx0Ly8gU3VwcG9ydCBtb2JpbGUgZW5oYW5jZWQgb3B0aW9uIGFuZCBtYWtlIGJhY2tjb21wYXQgbW9yZSBzYW5lXG5cdF9lbmhhbmNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVpU3Bpbm5lciA9IHRoaXMuZWxlbWVudFxuXHRcdFx0LmF0dHIoIFwiYXV0b2NvbXBsZXRlXCIsIFwib2ZmXCIgKVxuXHRcdFx0LndyYXAoIFwiPHNwYW4+XCIgKVxuXHRcdFx0LnBhcmVudCgpXG5cblx0XHRcdFx0Ly8gQWRkIGJ1dHRvbnNcblx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHRcIjxhPjwvYT48YT48L2E+XCJcblx0XHRcdFx0KTtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fZW5oYW5jZSgpO1xuXG5cdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMudWlTcGlubmVyLCBcInVpLXNwaW5uZXJcIiwgXCJ1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnRcIiApO1xuXHRcdHRoaXMuX2FkZENsYXNzKCBcInVpLXNwaW5uZXItaW5wdXRcIiApO1xuXG5cdFx0dGhpcy5lbGVtZW50LmF0dHIoIFwicm9sZVwiLCBcInNwaW5idXR0b25cIiApO1xuXG5cdFx0Ly8gQnV0dG9uIGJpbmRpbmdzXG5cdFx0dGhpcy5idXR0b25zID0gdGhpcy51aVNwaW5uZXIuY2hpbGRyZW4oIFwiYVwiIClcblx0XHRcdC5hdHRyKCBcInRhYkluZGV4XCIsIC0xIClcblx0XHRcdC5hdHRyKCBcImFyaWEtaGlkZGVuXCIsIHRydWUgKVxuXHRcdFx0LmJ1dHRvbigge1xuXHRcdFx0XHRjbGFzc2VzOiB7XG5cdFx0XHRcdFx0XCJ1aS1idXR0b25cIjogXCJcIlxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHQvLyBUT0RPOiBSaWdodCBub3cgYnV0dG9uIGRvZXMgbm90IHN1cHBvcnQgY2xhc3NlcyB0aGlzIGlzIGFscmVhZHkgdXBkYXRlZCBpbiBidXR0b24gUFJcblx0XHR0aGlzLl9yZW1vdmVDbGFzcyggdGhpcy5idXR0b25zLCBcInVpLWNvcm5lci1hbGxcIiApO1xuXG5cdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMuYnV0dG9ucy5maXJzdCgpLCBcInVpLXNwaW5uZXItYnV0dG9uIHVpLXNwaW5uZXItdXBcIiApO1xuXHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLmJ1dHRvbnMubGFzdCgpLCBcInVpLXNwaW5uZXItYnV0dG9uIHVpLXNwaW5uZXItZG93blwiICk7XG5cdFx0dGhpcy5idXR0b25zLmZpcnN0KCkuYnV0dG9uKCB7XG5cdFx0XHRcImljb25cIjogdGhpcy5vcHRpb25zLmljb25zLnVwLFxuXHRcdFx0XCJzaG93TGFiZWxcIjogZmFsc2Vcblx0XHR9ICk7XG5cdFx0dGhpcy5idXR0b25zLmxhc3QoKS5idXR0b24oIHtcblx0XHRcdFwiaWNvblwiOiB0aGlzLm9wdGlvbnMuaWNvbnMuZG93bixcblx0XHRcdFwic2hvd0xhYmVsXCI6IGZhbHNlXG5cdFx0fSApO1xuXG5cdFx0Ly8gSUUgNiBkb2Vzbid0IHVuZGVyc3RhbmQgaGVpZ2h0OiA1MCUgZm9yIHRoZSBidXR0b25zXG5cdFx0Ly8gdW5sZXNzIHRoZSB3cmFwcGVyIGhhcyBhbiBleHBsaWNpdCBoZWlnaHRcblx0XHRpZiAoIHRoaXMuYnV0dG9ucy5oZWlnaHQoKSA+IE1hdGguY2VpbCggdGhpcy51aVNwaW5uZXIuaGVpZ2h0KCkgKiAwLjUgKSAmJlxuXHRcdFx0XHR0aGlzLnVpU3Bpbm5lci5oZWlnaHQoKSA+IDAgKSB7XG5cdFx0XHR0aGlzLnVpU3Bpbm5lci5oZWlnaHQoIHRoaXMudWlTcGlubmVyLmhlaWdodCgpICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9rZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRrZXlDb2RlID0gJC51aS5rZXlDb2RlO1xuXG5cdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcblx0XHRjYXNlIGtleUNvZGUuVVA6XG5cdFx0XHR0aGlzLl9yZXBlYXQoIG51bGwsIDEsIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRjYXNlIGtleUNvZGUuRE9XTjpcblx0XHRcdHRoaXMuX3JlcGVhdCggbnVsbCwgLTEsIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRjYXNlIGtleUNvZGUuUEFHRV9VUDpcblx0XHRcdHRoaXMuX3JlcGVhdCggbnVsbCwgb3B0aW9ucy5wYWdlLCBldmVudCApO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0Y2FzZSBrZXlDb2RlLlBBR0VfRE9XTjpcblx0XHRcdHRoaXMuX3JlcGVhdCggbnVsbCwgLW9wdGlvbnMucGFnZSwgZXZlbnQgKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfc3RhcnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoICF0aGlzLnNwaW5uaW5nICYmIHRoaXMuX3RyaWdnZXIoIFwic3RhcnRcIiwgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5jb3VudGVyICkge1xuXHRcdFx0dGhpcy5jb3VudGVyID0gMTtcblx0XHR9XG5cdFx0dGhpcy5zcGlubmluZyA9IHRydWU7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X3JlcGVhdDogZnVuY3Rpb24oIGksIHN0ZXBzLCBldmVudCApIHtcblx0XHRpID0gaSB8fCA1MDA7XG5cblx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblx0XHR0aGlzLnRpbWVyID0gdGhpcy5fZGVsYXkoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fcmVwZWF0KCA0MCwgc3RlcHMsIGV2ZW50ICk7XG5cdFx0fSwgaSApO1xuXG5cdFx0dGhpcy5fc3Bpbiggc3RlcHMgKiB0aGlzLm9wdGlvbnMuc3RlcCwgZXZlbnQgKTtcblx0fSxcblxuXHRfc3BpbjogZnVuY3Rpb24oIHN0ZXAsIGV2ZW50ICkge1xuXHRcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKSB8fCAwO1xuXG5cdFx0aWYgKCAhdGhpcy5jb3VudGVyICkge1xuXHRcdFx0dGhpcy5jb3VudGVyID0gMTtcblx0XHR9XG5cblx0XHR2YWx1ZSA9IHRoaXMuX2FkanVzdFZhbHVlKCB2YWx1ZSArIHN0ZXAgKiB0aGlzLl9pbmNyZW1lbnQoIHRoaXMuY291bnRlciApICk7XG5cblx0XHRpZiAoICF0aGlzLnNwaW5uaW5nIHx8IHRoaXMuX3RyaWdnZXIoIFwic3BpblwiLCBldmVudCwgeyB2YWx1ZTogdmFsdWUgfSApICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMuX3ZhbHVlKCB2YWx1ZSApO1xuXHRcdFx0dGhpcy5jb3VudGVyKys7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbmNyZW1lbnQ6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBpbmNyZW1lbnRhbCA9IHRoaXMub3B0aW9ucy5pbmNyZW1lbnRhbDtcblxuXHRcdGlmICggaW5jcmVtZW50YWwgKSB7XG5cdFx0XHRyZXR1cm4gJC5pc0Z1bmN0aW9uKCBpbmNyZW1lbnRhbCApID9cblx0XHRcdFx0aW5jcmVtZW50YWwoIGkgKSA6XG5cdFx0XHRcdE1hdGguZmxvb3IoIGkgKiBpICogaSAvIDUwMDAwIC0gaSAqIGkgLyA1MDAgKyAxNyAqIGkgLyAyMDAgKyAxICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDE7XG5cdH0sXG5cblx0X3ByZWNpc2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByZWNpc2lvbiA9IHRoaXMuX3ByZWNpc2lvbk9mKCB0aGlzLm9wdGlvbnMuc3RlcCApO1xuXHRcdGlmICggdGhpcy5vcHRpb25zLm1pbiAhPT0gbnVsbCApIHtcblx0XHRcdHByZWNpc2lvbiA9IE1hdGgubWF4KCBwcmVjaXNpb24sIHRoaXMuX3ByZWNpc2lvbk9mKCB0aGlzLm9wdGlvbnMubWluICkgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHByZWNpc2lvbjtcblx0fSxcblxuXHRfcHJlY2lzaW9uT2Y6IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0dmFyIHN0ciA9IG51bS50b1N0cmluZygpLFxuXHRcdFx0ZGVjaW1hbCA9IHN0ci5pbmRleE9mKCBcIi5cIiApO1xuXHRcdHJldHVybiBkZWNpbWFsID09PSAtMSA/IDAgOiBzdHIubGVuZ3RoIC0gZGVjaW1hbCAtIDE7XG5cdH0sXG5cblx0X2FkanVzdFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGJhc2UsIGFib3ZlTWluLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSdyZSBhdCBhIHZhbGlkIHN0ZXBcblx0XHQvLyAtIGZpbmQgb3V0IHdoZXJlIHdlIGFyZSByZWxhdGl2ZSB0byB0aGUgYmFzZSAobWluIG9yIDApXG5cdFx0YmFzZSA9IG9wdGlvbnMubWluICE9PSBudWxsID8gb3B0aW9ucy5taW4gOiAwO1xuXHRcdGFib3ZlTWluID0gdmFsdWUgLSBiYXNlO1xuXG5cdFx0Ly8gLSByb3VuZCB0byB0aGUgbmVhcmVzdCBzdGVwXG5cdFx0YWJvdmVNaW4gPSBNYXRoLnJvdW5kKCBhYm92ZU1pbiAvIG9wdGlvbnMuc3RlcCApICogb3B0aW9ucy5zdGVwO1xuXG5cdFx0Ly8gLSByb3VuZGluZyBpcyBiYXNlZCBvbiAwLCBzbyBhZGp1c3QgYmFjayB0byBvdXIgYmFzZVxuXHRcdHZhbHVlID0gYmFzZSArIGFib3ZlTWluO1xuXG5cdFx0Ly8gRml4IHByZWNpc2lvbiBmcm9tIGJhZCBKUyBmbG9hdGluZyBwb2ludCBtYXRoXG5cdFx0dmFsdWUgPSBwYXJzZUZsb2F0KCB2YWx1ZS50b0ZpeGVkKCB0aGlzLl9wcmVjaXNpb24oKSApICk7XG5cblx0XHQvLyBDbGFtcCB0aGUgdmFsdWVcblx0XHRpZiAoIG9wdGlvbnMubWF4ICE9PSBudWxsICYmIHZhbHVlID4gb3B0aW9ucy5tYXggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5tYXg7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5taW4gIT09IG51bGwgJiYgdmFsdWUgPCBvcHRpb25zLm1pbiApIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1pbjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cblx0X3N0b3A6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoICF0aGlzLnNwaW5uaW5nICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNsZWFyVGltZW91dCggdGhpcy50aW1lciApO1xuXHRcdGNsZWFyVGltZW91dCggdGhpcy5tb3VzZXdoZWVsVGltZXIgKTtcblx0XHR0aGlzLmNvdW50ZXIgPSAwO1xuXHRcdHRoaXMuc3Bpbm5pbmcgPSBmYWxzZTtcblx0XHR0aGlzLl90cmlnZ2VyKCBcInN0b3BcIiwgZXZlbnQgKTtcblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgcHJldlZhbHVlLCBmaXJzdCwgbGFzdDtcblxuXHRcdGlmICgga2V5ID09PSBcImN1bHR1cmVcIiB8fCBrZXkgPT09IFwibnVtYmVyRm9ybWF0XCIgKSB7XG5cdFx0XHRwcmV2VmFsdWUgPSB0aGlzLl9wYXJzZSggdGhpcy5lbGVtZW50LnZhbCgpICk7XG5cdFx0XHR0aGlzLm9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cdFx0XHR0aGlzLmVsZW1lbnQudmFsKCB0aGlzLl9mb3JtYXQoIHByZXZWYWx1ZSApICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwibWF4XCIgfHwga2V5ID09PSBcIm1pblwiIHx8IGtleSA9PT0gXCJzdGVwXCIgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLl9wYXJzZSggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCBrZXkgPT09IFwiaWNvbnNcIiApIHtcblx0XHRcdGZpcnN0ID0gdGhpcy5idXR0b25zLmZpcnN0KCkuZmluZCggXCIudWktaWNvblwiICk7XG5cdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggZmlyc3QsIG51bGwsIHRoaXMub3B0aW9ucy5pY29ucy51cCApO1xuXHRcdFx0dGhpcy5fYWRkQ2xhc3MoIGZpcnN0LCBudWxsLCB2YWx1ZS51cCApO1xuXHRcdFx0bGFzdCA9IHRoaXMuYnV0dG9ucy5sYXN0KCkuZmluZCggXCIudWktaWNvblwiICk7XG5cdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggbGFzdCwgbnVsbCwgdGhpcy5vcHRpb25zLmljb25zLmRvd24gKTtcblx0XHRcdHRoaXMuX2FkZENsYXNzKCBsYXN0LCBudWxsLCB2YWx1ZS5kb3duICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblx0fSxcblxuXHRfc2V0T3B0aW9uRGlzYWJsZWQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zdXBlciggdmFsdWUgKTtcblxuXHRcdHRoaXMuX3RvZ2dsZUNsYXNzKCB0aGlzLnVpU3Bpbm5lciwgbnVsbCwgXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiLCAhIXZhbHVlICk7XG5cdFx0dGhpcy5lbGVtZW50LnByb3AoIFwiZGlzYWJsZWRcIiwgISF2YWx1ZSApO1xuXHRcdHRoaXMuYnV0dG9ucy5idXR0b24oIHZhbHVlID8gXCJkaXNhYmxlXCIgOiBcImVuYWJsZVwiICk7XG5cdH0sXG5cblx0X3NldE9wdGlvbnM6IHNwaW5uZXJNb2RpZmVyKCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR0aGlzLl9zdXBlciggb3B0aW9ucyApO1xuXHR9ICksXG5cblx0X3BhcnNlOiBmdW5jdGlvbiggdmFsICkge1xuXHRcdGlmICggdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiAmJiB2YWwgIT09IFwiXCIgKSB7XG5cdFx0XHR2YWwgPSB3aW5kb3cuR2xvYmFsaXplICYmIHRoaXMub3B0aW9ucy5udW1iZXJGb3JtYXQgP1xuXHRcdFx0XHRHbG9iYWxpemUucGFyc2VGbG9hdCggdmFsLCAxMCwgdGhpcy5vcHRpb25zLmN1bHR1cmUgKSA6ICt2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB2YWwgPT09IFwiXCIgfHwgaXNOYU4oIHZhbCApID8gbnVsbCA6IHZhbDtcblx0fSxcblxuXHRfZm9ybWF0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gXCJcIiApIHtcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH1cblx0XHRyZXR1cm4gd2luZG93Lkdsb2JhbGl6ZSAmJiB0aGlzLm9wdGlvbnMubnVtYmVyRm9ybWF0ID9cblx0XHRcdEdsb2JhbGl6ZS5mb3JtYXQoIHZhbHVlLCB0aGlzLm9wdGlvbnMubnVtYmVyRm9ybWF0LCB0aGlzLm9wdGlvbnMuY3VsdHVyZSApIDpcblx0XHRcdHZhbHVlO1xuXHR9LFxuXG5cdF9yZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQuYXR0cigge1xuXHRcdFx0XCJhcmlhLXZhbHVlbWluXCI6IHRoaXMub3B0aW9ucy5taW4sXG5cdFx0XHRcImFyaWEtdmFsdWVtYXhcIjogdGhpcy5vcHRpb25zLm1heCxcblxuXHRcdFx0Ly8gVE9ETzogd2hhdCBzaG91bGQgd2UgZG8gd2l0aCB2YWx1ZXMgdGhhdCBjYW4ndCBiZSBwYXJzZWQ/XG5cdFx0XHRcImFyaWEtdmFsdWVub3dcIjogdGhpcy5fcGFyc2UoIHRoaXMuZWxlbWVudC52YWwoKSApXG5cdFx0fSApO1xuXHR9LFxuXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKTtcblxuXHRcdC8vIE51bGwgaXMgaW52YWxpZFxuXHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdmFsdWUgZ2V0cyBhZGp1c3RlZCwgaXQncyBpbnZhbGlkXG5cdFx0cmV0dXJuIHZhbHVlID09PSB0aGlzLl9hZGp1c3RWYWx1ZSggdmFsdWUgKTtcblx0fSxcblxuXHQvLyBVcGRhdGUgdGhlIHZhbHVlIHdpdGhvdXQgdHJpZ2dlcmluZyBjaGFuZ2Vcblx0X3ZhbHVlOiBmdW5jdGlvbiggdmFsdWUsIGFsbG93QW55ICkge1xuXHRcdHZhciBwYXJzZWQ7XG5cdFx0aWYgKCB2YWx1ZSAhPT0gXCJcIiApIHtcblx0XHRcdHBhcnNlZCA9IHRoaXMuX3BhcnNlKCB2YWx1ZSApO1xuXHRcdFx0aWYgKCBwYXJzZWQgIT09IG51bGwgKSB7XG5cdFx0XHRcdGlmICggIWFsbG93QW55ICkge1xuXHRcdFx0XHRcdHBhcnNlZCA9IHRoaXMuX2FkanVzdFZhbHVlKCBwYXJzZWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuX2Zvcm1hdCggcGFyc2VkICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuZWxlbWVudC52YWwoIHZhbHVlICk7XG5cdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5wcm9wKCBcImRpc2FibGVkXCIsIGZhbHNlIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImF1dG9jb21wbGV0ZSByb2xlIGFyaWEtdmFsdWVtaW4gYXJpYS12YWx1ZW1heCBhcmlhLXZhbHVlbm93XCIgKTtcblxuXHRcdHRoaXMudWlTcGlubmVyLnJlcGxhY2VXaXRoKCB0aGlzLmVsZW1lbnQgKTtcblx0fSxcblxuXHRzdGVwVXA6IHNwaW5uZXJNb2RpZmVyKCBmdW5jdGlvbiggc3RlcHMgKSB7XG5cdFx0dGhpcy5fc3RlcFVwKCBzdGVwcyApO1xuXHR9ICksXG5cdF9zdGVwVXA6IGZ1bmN0aW9uKCBzdGVwcyApIHtcblx0XHRpZiAoIHRoaXMuX3N0YXJ0KCkgKSB7XG5cdFx0XHR0aGlzLl9zcGluKCAoIHN0ZXBzIHx8IDEgKSAqIHRoaXMub3B0aW9ucy5zdGVwICk7XG5cdFx0XHR0aGlzLl9zdG9wKCk7XG5cdFx0fVxuXHR9LFxuXG5cdHN0ZXBEb3duOiBzcGlubmVyTW9kaWZlciggZnVuY3Rpb24oIHN0ZXBzICkge1xuXHRcdHRoaXMuX3N0ZXBEb3duKCBzdGVwcyApO1xuXHR9ICksXG5cdF9zdGVwRG93bjogZnVuY3Rpb24oIHN0ZXBzICkge1xuXHRcdGlmICggdGhpcy5fc3RhcnQoKSApIHtcblx0XHRcdHRoaXMuX3NwaW4oICggc3RlcHMgfHwgMSApICogLXRoaXMub3B0aW9ucy5zdGVwICk7XG5cdFx0XHR0aGlzLl9zdG9wKCk7XG5cdFx0fVxuXHR9LFxuXG5cdHBhZ2VVcDogc3Bpbm5lck1vZGlmZXIoIGZ1bmN0aW9uKCBwYWdlcyApIHtcblx0XHR0aGlzLl9zdGVwVXAoICggcGFnZXMgfHwgMSApICogdGhpcy5vcHRpb25zLnBhZ2UgKTtcblx0fSApLFxuXG5cdHBhZ2VEb3duOiBzcGlubmVyTW9kaWZlciggZnVuY3Rpb24oIHBhZ2VzICkge1xuXHRcdHRoaXMuX3N0ZXBEb3duKCAoIHBhZ2VzIHx8IDEgKSAqIHRoaXMub3B0aW9ucy5wYWdlICk7XG5cdH0gKSxcblxuXHR2YWx1ZTogZnVuY3Rpb24oIG5ld1ZhbCApIHtcblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BhcnNlKCB0aGlzLmVsZW1lbnQudmFsKCkgKTtcblx0XHR9XG5cdFx0c3Bpbm5lck1vZGlmZXIoIHRoaXMuX3ZhbHVlICkuY2FsbCggdGhpcywgbmV3VmFsICk7XG5cdH0sXG5cblx0d2lkZ2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy51aVNwaW5uZXI7XG5cdH1cbn0gKTtcblxuLy8gREVQUkVDQVRFRFxuLy8gVE9ETzogc3dpdGNoIHJldHVybiBiYWNrIHRvIHdpZGdldCBkZWNsYXJhdGlvbiBhdCB0b3Agb2YgZmlsZSB3aGVuIHRoaXMgaXMgcmVtb3ZlZFxuaWYgKCAkLnVpQmFja0NvbXBhdCAhPT0gZmFsc2UgKSB7XG5cblx0Ly8gQmFja2NvbXBhdCBmb3Igc3Bpbm5lciBodG1sIGV4dGVuc2lvbiBwb2ludHNcblx0JC53aWRnZXQoIFwidWkuc3Bpbm5lclwiLCAkLnVpLnNwaW5uZXIsIHtcblx0XHRfZW5oYW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnVpU3Bpbm5lciA9IHRoaXMuZWxlbWVudFxuXHRcdFx0XHQuYXR0ciggXCJhdXRvY29tcGxldGVcIiwgXCJvZmZcIiApXG5cdFx0XHRcdC53cmFwKCB0aGlzLl91aVNwaW5uZXJIdG1sKCkgKVxuXHRcdFx0XHQucGFyZW50KClcblxuXHRcdFx0XHRcdC8vIEFkZCBidXR0b25zXG5cdFx0XHRcdFx0LmFwcGVuZCggdGhpcy5fYnV0dG9uSHRtbCgpICk7XG5cdFx0fSxcblx0XHRfdWlTcGlubmVySHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gXCI8c3Bhbj5cIjtcblx0XHR9LFxuXG5cdFx0X2J1dHRvbkh0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFwiPGE+PC9hPjxhPjwvYT5cIjtcblx0XHR9XG5cdH0gKTtcbn1cblxudmFyIHdpZGdldHNTcGlubmVyID0gJC51aS5zcGlubmVyO1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIFRhYnMgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IFRhYnNcbi8vPj5ncm91cDogV2lkZ2V0c1xuLy8+PmRlc2NyaXB0aW9uOiBUcmFuc2Zvcm1zIGEgc2V0IG9mIGNvbnRhaW5lciBlbGVtZW50cyBpbnRvIGEgdGFiIHN0cnVjdHVyZS5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS90YWJzL1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL3RhYnMvXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2UvY29yZS5jc3Ncbi8vPj5jc3Muc3RydWN0dXJlOiAuLi8uLi90aGVtZXMvYmFzZS90YWJzLmNzc1xuLy8+PmNzcy50aGVtZTogLi4vLi4vdGhlbWVzL2Jhc2UvdGhlbWUuY3NzXG5cblxuXG4kLndpZGdldCggXCJ1aS50YWJzXCIsIHtcblx0dmVyc2lvbjogXCIxLjEyLjFcIixcblx0ZGVsYXk6IDMwMCxcblx0b3B0aW9uczoge1xuXHRcdGFjdGl2ZTogbnVsbCxcblx0XHRjbGFzc2VzOiB7XG5cdFx0XHRcInVpLXRhYnNcIjogXCJ1aS1jb3JuZXItYWxsXCIsXG5cdFx0XHRcInVpLXRhYnMtbmF2XCI6IFwidWktY29ybmVyLWFsbFwiLFxuXHRcdFx0XCJ1aS10YWJzLXBhbmVsXCI6IFwidWktY29ybmVyLWJvdHRvbVwiLFxuXHRcdFx0XCJ1aS10YWJzLXRhYlwiOiBcInVpLWNvcm5lci10b3BcIlxuXHRcdH0sXG5cdFx0Y29sbGFwc2libGU6IGZhbHNlLFxuXHRcdGV2ZW50OiBcImNsaWNrXCIsXG5cdFx0aGVpZ2h0U3R5bGU6IFwiY29udGVudFwiLFxuXHRcdGhpZGU6IG51bGwsXG5cdFx0c2hvdzogbnVsbCxcblxuXHRcdC8vIENhbGxiYWNrc1xuXHRcdGFjdGl2YXRlOiBudWxsLFxuXHRcdGJlZm9yZUFjdGl2YXRlOiBudWxsLFxuXHRcdGJlZm9yZUxvYWQ6IG51bGwsXG5cdFx0bG9hZDogbnVsbFxuXHR9LFxuXG5cdF9pc0xvY2FsOiAoIGZ1bmN0aW9uKCkge1xuXHRcdHZhciByaGFzaCA9IC8jLiokLztcblxuXHRcdHJldHVybiBmdW5jdGlvbiggYW5jaG9yICkge1xuXHRcdFx0dmFyIGFuY2hvclVybCwgbG9jYXRpb25Vcmw7XG5cblx0XHRcdGFuY2hvclVybCA9IGFuY2hvci5ocmVmLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cdFx0XHRsb2NhdGlvblVybCA9IGxvY2F0aW9uLmhyZWYucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRGVjb2RpbmcgbWF5IHRocm93IGFuIGVycm9yIGlmIHRoZSBVUkwgaXNuJ3QgVVRGLTggKCM5NTE4KVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YW5jaG9yVXJsID0gZGVjb2RlVVJJQ29tcG9uZW50KCBhbmNob3JVcmwgKTtcblx0XHRcdH0gY2F0Y2ggKCBlcnJvciApIHt9XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRsb2NhdGlvblVybCA9IGRlY29kZVVSSUNvbXBvbmVudCggbG9jYXRpb25VcmwgKTtcblx0XHRcdH0gY2F0Y2ggKCBlcnJvciApIHt9XG5cblx0XHRcdHJldHVybiBhbmNob3IuaGFzaC5sZW5ndGggPiAxICYmIGFuY2hvclVybCA9PT0gbG9jYXRpb25Vcmw7XG5cdFx0fTtcblx0fSApKCksXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fYWRkQ2xhc3MoIFwidWktdGFic1wiLCBcInVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudFwiICk7XG5cdFx0dGhpcy5fdG9nZ2xlQ2xhc3MoIFwidWktdGFicy1jb2xsYXBzaWJsZVwiLCBudWxsLCBvcHRpb25zLmNvbGxhcHNpYmxlICk7XG5cblx0XHR0aGlzLl9wcm9jZXNzVGFicygpO1xuXHRcdG9wdGlvbnMuYWN0aXZlID0gdGhpcy5faW5pdGlhbEFjdGl2ZSgpO1xuXG5cdFx0Ly8gVGFrZSBkaXNhYmxpbmcgdGFicyB2aWEgY2xhc3MgYXR0cmlidXRlIGZyb20gSFRNTFxuXHRcdC8vIGludG8gYWNjb3VudCBhbmQgdXBkYXRlIG9wdGlvbiBwcm9wZXJseS5cblx0XHRpZiAoICQuaXNBcnJheSggb3B0aW9ucy5kaXNhYmxlZCApICkge1xuXHRcdFx0b3B0aW9ucy5kaXNhYmxlZCA9ICQudW5pcXVlKCBvcHRpb25zLmRpc2FibGVkLmNvbmNhdChcblx0XHRcdFx0JC5tYXAoIHRoaXMudGFicy5maWx0ZXIoIFwiLnVpLXN0YXRlLWRpc2FibGVkXCIgKSwgZnVuY3Rpb24oIGxpICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGF0LnRhYnMuaW5kZXgoIGxpICk7XG5cdFx0XHRcdH0gKVxuXHRcdFx0KSApLnNvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3IgbGVuZ3RoIGF2b2lkcyBlcnJvciB3aGVuIGluaXRpYWxpemluZyBlbXB0eSBsaXN0XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuYWN0aXZlICE9PSBmYWxzZSAmJiB0aGlzLmFuY2hvcnMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5hY3RpdmUgPSB0aGlzLl9maW5kQWN0aXZlKCBvcHRpb25zLmFjdGl2ZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFjdGl2ZSA9ICQoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cblx0XHRpZiAoIHRoaXMuYWN0aXZlLmxlbmd0aCApIHtcblx0XHRcdHRoaXMubG9hZCggb3B0aW9ucy5hY3RpdmUgKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRpYWxBY3RpdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhY3RpdmUgPSB0aGlzLm9wdGlvbnMuYWN0aXZlLFxuXHRcdFx0Y29sbGFwc2libGUgPSB0aGlzLm9wdGlvbnMuY29sbGFwc2libGUsXG5cdFx0XHRsb2NhdGlvbkhhc2ggPSBsb2NhdGlvbi5oYXNoLnN1YnN0cmluZyggMSApO1xuXG5cdFx0aWYgKCBhY3RpdmUgPT09IG51bGwgKSB7XG5cblx0XHRcdC8vIGNoZWNrIHRoZSBmcmFnbWVudCBpZGVudGlmaWVyIGluIHRoZSBVUkxcblx0XHRcdGlmICggbG9jYXRpb25IYXNoICkge1xuXHRcdFx0XHR0aGlzLnRhYnMuZWFjaCggZnVuY3Rpb24oIGksIHRhYiApIHtcblx0XHRcdFx0XHRpZiAoICQoIHRhYiApLmF0dHIoIFwiYXJpYS1jb250cm9sc1wiICkgPT09IGxvY2F0aW9uSGFzaCApIHtcblx0XHRcdFx0XHRcdGFjdGl2ZSA9IGk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGZvciBhIHRhYiBtYXJrZWQgYWN0aXZlIHZpYSBhIGNsYXNzXG5cdFx0XHRpZiAoIGFjdGl2ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0YWN0aXZlID0gdGhpcy50YWJzLmluZGV4KCB0aGlzLnRhYnMuZmlsdGVyKCBcIi51aS10YWJzLWFjdGl2ZVwiICkgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gYWN0aXZlIHRhYiwgc2V0IHRvIGZhbHNlXG5cdFx0XHRpZiAoIGFjdGl2ZSA9PT0gbnVsbCB8fCBhY3RpdmUgPT09IC0xICkge1xuXHRcdFx0XHRhY3RpdmUgPSB0aGlzLnRhYnMubGVuZ3RoID8gMCA6IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBudW1iZXJzOiBuZWdhdGl2ZSwgb3V0IG9mIHJhbmdlXG5cdFx0aWYgKCBhY3RpdmUgIT09IGZhbHNlICkge1xuXHRcdFx0YWN0aXZlID0gdGhpcy50YWJzLmluZGV4KCB0aGlzLnRhYnMuZXEoIGFjdGl2ZSApICk7XG5cdFx0XHRpZiAoIGFjdGl2ZSA9PT0gLTEgKSB7XG5cdFx0XHRcdGFjdGl2ZSA9IGNvbGxhcHNpYmxlID8gZmFsc2UgOiAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIERvbid0IGFsbG93IGNvbGxhcHNpYmxlOiBmYWxzZSBhbmQgYWN0aXZlOiBmYWxzZVxuXHRcdGlmICggIWNvbGxhcHNpYmxlICYmIGFjdGl2ZSA9PT0gZmFsc2UgJiYgdGhpcy5hbmNob3JzLmxlbmd0aCApIHtcblx0XHRcdGFjdGl2ZSA9IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjdGl2ZTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlRXZlbnREYXRhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dGFiOiB0aGlzLmFjdGl2ZSxcblx0XHRcdHBhbmVsOiAhdGhpcy5hY3RpdmUubGVuZ3RoID8gJCgpIDogdGhpcy5fZ2V0UGFuZWxGb3JUYWIoIHRoaXMuYWN0aXZlIClcblx0XHR9O1xuXHR9LFxuXG5cdF90YWJLZXlkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGZvY3VzZWRUYWIgPSAkKCAkLnVpLnNhZmVBY3RpdmVFbGVtZW50KCB0aGlzLmRvY3VtZW50WyAwIF0gKSApLmNsb3Nlc3QoIFwibGlcIiApLFxuXHRcdFx0c2VsZWN0ZWRJbmRleCA9IHRoaXMudGFicy5pbmRleCggZm9jdXNlZFRhYiApLFxuXHRcdFx0Z29pbmdGb3J3YXJkID0gdHJ1ZTtcblxuXHRcdGlmICggdGhpcy5faGFuZGxlUGFnZU5hdiggZXZlbnQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLlJJR0hUOlxuXHRcdGNhc2UgJC51aS5rZXlDb2RlLkRPV046XG5cdFx0XHRzZWxlY3RlZEluZGV4Kys7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5VUDpcblx0XHRjYXNlICQudWkua2V5Q29kZS5MRUZUOlxuXHRcdFx0Z29pbmdGb3J3YXJkID0gZmFsc2U7XG5cdFx0XHRzZWxlY3RlZEluZGV4LS07XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5FTkQ6XG5cdFx0XHRzZWxlY3RlZEluZGV4ID0gdGhpcy5hbmNob3JzLmxlbmd0aCAtIDE7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5IT01FOlxuXHRcdFx0c2VsZWN0ZWRJbmRleCA9IDA7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5TUEFDRTpcblxuXHRcdFx0Ly8gQWN0aXZhdGUgb25seSwgbm8gY29sbGFwc2luZ1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5hY3RpdmF0aW5nICk7XG5cdFx0XHR0aGlzLl9hY3RpdmF0ZSggc2VsZWN0ZWRJbmRleCApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLkVOVEVSOlxuXG5cdFx0XHQvLyBUb2dnbGUgKGNhbmNlbCBkZWxheWVkIGFjdGl2YXRpb24sIGFsbG93IGNvbGxhcHNpbmcpXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLmFjdGl2YXRpbmcgKTtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBjb2xsYXBzZSBvciBhY3RpdmF0ZVxuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIHNlbGVjdGVkSW5kZXggPT09IHRoaXMub3B0aW9ucy5hY3RpdmUgPyBmYWxzZSA6IHNlbGVjdGVkSW5kZXggKTtcblx0XHRcdHJldHVybjtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZvY3VzIHRoZSBhcHByb3ByaWF0ZSB0YWIsIGJhc2VkIG9uIHdoaWNoIGtleSB3YXMgcHJlc3NlZFxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLmFjdGl2YXRpbmcgKTtcblx0XHRzZWxlY3RlZEluZGV4ID0gdGhpcy5fZm9jdXNOZXh0VGFiKCBzZWxlY3RlZEluZGV4LCBnb2luZ0ZvcndhcmQgKTtcblxuXHRcdC8vIE5hdmlnYXRpbmcgd2l0aCBjb250cm9sL2NvbW1hbmQga2V5IHdpbGwgcHJldmVudCBhdXRvbWF0aWMgYWN0aXZhdGlvblxuXHRcdGlmICggIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50Lm1ldGFLZXkgKSB7XG5cblx0XHRcdC8vIFVwZGF0ZSBhcmlhLXNlbGVjdGVkIGltbWVkaWF0ZWx5IHNvIHRoYXQgQVQgdGhpbmsgdGhlIHRhYiBpcyBhbHJlYWR5IHNlbGVjdGVkLlxuXHRcdFx0Ly8gT3RoZXJ3aXNlIEFUIG1heSBjb25mdXNlIHRoZSB1c2VyIGJ5IHN0YXRpbmcgdGhhdCB0aGV5IG5lZWQgdG8gYWN0aXZhdGUgdGhlIHRhYixcblx0XHRcdC8vIGJ1dCB0aGUgdGFiIHdpbGwgYWxyZWFkeSBiZSBhY3RpdmF0ZWQgYnkgdGhlIHRpbWUgdGhlIGFubm91bmNlbWVudCBmaW5pc2hlcy5cblx0XHRcdGZvY3VzZWRUYWIuYXR0ciggXCJhcmlhLXNlbGVjdGVkXCIsIFwiZmFsc2VcIiApO1xuXHRcdFx0dGhpcy50YWJzLmVxKCBzZWxlY3RlZEluZGV4ICkuYXR0ciggXCJhcmlhLXNlbGVjdGVkXCIsIFwidHJ1ZVwiICk7XG5cblx0XHRcdHRoaXMuYWN0aXZhdGluZyA9IHRoaXMuX2RlbGF5KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5vcHRpb24oIFwiYWN0aXZlXCIsIHNlbGVjdGVkSW5kZXggKTtcblx0XHRcdH0sIHRoaXMuZGVsYXkgKTtcblx0XHR9XG5cdH0sXG5cblx0X3BhbmVsS2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggdGhpcy5faGFuZGxlUGFnZU5hdiggZXZlbnQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDdHJsK3VwIG1vdmVzIGZvY3VzIHRvIHRoZSBjdXJyZW50IHRhYlxuXHRcdGlmICggZXZlbnQuY3RybEtleSAmJiBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuVVAgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dGhpcy5hY3RpdmUudHJpZ2dlciggXCJmb2N1c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEFsdCtwYWdlIHVwL2Rvd24gbW92ZXMgZm9jdXMgdG8gdGhlIHByZXZpb3VzL25leHQgdGFiIChhbmQgYWN0aXZhdGVzKVxuXHRfaGFuZGxlUGFnZU5hdjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggZXZlbnQuYWx0S2V5ICYmIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5QQUdFX1VQICkge1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIHRoaXMuX2ZvY3VzTmV4dFRhYiggdGhpcy5vcHRpb25zLmFjdGl2ZSAtIDEsIGZhbHNlICkgKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRpZiAoIGV2ZW50LmFsdEtleSAmJiBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuUEFHRV9ET1dOICkge1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIHRoaXMuX2ZvY3VzTmV4dFRhYiggdGhpcy5vcHRpb25zLmFjdGl2ZSArIDEsIHRydWUgKSApO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdF9maW5kTmV4dFRhYjogZnVuY3Rpb24oIGluZGV4LCBnb2luZ0ZvcndhcmQgKSB7XG5cdFx0dmFyIGxhc3RUYWJJbmRleCA9IHRoaXMudGFicy5sZW5ndGggLSAxO1xuXG5cdFx0ZnVuY3Rpb24gY29uc3RyYWluKCkge1xuXHRcdFx0aWYgKCBpbmRleCA+IGxhc3RUYWJJbmRleCApIHtcblx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdGluZGV4ID0gbGFzdFRhYkluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGluZGV4O1xuXHRcdH1cblxuXHRcdHdoaWxlICggJC5pbkFycmF5KCBjb25zdHJhaW4oKSwgdGhpcy5vcHRpb25zLmRpc2FibGVkICkgIT09IC0xICkge1xuXHRcdFx0aW5kZXggPSBnb2luZ0ZvcndhcmQgPyBpbmRleCArIDEgOiBpbmRleCAtIDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9LFxuXG5cdF9mb2N1c05leHRUYWI6IGZ1bmN0aW9uKCBpbmRleCwgZ29pbmdGb3J3YXJkICkge1xuXHRcdGluZGV4ID0gdGhpcy5fZmluZE5leHRUYWIoIGluZGV4LCBnb2luZ0ZvcndhcmQgKTtcblx0XHR0aGlzLnRhYnMuZXEoIGluZGV4ICkudHJpZ2dlciggXCJmb2N1c1wiICk7XG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdGlmICgga2V5ID09PSBcImFjdGl2ZVwiICkge1xuXG5cdFx0XHQvLyBfYWN0aXZhdGUoKSB3aWxsIGhhbmRsZSBpbnZhbGlkIHZhbHVlcyBhbmQgdXBkYXRlIHRoaXMub3B0aW9uc1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIHZhbHVlICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblxuXHRcdGlmICgga2V5ID09PSBcImNvbGxhcHNpYmxlXCIgKSB7XG5cdFx0XHR0aGlzLl90b2dnbGVDbGFzcyggXCJ1aS10YWJzLWNvbGxhcHNpYmxlXCIsIG51bGwsIHZhbHVlICk7XG5cblx0XHRcdC8vIFNldHRpbmcgY29sbGFwc2libGU6IGZhbHNlIHdoaWxlIGNvbGxhcHNlZDsgb3BlbiBmaXJzdCBwYW5lbFxuXHRcdFx0aWYgKCAhdmFsdWUgJiYgdGhpcy5vcHRpb25zLmFjdGl2ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2YXRlKCAwICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwiZXZlbnRcIiApIHtcblx0XHRcdHRoaXMuX3NldHVwRXZlbnRzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ID09PSBcImhlaWdodFN0eWxlXCIgKSB7XG5cdFx0XHR0aGlzLl9zZXR1cEhlaWdodFN0eWxlKCB2YWx1ZSApO1xuXHRcdH1cblx0fSxcblxuXHRfc2FuaXRpemVTZWxlY3RvcjogZnVuY3Rpb24oIGhhc2ggKSB7XG5cdFx0cmV0dXJuIGhhc2ggPyBoYXNoLnJlcGxhY2UoIC9bIVwiJCUmJygpKissLlxcLzo7PD0+P0BcXFtcXF1cXF5ge3x9fl0vZywgXCJcXFxcJCZcIiApIDogXCJcIjtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGxpcyA9IHRoaXMudGFibGlzdC5jaGlsZHJlbiggXCI6aGFzKGFbaHJlZl0pXCIgKTtcblxuXHRcdC8vIEdldCBkaXNhYmxlZCB0YWJzIGZyb20gY2xhc3MgYXR0cmlidXRlIGZyb20gSFRNTFxuXHRcdC8vIHRoaXMgd2lsbCBnZXQgY29udmVydGVkIHRvIGEgYm9vbGVhbiBpZiBuZWVkZWQgaW4gX3JlZnJlc2goKVxuXHRcdG9wdGlvbnMuZGlzYWJsZWQgPSAkLm1hcCggbGlzLmZpbHRlciggXCIudWktc3RhdGUtZGlzYWJsZWRcIiApLCBmdW5jdGlvbiggdGFiICkge1xuXHRcdFx0cmV0dXJuIGxpcy5pbmRleCggdGFiICk7XG5cdFx0fSApO1xuXG5cdFx0dGhpcy5fcHJvY2Vzc1RhYnMoKTtcblxuXHRcdC8vIFdhcyBjb2xsYXBzZWQgb3Igbm8gdGFic1xuXHRcdGlmICggb3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlIHx8ICF0aGlzLmFuY2hvcnMubGVuZ3RoICkge1xuXHRcdFx0b3B0aW9ucy5hY3RpdmUgPSBmYWxzZTtcblx0XHRcdHRoaXMuYWN0aXZlID0gJCgpO1xuXG5cdFx0Ly8gd2FzIGFjdGl2ZSwgYnV0IGFjdGl2ZSB0YWIgaXMgZ29uZVxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuYWN0aXZlLmxlbmd0aCAmJiAhJC5jb250YWlucyggdGhpcy50YWJsaXN0WyAwIF0sIHRoaXMuYWN0aXZlWyAwIF0gKSApIHtcblxuXHRcdFx0Ly8gYWxsIHJlbWFpbmluZyB0YWJzIGFyZSBkaXNhYmxlZFxuXHRcdFx0aWYgKCB0aGlzLnRhYnMubGVuZ3RoID09PSBvcHRpb25zLmRpc2FibGVkLmxlbmd0aCApIHtcblx0XHRcdFx0b3B0aW9ucy5hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5hY3RpdmUgPSAkKCk7XG5cblx0XHRcdC8vIGFjdGl2YXRlIHByZXZpb3VzIHRhYlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZhdGUoIHRoaXMuX2ZpbmROZXh0VGFiKCBNYXRoLm1heCggMCwgb3B0aW9ucy5hY3RpdmUgLSAxICksIGZhbHNlICkgKTtcblx0XHRcdH1cblxuXHRcdC8vIHdhcyBhY3RpdmUsIGFjdGl2ZSB0YWIgc3RpbGwgZXhpc3RzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gbWFrZSBzdXJlIGFjdGl2ZSBpbmRleCBpcyBjb3JyZWN0XG5cdFx0XHRvcHRpb25zLmFjdGl2ZSA9IHRoaXMudGFicy5pbmRleCggdGhpcy5hY3RpdmUgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdH0sXG5cblx0X3JlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NldE9wdGlvbkRpc2FibGVkKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKTtcblx0XHR0aGlzLl9zZXR1cEV2ZW50cyggdGhpcy5vcHRpb25zLmV2ZW50ICk7XG5cdFx0dGhpcy5fc2V0dXBIZWlnaHRTdHlsZSggdGhpcy5vcHRpb25zLmhlaWdodFN0eWxlICk7XG5cblx0XHR0aGlzLnRhYnMubm90KCB0aGlzLmFjdGl2ZSApLmF0dHIoIHtcblx0XHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBcImZhbHNlXCIsXG5cdFx0XHRcImFyaWEtZXhwYW5kZWRcIjogXCJmYWxzZVwiLFxuXHRcdFx0dGFiSW5kZXg6IC0xXG5cdFx0fSApO1xuXHRcdHRoaXMucGFuZWxzLm5vdCggdGhpcy5fZ2V0UGFuZWxGb3JUYWIoIHRoaXMuYWN0aXZlICkgKVxuXHRcdFx0LmhpZGUoKVxuXHRcdFx0LmF0dHIoIHtcblx0XHRcdFx0XCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuXHRcdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIG9uZSB0YWIgaXMgaW4gdGhlIHRhYiBvcmRlclxuXHRcdGlmICggIXRoaXMuYWN0aXZlLmxlbmd0aCApIHtcblx0XHRcdHRoaXMudGFicy5lcSggMCApLmF0dHIoIFwidGFiSW5kZXhcIiwgMCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFjdGl2ZVxuXHRcdFx0XHQuYXR0cigge1xuXHRcdFx0XHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBcInRydWVcIixcblx0XHRcdFx0XHRcImFyaWEtZXhwYW5kZWRcIjogXCJ0cnVlXCIsXG5cdFx0XHRcdFx0dGFiSW5kZXg6IDBcblx0XHRcdFx0fSApO1xuXHRcdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMuYWN0aXZlLCBcInVpLXRhYnMtYWN0aXZlXCIsIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdHRoaXMuX2dldFBhbmVsRm9yVGFiKCB0aGlzLmFjdGl2ZSApXG5cdFx0XHRcdC5zaG93KClcblx0XHRcdFx0LmF0dHIoIHtcblx0XHRcdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwiZmFsc2VcIlxuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9wcm9jZXNzVGFiczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0cHJldlRhYnMgPSB0aGlzLnRhYnMsXG5cdFx0XHRwcmV2QW5jaG9ycyA9IHRoaXMuYW5jaG9ycyxcblx0XHRcdHByZXZQYW5lbHMgPSB0aGlzLnBhbmVscztcblxuXHRcdHRoaXMudGFibGlzdCA9IHRoaXMuX2dldExpc3QoKS5hdHRyKCBcInJvbGVcIiwgXCJ0YWJsaXN0XCIgKTtcblx0XHR0aGlzLl9hZGRDbGFzcyggdGhpcy50YWJsaXN0LCBcInVpLXRhYnMtbmF2XCIsXG5cdFx0XHRcInVpLWhlbHBlci1yZXNldCB1aS1oZWxwZXItY2xlYXJmaXggdWktd2lkZ2V0LWhlYWRlclwiICk7XG5cblx0XHQvLyBQcmV2ZW50IHVzZXJzIGZyb20gZm9jdXNpbmcgZGlzYWJsZWQgdGFicyB2aWEgY2xpY2tcblx0XHR0aGlzLnRhYmxpc3Rcblx0XHRcdC5vbiggXCJtb3VzZWRvd25cIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIFwiPiBsaVwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggJCggdGhpcyApLmlzKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5XG5cdFx0XHQvLyBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGFjdGlvbiBpbiBtb3VzZWRvd24gZG9lc24ndCBwcmV2ZW50IElFXG5cdFx0XHQvLyBmcm9tIGZvY3VzaW5nIHRoZSBlbGVtZW50LCBzbyBpZiB0aGUgYW5jaG9yIGdldHMgZm9jdXNlZCwgYmx1ci5cblx0XHRcdC8vIFdlIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgZm9jdXNpbmcgdGhlIHByZXZpb3VzbHkgZm9jdXNlZFxuXHRcdFx0Ly8gZWxlbWVudCBzaW5jZSBjbGlja2luZyBvbiBhIG5vbi1mb2N1c2FibGUgZWxlbWVudCBzaG91bGQgZm9jdXNcblx0XHRcdC8vIHRoZSBib2R5IGFueXdheS5cblx0XHRcdC5vbiggXCJmb2N1c1wiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgXCIudWktdGFicy1hbmNob3JcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggJCggdGhpcyApLmNsb3Nlc3QoIFwibGlcIiApLmlzKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblxuXHRcdHRoaXMudGFicyA9IHRoaXMudGFibGlzdC5maW5kKCBcIj4gbGk6aGFzKGFbaHJlZl0pXCIgKVxuXHRcdFx0LmF0dHIoIHtcblx0XHRcdFx0cm9sZTogXCJ0YWJcIixcblx0XHRcdFx0dGFiSW5kZXg6IC0xXG5cdFx0XHR9ICk7XG5cdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMudGFicywgXCJ1aS10YWJzLXRhYlwiLCBcInVpLXN0YXRlLWRlZmF1bHRcIiApO1xuXG5cdFx0dGhpcy5hbmNob3JzID0gdGhpcy50YWJzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gJCggXCJhXCIsIHRoaXMgKVsgMCBdO1xuXHRcdH0gKVxuXHRcdFx0LmF0dHIoIHtcblx0XHRcdFx0cm9sZTogXCJwcmVzZW50YXRpb25cIixcblx0XHRcdFx0dGFiSW5kZXg6IC0xXG5cdFx0XHR9ICk7XG5cdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMuYW5jaG9ycywgXCJ1aS10YWJzLWFuY2hvclwiICk7XG5cblx0XHR0aGlzLnBhbmVscyA9ICQoKTtcblxuXHRcdHRoaXMuYW5jaG9ycy5lYWNoKCBmdW5jdGlvbiggaSwgYW5jaG9yICkge1xuXHRcdFx0dmFyIHNlbGVjdG9yLCBwYW5lbCwgcGFuZWxJZCxcblx0XHRcdFx0YW5jaG9ySWQgPSAkKCBhbmNob3IgKS51bmlxdWVJZCgpLmF0dHIoIFwiaWRcIiApLFxuXHRcdFx0XHR0YWIgPSAkKCBhbmNob3IgKS5jbG9zZXN0KCBcImxpXCIgKSxcblx0XHRcdFx0b3JpZ2luYWxBcmlhQ29udHJvbHMgPSB0YWIuYXR0ciggXCJhcmlhLWNvbnRyb2xzXCIgKTtcblxuXHRcdFx0Ly8gSW5saW5lIHRhYlxuXHRcdFx0aWYgKCB0aGF0Ll9pc0xvY2FsKCBhbmNob3IgKSApIHtcblx0XHRcdFx0c2VsZWN0b3IgPSBhbmNob3IuaGFzaDtcblx0XHRcdFx0cGFuZWxJZCA9IHNlbGVjdG9yLnN1YnN0cmluZyggMSApO1xuXHRcdFx0XHRwYW5lbCA9IHRoYXQuZWxlbWVudC5maW5kKCB0aGF0Ll9zYW5pdGl6ZVNlbGVjdG9yKCBzZWxlY3RvciApICk7XG5cblx0XHRcdC8vIHJlbW90ZSB0YWJcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIHRhYiBkb2Vzbid0IGFscmVhZHkgaGF2ZSBhcmlhLWNvbnRyb2xzLFxuXHRcdFx0XHQvLyBnZW5lcmF0ZSBhbiBpZCBieSB1c2luZyBhIHRocm93LWF3YXkgZWxlbWVudFxuXHRcdFx0XHRwYW5lbElkID0gdGFiLmF0dHIoIFwiYXJpYS1jb250cm9sc1wiICkgfHwgJCgge30gKS51bmlxdWVJZCgpWyAwIF0uaWQ7XG5cdFx0XHRcdHNlbGVjdG9yID0gXCIjXCIgKyBwYW5lbElkO1xuXHRcdFx0XHRwYW5lbCA9IHRoYXQuZWxlbWVudC5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0XHRpZiAoICFwYW5lbC5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cGFuZWwgPSB0aGF0Ll9jcmVhdGVQYW5lbCggcGFuZWxJZCApO1xuXHRcdFx0XHRcdHBhbmVsLmluc2VydEFmdGVyKCB0aGF0LnBhbmVsc1sgaSAtIDEgXSB8fCB0aGF0LnRhYmxpc3QgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYW5lbC5hdHRyKCBcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggcGFuZWwubGVuZ3RoICkge1xuXHRcdFx0XHR0aGF0LnBhbmVscyA9IHRoYXQucGFuZWxzLmFkZCggcGFuZWwgKTtcblx0XHRcdH1cblx0XHRcdGlmICggb3JpZ2luYWxBcmlhQ29udHJvbHMgKSB7XG5cdFx0XHRcdHRhYi5kYXRhKCBcInVpLXRhYnMtYXJpYS1jb250cm9sc1wiLCBvcmlnaW5hbEFyaWFDb250cm9scyApO1xuXHRcdFx0fVxuXHRcdFx0dGFiLmF0dHIoIHtcblx0XHRcdFx0XCJhcmlhLWNvbnRyb2xzXCI6IHBhbmVsSWQsXG5cdFx0XHRcdFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFuY2hvcklkXG5cdFx0XHR9ICk7XG5cdFx0XHRwYW5lbC5hdHRyKCBcImFyaWEtbGFiZWxsZWRieVwiLCBhbmNob3JJZCApO1xuXHRcdH0gKTtcblxuXHRcdHRoaXMucGFuZWxzLmF0dHIoIFwicm9sZVwiLCBcInRhYnBhbmVsXCIgKTtcblx0XHR0aGlzLl9hZGRDbGFzcyggdGhpcy5wYW5lbHMsIFwidWktdGFicy1wYW5lbFwiLCBcInVpLXdpZGdldC1jb250ZW50XCIgKTtcblxuXHRcdC8vIEF2b2lkIG1lbW9yeSBsZWFrcyAoIzEwMDU2KVxuXHRcdGlmICggcHJldlRhYnMgKSB7XG5cdFx0XHR0aGlzLl9vZmYoIHByZXZUYWJzLm5vdCggdGhpcy50YWJzICkgKTtcblx0XHRcdHRoaXMuX29mZiggcHJldkFuY2hvcnMubm90KCB0aGlzLmFuY2hvcnMgKSApO1xuXHRcdFx0dGhpcy5fb2ZmKCBwcmV2UGFuZWxzLm5vdCggdGhpcy5wYW5lbHMgKSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBBbGxvdyBvdmVycmlkaW5nIGhvdyB0byBmaW5kIHRoZSBsaXN0IGZvciByYXJlIHVzYWdlIHNjZW5hcmlvcyAoIzc3MTUpXG5cdF9nZXRMaXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50YWJsaXN0IHx8IHRoaXMuZWxlbWVudC5maW5kKCBcIm9sLCB1bFwiICkuZXEoIDAgKTtcblx0fSxcblxuXHRfY3JlYXRlUGFuZWw6IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRyZXR1cm4gJCggXCI8ZGl2PlwiIClcblx0XHRcdC5hdHRyKCBcImlkXCIsIGlkIClcblx0XHRcdC5kYXRhKCBcInVpLXRhYnMtZGVzdHJveVwiLCB0cnVlICk7XG5cdH0sXG5cblx0X3NldE9wdGlvbkRpc2FibGVkOiBmdW5jdGlvbiggZGlzYWJsZWQgKSB7XG5cdFx0dmFyIGN1cnJlbnRJdGVtLCBsaSwgaTtcblxuXHRcdGlmICggJC5pc0FycmF5KCBkaXNhYmxlZCApICkge1xuXHRcdFx0aWYgKCAhZGlzYWJsZWQubGVuZ3RoICkge1xuXHRcdFx0XHRkaXNhYmxlZCA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggZGlzYWJsZWQubGVuZ3RoID09PSB0aGlzLmFuY2hvcnMubGVuZ3RoICkge1xuXHRcdFx0XHRkaXNhYmxlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRGlzYWJsZSB0YWJzXG5cdFx0Zm9yICggaSA9IDA7ICggbGkgPSB0aGlzLnRhYnNbIGkgXSApOyBpKysgKSB7XG5cdFx0XHRjdXJyZW50SXRlbSA9ICQoIGxpICk7XG5cdFx0XHRpZiAoIGRpc2FibGVkID09PSB0cnVlIHx8ICQuaW5BcnJheSggaSwgZGlzYWJsZWQgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdGN1cnJlbnRJdGVtLmF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiLCBcInRydWVcIiApO1xuXHRcdFx0XHR0aGlzLl9hZGRDbGFzcyggY3VycmVudEl0ZW0sIG51bGwsIFwidWktc3RhdGUtZGlzYWJsZWRcIiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VycmVudEl0ZW0ucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIGN1cnJlbnRJdGVtLCBudWxsLCBcInVpLXN0YXRlLWRpc2FibGVkXCIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcblxuXHRcdHRoaXMuX3RvZ2dsZUNsYXNzKCB0aGlzLndpZGdldCgpLCB0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWRcIiwgbnVsbCxcblx0XHRcdGRpc2FibGVkID09PSB0cnVlICk7XG5cdH0sXG5cblx0X3NldHVwRXZlbnRzOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGV2ZW50cyA9IHt9O1xuXHRcdGlmICggZXZlbnQgKSB7XG5cdFx0XHQkLmVhY2goIGV2ZW50LnNwbGl0KCBcIiBcIiApLCBmdW5jdGlvbiggaW5kZXgsIGV2ZW50TmFtZSApIHtcblx0XHRcdFx0ZXZlbnRzWyBldmVudE5hbWUgXSA9IFwiX2V2ZW50SGFuZGxlclwiO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHRoaXMuX29mZiggdGhpcy5hbmNob3JzLmFkZCggdGhpcy50YWJzICkuYWRkKCB0aGlzLnBhbmVscyApICk7XG5cblx0XHQvLyBBbHdheXMgcHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb24sIGV2ZW4gd2hlbiBkaXNhYmxlZFxuXHRcdHRoaXMuX29uKCB0cnVlLCB0aGlzLmFuY2hvcnMsIHtcblx0XHRcdGNsaWNrOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHRoaXMuX29uKCB0aGlzLmFuY2hvcnMsIGV2ZW50cyApO1xuXHRcdHRoaXMuX29uKCB0aGlzLnRhYnMsIHsga2V5ZG93bjogXCJfdGFiS2V5ZG93blwiIH0gKTtcblx0XHR0aGlzLl9vbiggdGhpcy5wYW5lbHMsIHsga2V5ZG93bjogXCJfcGFuZWxLZXlkb3duXCIgfSApO1xuXG5cdFx0dGhpcy5fZm9jdXNhYmxlKCB0aGlzLnRhYnMgKTtcblx0XHR0aGlzLl9ob3ZlcmFibGUoIHRoaXMudGFicyApO1xuXHR9LFxuXG5cdF9zZXR1cEhlaWdodFN0eWxlOiBmdW5jdGlvbiggaGVpZ2h0U3R5bGUgKSB7XG5cdFx0dmFyIG1heEhlaWdodCxcblx0XHRcdHBhcmVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnQoKTtcblxuXHRcdGlmICggaGVpZ2h0U3R5bGUgPT09IFwiZmlsbFwiICkge1xuXHRcdFx0bWF4SGVpZ2h0ID0gcGFyZW50LmhlaWdodCgpO1xuXHRcdFx0bWF4SGVpZ2h0IC09IHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpIC0gdGhpcy5lbGVtZW50LmhlaWdodCgpO1xuXG5cdFx0XHR0aGlzLmVsZW1lbnQuc2libGluZ3MoIFwiOnZpc2libGVcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9ICQoIHRoaXMgKSxcblx0XHRcdFx0XHRwb3NpdGlvbiA9IGVsZW0uY3NzKCBcInBvc2l0aW9uXCIgKTtcblxuXHRcdFx0XHRpZiAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF4SGVpZ2h0IC09IGVsZW0ub3V0ZXJIZWlnaHQoIHRydWUgKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5lbGVtZW50LmNoaWxkcmVuKCkubm90KCB0aGlzLnBhbmVscyApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRtYXhIZWlnaHQgLT0gJCggdGhpcyApLm91dGVySGVpZ2h0KCB0cnVlICk7XG5cdFx0XHR9ICk7XG5cblx0XHRcdHRoaXMucGFuZWxzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkKCB0aGlzICkuaGVpZ2h0KCBNYXRoLm1heCggMCwgbWF4SGVpZ2h0IC1cblx0XHRcdFx0XHQkKCB0aGlzICkuaW5uZXJIZWlnaHQoKSArICQoIHRoaXMgKS5oZWlnaHQoKSApICk7XG5cdFx0XHR9IClcblx0XHRcdFx0LmNzcyggXCJvdmVyZmxvd1wiLCBcImF1dG9cIiApO1xuXHRcdH0gZWxzZSBpZiAoIGhlaWdodFN0eWxlID09PSBcImF1dG9cIiApIHtcblx0XHRcdG1heEhlaWdodCA9IDA7XG5cdFx0XHR0aGlzLnBhbmVscy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0bWF4SGVpZ2h0ID0gTWF0aC5tYXgoIG1heEhlaWdodCwgJCggdGhpcyApLmhlaWdodCggXCJcIiApLmhlaWdodCgpICk7XG5cdFx0XHR9ICkuaGVpZ2h0KCBtYXhIZWlnaHQgKTtcblx0XHR9XG5cdH0sXG5cblx0X2V2ZW50SGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0YWN0aXZlID0gdGhpcy5hY3RpdmUsXG5cdFx0XHRhbmNob3IgPSAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksXG5cdFx0XHR0YWIgPSBhbmNob3IuY2xvc2VzdCggXCJsaVwiICksXG5cdFx0XHRjbGlja2VkSXNBY3RpdmUgPSB0YWJbIDAgXSA9PT0gYWN0aXZlWyAwIF0sXG5cdFx0XHRjb2xsYXBzaW5nID0gY2xpY2tlZElzQWN0aXZlICYmIG9wdGlvbnMuY29sbGFwc2libGUsXG5cdFx0XHR0b1Nob3cgPSBjb2xsYXBzaW5nID8gJCgpIDogdGhpcy5fZ2V0UGFuZWxGb3JUYWIoIHRhYiApLFxuXHRcdFx0dG9IaWRlID0gIWFjdGl2ZS5sZW5ndGggPyAkKCkgOiB0aGlzLl9nZXRQYW5lbEZvclRhYiggYWN0aXZlICksXG5cdFx0XHRldmVudERhdGEgPSB7XG5cdFx0XHRcdG9sZFRhYjogYWN0aXZlLFxuXHRcdFx0XHRvbGRQYW5lbDogdG9IaWRlLFxuXHRcdFx0XHRuZXdUYWI6IGNvbGxhcHNpbmcgPyAkKCkgOiB0YWIsXG5cdFx0XHRcdG5ld1BhbmVsOiB0b1Nob3dcblx0XHRcdH07XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0aWYgKCB0YWIuaGFzQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApIHx8XG5cblx0XHRcdFx0Ly8gdGFiIGlzIGFscmVhZHkgbG9hZGluZ1xuXHRcdFx0XHR0YWIuaGFzQ2xhc3MoIFwidWktdGFicy1sb2FkaW5nXCIgKSB8fFxuXG5cdFx0XHRcdC8vIGNhbid0IHN3aXRjaCBkdXJuaW5nIGFuIGFuaW1hdGlvblxuXHRcdFx0XHR0aGlzLnJ1bm5pbmcgfHxcblxuXHRcdFx0XHQvLyBjbGljayBvbiBhY3RpdmUgaGVhZGVyLCBidXQgbm90IGNvbGxhcHNpYmxlXG5cdFx0XHRcdCggY2xpY2tlZElzQWN0aXZlICYmICFvcHRpb25zLmNvbGxhcHNpYmxlICkgfHxcblxuXHRcdFx0XHQvLyBhbGxvdyBjYW5jZWxpbmcgYWN0aXZhdGlvblxuXHRcdFx0XHQoIHRoaXMuX3RyaWdnZXIoIFwiYmVmb3JlQWN0aXZhdGVcIiwgZXZlbnQsIGV2ZW50RGF0YSApID09PSBmYWxzZSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG9wdGlvbnMuYWN0aXZlID0gY29sbGFwc2luZyA/IGZhbHNlIDogdGhpcy50YWJzLmluZGV4KCB0YWIgKTtcblxuXHRcdHRoaXMuYWN0aXZlID0gY2xpY2tlZElzQWN0aXZlID8gJCgpIDogdGFiO1xuXHRcdGlmICggdGhpcy54aHIgKSB7XG5cdFx0XHR0aGlzLnhoci5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdGlmICggIXRvSGlkZS5sZW5ndGggJiYgIXRvU2hvdy5sZW5ndGggKSB7XG5cdFx0XHQkLmVycm9yKCBcImpRdWVyeSBVSSBUYWJzOiBNaXNtYXRjaGluZyBmcmFnbWVudCBpZGVudGlmaWVyLlwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0b1Nob3cubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5sb2FkKCB0aGlzLnRhYnMuaW5kZXgoIHRhYiApLCBldmVudCApO1xuXHRcdH1cblx0XHR0aGlzLl90b2dnbGUoIGV2ZW50LCBldmVudERhdGEgKTtcblx0fSxcblxuXHQvLyBIYW5kbGVzIHNob3cvaGlkZSBmb3Igc2VsZWN0aW5nIHRhYnNcblx0X3RvZ2dsZTogZnVuY3Rpb24oIGV2ZW50LCBldmVudERhdGEgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0dG9TaG93ID0gZXZlbnREYXRhLm5ld1BhbmVsLFxuXHRcdFx0dG9IaWRlID0gZXZlbnREYXRhLm9sZFBhbmVsO1xuXG5cdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuXHRcdFx0dGhhdC5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHR0aGF0Ll90cmlnZ2VyKCBcImFjdGl2YXRlXCIsIGV2ZW50LCBldmVudERhdGEgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzaG93KCkge1xuXHRcdFx0dGhhdC5fYWRkQ2xhc3MoIGV2ZW50RGF0YS5uZXdUYWIuY2xvc2VzdCggXCJsaVwiICksIFwidWktdGFicy1hY3RpdmVcIiwgXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXG5cdFx0XHRpZiAoIHRvU2hvdy5sZW5ndGggJiYgdGhhdC5vcHRpb25zLnNob3cgKSB7XG5cdFx0XHRcdHRoYXQuX3Nob3coIHRvU2hvdywgdGhhdC5vcHRpb25zLnNob3csIGNvbXBsZXRlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b1Nob3cuc2hvdygpO1xuXHRcdFx0XHRjb21wbGV0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN0YXJ0IG91dCBieSBoaWRpbmcsIHRoZW4gc2hvd2luZywgdGhlbiBjb21wbGV0aW5nXG5cdFx0aWYgKCB0b0hpZGUubGVuZ3RoICYmIHRoaXMub3B0aW9ucy5oaWRlICkge1xuXHRcdFx0dGhpcy5faGlkZSggdG9IaWRlLCB0aGlzLm9wdGlvbnMuaGlkZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoYXQuX3JlbW92ZUNsYXNzKCBldmVudERhdGEub2xkVGFiLmNsb3Nlc3QoIFwibGlcIiApLFxuXHRcdFx0XHRcdFwidWktdGFicy1hY3RpdmVcIiwgXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHRzaG93KCk7XG5cdFx0XHR9ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBldmVudERhdGEub2xkVGFiLmNsb3Nlc3QoIFwibGlcIiApLFxuXHRcdFx0XHRcInVpLXRhYnMtYWN0aXZlXCIsIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdHRvSGlkZS5oaWRlKCk7XG5cdFx0XHRzaG93KCk7XG5cdFx0fVxuXG5cdFx0dG9IaWRlLmF0dHIoIFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIgKTtcblx0XHRldmVudERhdGEub2xkVGFiLmF0dHIoIHtcblx0XHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBcImZhbHNlXCIsXG5cdFx0XHRcImFyaWEtZXhwYW5kZWRcIjogXCJmYWxzZVwiXG5cdFx0fSApO1xuXG5cdFx0Ly8gSWYgd2UncmUgc3dpdGNoaW5nIHRhYnMsIHJlbW92ZSB0aGUgb2xkIHRhYiBmcm9tIHRoZSB0YWIgb3JkZXIuXG5cdFx0Ly8gSWYgd2UncmUgb3BlbmluZyBmcm9tIGNvbGxhcHNlZCBzdGF0ZSwgcmVtb3ZlIHRoZSBwcmV2aW91cyB0YWIgZnJvbSB0aGUgdGFiIG9yZGVyLlxuXHRcdC8vIElmIHdlJ3JlIGNvbGxhcHNpbmcsIHRoZW4ga2VlcCB0aGUgY29sbGFwc2luZyB0YWIgaW4gdGhlIHRhYiBvcmRlci5cblx0XHRpZiAoIHRvU2hvdy5sZW5ndGggJiYgdG9IaWRlLmxlbmd0aCApIHtcblx0XHRcdGV2ZW50RGF0YS5vbGRUYWIuYXR0ciggXCJ0YWJJbmRleFwiLCAtMSApO1xuXHRcdH0gZWxzZSBpZiAoIHRvU2hvdy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLnRhYnMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICQoIHRoaXMgKS5hdHRyKCBcInRhYkluZGV4XCIgKSA9PT0gMDtcblx0XHRcdH0gKVxuXHRcdFx0XHQuYXR0ciggXCJ0YWJJbmRleFwiLCAtMSApO1xuXHRcdH1cblxuXHRcdHRvU2hvdy5hdHRyKCBcImFyaWEtaGlkZGVuXCIsIFwiZmFsc2VcIiApO1xuXHRcdGV2ZW50RGF0YS5uZXdUYWIuYXR0cigge1xuXHRcdFx0XCJhcmlhLXNlbGVjdGVkXCI6IFwidHJ1ZVwiLFxuXHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwidHJ1ZVwiLFxuXHRcdFx0dGFiSW5kZXg6IDBcblx0XHR9ICk7XG5cdH0sXG5cblx0X2FjdGl2YXRlOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0dmFyIGFuY2hvcixcblx0XHRcdGFjdGl2ZSA9IHRoaXMuX2ZpbmRBY3RpdmUoIGluZGV4ICk7XG5cblx0XHQvLyBUcnlpbmcgdG8gYWN0aXZhdGUgdGhlIGFscmVhZHkgYWN0aXZlIHBhbmVsXG5cdFx0aWYgKCBhY3RpdmVbIDAgXSA9PT0gdGhpcy5hY3RpdmVbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBUcnlpbmcgdG8gY29sbGFwc2UsIHNpbXVsYXRlIGEgY2xpY2sgb24gdGhlIGN1cnJlbnQgYWN0aXZlIGhlYWRlclxuXHRcdGlmICggIWFjdGl2ZS5sZW5ndGggKSB7XG5cdFx0XHRhY3RpdmUgPSB0aGlzLmFjdGl2ZTtcblx0XHR9XG5cblx0XHRhbmNob3IgPSBhY3RpdmUuZmluZCggXCIudWktdGFicy1hbmNob3JcIiApWyAwIF07XG5cdFx0dGhpcy5fZXZlbnRIYW5kbGVyKCB7XG5cdFx0XHR0YXJnZXQ6IGFuY2hvcixcblx0XHRcdGN1cnJlbnRUYXJnZXQ6IGFuY2hvcixcblx0XHRcdHByZXZlbnREZWZhdWx0OiAkLm5vb3Bcblx0XHR9ICk7XG5cdH0sXG5cblx0X2ZpbmRBY3RpdmU6IGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRyZXR1cm4gaW5kZXggPT09IGZhbHNlID8gJCgpIDogdGhpcy50YWJzLmVxKCBpbmRleCApO1xuXHR9LFxuXG5cdF9nZXRJbmRleDogZnVuY3Rpb24oIGluZGV4ICkge1xuXG5cdFx0Ly8gbWV0YS1mdW5jdGlvbiB0byBnaXZlIHVzZXJzIG9wdGlvbiB0byBwcm92aWRlIGEgaHJlZiBzdHJpbmcgaW5zdGVhZCBvZiBhIG51bWVyaWNhbCBpbmRleC5cblx0XHRpZiAoIHR5cGVvZiBpbmRleCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGluZGV4ID0gdGhpcy5hbmNob3JzLmluZGV4KCB0aGlzLmFuY2hvcnMuZmlsdGVyKCBcIltocmVmJD0nXCIgK1xuXHRcdFx0XHQkLnVpLmVzY2FwZVNlbGVjdG9yKCBpbmRleCApICsgXCInXVwiICkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaW5kZXg7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggdGhpcy54aHIgKSB7XG5cdFx0XHR0aGlzLnhoci5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdHRoaXMudGFibGlzdFxuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiIClcblx0XHRcdC5vZmYoIHRoaXMuZXZlbnROYW1lc3BhY2UgKTtcblxuXHRcdHRoaXMuYW5jaG9yc1xuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZSB0YWJJbmRleFwiIClcblx0XHRcdC5yZW1vdmVVbmlxdWVJZCgpO1xuXG5cdFx0dGhpcy50YWJzLmFkZCggdGhpcy5wYW5lbHMgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggJC5kYXRhKCB0aGlzLCBcInVpLXRhYnMtZGVzdHJveVwiICkgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVBdHRyKCBcInJvbGUgdGFiSW5kZXggXCIgK1xuXHRcdFx0XHRcdFwiYXJpYS1saXZlIGFyaWEtYnVzeSBhcmlhLXNlbGVjdGVkIGFyaWEtbGFiZWxsZWRieSBhcmlhLWhpZGRlbiBhcmlhLWV4cGFuZGVkXCIgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHR0aGlzLnRhYnMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbGkgPSAkKCB0aGlzICksXG5cdFx0XHRcdHByZXYgPSBsaS5kYXRhKCBcInVpLXRhYnMtYXJpYS1jb250cm9sc1wiICk7XG5cdFx0XHRpZiAoIHByZXYgKSB7XG5cdFx0XHRcdGxpXG5cdFx0XHRcdFx0LmF0dHIoIFwiYXJpYS1jb250cm9sc1wiLCBwcmV2IClcblx0XHRcdFx0XHQucmVtb3ZlRGF0YSggXCJ1aS10YWJzLWFyaWEtY29udHJvbHNcIiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGkucmVtb3ZlQXR0ciggXCJhcmlhLWNvbnRyb2xzXCIgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHR0aGlzLnBhbmVscy5zaG93KCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5oZWlnaHRTdHlsZSAhPT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHR0aGlzLnBhbmVscy5jc3MoIFwiaGVpZ2h0XCIsIFwiXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZW5hYmxlOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0dmFyIGRpc2FibGVkID0gdGhpcy5vcHRpb25zLmRpc2FibGVkO1xuXHRcdGlmICggZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGRpc2FibGVkID0gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgoIGluZGV4ICk7XG5cdFx0XHRpZiAoICQuaXNBcnJheSggZGlzYWJsZWQgKSApIHtcblx0XHRcdFx0ZGlzYWJsZWQgPSAkLm1hcCggZGlzYWJsZWQsIGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bSAhPT0gaW5kZXggPyBudW0gOiBudWxsO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkaXNhYmxlZCA9ICQubWFwKCB0aGlzLnRhYnMsIGZ1bmN0aW9uKCBsaSwgbnVtICkge1xuXHRcdFx0XHRcdHJldHVybiBudW0gIT09IGluZGV4ID8gbnVtIDogbnVsbDtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9zZXRPcHRpb25EaXNhYmxlZCggZGlzYWJsZWQgKTtcblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0dmFyIGRpc2FibGVkID0gdGhpcy5vcHRpb25zLmRpc2FibGVkO1xuXHRcdGlmICggZGlzYWJsZWQgPT09IHRydWUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0ZGlzYWJsZWQgPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbmRleCA9IHRoaXMuX2dldEluZGV4KCBpbmRleCApO1xuXHRcdFx0aWYgKCAkLmluQXJyYXkoIGluZGV4LCBkaXNhYmxlZCApICE9PSAtMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAkLmlzQXJyYXkoIGRpc2FibGVkICkgKSB7XG5cdFx0XHRcdGRpc2FibGVkID0gJC5tZXJnZSggWyBpbmRleCBdLCBkaXNhYmxlZCApLnNvcnQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpc2FibGVkID0gWyBpbmRleCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9zZXRPcHRpb25EaXNhYmxlZCggZGlzYWJsZWQgKTtcblx0fSxcblxuXHRsb2FkOiBmdW5jdGlvbiggaW5kZXgsIGV2ZW50ICkge1xuXHRcdGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgoIGluZGV4ICk7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0dGFiID0gdGhpcy50YWJzLmVxKCBpbmRleCApLFxuXHRcdFx0YW5jaG9yID0gdGFiLmZpbmQoIFwiLnVpLXRhYnMtYW5jaG9yXCIgKSxcblx0XHRcdHBhbmVsID0gdGhpcy5fZ2V0UGFuZWxGb3JUYWIoIHRhYiApLFxuXHRcdFx0ZXZlbnREYXRhID0ge1xuXHRcdFx0XHR0YWI6IHRhYixcblx0XHRcdFx0cGFuZWw6IHBhbmVsXG5cdFx0XHR9LFxuXHRcdFx0Y29tcGxldGUgPSBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHR0aGF0LnBhbmVscy5zdG9wKCBmYWxzZSwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhhdC5fcmVtb3ZlQ2xhc3MoIHRhYiwgXCJ1aS10YWJzLWxvYWRpbmdcIiApO1xuXHRcdFx0XHRwYW5lbC5yZW1vdmVBdHRyKCBcImFyaWEtYnVzeVwiICk7XG5cblx0XHRcdFx0aWYgKCBqcVhIUiA9PT0gdGhhdC54aHIgKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoYXQueGhyO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gTm90IHJlbW90ZVxuXHRcdGlmICggdGhpcy5faXNMb2NhbCggYW5jaG9yWyAwIF0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnhociA9ICQuYWpheCggdGhpcy5fYWpheFNldHRpbmdzKCBhbmNob3IsIGV2ZW50LCBldmVudERhdGEgKSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogalF1ZXJ5IDwxLjhcblx0XHQvLyBqUXVlcnkgPDEuOCByZXR1cm5zIGZhbHNlIGlmIHRoZSByZXF1ZXN0IGlzIGNhbmNlbGVkIGluIGJlZm9yZVNlbmQsXG5cdFx0Ly8gYnV0IGFzIG9mIDEuOCwgJC5hamF4KCkgYWx3YXlzIHJldHVybnMgYSBqcVhIUiBvYmplY3QuXG5cdFx0aWYgKCB0aGlzLnhociAmJiB0aGlzLnhoci5zdGF0dXNUZXh0ICE9PSBcImNhbmNlbGVkXCIgKSB7XG5cdFx0XHR0aGlzLl9hZGRDbGFzcyggdGFiLCBcInVpLXRhYnMtbG9hZGluZ1wiICk7XG5cdFx0XHRwYW5lbC5hdHRyKCBcImFyaWEtYnVzeVwiLCBcInRydWVcIiApO1xuXG5cdFx0XHR0aGlzLnhoclxuXHRcdFx0XHQuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlLCBzdGF0dXMsIGpxWEhSICkge1xuXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcblx0XHRcdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMTc3OFxuXHRcdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cGFuZWwuaHRtbCggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdHRoYXQuX3RyaWdnZXIoIFwibG9hZFwiLCBldmVudCwgZXZlbnREYXRhICk7XG5cblx0XHRcdFx0XHRcdGNvbXBsZXRlKCBqcVhIUiwgc3RhdHVzICk7XG5cdFx0XHRcdFx0fSwgMSApO1xuXHRcdFx0XHR9IClcblx0XHRcdFx0LmZhaWwoIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcblx0XHRcdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMTc3OFxuXHRcdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0Y29tcGxldGUoIGpxWEhSLCBzdGF0dXMgKTtcblx0XHRcdFx0XHR9LCAxICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cdH0sXG5cblx0X2FqYXhTZXR0aW5nczogZnVuY3Rpb24oIGFuY2hvciwgZXZlbnQsIGV2ZW50RGF0YSApIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPDExIG9ubHlcblx0XHRcdC8vIFN0cmlwIGFueSBoYXNoIHRoYXQgZXhpc3RzIHRvIHByZXZlbnQgZXJyb3JzIHdpdGggdGhlIEFqYXggcmVxdWVzdFxuXHRcdFx0dXJsOiBhbmNob3IuYXR0ciggXCJocmVmXCIgKS5yZXBsYWNlKCAvIy4qJC8sIFwiXCIgKSxcblx0XHRcdGJlZm9yZVNlbmQ6IGZ1bmN0aW9uKCBqcVhIUiwgc2V0dGluZ3MgKSB7XG5cdFx0XHRcdHJldHVybiB0aGF0Ll90cmlnZ2VyKCBcImJlZm9yZUxvYWRcIiwgZXZlbnQsXG5cdFx0XHRcdFx0JC5leHRlbmQoIHsganFYSFI6IGpxWEhSLCBhamF4U2V0dGluZ3M6IHNldHRpbmdzIH0sIGV2ZW50RGF0YSApICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSxcblxuXHRfZ2V0UGFuZWxGb3JUYWI6IGZ1bmN0aW9uKCB0YWIgKSB7XG5cdFx0dmFyIGlkID0gJCggdGFiICkuYXR0ciggXCJhcmlhLWNvbnRyb2xzXCIgKTtcblx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmZpbmQoIHRoaXMuX3Nhbml0aXplU2VsZWN0b3IoIFwiI1wiICsgaWQgKSApO1xuXHR9XG59ICk7XG5cbi8vIERFUFJFQ0FURURcbi8vIFRPRE86IFN3aXRjaCByZXR1cm4gYmFjayB0byB3aWRnZXQgZGVjbGFyYXRpb24gYXQgdG9wIG9mIGZpbGUgd2hlbiB0aGlzIGlzIHJlbW92ZWRcbmlmICggJC51aUJhY2tDb21wYXQgIT09IGZhbHNlICkge1xuXG5cdC8vIEJhY2tjb21wYXQgZm9yIHVpLXRhYiBjbGFzcyAobm93IHVpLXRhYnMtdGFiKVxuXHQkLndpZGdldCggXCJ1aS50YWJzXCIsICQudWkudGFicywge1xuXHRcdF9wcm9jZXNzVGFiczogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlckFwcGx5KCBhcmd1bWVudHMgKTtcblx0XHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLnRhYnMsIFwidWktdGFiXCIgKTtcblx0XHR9XG5cdH0gKTtcbn1cblxudmFyIHdpZGdldHNUYWJzID0gJC51aS50YWJzO1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIFRvb2x0aXAgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IFRvb2x0aXBcbi8vPj5ncm91cDogV2lkZ2V0c1xuLy8+PmRlc2NyaXB0aW9uOiBTaG93cyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhbnkgZWxlbWVudCBvbiBob3ZlciBvciBmb2N1cy5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS90b29sdGlwL1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL3Rvb2x0aXAvXG4vLz4+Y3NzLnN0cnVjdHVyZTogLi4vLi4vdGhlbWVzL2Jhc2UvY29yZS5jc3Ncbi8vPj5jc3Muc3RydWN0dXJlOiAuLi8uLi90aGVtZXMvYmFzZS90b29sdGlwLmNzc1xuLy8+PmNzcy50aGVtZTogLi4vLi4vdGhlbWVzL2Jhc2UvdGhlbWUuY3NzXG5cblxuXG4kLndpZGdldCggXCJ1aS50b29sdGlwXCIsIHtcblx0dmVyc2lvbjogXCIxLjEyLjFcIixcblx0b3B0aW9uczoge1xuXHRcdGNsYXNzZXM6IHtcblx0XHRcdFwidWktdG9vbHRpcFwiOiBcInVpLWNvcm5lci1hbGwgdWktd2lkZ2V0LXNoYWRvd1wiXG5cdFx0fSxcblx0XHRjb250ZW50OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gc3VwcG9ydDogSUU8OSwgT3BlcmEgaW4galF1ZXJ5IDwxLjdcblx0XHRcdC8vIC50ZXh0KCkgY2FuJ3QgYWNjZXB0IHVuZGVmaW5lZCwgc28gY29lcmNlIHRvIGEgc3RyaW5nXG5cdFx0XHR2YXIgdGl0bGUgPSAkKCB0aGlzICkuYXR0ciggXCJ0aXRsZVwiICkgfHwgXCJcIjtcblxuXHRcdFx0Ly8gRXNjYXBlIHRpdGxlLCBzaW5jZSB3ZSdyZSBnb2luZyBmcm9tIGFuIGF0dHJpYnV0ZSB0byByYXcgSFRNTFxuXHRcdFx0cmV0dXJuICQoIFwiPGE+XCIgKS50ZXh0KCB0aXRsZSApLmh0bWwoKTtcblx0XHR9LFxuXHRcdGhpZGU6IHRydWUsXG5cblx0XHQvLyBEaXNhYmxlZCBlbGVtZW50cyBoYXZlIGluY29uc2lzdGVudCBiZWhhdmlvciBhY3Jvc3MgYnJvd3NlcnMgKCM4NjYxKVxuXHRcdGl0ZW1zOiBcIlt0aXRsZV06bm90KFtkaXNhYmxlZF0pXCIsXG5cdFx0cG9zaXRpb246IHtcblx0XHRcdG15OiBcImxlZnQgdG9wKzE1XCIsXG5cdFx0XHRhdDogXCJsZWZ0IGJvdHRvbVwiLFxuXHRcdFx0Y29sbGlzaW9uOiBcImZsaXBmaXQgZmxpcFwiXG5cdFx0fSxcblx0XHRzaG93OiB0cnVlLFxuXHRcdHRyYWNrOiBmYWxzZSxcblxuXHRcdC8vIENhbGxiYWNrc1xuXHRcdGNsb3NlOiBudWxsLFxuXHRcdG9wZW46IG51bGxcblx0fSxcblxuXHRfYWRkRGVzY3JpYmVkQnk6IGZ1bmN0aW9uKCBlbGVtLCBpZCApIHtcblx0XHR2YXIgZGVzY3JpYmVkYnkgPSAoIGVsZW0uYXR0ciggXCJhcmlhLWRlc2NyaWJlZGJ5XCIgKSB8fCBcIlwiICkuc3BsaXQoIC9cXHMrLyApO1xuXHRcdGRlc2NyaWJlZGJ5LnB1c2goIGlkICk7XG5cdFx0ZWxlbVxuXHRcdFx0LmRhdGEoIFwidWktdG9vbHRpcC1pZFwiLCBpZCApXG5cdFx0XHQuYXR0ciggXCJhcmlhLWRlc2NyaWJlZGJ5XCIsICQudHJpbSggZGVzY3JpYmVkYnkuam9pbiggXCIgXCIgKSApICk7XG5cdH0sXG5cblx0X3JlbW92ZURlc2NyaWJlZEJ5OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgaWQgPSBlbGVtLmRhdGEoIFwidWktdG9vbHRpcC1pZFwiICksXG5cdFx0XHRkZXNjcmliZWRieSA9ICggZWxlbS5hdHRyKCBcImFyaWEtZGVzY3JpYmVkYnlcIiApIHx8IFwiXCIgKS5zcGxpdCggL1xccysvICksXG5cdFx0XHRpbmRleCA9ICQuaW5BcnJheSggaWQsIGRlc2NyaWJlZGJ5ICk7XG5cblx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdGRlc2NyaWJlZGJ5LnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHR9XG5cblx0XHRlbGVtLnJlbW92ZURhdGEoIFwidWktdG9vbHRpcC1pZFwiICk7XG5cdFx0ZGVzY3JpYmVkYnkgPSAkLnRyaW0oIGRlc2NyaWJlZGJ5LmpvaW4oIFwiIFwiICkgKTtcblx0XHRpZiAoIGRlc2NyaWJlZGJ5ICkge1xuXHRcdFx0ZWxlbS5hdHRyKCBcImFyaWEtZGVzY3JpYmVkYnlcIiwgZGVzY3JpYmVkYnkgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5yZW1vdmVBdHRyKCBcImFyaWEtZGVzY3JpYmVkYnlcIiApO1xuXHRcdH1cblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9vbigge1xuXHRcdFx0bW91c2VvdmVyOiBcIm9wZW5cIixcblx0XHRcdGZvY3VzaW46IFwib3BlblwiXG5cdFx0fSApO1xuXG5cdFx0Ly8gSURzIG9mIGdlbmVyYXRlZCB0b29sdGlwcywgbmVlZGVkIGZvciBkZXN0cm95XG5cdFx0dGhpcy50b29sdGlwcyA9IHt9O1xuXG5cdFx0Ly8gSURzIG9mIHBhcmVudCB0b29sdGlwcyB3aGVyZSB3ZSByZW1vdmVkIHRoZSB0aXRsZSBhdHRyaWJ1dGVcblx0XHR0aGlzLnBhcmVudHMgPSB7fTtcblxuXHRcdC8vIEFwcGVuZCB0aGUgYXJpYS1saXZlIHJlZ2lvbiBzbyB0b29sdGlwcyBhbm5vdW5jZSBjb3JyZWN0bHlcblx0XHR0aGlzLmxpdmVSZWdpb24gPSAkKCBcIjxkaXY+XCIgKVxuXHRcdFx0LmF0dHIoIHtcblx0XHRcdFx0cm9sZTogXCJsb2dcIixcblx0XHRcdFx0XCJhcmlhLWxpdmVcIjogXCJhc3NlcnRpdmVcIixcblx0XHRcdFx0XCJhcmlhLXJlbGV2YW50XCI6IFwiYWRkaXRpb25zXCJcblx0XHRcdH0gKVxuXHRcdFx0LmFwcGVuZFRvKCB0aGlzLmRvY3VtZW50WyAwIF0uYm9keSApO1xuXHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLmxpdmVSZWdpb24sIG51bGwsIFwidWktaGVscGVyLWhpZGRlbi1hY2Nlc3NpYmxlXCIgKTtcblxuXHRcdHRoaXMuZGlzYWJsZWRUaXRsZXMgPSAkKCBbXSApO1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHQkLmVhY2goIHRoaXMudG9vbHRpcHMsIGZ1bmN0aW9uKCBpZCwgdG9vbHRpcERhdGEgKSB7XG5cdFx0XHRcdHRoYXQuX3VwZGF0ZUNvbnRlbnQoIHRvb2x0aXBEYXRhLmVsZW1lbnQgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbkRpc2FibGVkOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dGhpc1sgdmFsdWUgPyBcIl9kaXNhYmxlXCIgOiBcIl9lbmFibGVcIiBdKCk7XG5cdH0sXG5cblx0X2Rpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdC8vIENsb3NlIG9wZW4gdG9vbHRpcHNcblx0XHQkLmVhY2goIHRoaXMudG9vbHRpcHMsIGZ1bmN0aW9uKCBpZCwgdG9vbHRpcERhdGEgKSB7XG5cdFx0XHR2YXIgZXZlbnQgPSAkLkV2ZW50KCBcImJsdXJcIiApO1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCA9IHRvb2x0aXBEYXRhLmVsZW1lbnRbIDAgXTtcblx0XHRcdHRoYXQuY2xvc2UoIGV2ZW50LCB0cnVlICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gUmVtb3ZlIHRpdGxlIGF0dHJpYnV0ZXMgdG8gcHJldmVudCBuYXRpdmUgdG9vbHRpcHNcblx0XHR0aGlzLmRpc2FibGVkVGl0bGVzID0gdGhpcy5kaXNhYmxlZFRpdGxlcy5hZGQoXG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCggdGhpcy5vcHRpb25zLml0ZW1zICkuYWRkQmFjaygpXG5cdFx0XHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBlbGVtZW50ID0gJCggdGhpcyApO1xuXHRcdFx0XHRcdGlmICggZWxlbWVudC5pcyggXCJbdGl0bGVdXCIgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdC5kYXRhKCBcInVpLXRvb2x0aXAtdGl0bGVcIiwgZWxlbWVudC5hdHRyKCBcInRpdGxlXCIgKSApXG5cdFx0XHRcdFx0XHRcdC5yZW1vdmVBdHRyKCBcInRpdGxlXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKVxuXHRcdCk7XG5cdH0sXG5cblx0X2VuYWJsZTogZnVuY3Rpb24oKSB7XG5cblx0XHQvLyByZXN0b3JlIHRpdGxlIGF0dHJpYnV0ZXNcblx0XHR0aGlzLmRpc2FibGVkVGl0bGVzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSAkKCB0aGlzICk7XG5cdFx0XHRpZiAoIGVsZW1lbnQuZGF0YSggXCJ1aS10b29sdGlwLXRpdGxlXCIgKSApIHtcblx0XHRcdFx0ZWxlbWVudC5hdHRyKCBcInRpdGxlXCIsIGVsZW1lbnQuZGF0YSggXCJ1aS10b29sdGlwLXRpdGxlXCIgKSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHR0aGlzLmRpc2FibGVkVGl0bGVzID0gJCggW10gKTtcblx0fSxcblxuXHRvcGVuOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0dGFyZ2V0ID0gJCggZXZlbnQgPyBldmVudC50YXJnZXQgOiB0aGlzLmVsZW1lbnQgKVxuXG5cdFx0XHRcdC8vIHdlIG5lZWQgY2xvc2VzdCBoZXJlIGR1ZSB0byBtb3VzZW92ZXIgYnViYmxpbmcsXG5cdFx0XHRcdC8vIGJ1dCBhbHdheXMgcG9pbnRpbmcgYXQgdGhlIHNhbWUgZXZlbnQgdGFyZ2V0XG5cdFx0XHRcdC5jbG9zZXN0KCB0aGlzLm9wdGlvbnMuaXRlbXMgKTtcblxuXHRcdC8vIE5vIGVsZW1lbnQgdG8gc2hvdyBhIHRvb2x0aXAgZm9yIG9yIHRoZSB0b29sdGlwIGlzIGFscmVhZHkgb3BlblxuXHRcdGlmICggIXRhcmdldC5sZW5ndGggfHwgdGFyZ2V0LmRhdGEoIFwidWktdG9vbHRpcC1pZFwiICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0YXJnZXQuYXR0ciggXCJ0aXRsZVwiICkgKSB7XG5cdFx0XHR0YXJnZXQuZGF0YSggXCJ1aS10b29sdGlwLXRpdGxlXCIsIHRhcmdldC5hdHRyKCBcInRpdGxlXCIgKSApO1xuXHRcdH1cblxuXHRcdHRhcmdldC5kYXRhKCBcInVpLXRvb2x0aXAtb3BlblwiLCB0cnVlICk7XG5cblx0XHQvLyBLaWxsIHBhcmVudCB0b29sdGlwcywgY3VzdG9tIG9yIG5hdGl2ZSwgZm9yIGhvdmVyXG5cdFx0aWYgKCBldmVudCAmJiBldmVudC50eXBlID09PSBcIm1vdXNlb3ZlclwiICkge1xuXHRcdFx0dGFyZ2V0LnBhcmVudHMoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHBhcmVudCA9ICQoIHRoaXMgKSxcblx0XHRcdFx0XHRibHVyRXZlbnQ7XG5cdFx0XHRcdGlmICggcGFyZW50LmRhdGEoIFwidWktdG9vbHRpcC1vcGVuXCIgKSApIHtcblx0XHRcdFx0XHRibHVyRXZlbnQgPSAkLkV2ZW50KCBcImJsdXJcIiApO1xuXHRcdFx0XHRcdGJsdXJFdmVudC50YXJnZXQgPSBibHVyRXZlbnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG5cdFx0XHRcdFx0dGhhdC5jbG9zZSggYmx1ckV2ZW50LCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBwYXJlbnQuYXR0ciggXCJ0aXRsZVwiICkgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnVuaXF1ZUlkKCk7XG5cdFx0XHRcdFx0dGhhdC5wYXJlbnRzWyB0aGlzLmlkIF0gPSB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiB0aGlzLFxuXHRcdFx0XHRcdFx0dGl0bGU6IHBhcmVudC5hdHRyKCBcInRpdGxlXCIgKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cGFyZW50LmF0dHIoIFwidGl0bGVcIiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVnaXN0ZXJDbG9zZUhhbmRsZXJzKCBldmVudCwgdGFyZ2V0ICk7XG5cdFx0dGhpcy5fdXBkYXRlQ29udGVudCggdGFyZ2V0LCBldmVudCApO1xuXHR9LFxuXG5cdF91cGRhdGVDb250ZW50OiBmdW5jdGlvbiggdGFyZ2V0LCBldmVudCApIHtcblx0XHR2YXIgY29udGVudCxcblx0XHRcdGNvbnRlbnRPcHRpb24gPSB0aGlzLm9wdGlvbnMuY29udGVudCxcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0ZXZlbnRUeXBlID0gZXZlbnQgPyBldmVudC50eXBlIDogbnVsbDtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRlbnRPcHRpb24gPT09IFwic3RyaW5nXCIgfHwgY29udGVudE9wdGlvbi5ub2RlVHlwZSB8fFxuXHRcdFx0XHRjb250ZW50T3B0aW9uLmpxdWVyeSApIHtcblx0XHRcdHJldHVybiB0aGlzLl9vcGVuKCBldmVudCwgdGFyZ2V0LCBjb250ZW50T3B0aW9uICk7XG5cdFx0fVxuXG5cdFx0Y29udGVudCA9IGNvbnRlbnRPcHRpb24uY2FsbCggdGFyZ2V0WyAwIF0sIGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblxuXHRcdFx0Ly8gSUUgbWF5IGluc3RhbnRseSBzZXJ2ZSBhIGNhY2hlZCByZXNwb25zZSBmb3IgYWpheCByZXF1ZXN0c1xuXHRcdFx0Ly8gZGVsYXkgdGhpcyBjYWxsIHRvIF9vcGVuIHNvIHRoZSBvdGhlciBjYWxsIHRvIF9vcGVuIHJ1bnMgZmlyc3Rcblx0XHRcdHRoYXQuX2RlbGF5KCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYXN5bmMgcmVzcG9uc2UgaWYgdG9vbHRpcCB3YXMgY2xvc2VkIGFscmVhZHlcblx0XHRcdFx0aWYgKCAhdGFyZ2V0LmRhdGEoIFwidWktdG9vbHRpcC1vcGVuXCIgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBKUXVlcnkgY3JlYXRlcyBhIHNwZWNpYWwgZXZlbnQgZm9yIGZvY3VzaW4gd2hlbiBpdCBkb2Vzbid0XG5cdFx0XHRcdC8vIGV4aXN0IG5hdGl2ZWx5LiBUbyBpbXByb3ZlIHBlcmZvcm1hbmNlLCB0aGUgbmF0aXZlIGV2ZW50XG5cdFx0XHRcdC8vIG9iamVjdCBpcyByZXVzZWQgYW5kIHRoZSB0eXBlIGlzIGNoYW5nZWQuIFRoZXJlZm9yZSwgd2UgY2FuJ3Rcblx0XHRcdFx0Ly8gcmVseSBvbiB0aGUgdHlwZSBiZWluZyBjb3JyZWN0IGFmdGVyIHRoZSBldmVudCBmaW5pc2hlZFxuXHRcdFx0XHQvLyBidWJibGluZywgc28gd2Ugc2V0IGl0IGJhY2sgdG8gdGhlIHByZXZpb3VzIHZhbHVlLiAoIzg3NDApXG5cdFx0XHRcdGlmICggZXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQudHlwZSA9IGV2ZW50VHlwZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9vcGVuKCBldmVudCwgdGFyZ2V0LCByZXNwb25zZSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0XHRpZiAoIGNvbnRlbnQgKSB7XG5cdFx0XHR0aGlzLl9vcGVuKCBldmVudCwgdGFyZ2V0LCBjb250ZW50ICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vcGVuOiBmdW5jdGlvbiggZXZlbnQsIHRhcmdldCwgY29udGVudCApIHtcblx0XHR2YXIgdG9vbHRpcERhdGEsIHRvb2x0aXAsIGRlbGF5ZWRTaG93LCBhMTF5Q29udGVudCxcblx0XHRcdHBvc2l0aW9uT3B0aW9uID0gJC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnMucG9zaXRpb24gKTtcblxuXHRcdGlmICggIWNvbnRlbnQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ29udGVudCBjYW4gYmUgdXBkYXRlZCBtdWx0aXBsZSB0aW1lcy4gSWYgdGhlIHRvb2x0aXAgYWxyZWFkeVxuXHRcdC8vIGV4aXN0cywgdGhlbiBqdXN0IHVwZGF0ZSB0aGUgY29udGVudCBhbmQgYmFpbC5cblx0XHR0b29sdGlwRGF0YSA9IHRoaXMuX2ZpbmQoIHRhcmdldCApO1xuXHRcdGlmICggdG9vbHRpcERhdGEgKSB7XG5cdFx0XHR0b29sdGlwRGF0YS50b29sdGlwLmZpbmQoIFwiLnVpLXRvb2x0aXAtY29udGVudFwiICkuaHRtbCggY29udGVudCApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGhhdmUgYSB0aXRsZSwgY2xlYXIgaXQgdG8gcHJldmVudCB0aGUgbmF0aXZlIHRvb2x0aXBcblx0XHQvLyB3ZSBoYXZlIHRvIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGRlZmluaW5nIGEgdGl0bGUgaWYgbm9uZSBleGlzdHNcblx0XHQvLyAod2UgZG9uJ3Qgd2FudCB0byBjYXVzZSBhbiBlbGVtZW50IHRvIHN0YXJ0IG1hdGNoaW5nIFt0aXRsZV0pXG5cdFx0Ly9cblx0XHQvLyBXZSB1c2UgcmVtb3ZlQXR0ciBvbmx5IGZvciBrZXkgZXZlbnRzLCB0byBhbGxvdyBJRSB0byBleHBvcnQgdGhlIGNvcnJlY3Rcblx0XHQvLyBhY2Nlc3NpYmxlIGF0dHJpYnV0ZXMuIEZvciBtb3VzZSBldmVudHMsIHNldCB0byBlbXB0eSBzdHJpbmcgdG8gYXZvaWRcblx0XHQvLyBuYXRpdmUgdG9vbHRpcCBzaG93aW5nIHVwIChoYXBwZW5zIG9ubHkgd2hlbiByZW1vdmluZyBpbnNpZGUgbW91c2VvdmVyKS5cblx0XHRpZiAoIHRhcmdldC5pcyggXCJbdGl0bGVdXCIgKSApIHtcblx0XHRcdGlmICggZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJtb3VzZW92ZXJcIiApIHtcblx0XHRcdFx0dGFyZ2V0LmF0dHIoIFwidGl0bGVcIiwgXCJcIiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0LnJlbW92ZUF0dHIoIFwidGl0bGVcIiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRvb2x0aXBEYXRhID0gdGhpcy5fdG9vbHRpcCggdGFyZ2V0ICk7XG5cdFx0dG9vbHRpcCA9IHRvb2x0aXBEYXRhLnRvb2x0aXA7XG5cdFx0dGhpcy5fYWRkRGVzY3JpYmVkQnkoIHRhcmdldCwgdG9vbHRpcC5hdHRyKCBcImlkXCIgKSApO1xuXHRcdHRvb2x0aXAuZmluZCggXCIudWktdG9vbHRpcC1jb250ZW50XCIgKS5odG1sKCBjb250ZW50ICk7XG5cblx0XHQvLyBTdXBwb3J0OiBWb2ljZW92ZXIgb24gT1MgWCwgSkFXUyBvbiBJRSA8PSA5XG5cdFx0Ly8gSkFXUyBhbm5vdW5jZXMgZGVsZXRpb25zIGV2ZW4gd2hlbiBhcmlhLXJlbGV2YW50PVwiYWRkaXRpb25zXCJcblx0XHQvLyBWb2ljZW92ZXIgd2lsbCBzb21ldGltZXMgcmUtcmVhZCB0aGUgZW50aXJlIGxvZyByZWdpb24ncyBjb250ZW50cyBmcm9tIHRoZSBiZWdpbm5pbmdcblx0XHR0aGlzLmxpdmVSZWdpb24uY2hpbGRyZW4oKS5oaWRlKCk7XG5cdFx0YTExeUNvbnRlbnQgPSAkKCBcIjxkaXY+XCIgKS5odG1sKCB0b29sdGlwLmZpbmQoIFwiLnVpLXRvb2x0aXAtY29udGVudFwiICkuaHRtbCgpICk7XG5cdFx0YTExeUNvbnRlbnQucmVtb3ZlQXR0ciggXCJuYW1lXCIgKS5maW5kKCBcIltuYW1lXVwiICkucmVtb3ZlQXR0ciggXCJuYW1lXCIgKTtcblx0XHRhMTF5Q29udGVudC5yZW1vdmVBdHRyKCBcImlkXCIgKS5maW5kKCBcIltpZF1cIiApLnJlbW92ZUF0dHIoIFwiaWRcIiApO1xuXHRcdGExMXlDb250ZW50LmFwcGVuZFRvKCB0aGlzLmxpdmVSZWdpb24gKTtcblxuXHRcdGZ1bmN0aW9uIHBvc2l0aW9uKCBldmVudCApIHtcblx0XHRcdHBvc2l0aW9uT3B0aW9uLm9mID0gZXZlbnQ7XG5cdFx0XHRpZiAoIHRvb2x0aXAuaXMoIFwiOmhpZGRlblwiICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRvb2x0aXAucG9zaXRpb24oIHBvc2l0aW9uT3B0aW9uICk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5vcHRpb25zLnRyYWNrICYmIGV2ZW50ICYmIC9ebW91c2UvLnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHRoaXMuX29uKCB0aGlzLmRvY3VtZW50LCB7XG5cdFx0XHRcdG1vdXNlbW92ZTogcG9zaXRpb25cblx0XHRcdH0gKTtcblxuXHRcdFx0Ly8gdHJpZ2dlciBvbmNlIHRvIG92ZXJyaWRlIGVsZW1lbnQtcmVsYXRpdmUgcG9zaXRpb25pbmdcblx0XHRcdHBvc2l0aW9uKCBldmVudCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0b29sdGlwLnBvc2l0aW9uKCAkLmV4dGVuZCgge1xuXHRcdFx0XHRvZjogdGFyZ2V0XG5cdFx0XHR9LCB0aGlzLm9wdGlvbnMucG9zaXRpb24gKSApO1xuXHRcdH1cblxuXHRcdHRvb2x0aXAuaGlkZSgpO1xuXG5cdFx0dGhpcy5fc2hvdyggdG9vbHRpcCwgdGhpcy5vcHRpb25zLnNob3cgKTtcblxuXHRcdC8vIEhhbmRsZSB0cmFja2luZyB0b29sdGlwcyB0aGF0IGFyZSBzaG93biB3aXRoIGEgZGVsYXkgKCM4NjQ0KS4gQXMgc29vblxuXHRcdC8vIGFzIHRoZSB0b29sdGlwIGlzIHZpc2libGUsIHBvc2l0aW9uIHRoZSB0b29sdGlwIHVzaW5nIHRoZSBtb3N0IHJlY2VudFxuXHRcdC8vIGV2ZW50LlxuXHRcdC8vIEFkZHMgdGhlIGNoZWNrIHRvIGFkZCB0aGUgdGltZXJzIG9ubHkgd2hlbiBib3RoIGRlbGF5IGFuZCB0cmFjayBvcHRpb25zIGFyZSBzZXQgKCMxNDY4Milcblx0XHRpZiAoIHRoaXMub3B0aW9ucy50cmFjayAmJiB0aGlzLm9wdGlvbnMuc2hvdyAmJiB0aGlzLm9wdGlvbnMuc2hvdy5kZWxheSApIHtcblx0XHRcdGRlbGF5ZWRTaG93ID0gdGhpcy5kZWxheWVkU2hvdyA9IHNldEludGVydmFsKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0b29sdGlwLmlzKCBcIjp2aXNpYmxlXCIgKSApIHtcblx0XHRcdFx0XHRwb3NpdGlvbiggcG9zaXRpb25PcHRpb24ub2YgKTtcblx0XHRcdFx0XHRjbGVhckludGVydmFsKCBkZWxheWVkU2hvdyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCAkLmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdHJpZ2dlciggXCJvcGVuXCIsIGV2ZW50LCB7IHRvb2x0aXA6IHRvb2x0aXAgfSApO1xuXHR9LFxuXG5cdF9yZWdpc3RlckNsb3NlSGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgdGFyZ2V0ICkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHRrZXl1cDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5FU0NBUEUgKSB7XG5cdFx0XHRcdFx0dmFyIGZha2VFdmVudCA9ICQuRXZlbnQoIGV2ZW50ICk7XG5cdFx0XHRcdFx0ZmFrZUV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0YXJnZXRbIDAgXTtcblx0XHRcdFx0XHR0aGlzLmNsb3NlKCBmYWtlRXZlbnQsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBPbmx5IGJpbmQgcmVtb3ZlIGhhbmRsZXIgZm9yIGRlbGVnYXRlZCB0YXJnZXRzLiBOb24tZGVsZWdhdGVkXG5cdFx0Ly8gdG9vbHRpcHMgd2lsbCBoYW5kbGUgdGhpcyBpbiBkZXN0cm95LlxuXHRcdGlmICggdGFyZ2V0WyAwIF0gIT09IHRoaXMuZWxlbWVudFsgMCBdICkge1xuXHRcdFx0ZXZlbnRzLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUb29sdGlwKCB0aGlzLl9maW5kKCB0YXJnZXQgKS50b29sdGlwICk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGlmICggIWV2ZW50IHx8IGV2ZW50LnR5cGUgPT09IFwibW91c2VvdmVyXCIgKSB7XG5cdFx0XHRldmVudHMubW91c2VsZWF2ZSA9IFwiY2xvc2VcIjtcblx0XHR9XG5cdFx0aWYgKCAhZXZlbnQgfHwgZXZlbnQudHlwZSA9PT0gXCJmb2N1c2luXCIgKSB7XG5cdFx0XHRldmVudHMuZm9jdXNvdXQgPSBcImNsb3NlXCI7XG5cdFx0fVxuXHRcdHRoaXMuX29uKCB0cnVlLCB0YXJnZXQsIGV2ZW50cyApO1xuXHR9LFxuXG5cdGNsb3NlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHRvb2x0aXAsXG5cdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdHRhcmdldCA9ICQoIGV2ZW50ID8gZXZlbnQuY3VycmVudFRhcmdldCA6IHRoaXMuZWxlbWVudCApLFxuXHRcdFx0dG9vbHRpcERhdGEgPSB0aGlzLl9maW5kKCB0YXJnZXQgKTtcblxuXHRcdC8vIFRoZSB0b29sdGlwIG1heSBhbHJlYWR5IGJlIGNsb3NlZFxuXHRcdGlmICggIXRvb2x0aXBEYXRhICkge1xuXG5cdFx0XHQvLyBXZSBzZXQgdWktdG9vbHRpcC1vcGVuIGltbWVkaWF0ZWx5IHVwb24gb3BlbiAoaW4gb3BlbigpKSwgYnV0IG9ubHkgc2V0IHRoZVxuXHRcdFx0Ly8gYWRkaXRpb25hbCBkYXRhIG9uY2UgdGhlcmUncyBhY3R1YWxseSBjb250ZW50IHRvIHNob3cgKGluIF9vcGVuKCkpLiBTbyBldmVuIGlmIHRoZVxuXHRcdFx0Ly8gdG9vbHRpcCBkb2Vzbid0IGhhdmUgZnVsbCBkYXRhLCB3ZSBhbHdheXMgcmVtb3ZlIHVpLXRvb2x0aXAtb3BlbiBpbiBjYXNlIHdlJ3JlIGluXG5cdFx0XHQvLyB0aGUgcGVyaW9kIGJldHdlZW4gb3BlbigpIGFuZCBfb3BlbigpLlxuXHRcdFx0dGFyZ2V0LnJlbW92ZURhdGEoIFwidWktdG9vbHRpcC1vcGVuXCIgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0b29sdGlwID0gdG9vbHRpcERhdGEudG9vbHRpcDtcblxuXHRcdC8vIERpc2FibGluZyBjbG9zZXMgdGhlIHRvb2x0aXAsIHNvIHdlIG5lZWQgdG8gdHJhY2sgd2hlbiB3ZSdyZSBjbG9zaW5nXG5cdFx0Ly8gdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCBpbiBjYXNlIHRoZSB0b29sdGlwIGJlY29tZXMgZGlzYWJsZWQgb24gY2xvc2Vcblx0XHRpZiAoIHRvb2x0aXBEYXRhLmNsb3NpbmcgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2xlYXIgdGhlIGludGVydmFsIGZvciBkZWxheWVkIHRyYWNraW5nIHRvb2x0aXBzXG5cdFx0Y2xlYXJJbnRlcnZhbCggdGhpcy5kZWxheWVkU2hvdyApO1xuXG5cdFx0Ly8gT25seSBzZXQgdGl0bGUgaWYgd2UgaGFkIG9uZSBiZWZvcmUgKHNlZSBjb21tZW50IGluIF9vcGVuKCkpXG5cdFx0Ly8gSWYgdGhlIHRpdGxlIGF0dHJpYnV0ZSBoYXMgY2hhbmdlZCBzaW5jZSBvcGVuKCksIGRvbid0IHJlc3RvcmVcblx0XHRpZiAoIHRhcmdldC5kYXRhKCBcInVpLXRvb2x0aXAtdGl0bGVcIiApICYmICF0YXJnZXQuYXR0ciggXCJ0aXRsZVwiICkgKSB7XG5cdFx0XHR0YXJnZXQuYXR0ciggXCJ0aXRsZVwiLCB0YXJnZXQuZGF0YSggXCJ1aS10b29sdGlwLXRpdGxlXCIgKSApO1xuXHRcdH1cblxuXHRcdHRoaXMuX3JlbW92ZURlc2NyaWJlZEJ5KCB0YXJnZXQgKTtcblxuXHRcdHRvb2x0aXBEYXRhLmhpZGluZyA9IHRydWU7XG5cdFx0dG9vbHRpcC5zdG9wKCB0cnVlICk7XG5cdFx0dGhpcy5faGlkZSggdG9vbHRpcCwgdGhpcy5vcHRpb25zLmhpZGUsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhhdC5fcmVtb3ZlVG9vbHRpcCggJCggdGhpcyApICk7XG5cdFx0fSApO1xuXG5cdFx0dGFyZ2V0LnJlbW92ZURhdGEoIFwidWktdG9vbHRpcC1vcGVuXCIgKTtcblx0XHR0aGlzLl9vZmYoIHRhcmdldCwgXCJtb3VzZWxlYXZlIGZvY3Vzb3V0IGtleXVwXCIgKTtcblxuXHRcdC8vIFJlbW92ZSAncmVtb3ZlJyBiaW5kaW5nIG9ubHkgb24gZGVsZWdhdGVkIHRhcmdldHNcblx0XHRpZiAoIHRhcmdldFsgMCBdICE9PSB0aGlzLmVsZW1lbnRbIDAgXSApIHtcblx0XHRcdHRoaXMuX29mZiggdGFyZ2V0LCBcInJlbW92ZVwiICk7XG5cdFx0fVxuXHRcdHRoaXMuX29mZiggdGhpcy5kb2N1bWVudCwgXCJtb3VzZW1vdmVcIiApO1xuXG5cdFx0aWYgKCBldmVudCAmJiBldmVudC50eXBlID09PSBcIm1vdXNlbGVhdmVcIiApIHtcblx0XHRcdCQuZWFjaCggdGhpcy5wYXJlbnRzLCBmdW5jdGlvbiggaWQsIHBhcmVudCApIHtcblx0XHRcdFx0JCggcGFyZW50LmVsZW1lbnQgKS5hdHRyKCBcInRpdGxlXCIsIHBhcmVudC50aXRsZSApO1xuXHRcdFx0XHRkZWxldGUgdGhhdC5wYXJlbnRzWyBpZCBdO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHRvb2x0aXBEYXRhLmNsb3NpbmcgPSB0cnVlO1xuXHRcdHRoaXMuX3RyaWdnZXIoIFwiY2xvc2VcIiwgZXZlbnQsIHsgdG9vbHRpcDogdG9vbHRpcCB9ICk7XG5cdFx0aWYgKCAhdG9vbHRpcERhdGEuaGlkaW5nICkge1xuXHRcdFx0dG9vbHRpcERhdGEuY2xvc2luZyA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHRfdG9vbHRpcDogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dmFyIHRvb2x0aXAgPSAkKCBcIjxkaXY+XCIgKS5hdHRyKCBcInJvbGVcIiwgXCJ0b29sdGlwXCIgKSxcblx0XHRcdGNvbnRlbnQgPSAkKCBcIjxkaXY+XCIgKS5hcHBlbmRUbyggdG9vbHRpcCApLFxuXHRcdFx0aWQgPSB0b29sdGlwLnVuaXF1ZUlkKCkuYXR0ciggXCJpZFwiICk7XG5cblx0XHR0aGlzLl9hZGRDbGFzcyggY29udGVudCwgXCJ1aS10b29sdGlwLWNvbnRlbnRcIiApO1xuXHRcdHRoaXMuX2FkZENsYXNzKCB0b29sdGlwLCBcInVpLXRvb2x0aXBcIiwgXCJ1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnRcIiApO1xuXG5cdFx0dG9vbHRpcC5hcHBlbmRUbyggdGhpcy5fYXBwZW5kVG8oIGVsZW1lbnQgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXMudG9vbHRpcHNbIGlkIF0gPSB7XG5cdFx0XHRlbGVtZW50OiBlbGVtZW50LFxuXHRcdFx0dG9vbHRpcDogdG9vbHRpcFxuXHRcdH07XG5cdH0sXG5cblx0X2ZpbmQ6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIGlkID0gdGFyZ2V0LmRhdGEoIFwidWktdG9vbHRpcC1pZFwiICk7XG5cdFx0cmV0dXJuIGlkID8gdGhpcy50b29sdGlwc1sgaWQgXSA6IG51bGw7XG5cdH0sXG5cblx0X3JlbW92ZVRvb2x0aXA6IGZ1bmN0aW9uKCB0b29sdGlwICkge1xuXHRcdHRvb2x0aXAucmVtb3ZlKCk7XG5cdFx0ZGVsZXRlIHRoaXMudG9vbHRpcHNbIHRvb2x0aXAuYXR0ciggXCJpZFwiICkgXTtcblx0fSxcblxuXHRfYXBwZW5kVG86IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0YXJnZXQuY2xvc2VzdCggXCIudWktZnJvbnQsIGRpYWxvZ1wiICk7XG5cblx0XHRpZiAoICFlbGVtZW50Lmxlbmd0aCApIHtcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmRvY3VtZW50WyAwIF0uYm9keTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbWVudDtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2xvc2Ugb3BlbiB0b29sdGlwc1xuXHRcdCQuZWFjaCggdGhpcy50b29sdGlwcywgZnVuY3Rpb24oIGlkLCB0b29sdGlwRGF0YSApIHtcblxuXHRcdFx0Ly8gRGVsZWdhdGUgdG8gY2xvc2UgbWV0aG9kIHRvIGhhbmRsZSBjb21tb24gY2xlYW51cFxuXHRcdFx0dmFyIGV2ZW50ID0gJC5FdmVudCggXCJibHVyXCIgKSxcblx0XHRcdFx0ZWxlbWVudCA9IHRvb2x0aXBEYXRhLmVsZW1lbnQ7XG5cdFx0XHRldmVudC50YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0ID0gZWxlbWVudFsgMCBdO1xuXHRcdFx0dGhhdC5jbG9zZSggZXZlbnQsIHRydWUgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIGltbWVkaWF0ZWx5OyBkZXN0cm95aW5nIGFuIG9wZW4gdG9vbHRpcCBkb2Vzbid0IHVzZSB0aGVcblx0XHRcdC8vIGhpZGUgYW5pbWF0aW9uXG5cdFx0XHQkKCBcIiNcIiArIGlkICkucmVtb3ZlKCk7XG5cblx0XHRcdC8vIFJlc3RvcmUgdGhlIHRpdGxlXG5cdFx0XHRpZiAoIGVsZW1lbnQuZGF0YSggXCJ1aS10b29sdGlwLXRpdGxlXCIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGUgdGl0bGUgYXR0cmlidXRlIGhhcyBjaGFuZ2VkIHNpbmNlIG9wZW4oKSwgZG9uJ3QgcmVzdG9yZVxuXHRcdFx0XHRpZiAoICFlbGVtZW50LmF0dHIoIFwidGl0bGVcIiApICkge1xuXHRcdFx0XHRcdGVsZW1lbnQuYXR0ciggXCJ0aXRsZVwiLCBlbGVtZW50LmRhdGEoIFwidWktdG9vbHRpcC10aXRsZVwiICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbGVtZW50LnJlbW92ZURhdGEoIFwidWktdG9vbHRpcC10aXRsZVwiICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHRoaXMubGl2ZVJlZ2lvbi5yZW1vdmUoKTtcblx0fVxufSApO1xuXG4vLyBERVBSRUNBVEVEXG4vLyBUT0RPOiBTd2l0Y2ggcmV0dXJuIGJhY2sgdG8gd2lkZ2V0IGRlY2xhcmF0aW9uIGF0IHRvcCBvZiBmaWxlIHdoZW4gdGhpcyBpcyByZW1vdmVkXG5pZiAoICQudWlCYWNrQ29tcGF0ICE9PSBmYWxzZSApIHtcblxuXHQvLyBCYWNrY29tcGF0IGZvciB0b29sdGlwQ2xhc3Mgb3B0aW9uXG5cdCQud2lkZ2V0KCBcInVpLnRvb2x0aXBcIiwgJC51aS50b29sdGlwLCB7XG5cdFx0b3B0aW9uczoge1xuXHRcdFx0dG9vbHRpcENsYXNzOiBudWxsXG5cdFx0fSxcblx0XHRfdG9vbHRpcDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdG9vbHRpcERhdGEgPSB0aGlzLl9zdXBlckFwcGx5KCBhcmd1bWVudHMgKTtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnRvb2x0aXBDbGFzcyApIHtcblx0XHRcdFx0dG9vbHRpcERhdGEudG9vbHRpcC5hZGRDbGFzcyggdGhpcy5vcHRpb25zLnRvb2x0aXBDbGFzcyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRvb2x0aXBEYXRhO1xuXHRcdH1cblx0fSApO1xufVxuXG52YXIgd2lkZ2V0c1Rvb2x0aXAgPSAkLnVpLnRvb2x0aXA7XG5cblxuXG5cbn0pKTsiLCIvKiBSdXNzaWFuIChVVEYtOCkgaW5pdGlhbGlzYXRpb24gZm9yIHRoZSBqUXVlcnkgVUkgZGF0ZSBwaWNrZXIgcGx1Z2luLiAqL1xuLyogV3JpdHRlbiBieSBBbmRyZXcgU3Ryb21ub3YgKHN0cm9tbm92QGdtYWlsLmNvbSkuICovXG4oIGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZSggWyBcIi4uL3dpZGdldHMvZGF0ZXBpY2tlclwiIF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3RvcnkoIGpRdWVyeS5kYXRlcGlja2VyICk7XG5cdH1cbn0oIGZ1bmN0aW9uKCBkYXRlcGlja2VyICkge1xuXG5kYXRlcGlja2VyLnJlZ2lvbmFsLnJ1ID0ge1xuXHRjbG9zZVRleHQ6IFwi0JfQsNC60YDRi9GC0YxcIixcblx0cHJldlRleHQ6IFwiJiN4M0M70J/RgNC10LRcIixcblx0bmV4dFRleHQ6IFwi0KHQu9C10LQmI3gzRTtcIixcblx0Y3VycmVudFRleHQ6IFwi0KHQtdCz0L7QtNC90Y9cIixcblx0bW9udGhOYW1lczogWyBcItCv0L3QstCw0YDRjFwiLFwi0KTQtdCy0YDQsNC70YxcIixcItCc0LDRgNGCXCIsXCLQkNC/0YDQtdC70YxcIixcItCc0LDQuVwiLFwi0JjRjtC90YxcIixcblx0XCLQmNGO0LvRjFwiLFwi0JDQstCz0YPRgdGCXCIsXCLQodC10L3RgtGP0LHRgNGMXCIsXCLQntC60YLRj9Cx0YDRjFwiLFwi0J3QvtGP0LHRgNGMXCIsXCLQlNC10LrQsNCx0YDRjFwiIF0sXG5cdG1vbnRoTmFtZXNTaG9ydDogWyBcItCv0L3QslwiLFwi0KTQtdCyXCIsXCLQnNCw0YBcIixcItCQ0L/RgFwiLFwi0JzQsNC5XCIsXCLQmNGO0L1cIixcblx0XCLQmNGO0LtcIixcItCQ0LLQs1wiLFwi0KHQtdC9XCIsXCLQntC60YJcIixcItCd0L7Rj1wiLFwi0JTQtdC6XCIgXSxcblx0ZGF5TmFtZXM6IFsgXCLQstC+0YHQutGA0LXRgdC10L3RjNC1XCIsXCLQv9C+0L3QtdC00LXQu9GM0L3QuNC6XCIsXCLQstGC0L7RgNC90LjQulwiLFwi0YHRgNC10LTQsFwiLFwi0YfQtdGC0LLQtdGA0LNcIixcItC/0Y/RgtC90LjRhtCwXCIsXCLRgdGD0LHQsdC+0YLQsFwiIF0sXG5cdGRheU5hbWVzU2hvcnQ6IFsgXCLQstGB0LpcIixcItC/0L3QtFwiLFwi0LLRgtGAXCIsXCLRgdGA0LRcIixcItGH0YLQslwiLFwi0L/RgtC9XCIsXCLRgdCx0YJcIiBdLFxuXHRkYXlOYW1lc01pbjogWyBcItCS0YFcIixcItCf0L1cIixcItCS0YJcIixcItCh0YBcIixcItCn0YJcIixcItCf0YJcIixcItCh0LFcIiBdLFxuXHR3ZWVrSGVhZGVyOiBcItCd0LXQtFwiLFxuXHRkYXRlRm9ybWF0OiBcImRkLm1tLnl5XCIsXG5cdGZpcnN0RGF5OiAxLFxuXHRpc1JUTDogZmFsc2UsXG5cdHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cdHllYXJTdWZmaXg6IFwiXCIgfTtcbmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoIGRhdGVwaWNrZXIucmVnaW9uYWwucnUgKTtcblxucmV0dXJuIGRhdGVwaWNrZXIucmVnaW9uYWwucnU7XG5cbn0gKSApO1xuIiwiLyohXG4gKiBqUXVlcnkgQ29va2llIFBsdWdpbiB2MS40LjFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXJoYXJ0bC9qcXVlcnktY29va2llXG4gKlxuICogQ29weXJpZ2h0IDIwMTMgS2xhdXMgSGFydGxcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3RvcnkoalF1ZXJ5KTtcblx0fVxufShmdW5jdGlvbiAoJCkge1xuXG5cdHZhciBwbHVzZXMgPSAvXFwrL2c7XG5cblx0ZnVuY3Rpb24gZW5jb2RlKHMpIHtcblx0XHRyZXR1cm4gY29uZmlnLnJhdyA/IHMgOiBlbmNvZGVVUklDb21wb25lbnQocyk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWNvZGUocykge1xuXHRcdHJldHVybiBjb25maWcucmF3ID8gcyA6IGRlY29kZVVSSUNvbXBvbmVudChzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHN0cmluZ2lmeUNvb2tpZVZhbHVlKHZhbHVlKSB7XG5cdFx0cmV0dXJuIGVuY29kZShjb25maWcuanNvbiA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IFN0cmluZyh2YWx1ZSkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VDb29raWVWYWx1ZShzKSB7XG5cdFx0aWYgKHMuaW5kZXhPZignXCInKSA9PT0gMCkge1xuXHRcdFx0Ly8gVGhpcyBpcyBhIHF1b3RlZCBjb29raWUgYXMgYWNjb3JkaW5nIHRvIFJGQzIwNjgsIHVuZXNjYXBlLi4uXG5cdFx0XHRzID0gcy5zbGljZSgxLCAtMSkucmVwbGFjZSgvXFxcXFwiL2csICdcIicpLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIFJlcGxhY2Ugc2VydmVyLXNpZGUgd3JpdHRlbiBwbHVzZXMgd2l0aCBzcGFjZXMuXG5cdFx0XHQvLyBJZiB3ZSBjYW4ndCBkZWNvZGUgdGhlIGNvb2tpZSwgaWdub3JlIGl0LCBpdCdzIHVudXNhYmxlLlxuXHRcdFx0Ly8gSWYgd2UgY2FuJ3QgcGFyc2UgdGhlIGNvb2tpZSwgaWdub3JlIGl0LCBpdCdzIHVudXNhYmxlLlxuXHRcdFx0cyA9IGRlY29kZVVSSUNvbXBvbmVudChzLnJlcGxhY2UocGx1c2VzLCAnICcpKTtcblx0XHRcdHJldHVybiBjb25maWcuanNvbiA/IEpTT04ucGFyc2UocykgOiBzO1xuXHRcdH0gY2F0Y2goZSkge31cblx0fVxuXG5cdGZ1bmN0aW9uIHJlYWQocywgY29udmVydGVyKSB7XG5cdFx0dmFyIHZhbHVlID0gY29uZmlnLnJhdyA/IHMgOiBwYXJzZUNvb2tpZVZhbHVlKHMpO1xuXHRcdHJldHVybiAkLmlzRnVuY3Rpb24oY29udmVydGVyKSA/IGNvbnZlcnRlcih2YWx1ZSkgOiB2YWx1ZTtcblx0fVxuXG5cdHZhciBjb25maWcgPSAkLmNvb2tpZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBvcHRpb25zKSB7XG5cblx0XHQvLyBXcml0ZVxuXG5cdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgISQuaXNGdW5jdGlvbih2YWx1ZSkpIHtcblx0XHRcdG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgY29uZmlnLmRlZmF1bHRzLCBvcHRpb25zKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBvcHRpb25zLmV4cGlyZXMgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdHZhciBkYXlzID0gb3B0aW9ucy5leHBpcmVzLCB0ID0gb3B0aW9ucy5leHBpcmVzID0gbmV3IERhdGUoKTtcblx0XHRcdFx0dC5zZXRUaW1lKCt0ICsgZGF5cyAqIDg2NGUrNSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoZG9jdW1lbnQuY29va2llID0gW1xuXHRcdFx0XHRlbmNvZGUoa2V5KSwgJz0nLCBzdHJpbmdpZnlDb29raWVWYWx1ZSh2YWx1ZSksXG5cdFx0XHRcdG9wdGlvbnMuZXhwaXJlcyA/ICc7IGV4cGlyZXM9JyArIG9wdGlvbnMuZXhwaXJlcy50b1VUQ1N0cmluZygpIDogJycsIC8vIHVzZSBleHBpcmVzIGF0dHJpYnV0ZSwgbWF4LWFnZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFXG5cdFx0XHRcdG9wdGlvbnMucGF0aCAgICA/ICc7IHBhdGg9JyArIG9wdGlvbnMucGF0aCA6ICcnLFxuXHRcdFx0XHRvcHRpb25zLmRvbWFpbiAgPyAnOyBkb21haW49JyArIG9wdGlvbnMuZG9tYWluIDogJycsXG5cdFx0XHRcdG9wdGlvbnMuc2VjdXJlICA/ICc7IHNlY3VyZScgOiAnJ1xuXHRcdFx0XS5qb2luKCcnKSk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVhZFxuXG5cdFx0dmFyIHJlc3VsdCA9IGtleSA/IHVuZGVmaW5lZCA6IHt9O1xuXG5cdFx0Ly8gVG8gcHJldmVudCB0aGUgZm9yIGxvb3AgaW4gdGhlIGZpcnN0IHBsYWNlIGFzc2lnbiBhbiBlbXB0eSBhcnJheVxuXHRcdC8vIGluIGNhc2UgdGhlcmUgYXJlIG5vIGNvb2tpZXMgYXQgYWxsLiBBbHNvIHByZXZlbnRzIG9kZCByZXN1bHQgd2hlblxuXHRcdC8vIGNhbGxpbmcgJC5jb29raWUoKS5cblx0XHR2YXIgY29va2llcyA9IGRvY3VtZW50LmNvb2tpZSA/IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOyAnKSA6IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb29raWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHBhcnRzID0gY29va2llc1tpXS5zcGxpdCgnPScpO1xuXHRcdFx0dmFyIG5hbWUgPSBkZWNvZGUocGFydHMuc2hpZnQoKSk7XG5cdFx0XHR2YXIgY29va2llID0gcGFydHMuam9pbignPScpO1xuXG5cdFx0XHRpZiAoa2V5ICYmIGtleSA9PT0gbmFtZSkge1xuXHRcdFx0XHQvLyBJZiBzZWNvbmQgYXJndW1lbnQgKHZhbHVlKSBpcyBhIGZ1bmN0aW9uIGl0J3MgYSBjb252ZXJ0ZXIuLi5cblx0XHRcdFx0cmVzdWx0ID0gcmVhZChjb29raWUsIHZhbHVlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFByZXZlbnQgc3RvcmluZyBhIGNvb2tpZSB0aGF0IHdlIGNvdWxkbid0IGRlY29kZS5cblx0XHRcdGlmICgha2V5ICYmIChjb29raWUgPSByZWFkKGNvb2tpZSkpICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmVzdWx0W25hbWVdID0gY29va2llO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Y29uZmlnLmRlZmF1bHRzID0ge307XG5cblx0JC5yZW1vdmVDb29raWUgPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25zKSB7XG5cdFx0aWYgKCQuY29va2llKGtleSkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIE11c3Qgbm90IGFsdGVyIG9wdGlvbnMsIHRodXMgZXh0ZW5kaW5nIGEgZnJlc2ggb2JqZWN0Li4uXG5cdFx0JC5jb29raWUoa2V5LCAnJywgJC5leHRlbmQoe30sIG9wdGlvbnMsIHsgZXhwaXJlczogLTEgfSkpO1xuXHRcdHJldHVybiAhJC5jb29raWUoa2V5KTtcblx0fTtcblxufSkpO1xuIiwiLyohIGpRdWVyeSBUaW1lcGlja2VyIEFkZG9uIC0gdjEuNi4zIC0gMjAxNi0wNC0yMFxuKiBodHRwOi8vdHJlbnRyaWNoYXJkc29uLmNvbS9leGFtcGxlcy90aW1lcGlja2VyXG4qIENvcHlyaWdodCAoYykgMjAxNiBUcmVudCBSaWNoYXJkc29uOyBMaWNlbnNlZCBNSVQgKi9cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0ZGVmaW5lKFsnanF1ZXJ5JywgJ2pxdWVyeS11aSddLCBmYWN0b3J5KTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KGpRdWVyeSk7XG5cdH1cbn0oZnVuY3Rpb24gKCQpIHtcblxuXHQvKlxuXHQqIExldHMgbm90IHJlZGVmaW5lIHRpbWVwaWNrZXIsIFByZXZlbnQgXCJVbmNhdWdodCBSYW5nZUVycm9yOiBNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiXG5cdCovXG5cdCQudWkudGltZXBpY2tlciA9ICQudWkudGltZXBpY2tlciB8fCB7fTtcblx0aWYgKCQudWkudGltZXBpY2tlci52ZXJzaW9uKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Lypcblx0KiBFeHRlbmQgalF1ZXJ5VUksIGdldCBpdCBzdGFydGVkIHdpdGggb3VyIHZlcnNpb24gbnVtYmVyXG5cdCovXG5cdCQuZXh0ZW5kKCQudWksIHtcblx0XHR0aW1lcGlja2VyOiB7XG5cdFx0XHR2ZXJzaW9uOiBcIjEuNi4zXCJcblx0XHR9XG5cdH0pO1xuXG5cdC8qXG5cdCogVGltZXBpY2tlciBtYW5hZ2VyLlxuXHQqIFVzZSB0aGUgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MsICQudGltZXBpY2tlciwgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgdGltZSBwaWNrZXIuXG5cdCogU2V0dGluZ3MgZm9yIChncm91cHMgb2YpIHRpbWUgcGlja2VycyBhcmUgbWFpbnRhaW5lZCBpbiBhbiBpbnN0YW5jZSBvYmplY3QsXG5cdCogYWxsb3dpbmcgbXVsdGlwbGUgZGlmZmVyZW50IHNldHRpbmdzIG9uIHRoZSBzYW1lIHBhZ2UuXG5cdCovXG5cdHZhciBUaW1lcGlja2VyID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMucmVnaW9uYWwgPSBbXTsgLy8gQXZhaWxhYmxlIHJlZ2lvbmFsIHNldHRpbmdzLCBpbmRleGVkIGJ5IGxhbmd1YWdlIGNvZGVcblx0XHR0aGlzLnJlZ2lvbmFsWycnXSA9IHsgLy8gRGVmYXVsdCByZWdpb25hbCBzZXR0aW5nc1xuXHRcdFx0Y3VycmVudFRleHQ6ICdOb3cnLFxuXHRcdFx0Y2xvc2VUZXh0OiAnRG9uZScsXG5cdFx0XHRhbU5hbWVzOiBbJ0FNJywgJ0EnXSxcblx0XHRcdHBtTmFtZXM6IFsnUE0nLCAnUCddLFxuXHRcdFx0dGltZUZvcm1hdDogJ0hIOm1tJyxcblx0XHRcdHRpbWVTdWZmaXg6ICcnLFxuXHRcdFx0dGltZU9ubHlUaXRsZTogJ0Nob29zZSBUaW1lJyxcblx0XHRcdHRpbWVUZXh0OiAnVGltZScsXG5cdFx0XHRob3VyVGV4dDogJ0hvdXInLFxuXHRcdFx0bWludXRlVGV4dDogJ01pbnV0ZScsXG5cdFx0XHRzZWNvbmRUZXh0OiAnU2Vjb25kJyxcblx0XHRcdG1pbGxpc2VjVGV4dDogJ01pbGxpc2Vjb25kJyxcblx0XHRcdG1pY3Jvc2VjVGV4dDogJ01pY3Jvc2Vjb25kJyxcblx0XHRcdHRpbWV6b25lVGV4dDogJ1RpbWUgWm9uZScsXG5cdFx0XHRpc1JUTDogZmFsc2Vcblx0XHR9O1xuXHRcdHRoaXMuX2RlZmF1bHRzID0geyAvLyBHbG9iYWwgZGVmYXVsdHMgZm9yIGFsbCB0aGUgZGF0ZXRpbWUgcGlja2VyIGluc3RhbmNlc1xuXHRcdFx0c2hvd0J1dHRvblBhbmVsOiB0cnVlLFxuXHRcdFx0dGltZU9ubHk6IGZhbHNlLFxuXHRcdFx0dGltZU9ubHlTaG93RGF0ZTogZmFsc2UsXG5cdFx0XHRzaG93SG91cjogbnVsbCxcblx0XHRcdHNob3dNaW51dGU6IG51bGwsXG5cdFx0XHRzaG93U2Vjb25kOiBudWxsLFxuXHRcdFx0c2hvd01pbGxpc2VjOiBudWxsLFxuXHRcdFx0c2hvd01pY3Jvc2VjOiBudWxsLFxuXHRcdFx0c2hvd1RpbWV6b25lOiBudWxsLFxuXHRcdFx0c2hvd1RpbWU6IHRydWUsXG5cdFx0XHRzdGVwSG91cjogMSxcblx0XHRcdHN0ZXBNaW51dGU6IDEsXG5cdFx0XHRzdGVwU2Vjb25kOiAxLFxuXHRcdFx0c3RlcE1pbGxpc2VjOiAxLFxuXHRcdFx0c3RlcE1pY3Jvc2VjOiAxLFxuXHRcdFx0aG91cjogMCxcblx0XHRcdG1pbnV0ZTogMCxcblx0XHRcdHNlY29uZDogMCxcblx0XHRcdG1pbGxpc2VjOiAwLFxuXHRcdFx0bWljcm9zZWM6IDAsXG5cdFx0XHR0aW1lem9uZTogbnVsbCxcblx0XHRcdGhvdXJNaW46IDAsXG5cdFx0XHRtaW51dGVNaW46IDAsXG5cdFx0XHRzZWNvbmRNaW46IDAsXG5cdFx0XHRtaWxsaXNlY01pbjogMCxcblx0XHRcdG1pY3Jvc2VjTWluOiAwLFxuXHRcdFx0aG91ck1heDogMjMsXG5cdFx0XHRtaW51dGVNYXg6IDU5LFxuXHRcdFx0c2Vjb25kTWF4OiA1OSxcblx0XHRcdG1pbGxpc2VjTWF4OiA5OTksXG5cdFx0XHRtaWNyb3NlY01heDogOTk5LFxuXHRcdFx0bWluRGF0ZVRpbWU6IG51bGwsXG5cdFx0XHRtYXhEYXRlVGltZTogbnVsbCxcblx0XHRcdG1heFRpbWU6IG51bGwsXG5cdFx0XHRtaW5UaW1lOiBudWxsLFxuXHRcdFx0b25TZWxlY3Q6IG51bGwsXG5cdFx0XHRob3VyR3JpZDogMCxcblx0XHRcdG1pbnV0ZUdyaWQ6IDAsXG5cdFx0XHRzZWNvbmRHcmlkOiAwLFxuXHRcdFx0bWlsbGlzZWNHcmlkOiAwLFxuXHRcdFx0bWljcm9zZWNHcmlkOiAwLFxuXHRcdFx0YWx3YXlzU2V0VGltZTogdHJ1ZSxcblx0XHRcdHNlcGFyYXRvcjogJyAnLFxuXHRcdFx0YWx0RmllbGRUaW1lT25seTogdHJ1ZSxcblx0XHRcdGFsdFRpbWVGb3JtYXQ6IG51bGwsXG5cdFx0XHRhbHRTZXBhcmF0b3I6IG51bGwsXG5cdFx0XHRhbHRUaW1lU3VmZml4OiBudWxsLFxuXHRcdFx0YWx0UmVkaXJlY3RGb2N1czogdHJ1ZSxcblx0XHRcdHBpY2tlclRpbWVGb3JtYXQ6IG51bGwsXG5cdFx0XHRwaWNrZXJUaW1lU3VmZml4OiBudWxsLFxuXHRcdFx0c2hvd1RpbWVwaWNrZXI6IHRydWUsXG5cdFx0XHR0aW1lem9uZUxpc3Q6IG51bGwsXG5cdFx0XHRhZGRTbGlkZXJBY2Nlc3M6IGZhbHNlLFxuXHRcdFx0c2xpZGVyQWNjZXNzQXJnczogbnVsbCxcblx0XHRcdGNvbnRyb2xUeXBlOiAnc2xpZGVyJyxcblx0XHRcdG9uZUxpbmU6IGZhbHNlLFxuXHRcdFx0ZGVmYXVsdFZhbHVlOiBudWxsLFxuXHRcdFx0cGFyc2U6ICdzdHJpY3QnLFxuXHRcdFx0YWZ0ZXJJbmplY3Q6IG51bGxcblx0XHR9O1xuXHRcdCQuZXh0ZW5kKHRoaXMuX2RlZmF1bHRzLCB0aGlzLnJlZ2lvbmFsWycnXSk7XG5cdH07XG5cblx0JC5leHRlbmQoVGltZXBpY2tlci5wcm90b3R5cGUsIHtcblx0XHQkaW5wdXQ6IG51bGwsXG5cdFx0JGFsdElucHV0OiBudWxsLFxuXHRcdCR0aW1lT2JqOiBudWxsLFxuXHRcdGluc3Q6IG51bGwsXG5cdFx0aG91cl9zbGlkZXI6IG51bGwsXG5cdFx0bWludXRlX3NsaWRlcjogbnVsbCxcblx0XHRzZWNvbmRfc2xpZGVyOiBudWxsLFxuXHRcdG1pbGxpc2VjX3NsaWRlcjogbnVsbCxcblx0XHRtaWNyb3NlY19zbGlkZXI6IG51bGwsXG5cdFx0dGltZXpvbmVfc2VsZWN0OiBudWxsLFxuXHRcdG1heFRpbWU6IG51bGwsXG5cdFx0bWluVGltZTogbnVsbCxcblx0XHRob3VyOiAwLFxuXHRcdG1pbnV0ZTogMCxcblx0XHRzZWNvbmQ6IDAsXG5cdFx0bWlsbGlzZWM6IDAsXG5cdFx0bWljcm9zZWM6IDAsXG5cdFx0dGltZXpvbmU6IG51bGwsXG5cdFx0aG91ck1pbk9yaWdpbmFsOiBudWxsLFxuXHRcdG1pbnV0ZU1pbk9yaWdpbmFsOiBudWxsLFxuXHRcdHNlY29uZE1pbk9yaWdpbmFsOiBudWxsLFxuXHRcdG1pbGxpc2VjTWluT3JpZ2luYWw6IG51bGwsXG5cdFx0bWljcm9zZWNNaW5PcmlnaW5hbDogbnVsbCxcblx0XHRob3VyTWF4T3JpZ2luYWw6IG51bGwsXG5cdFx0bWludXRlTWF4T3JpZ2luYWw6IG51bGwsXG5cdFx0c2Vjb25kTWF4T3JpZ2luYWw6IG51bGwsXG5cdFx0bWlsbGlzZWNNYXhPcmlnaW5hbDogbnVsbCxcblx0XHRtaWNyb3NlY01heE9yaWdpbmFsOiBudWxsLFxuXHRcdGFtcG06ICcnLFxuXHRcdGZvcm1hdHRlZERhdGU6ICcnLFxuXHRcdGZvcm1hdHRlZFRpbWU6ICcnLFxuXHRcdGZvcm1hdHRlZERhdGVUaW1lOiAnJyxcblx0XHR0aW1lem9uZUxpc3Q6IG51bGwsXG5cdFx0dW5pdHM6IFsnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2VjJywgJ21pY3Jvc2VjJ10sXG5cdFx0c3VwcG9ydDoge30sXG5cdFx0Y29udHJvbDogbnVsbCxcblxuXHRcdC8qXG5cdFx0KiBPdmVycmlkZSB0aGUgZGVmYXVsdCBzZXR0aW5ncyBmb3IgYWxsIGluc3RhbmNlcyBvZiB0aGUgdGltZSBwaWNrZXIuXG5cdFx0KiBAcGFyYW0gIHtPYmplY3R9IHNldHRpbmdzICBvYmplY3QgLSB0aGUgbmV3IHNldHRpbmdzIHRvIHVzZSBhcyBkZWZhdWx0cyAoYW5vbnltb3VzIG9iamVjdClcblx0XHQqIEByZXR1cm4ge09iamVjdH0gdGhlIG1hbmFnZXIgb2JqZWN0XG5cdFx0Ki9cblx0XHRzZXREZWZhdWx0czogZnVuY3Rpb24gKHNldHRpbmdzKSB7XG5cdFx0XHRleHRlbmRSZW1vdmUodGhpcy5fZGVmYXVsdHMsIHNldHRpbmdzIHx8IHt9KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvKlxuXHRcdCogQ3JlYXRlIGEgbmV3IFRpbWVwaWNrZXIgaW5zdGFuY2Vcblx0XHQqL1xuXHRcdF9uZXdJbnN0OiBmdW5jdGlvbiAoJGlucHV0LCBvcHRzKSB7XG5cdFx0XHR2YXIgdHBfaW5zdCA9IG5ldyBUaW1lcGlja2VyKCksXG5cdFx0XHRcdGlubGluZVNldHRpbmdzID0ge30sXG5cdFx0XHRcdGZucyA9IHt9LFxuXHRcdFx0XHRvdmVycmlkZXMsIGk7XG5cblx0XHRcdGZvciAodmFyIGF0dHJOYW1lIGluIHRoaXMuX2RlZmF1bHRzKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9kZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShhdHRyTmFtZSkpIHtcblx0XHRcdFx0XHR2YXIgYXR0clZhbHVlID0gJGlucHV0LmF0dHIoJ3RpbWU6JyArIGF0dHJOYW1lKTtcblx0XHRcdFx0XHRpZiAoYXR0clZhbHVlKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRpbmxpbmVTZXR0aW5nc1thdHRyTmFtZV0gPSBldmFsKGF0dHJWYWx1ZSk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRcdFx0aW5saW5lU2V0dGluZ3NbYXR0ck5hbWVdID0gYXR0clZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRvdmVycmlkZXMgPSB7XG5cdFx0XHRcdGJlZm9yZVNob3c6IGZ1bmN0aW9uIChpbnB1dCwgZHBfaW5zdCkge1xuXHRcdFx0XHRcdGlmICgkLmlzRnVuY3Rpb24odHBfaW5zdC5fZGVmYXVsdHMuZXZudHMuYmVmb3JlU2hvdykpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cF9pbnN0Ll9kZWZhdWx0cy5ldm50cy5iZWZvcmVTaG93LmNhbGwoJGlucHV0WzBdLCBpbnB1dCwgZHBfaW5zdCwgdHBfaW5zdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRvbkNoYW5nZU1vbnRoWWVhcjogZnVuY3Rpb24gKHllYXIsIG1vbnRoLCBkcF9pbnN0KSB7XG5cdFx0XHRcdFx0Ly8gVXBkYXRlIHRoZSB0aW1lIGFzIHdlbGwgOiB0aGlzIHByZXZlbnRzIHRoZSB0aW1lIGZyb20gZGlzYXBwZWFyaW5nIGZyb20gdGhlICRpbnB1dCBmaWVsZC5cblx0XHRcdFx0XHQvLyB0cF9pbnN0Ll91cGRhdGVEYXRlVGltZShkcF9pbnN0KTtcblx0XHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKHRwX2luc3QuX2RlZmF1bHRzLmV2bnRzLm9uQ2hhbmdlTW9udGhZZWFyKSkge1xuXHRcdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMuZXZudHMub25DaGFuZ2VNb250aFllYXIuY2FsbCgkaW5wdXRbMF0sIHllYXIsIG1vbnRoLCBkcF9pbnN0LCB0cF9pbnN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG9uQ2xvc2U6IGZ1bmN0aW9uIChkYXRlVGV4dCwgZHBfaW5zdCkge1xuXHRcdFx0XHRcdGlmICh0cF9pbnN0LnRpbWVEZWZpbmVkID09PSB0cnVlICYmICRpbnB1dC52YWwoKSAhPT0gJycpIHtcblx0XHRcdFx0XHRcdHRwX2luc3QuX3VwZGF0ZURhdGVUaW1lKGRwX2luc3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKHRwX2luc3QuX2RlZmF1bHRzLmV2bnRzLm9uQ2xvc2UpKSB7XG5cdFx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5ldm50cy5vbkNsb3NlLmNhbGwoJGlucHV0WzBdLCBkYXRlVGV4dCwgZHBfaW5zdCwgdHBfaW5zdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0Zm9yIChpIGluIG92ZXJyaWRlcykge1xuXHRcdFx0XHRpZiAob3ZlcnJpZGVzLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0Zm5zW2ldID0gb3B0c1tpXSB8fCB0aGlzLl9kZWZhdWx0c1tpXSB8fCBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRwX2luc3QuX2RlZmF1bHRzID0gJC5leHRlbmQoe30sIHRoaXMuX2RlZmF1bHRzLCBpbmxpbmVTZXR0aW5ncywgb3B0cywgb3ZlcnJpZGVzLCB7XG5cdFx0XHRcdGV2bnRzOiBmbnMsXG5cdFx0XHRcdHRpbWVwaWNrZXI6IHRwX2luc3QgLy8gYWRkIHRpbWVwaWNrZXIgYXMgYSBwcm9wZXJ0eSBvZiBkYXRlcGlja2VyOiAkLmRhdGVwaWNrZXIuX2dldChkcF9pbnN0LCAndGltZXBpY2tlcicpO1xuXHRcdFx0fSk7XG5cdFx0XHR0cF9pbnN0LmFtTmFtZXMgPSAkLm1hcCh0cF9pbnN0Ll9kZWZhdWx0cy5hbU5hbWVzLCBmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRcdHJldHVybiB2YWwudG9VcHBlckNhc2UoKTtcblx0XHRcdH0pO1xuXHRcdFx0dHBfaW5zdC5wbU5hbWVzID0gJC5tYXAodHBfaW5zdC5fZGVmYXVsdHMucG1OYW1lcywgZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0XHRyZXR1cm4gdmFsLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gZGV0ZWN0IHdoaWNoIHVuaXRzIGFyZSBzdXBwb3J0ZWRcblx0XHRcdHRwX2luc3Quc3VwcG9ydCA9IGRldGVjdFN1cHBvcnQoXG5cdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMudGltZUZvcm1hdCArXG5cdFx0XHRcdFx0KHRwX2luc3QuX2RlZmF1bHRzLnBpY2tlclRpbWVGb3JtYXQgPyB0cF9pbnN0Ll9kZWZhdWx0cy5waWNrZXJUaW1lRm9ybWF0IDogJycpICtcblx0XHRcdFx0XHQodHBfaW5zdC5fZGVmYXVsdHMuYWx0VGltZUZvcm1hdCA/IHRwX2luc3QuX2RlZmF1bHRzLmFsdFRpbWVGb3JtYXQgOiAnJykpO1xuXG5cdFx0XHQvLyBjb250cm9sVHlwZSBpcyBzdHJpbmcgLSBrZXkgdG8gb3VyIHRoaXMuX2NvbnRyb2xzXG5cdFx0XHRpZiAodHlwZW9mKHRwX2luc3QuX2RlZmF1bHRzLmNvbnRyb2xUeXBlKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLmNvbnRyb2xUeXBlID09PSAnc2xpZGVyJyAmJiB0eXBlb2YoJC51aS5zbGlkZXIpID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLmNvbnRyb2xUeXBlID0gJ3NlbGVjdCc7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHBfaW5zdC5jb250cm9sID0gdHBfaW5zdC5fY29udHJvbHNbdHBfaW5zdC5fZGVmYXVsdHMuY29udHJvbFR5cGVdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY29udHJvbFR5cGUgaXMgYW4gb2JqZWN0IGFuZCBtdXN0IGltcGxlbWVudCBjcmVhdGUsIG9wdGlvbnMsIHZhbHVlIG1ldGhvZHNcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0cF9pbnN0LmNvbnRyb2wgPSB0cF9pbnN0Ll9kZWZhdWx0cy5jb250cm9sVHlwZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJlcCB0aGUgdGltZXpvbmUgb3B0aW9uc1xuXHRcdFx0dmFyIHRpbWV6b25lTGlzdCA9IFstNzIwLCAtNjYwLCAtNjAwLCAtNTcwLCAtNTQwLCAtNDgwLCAtNDIwLCAtMzYwLCAtMzAwLCAtMjcwLCAtMjQwLCAtMjEwLCAtMTgwLCAtMTIwLCAtNjAsXG5cdFx0XHRcdFx0MCwgNjAsIDEyMCwgMTgwLCAyMTAsIDI0MCwgMjcwLCAzMDAsIDMzMCwgMzQ1LCAzNjAsIDM5MCwgNDIwLCA0ODAsIDUyNSwgNTQwLCA1NzAsIDYwMCwgNjMwLCA2NjAsIDY5MCwgNzIwLCA3NjUsIDc4MCwgODQwXTtcblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZUxpc3QgIT09IG51bGwpIHtcblx0XHRcdFx0dGltZXpvbmVMaXN0ID0gdHBfaW5zdC5fZGVmYXVsdHMudGltZXpvbmVMaXN0O1xuXHRcdFx0fVxuXHRcdFx0dmFyIHR6bCA9IHRpbWV6b25lTGlzdC5sZW5ndGgsIHR6aSA9IDAsIHR6diA9IG51bGw7XG5cdFx0XHRpZiAodHpsID4gMCAmJiB0eXBlb2YgdGltZXpvbmVMaXN0WzBdICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKDsgdHppIDwgdHpsOyB0emkrKykge1xuXHRcdFx0XHRcdHR6diA9IHRpbWV6b25lTGlzdFt0emldO1xuXHRcdFx0XHRcdHRpbWV6b25lTGlzdFt0emldID0geyB2YWx1ZTogdHp2LCBsYWJlbDogJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0U3RyaW5nKHR6diwgdHBfaW5zdC5zdXBwb3J0Lmlzbzg2MDEpIH07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLnRpbWV6b25lTGlzdCA9IHRpbWV6b25lTGlzdDtcblxuXHRcdFx0Ly8gc2V0IHRoZSBkZWZhdWx0IHVuaXRzXG5cdFx0XHR0cF9pbnN0LnRpbWV6b25lID0gdHBfaW5zdC5fZGVmYXVsdHMudGltZXpvbmUgIT09IG51bGwgPyAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXROdW1iZXIodHBfaW5zdC5fZGVmYXVsdHMudGltZXpvbmUpIDpcblx0XHRcdFx0XHRcdFx0KChuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpICogLTEpO1xuXHRcdFx0dHBfaW5zdC5ob3VyID0gdHBfaW5zdC5fZGVmYXVsdHMuaG91ciA8IHRwX2luc3QuX2RlZmF1bHRzLmhvdXJNaW4gPyB0cF9pbnN0Ll9kZWZhdWx0cy5ob3VyTWluIDpcblx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMuaG91ciA+IHRwX2luc3QuX2RlZmF1bHRzLmhvdXJNYXggPyB0cF9pbnN0Ll9kZWZhdWx0cy5ob3VyTWF4IDogdHBfaW5zdC5fZGVmYXVsdHMuaG91cjtcblx0XHRcdHRwX2luc3QubWludXRlID0gdHBfaW5zdC5fZGVmYXVsdHMubWludXRlIDwgdHBfaW5zdC5fZGVmYXVsdHMubWludXRlTWluID8gdHBfaW5zdC5fZGVmYXVsdHMubWludXRlTWluIDpcblx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWludXRlID4gdHBfaW5zdC5fZGVmYXVsdHMubWludXRlTWF4ID8gdHBfaW5zdC5fZGVmYXVsdHMubWludXRlTWF4IDogdHBfaW5zdC5fZGVmYXVsdHMubWludXRlO1xuXHRcdFx0dHBfaW5zdC5zZWNvbmQgPSB0cF9pbnN0Ll9kZWZhdWx0cy5zZWNvbmQgPCB0cF9pbnN0Ll9kZWZhdWx0cy5zZWNvbmRNaW4gPyB0cF9pbnN0Ll9kZWZhdWx0cy5zZWNvbmRNaW4gOlxuXHRcdFx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5zZWNvbmQgPiB0cF9pbnN0Ll9kZWZhdWx0cy5zZWNvbmRNYXggPyB0cF9pbnN0Ll9kZWZhdWx0cy5zZWNvbmRNYXggOiB0cF9pbnN0Ll9kZWZhdWx0cy5zZWNvbmQ7XG5cdFx0XHR0cF9pbnN0Lm1pbGxpc2VjID0gdHBfaW5zdC5fZGVmYXVsdHMubWlsbGlzZWMgPCB0cF9pbnN0Ll9kZWZhdWx0cy5taWxsaXNlY01pbiA/IHRwX2luc3QuX2RlZmF1bHRzLm1pbGxpc2VjTWluIDpcblx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWlsbGlzZWMgPiB0cF9pbnN0Ll9kZWZhdWx0cy5taWxsaXNlY01heCA/IHRwX2luc3QuX2RlZmF1bHRzLm1pbGxpc2VjTWF4IDogdHBfaW5zdC5fZGVmYXVsdHMubWlsbGlzZWM7XG5cdFx0XHR0cF9pbnN0Lm1pY3Jvc2VjID0gdHBfaW5zdC5fZGVmYXVsdHMubWljcm9zZWMgPCB0cF9pbnN0Ll9kZWZhdWx0cy5taWNyb3NlY01pbiA/IHRwX2luc3QuX2RlZmF1bHRzLm1pY3Jvc2VjTWluIDpcblx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWljcm9zZWMgPiB0cF9pbnN0Ll9kZWZhdWx0cy5taWNyb3NlY01heCA/IHRwX2luc3QuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4IDogdHBfaW5zdC5fZGVmYXVsdHMubWljcm9zZWM7XG5cdFx0XHR0cF9pbnN0LmFtcG0gPSAnJztcblx0XHRcdHRwX2luc3QuJGlucHV0ID0gJGlucHV0O1xuXG5cdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMuYWx0RmllbGQpIHtcblx0XHRcdFx0dHBfaW5zdC4kYWx0SW5wdXQgPSAkKHRwX2luc3QuX2RlZmF1bHRzLmFsdEZpZWxkKTtcblx0XHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLmFsdFJlZGlyZWN0Rm9jdXMgPT09IHRydWUpIHtcblx0XHRcdFx0XHR0cF9pbnN0LiRhbHRJbnB1dC5jc3Moe1xuXHRcdFx0XHRcdFx0Y3Vyc29yOiAncG9pbnRlcidcblx0XHRcdFx0XHR9KS5mb2N1cyhmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHQkaW5wdXQudHJpZ2dlcihcImZvY3VzXCIpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlID09PSAwIHx8IHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGVUaW1lID09PSAwKSB7XG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGUgPT09IDAgfHwgdHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZVRpbWUgPT09IDApIHtcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRhdGVwaWNrZXIgbmVlZHMgbWluRGF0ZS9tYXhEYXRlLCB0aW1lcGlja2VyIG5lZWRzIG1pbkRhdGVUaW1lL21heERhdGVUaW1lLi5cblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlICE9PSB1bmRlZmluZWQgJiYgdHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZVRpbWUgPSBuZXcgRGF0ZSh0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlLmdldFRpbWUoKSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZVRpbWUgIT09IHVuZGVmaW5lZCAmJiB0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlVGltZSBpbnN0YW5jZW9mIERhdGUpIHtcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZSA9IG5ldyBEYXRlKHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGVUaW1lLmdldFRpbWUoKSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZSAhPT0gdW5kZWZpbmVkICYmIHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGVUaW1lID0gbmV3IERhdGUodHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZS5nZXRUaW1lKCkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGVUaW1lICE9PSB1bmRlZmluZWQgJiYgdHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZVRpbWUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGUgPSBuZXcgRGF0ZSh0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlVGltZS5nZXRUaW1lKCkpO1xuXHRcdFx0fVxuXHRcdFx0dHBfaW5zdC4kaW5wdXQuYmluZCgnZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRwX2luc3QuX29uRm9jdXMoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gdHBfaW5zdDtcblx0XHR9LFxuXG5cdFx0Lypcblx0XHQqIGFkZCBvdXIgc2xpZGVycyB0byB0aGUgY2FsZW5kYXJcblx0XHQqL1xuXHRcdF9hZGRUaW1lUGlja2VyOiBmdW5jdGlvbiAoZHBfaW5zdCkge1xuXHRcdFx0dmFyIGN1cnJEVCA9ICQudHJpbSgodGhpcy4kYWx0SW5wdXQgJiYgdGhpcy5fZGVmYXVsdHMuYWx0RmllbGRUaW1lT25seSkgPyB0aGlzLiRpbnB1dC52YWwoKSArICcgJyArIHRoaXMuJGFsdElucHV0LnZhbCgpIDogdGhpcy4kaW5wdXQudmFsKCkpO1xuXG5cdFx0XHR0aGlzLnRpbWVEZWZpbmVkID0gdGhpcy5fcGFyc2VUaW1lKGN1cnJEVCk7XG5cdFx0XHR0aGlzLl9saW1pdE1pbk1heERhdGVUaW1lKGRwX2luc3QsIGZhbHNlKTtcblx0XHRcdHRoaXMuX2luamVjdFRpbWVQaWNrZXIoKTtcblx0XHRcdHRoaXMuX2FmdGVySW5qZWN0KCk7XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx0KiBwYXJzZSB0aGUgdGltZSBzdHJpbmcgZnJvbSBpbnB1dCB2YWx1ZSBvciBfc2V0VGltZVxuXHRcdCovXG5cdFx0X3BhcnNlVGltZTogZnVuY3Rpb24gKHRpbWVTdHJpbmcsIHdpdGhEYXRlKSB7XG5cdFx0XHRpZiAoIXRoaXMuaW5zdCkge1xuXHRcdFx0XHR0aGlzLmluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QodGhpcy4kaW5wdXRbMF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAod2l0aERhdGUgfHwgIXRoaXMuX2RlZmF1bHRzLnRpbWVPbmx5KSB7XG5cdFx0XHRcdHZhciBkcF9kYXRlRm9ybWF0ID0gJC5kYXRlcGlja2VyLl9nZXQodGhpcy5pbnN0LCAnZGF0ZUZvcm1hdCcpO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBwYXJzZVJlcyA9IHBhcnNlRGF0ZVRpbWVJbnRlcm5hbChkcF9kYXRlRm9ybWF0LCB0aGlzLl9kZWZhdWx0cy50aW1lRm9ybWF0LCB0aW1lU3RyaW5nLCAkLmRhdGVwaWNrZXIuX2dldEZvcm1hdENvbmZpZyh0aGlzLmluc3QpLCB0aGlzLl9kZWZhdWx0cyk7XG5cdFx0XHRcdFx0aWYgKCFwYXJzZVJlcy50aW1lT2JqKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCQuZXh0ZW5kKHRoaXMsIHBhcnNlUmVzLnRpbWVPYmopO1xuXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHQkLnRpbWVwaWNrZXIubG9nKFwiRXJyb3IgcGFyc2luZyB0aGUgZGF0ZS90aW1lIHN0cmluZzogXCIgKyBlcnIgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJcXG5kYXRlL3RpbWUgc3RyaW5nID0gXCIgKyB0aW1lU3RyaW5nICtcblx0XHRcdFx0XHRcdFx0XHRcdFwiXFxudGltZUZvcm1hdCA9IFwiICsgdGhpcy5fZGVmYXVsdHMudGltZUZvcm1hdCArXG5cdFx0XHRcdFx0XHRcdFx0XHRcIlxcbmRhdGVGb3JtYXQgPSBcIiArIGRwX2RhdGVGb3JtYXQpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB0aW1lT2JqID0gJC5kYXRlcGlja2VyLnBhcnNlVGltZSh0aGlzLl9kZWZhdWx0cy50aW1lRm9ybWF0LCB0aW1lU3RyaW5nLCB0aGlzLl9kZWZhdWx0cyk7XG5cdFx0XHRcdGlmICghdGltZU9iaikge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkLmV4dGVuZCh0aGlzLCB0aW1lT2JqKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx0KiBIYW5kbGUgY2FsbGJhY2sgb3B0aW9uIGFmdGVyIGluamVjdGluZyB0aW1lcGlja2VyXG5cdFx0Ki9cblx0XHRfYWZ0ZXJJbmplY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG8gPSB0aGlzLmluc3Quc2V0dGluZ3M7XG5cdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKG8uYWZ0ZXJJbmplY3QpKSB7XG5cdFx0XHRcdG8uYWZ0ZXJJbmplY3QuY2FsbCh0aGlzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Lypcblx0XHQqIGdlbmVyYXRlIGFuZCBpbmplY3QgaHRtbCBmb3IgdGltZXBpY2tlciBpbnRvIHVpIGRhdGVwaWNrZXJcblx0XHQqL1xuXHRcdF9pbmplY3RUaW1lUGlja2VyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgJGRwID0gdGhpcy5pbnN0LmRwRGl2LFxuXHRcdFx0XHRvID0gdGhpcy5pbnN0LnNldHRpbmdzLFxuXHRcdFx0XHR0cF9pbnN0ID0gdGhpcyxcblx0XHRcdFx0bGl0ZW0gPSAnJyxcblx0XHRcdFx0dWl0ZW0gPSAnJyxcblx0XHRcdFx0c2hvdyA9IG51bGwsXG5cdFx0XHRcdG1heCA9IHt9LFxuXHRcdFx0XHRncmlkU2l6ZSA9IHt9LFxuXHRcdFx0XHRzaXplID0gbnVsbCxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSAwO1xuXG5cdFx0XHQvLyBQcmV2ZW50IGRpc3BsYXlpbmcgdHdpY2Vcblx0XHRcdGlmICgkZHAuZmluZChcImRpdi51aS10aW1lcGlja2VyLWRpdlwiKS5sZW5ndGggPT09IDAgJiYgby5zaG93VGltZXBpY2tlcikge1xuXHRcdFx0XHR2YXIgbm9EaXNwbGF5ID0gJyB1aV90cGlja2VyX3VuaXRfaGlkZScsXG5cdFx0XHRcdFx0aHRtbCA9ICc8ZGl2IGNsYXNzPVwidWktdGltZXBpY2tlci1kaXYnICsgKG8uaXNSVEwgPyAnIHVpLXRpbWVwaWNrZXItcnRsJyA6ICcnKSArIChvLm9uZUxpbmUgJiYgby5jb250cm9sVHlwZSA9PT0gJ3NlbGVjdCcgPyAnIHVpLXRpbWVwaWNrZXItb25lTGluZScgOiAnJykgKyAnXCI+PGRsPicgKyAnPGR0IGNsYXNzPVwidWlfdHBpY2tlcl90aW1lX2xhYmVsJyArICgoby5zaG93VGltZSkgPyAnJyA6IG5vRGlzcGxheSkgKyAnXCI+JyArIG8udGltZVRleHQgKyAnPC9kdD4nICtcblx0XHRcdFx0XHRcdFx0XHQnPGRkIGNsYXNzPVwidWlfdHBpY2tlcl90aW1lICcrICgoby5zaG93VGltZSkgPyAnJyA6IG5vRGlzcGxheSkgKyAnXCI+PGlucHV0IGNsYXNzPVwidWlfdHBpY2tlcl90aW1lX2lucHV0XCIgJyArIChvLnRpbWVJbnB1dCA/ICcnIDogJ2Rpc2FibGVkJykgKyAnLz48L2RkPic7XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBtYXJrdXBcblx0XHRcdFx0Zm9yIChpID0gMCwgbCA9IHRoaXMudW5pdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0bGl0ZW0gPSB0aGlzLnVuaXRzW2ldO1xuXHRcdFx0XHRcdHVpdGVtID0gbGl0ZW0uc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBsaXRlbS5zdWJzdHIoMSk7XG5cdFx0XHRcdFx0c2hvdyA9IG9bJ3Nob3cnICsgdWl0ZW1dICE9PSBudWxsID8gb1snc2hvdycgKyB1aXRlbV0gOiB0aGlzLnN1cHBvcnRbbGl0ZW1dO1xuXG5cdFx0XHRcdFx0Ly8gQWRkZWQgYnkgUGV0ZXIgTWVkZWlyb3M6XG5cdFx0XHRcdFx0Ly8gLSBGaWd1cmUgb3V0IHdoYXQgdGhlIGhvdXIvbWludXRlL3NlY29uZCBtYXggc2hvdWxkIGJlIGJhc2VkIG9uIHRoZSBzdGVwIHZhbHVlcy5cblx0XHRcdFx0XHQvLyAtIEV4YW1wbGU6IGlmIHN0ZXBNaW51dGUgaXMgMTUsIHRoZW4gbWluTWF4IGlzIDQ1LlxuXHRcdFx0XHRcdG1heFtsaXRlbV0gPSBwYXJzZUludCgob1tsaXRlbSArICdNYXgnXSAtICgob1tsaXRlbSArICdNYXgnXSAtIG9bbGl0ZW0gKyAnTWluJ10pICUgb1snc3RlcCcgKyB1aXRlbV0pKSwgMTApO1xuXHRcdFx0XHRcdGdyaWRTaXplW2xpdGVtXSA9IDA7XG5cblx0XHRcdFx0XHRodG1sICs9ICc8ZHQgY2xhc3M9XCJ1aV90cGlja2VyXycgKyBsaXRlbSArICdfbGFiZWwnICsgKHNob3cgPyAnJyA6IG5vRGlzcGxheSkgKyAnXCI+JyArIG9bbGl0ZW0gKyAnVGV4dCddICsgJzwvZHQ+JyArXG5cdFx0XHRcdFx0XHRcdFx0JzxkZCBjbGFzcz1cInVpX3RwaWNrZXJfJyArIGxpdGVtICsgKHNob3cgPyAnJyA6IG5vRGlzcGxheSkgKyAnXCI+PGRpdiBjbGFzcz1cInVpX3RwaWNrZXJfJyArIGxpdGVtICsgJ19zbGlkZXInICsgKHNob3cgPyAnJyA6IG5vRGlzcGxheSkgKyAnXCI+PC9kaXY+JztcblxuXHRcdFx0XHRcdGlmIChzaG93ICYmIG9bbGl0ZW0gKyAnR3JpZCddID4gMCkge1xuXHRcdFx0XHRcdFx0aHRtbCArPSAnPGRpdiBzdHlsZT1cInBhZGRpbmctbGVmdDogMXB4XCI+PHRhYmxlIGNsYXNzPVwidWktdHBpY2tlci1ncmlkLWxhYmVsXCI+PHRyPic7XG5cblx0XHRcdFx0XHRcdGlmIChsaXRlbSA9PT0gJ2hvdXInKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGggPSBvW2xpdGVtICsgJ01pbiddOyBoIDw9IG1heFtsaXRlbV07IGggKz0gcGFyc2VJbnQob1tsaXRlbSArICdHcmlkJ10sIDEwKSkge1xuXHRcdFx0XHRcdFx0XHRcdGdyaWRTaXplW2xpdGVtXSsrO1xuXHRcdFx0XHRcdFx0XHRcdHZhciB0bXBoID0gJC5kYXRlcGlja2VyLmZvcm1hdFRpbWUodGhpcy5zdXBwb3J0LmFtcG0gPyAnaGh0JyA6ICdISCcsIHtob3VyOiBofSwgbyk7XG5cdFx0XHRcdFx0XHRcdFx0aHRtbCArPSAnPHRkIGRhdGEtZm9yPVwiJyArIGxpdGVtICsgJ1wiPicgKyB0bXBoICsgJzwvdGQ+Jztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIG0gPSBvW2xpdGVtICsgJ01pbiddOyBtIDw9IG1heFtsaXRlbV07IG0gKz0gcGFyc2VJbnQob1tsaXRlbSArICdHcmlkJ10sIDEwKSkge1xuXHRcdFx0XHRcdFx0XHRcdGdyaWRTaXplW2xpdGVtXSsrO1xuXHRcdFx0XHRcdFx0XHRcdGh0bWwgKz0gJzx0ZCBkYXRhLWZvcj1cIicgKyBsaXRlbSArICdcIj4nICsgKChtIDwgMTApID8gJzAnIDogJycpICsgbSArICc8L3RkPic7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aHRtbCArPSAnPC90cj48L3RhYmxlPjwvZGl2Pic7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGh0bWwgKz0gJzwvZGQ+Jztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRpbWV6b25lXG5cdFx0XHRcdHZhciBzaG93VHogPSBvLnNob3dUaW1lem9uZSAhPT0gbnVsbCA/IG8uc2hvd1RpbWV6b25lIDogdGhpcy5zdXBwb3J0LnRpbWV6b25lO1xuXHRcdFx0XHRodG1sICs9ICc8ZHQgY2xhc3M9XCJ1aV90cGlja2VyX3RpbWV6b25lX2xhYmVsJyArIChzaG93VHogPyAnJyA6IG5vRGlzcGxheSkgKyAnXCI+JyArIG8udGltZXpvbmVUZXh0ICsgJzwvZHQ+Jztcblx0XHRcdFx0aHRtbCArPSAnPGRkIGNsYXNzPVwidWlfdHBpY2tlcl90aW1lem9uZScgKyAoc2hvd1R6ID8gJycgOiBub0Rpc3BsYXkpICsgJ1wiPjwvZGQ+JztcblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGVsZW1lbnRzIGZyb20gc3RyaW5nXG5cdFx0XHRcdGh0bWwgKz0gJzwvZGw+PC9kaXY+Jztcblx0XHRcdFx0dmFyICR0cCA9ICQoaHRtbCk7XG5cblx0XHRcdFx0Ly8gaWYgd2Ugb25seSB3YW50IHRpbWUgcGlja2VyLi4uXG5cdFx0XHRcdGlmIChvLnRpbWVPbmx5ID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0JHRwLnByZXBlbmQoJzxkaXYgY2xhc3M9XCJ1aS13aWRnZXQtaGVhZGVyIHVpLWhlbHBlci1jbGVhcmZpeCB1aS1jb3JuZXItYWxsXCI+JyArICc8ZGl2IGNsYXNzPVwidWktZGF0ZXBpY2tlci10aXRsZVwiPicgKyBvLnRpbWVPbmx5VGl0bGUgKyAnPC9kaXY+JyArICc8L2Rpdj4nKTtcblx0XHRcdFx0XHQkZHAuZmluZCgnLnVpLWRhdGVwaWNrZXItaGVhZGVyLCAudWktZGF0ZXBpY2tlci1jYWxlbmRhcicpLmhpZGUoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFkZCBzbGlkZXJzLCBhZGp1c3QgZ3JpZHMsIGFkZCBldmVudHNcblx0XHRcdFx0Zm9yIChpID0gMCwgbCA9IHRwX2luc3QudW5pdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0bGl0ZW0gPSB0cF9pbnN0LnVuaXRzW2ldO1xuXHRcdFx0XHRcdHVpdGVtID0gbGl0ZW0uc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBsaXRlbS5zdWJzdHIoMSk7XG5cdFx0XHRcdFx0c2hvdyA9IG9bJ3Nob3cnICsgdWl0ZW1dICE9PSBudWxsID8gb1snc2hvdycgKyB1aXRlbV0gOiB0aGlzLnN1cHBvcnRbbGl0ZW1dO1xuXG5cdFx0XHRcdFx0Ly8gYWRkIHRoZSBzbGlkZXJcblx0XHRcdFx0XHR0cF9pbnN0W2xpdGVtICsgJ19zbGlkZXInXSA9IHRwX2luc3QuY29udHJvbC5jcmVhdGUodHBfaW5zdCwgJHRwLmZpbmQoJy51aV90cGlja2VyXycgKyBsaXRlbSArICdfc2xpZGVyJyksIGxpdGVtLCB0cF9pbnN0W2xpdGVtXSwgb1tsaXRlbSArICdNaW4nXSwgbWF4W2xpdGVtXSwgb1snc3RlcCcgKyB1aXRlbV0pO1xuXG5cdFx0XHRcdFx0Ly8gYWRqdXN0IHRoZSBncmlkIGFuZCBhZGQgY2xpY2sgZXZlbnRcblx0XHRcdFx0XHRpZiAoc2hvdyAmJiBvW2xpdGVtICsgJ0dyaWQnXSA+IDApIHtcblx0XHRcdFx0XHRcdHNpemUgPSAxMDAgKiBncmlkU2l6ZVtsaXRlbV0gKiBvW2xpdGVtICsgJ0dyaWQnXSAvIChtYXhbbGl0ZW1dIC0gb1tsaXRlbSArICdNaW4nXSk7XG5cdFx0XHRcdFx0XHQkdHAuZmluZCgnLnVpX3RwaWNrZXJfJyArIGxpdGVtICsgJyB0YWJsZScpLmNzcyh7XG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBzaXplICsgXCIlXCIsXG5cdFx0XHRcdFx0XHRcdG1hcmdpbkxlZnQ6IG8uaXNSVEwgPyAnMCcgOiAoKHNpemUgLyAoLTIgKiBncmlkU2l6ZVtsaXRlbV0pKSArIFwiJVwiKSxcblx0XHRcdFx0XHRcdFx0bWFyZ2luUmlnaHQ6IG8uaXNSVEwgPyAoKHNpemUgLyAoLTIgKiBncmlkU2l6ZVtsaXRlbV0pKSArIFwiJVwiKSA6ICcwJyxcblx0XHRcdFx0XHRcdFx0Ym9yZGVyQ29sbGFwc2U6ICdjb2xsYXBzZSdcblx0XHRcdFx0XHRcdH0pLmZpbmQoXCJ0ZFwiKS5jbGljayhmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciAkdCA9ICQodGhpcyksXG5cdFx0XHRcdFx0XHRcdFx0XHRoID0gJHQuaHRtbCgpLFxuXHRcdFx0XHRcdFx0XHRcdFx0biA9IHBhcnNlSW50KGgucmVwbGFjZSgvW14wLTldL2cpLCAxMCksXG5cdFx0XHRcdFx0XHRcdFx0XHRhcCA9IGgucmVwbGFjZSgvW15hcG1dL2lnKSxcblx0XHRcdFx0XHRcdFx0XHRcdGYgPSAkdC5kYXRhKCdmb3InKTsgLy8gbG9zZXMgc2NvcGUsIHNvIHdlIHVzZSBkYXRhLWZvclxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGYgPT09ICdob3VyJykge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGFwLmluZGV4T2YoJ3AnKSAhPT0gLTEgJiYgbiA8IDEyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG4gKz0gMTI7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGFwLmluZGV4T2YoJ2EnKSAhPT0gLTEgJiYgbiA9PT0gMTIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuID0gMDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHRwX2luc3QuY29udHJvbC52YWx1ZSh0cF9pbnN0LCB0cF9pbnN0W2YgKyAnX3NsaWRlciddLCBsaXRlbSwgbik7XG5cblx0XHRcdFx0XHRcdFx0XHR0cF9pbnN0Ll9vblRpbWVDaGFuZ2UoKTtcblx0XHRcdFx0XHRcdFx0XHR0cF9pbnN0Ll9vblNlbGVjdEhhbmRsZXIoKTtcblx0XHRcdFx0XHRcdFx0fSkuY3NzKHtcblx0XHRcdFx0XHRcdFx0XHRjdXJzb3I6ICdwb2ludGVyJyxcblx0XHRcdFx0XHRcdFx0XHR3aWR0aDogKDEwMCAvIGdyaWRTaXplW2xpdGVtXSkgKyAnJScsXG5cdFx0XHRcdFx0XHRcdFx0dGV4dEFsaWduOiAnY2VudGVyJyxcblx0XHRcdFx0XHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbidcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSAvLyBlbmQgaWYgZ3JpZCA+IDBcblx0XHRcdFx0fSAvLyBlbmQgZm9yIGxvb3BcblxuXHRcdFx0XHQvLyBBZGQgdGltZXpvbmUgb3B0aW9uc1xuXHRcdFx0XHR0aGlzLnRpbWV6b25lX3NlbGVjdCA9ICR0cC5maW5kKCcudWlfdHBpY2tlcl90aW1lem9uZScpLmFwcGVuZCgnPHNlbGVjdD48L3NlbGVjdD4nKS5maW5kKFwic2VsZWN0XCIpO1xuXHRcdFx0XHQkLmZuLmFwcGVuZC5hcHBseSh0aGlzLnRpbWV6b25lX3NlbGVjdCxcblx0XHRcdFx0JC5tYXAoby50aW1lem9uZUxpc3QsIGZ1bmN0aW9uICh2YWwsIGlkeCkge1xuXHRcdFx0XHRcdHJldHVybiAkKFwiPG9wdGlvbiAvPlwiKS52YWwodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiA/IHZhbC52YWx1ZSA6IHZhbCkudGV4dCh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiID8gdmFsLmxhYmVsIDogdmFsKTtcblx0XHRcdFx0fSkpO1xuXHRcdFx0XHRpZiAodHlwZW9mKHRoaXMudGltZXpvbmUpICE9PSBcInVuZGVmaW5lZFwiICYmIHRoaXMudGltZXpvbmUgIT09IG51bGwgJiYgdGhpcy50aW1lem9uZSAhPT0gXCJcIikge1xuXHRcdFx0XHRcdHZhciBsb2NhbF90aW1lem9uZSA9IChuZXcgRGF0ZSh0aGlzLmluc3Quc2VsZWN0ZWRZZWFyLCB0aGlzLmluc3Quc2VsZWN0ZWRNb250aCwgdGhpcy5pbnN0LnNlbGVjdGVkRGF5LCAxMikpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiAtMTtcblx0XHRcdFx0XHRpZiAobG9jYWxfdGltZXpvbmUgPT09IHRoaXMudGltZXpvbmUpIHtcblx0XHRcdFx0XHRcdHNlbGVjdExvY2FsVGltZXpvbmUodHBfaW5zdCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMudGltZXpvbmVfc2VsZWN0LnZhbCh0aGlzLnRpbWV6b25lKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZih0aGlzLmhvdXIpICE9PSBcInVuZGVmaW5lZFwiICYmIHRoaXMuaG91ciAhPT0gbnVsbCAmJiB0aGlzLmhvdXIgIT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdHRoaXMudGltZXpvbmVfc2VsZWN0LnZhbChvLnRpbWV6b25lKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZWN0TG9jYWxUaW1lem9uZSh0cF9pbnN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy50aW1lem9uZV9zZWxlY3QuY2hhbmdlKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0cF9pbnN0Ll9vblRpbWVDaGFuZ2UoKTtcblx0XHRcdFx0XHR0cF9pbnN0Ll9vblNlbGVjdEhhbmRsZXIoKTtcblx0XHRcdFx0XHR0cF9pbnN0Ll9hZnRlckluamVjdCgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gRW5kIHRpbWV6b25lIG9wdGlvbnNcblxuXHRcdFx0XHQvLyBpbmplY3QgdGltZXBpY2tlciBpbnRvIGRhdGVwaWNrZXJcblx0XHRcdFx0dmFyICRidXR0b25QYW5lbCA9ICRkcC5maW5kKCcudWktZGF0ZXBpY2tlci1idXR0b25wYW5lJyk7XG5cdFx0XHRcdGlmICgkYnV0dG9uUGFuZWwubGVuZ3RoKSB7XG5cdFx0XHRcdFx0JGJ1dHRvblBhbmVsLmJlZm9yZSgkdHApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCRkcC5hcHBlbmQoJHRwKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuJHRpbWVPYmogPSAkdHAuZmluZCgnLnVpX3RwaWNrZXJfdGltZV9pbnB1dCcpO1xuXHRcdFx0XHR0aGlzLiR0aW1lT2JqLmNoYW5nZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIHRpbWVGb3JtYXQgPSB0cF9pbnN0Lmluc3Quc2V0dGluZ3MudGltZUZvcm1hdDtcblx0XHRcdFx0XHR2YXIgcGFyc2VkVGltZSA9ICQuZGF0ZXBpY2tlci5wYXJzZVRpbWUodGltZUZvcm1hdCwgdGhpcy52YWx1ZSk7XG5cdFx0XHRcdFx0dmFyIHVwZGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHRcdFx0aWYgKHBhcnNlZFRpbWUpIHtcblx0XHRcdFx0XHRcdHVwZGF0ZS5zZXRIb3VycyhwYXJzZWRUaW1lLmhvdXIpO1xuXHRcdFx0XHRcdFx0dXBkYXRlLnNldE1pbnV0ZXMocGFyc2VkVGltZS5taW51dGUpO1xuXHRcdFx0XHRcdFx0dXBkYXRlLnNldFNlY29uZHMocGFyc2VkVGltZS5zZWNvbmQpO1xuXHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZXRUaW1lKHRwX2luc3QuaW5zdCwgdXBkYXRlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHRwX2luc3QuZm9ybWF0dGVkVGltZTtcblx0XHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKHRoaXMuaW5zdCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHZhciB0aW1lRGVmaW5lZCA9IHRoaXMudGltZURlZmluZWQ7XG5cdFx0XHRcdFx0dGhpcy5fb25UaW1lQ2hhbmdlKCk7XG5cdFx0XHRcdFx0dGhpcy50aW1lRGVmaW5lZCA9IHRpbWVEZWZpbmVkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc2xpZGVBY2Nlc3MgaW50ZWdyYXRpb246IGh0dHA6Ly90cmVudHJpY2hhcmRzb24uY29tLzIwMTEvMTEvMTEvanF1ZXJ5LXVpLXNsaWRlcnMtYW5kLXRvdWNoLWFjY2Vzc2liaWxpdHkvXG5cdFx0XHRcdGlmICh0aGlzLl9kZWZhdWx0cy5hZGRTbGlkZXJBY2Nlc3MpIHtcblx0XHRcdFx0XHR2YXIgc2xpZGVyQWNjZXNzQXJncyA9IHRoaXMuX2RlZmF1bHRzLnNsaWRlckFjY2Vzc0FyZ3MsXG5cdFx0XHRcdFx0XHRydGwgPSB0aGlzLl9kZWZhdWx0cy5pc1JUTDtcblx0XHRcdFx0XHRzbGlkZXJBY2Nlc3NBcmdzLmlzUlRMID0gcnRsO1xuXG5cdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7IC8vIGZpeCBmb3IgaW5saW5lIG1vZGVcblx0XHRcdFx0XHRcdGlmICgkdHAuZmluZCgnLnVpLXNsaWRlci1hY2Nlc3MnKS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0JHRwLmZpbmQoJy51aS1zbGlkZXI6dmlzaWJsZScpLnNsaWRlckFjY2VzcyhzbGlkZXJBY2Nlc3NBcmdzKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBmaXggYW55IGdyaWRzIHNpbmNlIHNsaWRlcnMgYXJlIHNob3J0ZXJcblx0XHRcdFx0XHRcdFx0dmFyIHNsaWRlckFjY2Vzc1dpZHRoID0gJHRwLmZpbmQoJy51aS1zbGlkZXItYWNjZXNzOmVxKDApJykub3V0ZXJXaWR0aCh0cnVlKTtcblx0XHRcdFx0XHRcdFx0aWYgKHNsaWRlckFjY2Vzc1dpZHRoKSB7XG5cdFx0XHRcdFx0XHRcdFx0JHRwLmZpbmQoJ3RhYmxlOnZpc2libGUnKS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciAkZyA9ICQodGhpcyksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9sZFdpZHRoID0gJGcub3V0ZXJXaWR0aCgpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbGRNYXJnaW5MZWZ0ID0gJGcuY3NzKHJ0bCA/ICdtYXJnaW5SaWdodCcgOiAnbWFyZ2luTGVmdCcpLnRvU3RyaW5nKCkucmVwbGFjZSgnJScsICcnKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3V2lkdGggPSBvbGRXaWR0aCAtIHNsaWRlckFjY2Vzc1dpZHRoLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXdNYXJnaW5MZWZ0ID0gKChvbGRNYXJnaW5MZWZ0ICogbmV3V2lkdGgpIC8gb2xkV2lkdGgpICsgJyUnLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjc3MgPSB7IHdpZHRoOiBuZXdXaWR0aCwgbWFyZ2luUmlnaHQ6IDAsIG1hcmdpbkxlZnQ6IDAgfTtcblx0XHRcdFx0XHRcdFx0XHRcdGNzc1tydGwgPyAnbWFyZ2luUmlnaHQnIDogJ21hcmdpbkxlZnQnXSA9IG5ld01hcmdpbkxlZnQ7XG5cdFx0XHRcdFx0XHRcdFx0XHQkZy5jc3MoY3NzKTtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIDEwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBlbmQgc2xpZGVBY2Nlc3MgaW50ZWdyYXRpb25cblxuXHRcdFx0XHR0cF9pbnN0Ll9saW1pdE1pbk1heERhdGVUaW1lKHRoaXMuaW5zdCwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx0KiBUaGlzIGZ1bmN0aW9uIHRyaWVzIHRvIGxpbWl0IHRoZSBhYmlsaXR5IHRvIGdvIG91dHNpZGUgdGhlXG5cdFx0KiBtaW4vbWF4IGRhdGUgcmFuZ2Vcblx0XHQqL1xuXHRcdF9saW1pdE1pbk1heERhdGVUaW1lOiBmdW5jdGlvbiAoZHBfaW5zdCwgYWRqdXN0U2xpZGVycykge1xuXHRcdFx0dmFyIG8gPSB0aGlzLl9kZWZhdWx0cyxcblx0XHRcdFx0ZHBfZGF0ZSA9IG5ldyBEYXRlKGRwX2luc3Quc2VsZWN0ZWRZZWFyLCBkcF9pbnN0LnNlbGVjdGVkTW9udGgsIGRwX2luc3Quc2VsZWN0ZWREYXkpO1xuXG5cdFx0XHRpZiAoIXRoaXMuX2RlZmF1bHRzLnNob3dUaW1lcGlja2VyKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gLy8gTm8gdGltZSBzbyBub3RoaW5nIHRvIGNoZWNrIGhlcmVcblxuXHRcdFx0aWYgKCQuZGF0ZXBpY2tlci5fZ2V0KGRwX2luc3QsICdtaW5EYXRlVGltZScpICE9PSBudWxsICYmICQuZGF0ZXBpY2tlci5fZ2V0KGRwX2luc3QsICdtaW5EYXRlVGltZScpICE9PSB1bmRlZmluZWQgJiYgZHBfZGF0ZSkge1xuXHRcdFx0XHR2YXIgbWluRGF0ZVRpbWUgPSAkLmRhdGVwaWNrZXIuX2dldChkcF9pbnN0LCAnbWluRGF0ZVRpbWUnKSxcblx0XHRcdFx0XHRtaW5EYXRlVGltZURhdGUgPSBuZXcgRGF0ZShtaW5EYXRlVGltZS5nZXRGdWxsWWVhcigpLCBtaW5EYXRlVGltZS5nZXRNb250aCgpLCBtaW5EYXRlVGltZS5nZXREYXRlKCksIDAsIDAsIDAsIDApO1xuXG5cdFx0XHRcdGlmICh0aGlzLmhvdXJNaW5PcmlnaW5hbCA9PT0gbnVsbCB8fCB0aGlzLm1pbnV0ZU1pbk9yaWdpbmFsID09PSBudWxsIHx8IHRoaXMuc2Vjb25kTWluT3JpZ2luYWwgPT09IG51bGwgfHwgdGhpcy5taWxsaXNlY01pbk9yaWdpbmFsID09PSBudWxsIHx8IHRoaXMubWljcm9zZWNNaW5PcmlnaW5hbCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMuaG91ck1pbk9yaWdpbmFsID0gby5ob3VyTWluO1xuXHRcdFx0XHRcdHRoaXMubWludXRlTWluT3JpZ2luYWwgPSBvLm1pbnV0ZU1pbjtcblx0XHRcdFx0XHR0aGlzLnNlY29uZE1pbk9yaWdpbmFsID0gby5zZWNvbmRNaW47XG5cdFx0XHRcdFx0dGhpcy5taWxsaXNlY01pbk9yaWdpbmFsID0gby5taWxsaXNlY01pbjtcblx0XHRcdFx0XHR0aGlzLm1pY3Jvc2VjTWluT3JpZ2luYWwgPSBvLm1pY3Jvc2VjTWluO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGRwX2luc3Quc2V0dGluZ3MudGltZU9ubHkgfHwgbWluRGF0ZVRpbWVEYXRlLmdldFRpbWUoKSA9PT0gZHBfZGF0ZS5nZXRUaW1lKCkpIHtcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5ob3VyTWluID0gbWluRGF0ZVRpbWUuZ2V0SG91cnMoKTtcblx0XHRcdFx0XHRpZiAodGhpcy5ob3VyIDw9IHRoaXMuX2RlZmF1bHRzLmhvdXJNaW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuaG91ciA9IHRoaXMuX2RlZmF1bHRzLmhvdXJNaW47XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNaW4gPSBtaW5EYXRlVGltZS5nZXRNaW51dGVzKCk7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5taW51dGUgPD0gdGhpcy5fZGVmYXVsdHMubWludXRlTWluKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMubWludXRlID0gdGhpcy5fZGVmYXVsdHMubWludXRlTWluO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5zZWNvbmRNaW4gPSBtaW5EYXRlVGltZS5nZXRTZWNvbmRzKCk7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLnNlY29uZCA8PSB0aGlzLl9kZWZhdWx0cy5zZWNvbmRNaW4pIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNlY29uZCA9IHRoaXMuX2RlZmF1bHRzLnNlY29uZE1pbjtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01pbiA9IG1pbkRhdGVUaW1lLmdldE1pbGxpc2Vjb25kcygpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLm1pbGxpc2VjIDw9IHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLm1pbGxpc2VjID0gdGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNaW47XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01pbiA9IG1pbkRhdGVUaW1lLmdldE1pY3Jvc2Vjb25kcygpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5taWNyb3NlYyA8IHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWluKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMubWljcm9zZWMgPSB0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01pbjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWluID0gdGhpcy5taWNyb3NlY01pbk9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01pbiA9IHRoaXMubWlsbGlzZWNNaW5PcmlnaW5hbDtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01pbiA9IHRoaXMubWljcm9zZWNNaW5PcmlnaW5hbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuc2Vjb25kTWluID0gdGhpcy5zZWNvbmRNaW5PcmlnaW5hbDtcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNaW4gPSB0aGlzLm1pbGxpc2VjTWluT3JpZ2luYWw7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWluID0gdGhpcy5taWNyb3NlY01pbk9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNaW4gPSB0aGlzLm1pbnV0ZU1pbk9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuc2Vjb25kTWluID0gdGhpcy5zZWNvbmRNaW5PcmlnaW5hbDtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluID0gdGhpcy5taWxsaXNlY01pbk9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4gPSB0aGlzLm1pY3Jvc2VjTWluT3JpZ2luYWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLmhvdXJNaW4gPSB0aGlzLmhvdXJNaW5PcmlnaW5hbDtcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNaW4gPSB0aGlzLm1pbnV0ZU1pbk9yaWdpbmFsO1xuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1pbiA9IHRoaXMuc2Vjb25kTWluT3JpZ2luYWw7XG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNaW4gPSB0aGlzLm1pbGxpc2VjTWluT3JpZ2luYWw7XG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4gPSB0aGlzLm1pY3Jvc2VjTWluT3JpZ2luYWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCQuZGF0ZXBpY2tlci5fZ2V0KGRwX2luc3QsICdtYXhEYXRlVGltZScpICE9PSBudWxsICYmICQuZGF0ZXBpY2tlci5fZ2V0KGRwX2luc3QsICdtYXhEYXRlVGltZScpICE9PSB1bmRlZmluZWQgJiYgZHBfZGF0ZSkge1xuXHRcdFx0XHR2YXIgbWF4RGF0ZVRpbWUgPSAkLmRhdGVwaWNrZXIuX2dldChkcF9pbnN0LCAnbWF4RGF0ZVRpbWUnKSxcblx0XHRcdFx0XHRtYXhEYXRlVGltZURhdGUgPSBuZXcgRGF0ZShtYXhEYXRlVGltZS5nZXRGdWxsWWVhcigpLCBtYXhEYXRlVGltZS5nZXRNb250aCgpLCBtYXhEYXRlVGltZS5nZXREYXRlKCksIDAsIDAsIDAsIDApO1xuXG5cdFx0XHRcdGlmICh0aGlzLmhvdXJNYXhPcmlnaW5hbCA9PT0gbnVsbCB8fCB0aGlzLm1pbnV0ZU1heE9yaWdpbmFsID09PSBudWxsIHx8IHRoaXMuc2Vjb25kTWF4T3JpZ2luYWwgPT09IG51bGwgfHwgdGhpcy5taWxsaXNlY01heE9yaWdpbmFsID09PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5ob3VyTWF4T3JpZ2luYWwgPSBvLmhvdXJNYXg7XG5cdFx0XHRcdFx0dGhpcy5taW51dGVNYXhPcmlnaW5hbCA9IG8ubWludXRlTWF4O1xuXHRcdFx0XHRcdHRoaXMuc2Vjb25kTWF4T3JpZ2luYWwgPSBvLnNlY29uZE1heDtcblx0XHRcdFx0XHR0aGlzLm1pbGxpc2VjTWF4T3JpZ2luYWwgPSBvLm1pbGxpc2VjTWF4O1xuXHRcdFx0XHRcdHRoaXMubWljcm9zZWNNYXhPcmlnaW5hbCA9IG8ubWljcm9zZWNNYXg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZHBfaW5zdC5zZXR0aW5ncy50aW1lT25seSB8fCBtYXhEYXRlVGltZURhdGUuZ2V0VGltZSgpID09PSBkcF9kYXRlLmdldFRpbWUoKSkge1xuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLmhvdXJNYXggPSBtYXhEYXRlVGltZS5nZXRIb3VycygpO1xuXHRcdFx0XHRcdGlmICh0aGlzLmhvdXIgPj0gdGhpcy5fZGVmYXVsdHMuaG91ck1heCkge1xuXHRcdFx0XHRcdFx0dGhpcy5ob3VyID0gdGhpcy5fZGVmYXVsdHMuaG91ck1heDtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heCA9IG1heERhdGVUaW1lLmdldE1pbnV0ZXMoKTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLm1pbnV0ZSA+PSB0aGlzLl9kZWZhdWx0cy5taW51dGVNYXgpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5taW51dGUgPSB0aGlzLl9kZWZhdWx0cy5taW51dGVNYXg7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1heCA9IG1heERhdGVUaW1lLmdldFNlY29uZHMoKTtcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuc2Vjb25kID49IHRoaXMuX2RlZmF1bHRzLnNlY29uZE1heCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2Vjb25kID0gdGhpcy5fZGVmYXVsdHMuc2Vjb25kTWF4O1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4ID0gbWF4RGF0ZVRpbWUuZ2V0TWlsbGlzZWNvbmRzKCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHRoaXMubWlsbGlzZWMgPj0gdGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNYXgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMubWlsbGlzZWMgPSB0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01heDtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4ID0gbWF4RGF0ZVRpbWUuZ2V0TWljcm9zZWNvbmRzKCk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLm1pY3Jvc2VjID4gdGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5taWNyb3NlYyA9IHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4O1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXggPSB0aGlzLm1pY3Jvc2VjTWF4T3JpZ2luYWw7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4ID0gdGhpcy5taWxsaXNlY01heE9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4ID0gdGhpcy5taWNyb3NlY01heE9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5zZWNvbmRNYXggPSB0aGlzLnNlY29uZE1heE9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01heCA9IHRoaXMubWlsbGlzZWNNYXhPcmlnaW5hbDtcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXggPSB0aGlzLm1pY3Jvc2VjTWF4T3JpZ2luYWw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heCA9IHRoaXMubWludXRlTWF4T3JpZ2luYWw7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5zZWNvbmRNYXggPSB0aGlzLnNlY29uZE1heE9yaWdpbmFsO1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNYXggPSB0aGlzLm1pbGxpc2VjTWF4T3JpZ2luYWw7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01heCA9IHRoaXMubWljcm9zZWNNYXhPcmlnaW5hbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuaG91ck1heCA9IHRoaXMuaG91ck1heE9yaWdpbmFsO1xuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heCA9IHRoaXMubWludXRlTWF4T3JpZ2luYWw7XG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuc2Vjb25kTWF4ID0gdGhpcy5zZWNvbmRNYXhPcmlnaW5hbDtcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01heCA9IHRoaXMubWlsbGlzZWNNYXhPcmlnaW5hbDtcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01heCA9IHRoaXMubWljcm9zZWNNYXhPcmlnaW5hbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZHBfaW5zdC5zZXR0aW5ncy5taW5UaW1lIT09bnVsbCkge1xuXHRcdFx0XHR2YXIgdGVtcE1pblRpbWU9bmV3IERhdGUoXCIwMS8wMS8xOTcwIFwiICsgZHBfaW5zdC5zZXR0aW5ncy5taW5UaW1lKTtcblx0XHRcdFx0aWYgKHRoaXMuaG91cjx0ZW1wTWluVGltZS5nZXRIb3VycygpKSB7XG5cdFx0XHRcdFx0dGhpcy5ob3VyPXRoaXMuX2RlZmF1bHRzLmhvdXJNaW49dGVtcE1pblRpbWUuZ2V0SG91cnMoKTtcblx0XHRcdFx0XHR0aGlzLm1pbnV0ZT10aGlzLl9kZWZhdWx0cy5taW51dGVNaW49dGVtcE1pblRpbWUuZ2V0TWludXRlcygpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuaG91cj09PXRlbXBNaW5UaW1lLmdldEhvdXJzKCkgJiYgdGhpcy5taW51dGU8dGVtcE1pblRpbWUuZ2V0TWludXRlcygpKSB7XG5cdFx0XHRcdFx0dGhpcy5taW51dGU9dGhpcy5fZGVmYXVsdHMubWludXRlTWluPXRlbXBNaW5UaW1lLmdldE1pbnV0ZXMoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fZGVmYXVsdHMuaG91ck1pbjx0ZW1wTWluVGltZS5nZXRIb3VycygpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5ob3VyTWluPXRlbXBNaW5UaW1lLmdldEhvdXJzKCk7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNaW49dGVtcE1pblRpbWUuZ2V0TWludXRlcygpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZGVmYXVsdHMuaG91ck1pbj09PXRlbXBNaW5UaW1lLmdldEhvdXJzKCk9PT10aGlzLmhvdXIgJiYgdGhpcy5fZGVmYXVsdHMubWludXRlTWluPHRlbXBNaW5UaW1lLmdldE1pbnV0ZXMoKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWluPXRlbXBNaW5UaW1lLmdldE1pbnV0ZXMoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWluPTA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkcF9pbnN0LnNldHRpbmdzLm1heFRpbWUhPT1udWxsKSB7XG5cdFx0XHRcdHZhciB0ZW1wTWF4VGltZT1uZXcgRGF0ZShcIjAxLzAxLzE5NzAgXCIgKyBkcF9pbnN0LnNldHRpbmdzLm1heFRpbWUpO1xuXHRcdFx0XHRpZiAodGhpcy5ob3VyPnRlbXBNYXhUaW1lLmdldEhvdXJzKCkpIHtcblx0XHRcdFx0XHR0aGlzLmhvdXI9dGhpcy5fZGVmYXVsdHMuaG91ck1heD10ZW1wTWF4VGltZS5nZXRIb3VycygpO1xuXHRcdFx0XHRcdHRoaXMubWludXRlPXRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heD10ZW1wTWF4VGltZS5nZXRNaW51dGVzKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5ob3VyPT09dGVtcE1heFRpbWUuZ2V0SG91cnMoKSAmJiB0aGlzLm1pbnV0ZT50ZW1wTWF4VGltZS5nZXRNaW51dGVzKCkpIHtcblx0XHRcdFx0XHR0aGlzLm1pbnV0ZT10aGlzLl9kZWZhdWx0cy5taW51dGVNYXg9dGVtcE1heFRpbWUuZ2V0TWludXRlcygpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9kZWZhdWx0cy5ob3VyTWF4PnRlbXBNYXhUaW1lLmdldEhvdXJzKCkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLmhvdXJNYXg9dGVtcE1heFRpbWUuZ2V0SG91cnMoKTtcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heD10ZW1wTWF4VGltZS5nZXRNaW51dGVzKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9kZWZhdWx0cy5ob3VyTWF4PT09dGVtcE1heFRpbWUuZ2V0SG91cnMoKT09PXRoaXMuaG91ciAmJiB0aGlzLl9kZWZhdWx0cy5taW51dGVNYXg+dGVtcE1heFRpbWUuZ2V0TWludXRlcygpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNYXg9dGVtcE1heFRpbWUuZ2V0TWludXRlcygpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNYXg9NTk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChhZGp1c3RTbGlkZXJzICE9PSB1bmRlZmluZWQgJiYgYWRqdXN0U2xpZGVycyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR2YXIgaG91ck1heCA9IHBhcnNlSW50KCh0aGlzLl9kZWZhdWx0cy5ob3VyTWF4IC0gKCh0aGlzLl9kZWZhdWx0cy5ob3VyTWF4IC0gdGhpcy5fZGVmYXVsdHMuaG91ck1pbikgJSB0aGlzLl9kZWZhdWx0cy5zdGVwSG91cikpLCAxMCksXG5cdFx0XHRcdFx0bWluTWF4ID0gcGFyc2VJbnQoKHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heCAtICgodGhpcy5fZGVmYXVsdHMubWludXRlTWF4IC0gdGhpcy5fZGVmYXVsdHMubWludXRlTWluKSAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBNaW51dGUpKSwgMTApLFxuXHRcdFx0XHRcdHNlY01heCA9IHBhcnNlSW50KCh0aGlzLl9kZWZhdWx0cy5zZWNvbmRNYXggLSAoKHRoaXMuX2RlZmF1bHRzLnNlY29uZE1heCAtIHRoaXMuX2RlZmF1bHRzLnNlY29uZE1pbikgJSB0aGlzLl9kZWZhdWx0cy5zdGVwU2Vjb25kKSksIDEwKSxcblx0XHRcdFx0XHRtaWxsaXNlY01heCA9IHBhcnNlSW50KCh0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01heCAtICgodGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNYXggLSB0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01pbikgJSB0aGlzLl9kZWZhdWx0cy5zdGVwTWlsbGlzZWMpKSwgMTApLFxuXHRcdFx0XHRcdG1pY3Jvc2VjTWF4ID0gcGFyc2VJbnQoKHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4IC0gKCh0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01heCAtIHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWluKSAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBNaWNyb3NlYykpLCAxMCk7XG5cblx0XHRcdFx0aWYgKHRoaXMuaG91cl9zbGlkZXIpIHtcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wub3B0aW9ucyh0aGlzLCB0aGlzLmhvdXJfc2xpZGVyLCAnaG91cicsIHsgbWluOiB0aGlzLl9kZWZhdWx0cy5ob3VyTWluLCBtYXg6IGhvdXJNYXgsIHN0ZXA6IHRoaXMuX2RlZmF1bHRzLnN0ZXBIb3VyIH0pO1xuXHRcdFx0XHRcdHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLmhvdXJfc2xpZGVyLCAnaG91cicsIHRoaXMuaG91ciAtICh0aGlzLmhvdXIgJSB0aGlzLl9kZWZhdWx0cy5zdGVwSG91cikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLm1pbnV0ZV9zbGlkZXIpIHtcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wub3B0aW9ucyh0aGlzLCB0aGlzLm1pbnV0ZV9zbGlkZXIsICdtaW51dGUnLCB7IG1pbjogdGhpcy5fZGVmYXVsdHMubWludXRlTWluLCBtYXg6IG1pbk1heCwgc3RlcDogdGhpcy5fZGVmYXVsdHMuc3RlcE1pbnV0ZSB9KTtcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wudmFsdWUodGhpcywgdGhpcy5taW51dGVfc2xpZGVyLCAnbWludXRlJywgdGhpcy5taW51dGUgLSAodGhpcy5taW51dGUgJSB0aGlzLl9kZWZhdWx0cy5zdGVwTWludXRlKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuc2Vjb25kX3NsaWRlcikge1xuXHRcdFx0XHRcdHRoaXMuY29udHJvbC5vcHRpb25zKHRoaXMsIHRoaXMuc2Vjb25kX3NsaWRlciwgJ3NlY29uZCcsIHsgbWluOiB0aGlzLl9kZWZhdWx0cy5zZWNvbmRNaW4sIG1heDogc2VjTWF4LCBzdGVwOiB0aGlzLl9kZWZhdWx0cy5zdGVwU2Vjb25kIH0pO1xuXHRcdFx0XHRcdHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLnNlY29uZF9zbGlkZXIsICdzZWNvbmQnLCB0aGlzLnNlY29uZCAtICh0aGlzLnNlY29uZCAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBTZWNvbmQpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5taWxsaXNlY19zbGlkZXIpIHtcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wub3B0aW9ucyh0aGlzLCB0aGlzLm1pbGxpc2VjX3NsaWRlciwgJ21pbGxpc2VjJywgeyBtaW46IHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluLCBtYXg6IG1pbGxpc2VjTWF4LCBzdGVwOiB0aGlzLl9kZWZhdWx0cy5zdGVwTWlsbGlzZWMgfSk7XG5cdFx0XHRcdFx0dGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMubWlsbGlzZWNfc2xpZGVyLCAnbWlsbGlzZWMnLCB0aGlzLm1pbGxpc2VjIC0gKHRoaXMubWlsbGlzZWMgJSB0aGlzLl9kZWZhdWx0cy5zdGVwTWlsbGlzZWMpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5taWNyb3NlY19zbGlkZXIpIHtcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wub3B0aW9ucyh0aGlzLCB0aGlzLm1pY3Jvc2VjX3NsaWRlciwgJ21pY3Jvc2VjJywgeyBtaW46IHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWluLCBtYXg6IG1pY3Jvc2VjTWF4LCBzdGVwOiB0aGlzLl9kZWZhdWx0cy5zdGVwTWljcm9zZWMgfSk7XG5cdFx0XHRcdFx0dGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMubWljcm9zZWNfc2xpZGVyLCAnbWljcm9zZWMnLCB0aGlzLm1pY3Jvc2VjIC0gKHRoaXMubWljcm9zZWMgJSB0aGlzLl9kZWZhdWx0cy5zdGVwTWljcm9zZWMpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdC8qXG5cdFx0KiB3aGVuIGEgc2xpZGVyIG1vdmVzLCBzZXQgdGhlIGludGVybmFsIHRpbWUuLi5cblx0XHQqIG9uIHRpbWUgY2hhbmdlIGlzIGFsc28gY2FsbGVkIHdoZW4gdGhlIHRpbWUgaXMgdXBkYXRlZCBpbiB0aGUgdGV4dCBmaWVsZFxuXHRcdCovXG5cdFx0X29uVGltZUNoYW5nZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCF0aGlzLl9kZWZhdWx0cy5zaG93VGltZXBpY2tlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgaG91ciA9ICh0aGlzLmhvdXJfc2xpZGVyKSA/IHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLmhvdXJfc2xpZGVyLCAnaG91cicpIDogZmFsc2UsXG5cdFx0XHRcdG1pbnV0ZSA9ICh0aGlzLm1pbnV0ZV9zbGlkZXIpID8gdGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMubWludXRlX3NsaWRlciwgJ21pbnV0ZScpIDogZmFsc2UsXG5cdFx0XHRcdHNlY29uZCA9ICh0aGlzLnNlY29uZF9zbGlkZXIpID8gdGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMuc2Vjb25kX3NsaWRlciwgJ3NlY29uZCcpIDogZmFsc2UsXG5cdFx0XHRcdG1pbGxpc2VjID0gKHRoaXMubWlsbGlzZWNfc2xpZGVyKSA/IHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLm1pbGxpc2VjX3NsaWRlciwgJ21pbGxpc2VjJykgOiBmYWxzZSxcblx0XHRcdFx0bWljcm9zZWMgPSAodGhpcy5taWNyb3NlY19zbGlkZXIpID8gdGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMubWljcm9zZWNfc2xpZGVyLCAnbWljcm9zZWMnKSA6IGZhbHNlLFxuXHRcdFx0XHR0aW1lem9uZSA9ICh0aGlzLnRpbWV6b25lX3NlbGVjdCkgPyB0aGlzLnRpbWV6b25lX3NlbGVjdC52YWwoKSA6IGZhbHNlLFxuXHRcdFx0XHRvID0gdGhpcy5fZGVmYXVsdHMsXG5cdFx0XHRcdHBpY2tlclRpbWVGb3JtYXQgPSBvLnBpY2tlclRpbWVGb3JtYXQgfHwgby50aW1lRm9ybWF0LFxuXHRcdFx0XHRwaWNrZXJUaW1lU3VmZml4ID0gby5waWNrZXJUaW1lU3VmZml4IHx8IG8udGltZVN1ZmZpeDtcblxuXHRcdFx0aWYgKHR5cGVvZihob3VyKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aG91ciA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZihtaW51dGUpID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRtaW51dGUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2Yoc2Vjb25kKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0c2Vjb25kID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mKG1pbGxpc2VjKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0bWlsbGlzZWMgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YobWljcm9zZWMpID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRtaWNyb3NlYyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZih0aW1lem9uZSkgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHRpbWV6b25lID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChob3VyICE9PSBmYWxzZSkge1xuXHRcdFx0XHRob3VyID0gcGFyc2VJbnQoaG91ciwgMTApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1pbnV0ZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0bWludXRlID0gcGFyc2VJbnQobWludXRlLCAxMCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2Vjb25kICE9PSBmYWxzZSkge1xuXHRcdFx0XHRzZWNvbmQgPSBwYXJzZUludChzZWNvbmQsIDEwKTtcblx0XHRcdH1cblx0XHRcdGlmIChtaWxsaXNlYyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0bWlsbGlzZWMgPSBwYXJzZUludChtaWxsaXNlYywgMTApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1pY3Jvc2VjICE9PSBmYWxzZSkge1xuXHRcdFx0XHRtaWNyb3NlYyA9IHBhcnNlSW50KG1pY3Jvc2VjLCAxMCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGltZXpvbmUgIT09IGZhbHNlKSB7XG5cdFx0XHRcdHRpbWV6b25lID0gdGltZXpvbmUudG9TdHJpbmcoKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGFtcG0gPSBvW2hvdXIgPCAxMiA/ICdhbU5hbWVzJyA6ICdwbU5hbWVzJ11bMF07XG5cblx0XHRcdC8vIElmIHRoZSB1cGRhdGUgd2FzIGRvbmUgaW4gdGhlIGlucHV0IGZpZWxkLCB0aGUgaW5wdXQgZmllbGQgc2hvdWxkIG5vdCBiZSB1cGRhdGVkLlxuXHRcdFx0Ly8gSWYgdGhlIHVwZGF0ZSB3YXMgZG9uZSB1c2luZyB0aGUgc2xpZGVycywgdXBkYXRlIHRoZSBpbnB1dCBmaWVsZC5cblx0XHRcdHZhciBoYXNDaGFuZ2VkID0gKFxuXHRcdFx0XHRcdFx0aG91ciAhPT0gcGFyc2VJbnQodGhpcy5ob3VyLDEwKSB8fCAvLyBzbGlkZXJzIHNob3VsZCBhbGwgYmUgbnVtZXJpY1xuXHRcdFx0XHRcdFx0bWludXRlICE9PSBwYXJzZUludCh0aGlzLm1pbnV0ZSwxMCkgfHxcblx0XHRcdFx0XHRcdHNlY29uZCAhPT0gcGFyc2VJbnQodGhpcy5zZWNvbmQsMTApIHx8XG5cdFx0XHRcdFx0XHRtaWxsaXNlYyAhPT0gcGFyc2VJbnQodGhpcy5taWxsaXNlYywxMCkgfHxcblx0XHRcdFx0XHRcdG1pY3Jvc2VjICE9PSBwYXJzZUludCh0aGlzLm1pY3Jvc2VjLDEwKSB8fFxuXHRcdFx0XHRcdFx0KHRoaXMuYW1wbS5sZW5ndGggPiAwICYmIChob3VyIDwgMTIpICE9PSAoJC5pbkFycmF5KHRoaXMuYW1wbS50b1VwcGVyQ2FzZSgpLCB0aGlzLmFtTmFtZXMpICE9PSAtMSkpIHx8XG5cdFx0XHRcdFx0XHQodGhpcy50aW1lem9uZSAhPT0gbnVsbCAmJiB0aW1lem9uZSAhPT0gdGhpcy50aW1lem9uZS50b1N0cmluZygpKSAvLyBjb3VsZCBiZSBudW1lcmljIG9yIFwiRVNUXCIgZm9ybWF0LCBzbyB1c2UgdG9TdHJpbmcoKVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdGlmIChoYXNDaGFuZ2VkKSB7XG5cblx0XHRcdFx0aWYgKGhvdXIgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0dGhpcy5ob3VyID0gaG91cjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobWludXRlICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdHRoaXMubWludXRlID0gbWludXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzZWNvbmQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0dGhpcy5zZWNvbmQgPSBzZWNvbmQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG1pbGxpc2VjICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdHRoaXMubWlsbGlzZWMgPSBtaWxsaXNlYztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobWljcm9zZWMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0dGhpcy5taWNyb3NlYyA9IG1pY3Jvc2VjO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aW1lem9uZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHR0aGlzLnRpbWV6b25lID0gdGltZXpvbmU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIXRoaXMuaW5zdCkge1xuXHRcdFx0XHRcdHRoaXMuaW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdCh0aGlzLiRpbnB1dFswXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9saW1pdE1pbk1heERhdGVUaW1lKHRoaXMuaW5zdCwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5zdXBwb3J0LmFtcG0pIHtcblx0XHRcdFx0dGhpcy5hbXBtID0gYW1wbTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlcyB0aGUgdGltZSB3aXRoaW4gdGhlIHRpbWVwaWNrZXJcblx0XHRcdHRoaXMuZm9ybWF0dGVkVGltZSA9ICQuZGF0ZXBpY2tlci5mb3JtYXRUaW1lKG8udGltZUZvcm1hdCwgdGhpcywgbyk7XG5cdFx0XHRpZiAodGhpcy4kdGltZU9iaikge1xuXHRcdFx0XHRpZiAocGlja2VyVGltZUZvcm1hdCA9PT0gby50aW1lRm9ybWF0KSB7XG5cdFx0XHRcdFx0dGhpcy4kdGltZU9iai52YWwodGhpcy5mb3JtYXR0ZWRUaW1lICsgcGlja2VyVGltZVN1ZmZpeCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy4kdGltZU9iai52YWwoJC5kYXRlcGlja2VyLmZvcm1hdFRpbWUocGlja2VyVGltZUZvcm1hdCwgdGhpcywgbykgKyBwaWNrZXJUaW1lU3VmZml4KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy4kdGltZU9ialswXS5zZXRTZWxlY3Rpb25SYW5nZSkge1xuXHRcdFx0XHRcdHZhciBzUG9zID0gdGhpcy4kdGltZU9ialswXS5zZWxlY3Rpb25TdGFydDtcblx0XHRcdFx0XHR2YXIgZVBvcyA9IHRoaXMuJHRpbWVPYmpbMF0uc2VsZWN0aW9uRW5kO1xuXHRcdFx0XHRcdHRoaXMuJHRpbWVPYmpbMF0uc2V0U2VsZWN0aW9uUmFuZ2Uoc1BvcywgZVBvcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy50aW1lRGVmaW5lZCA9IHRydWU7XG5cdFx0XHRpZiAoaGFzQ2hhbmdlZCkge1xuXHRcdFx0XHR0aGlzLl91cGRhdGVEYXRlVGltZSgpO1xuXHRcdFx0XHQvL3RoaXMuJGlucHV0LmZvY3VzKCk7IC8vIG1heSBhdXRvbWF0aWNhbGx5IG9wZW4gdGhlIHBpY2tlciBvbiBzZXREYXRlXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx0KiBjYWxsIGN1c3RvbSBvblNlbGVjdC5cblx0XHQqIGJpbmQgdG8gc2xpZGVycyBzbGlkZXN0b3AsIGFuZCBncmlkIGNsaWNrLlxuXHRcdCovXG5cdFx0X29uU2VsZWN0SGFuZGxlcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG9uU2VsZWN0ID0gdGhpcy5fZGVmYXVsdHMub25TZWxlY3QgfHwgdGhpcy5pbnN0LnNldHRpbmdzLm9uU2VsZWN0O1xuXHRcdFx0dmFyIGlucHV0RWwgPSB0aGlzLiRpbnB1dCA/IHRoaXMuJGlucHV0WzBdIDogbnVsbDtcblx0XHRcdGlmIChvblNlbGVjdCAmJiBpbnB1dEVsKSB7XG5cdFx0XHRcdG9uU2VsZWN0LmFwcGx5KGlucHV0RWwsIFt0aGlzLmZvcm1hdHRlZERhdGVUaW1lLCB0aGlzXSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx0KiB1cGRhdGUgb3VyIGlucHV0IHdpdGggdGhlIG5ldyBkYXRlIHRpbWUuLlxuXHRcdCovXG5cdFx0X3VwZGF0ZURhdGVUaW1lOiBmdW5jdGlvbiAoZHBfaW5zdCkge1xuXHRcdFx0ZHBfaW5zdCA9IHRoaXMuaW5zdCB8fCBkcF9pbnN0O1xuXHRcdFx0dmFyIGR0VG1wID0gKGRwX2luc3QuY3VycmVudFllYXIgPiAwP1xuXHRcdFx0XHRcdFx0XHRuZXcgRGF0ZShkcF9pbnN0LmN1cnJlbnRZZWFyLCBkcF9pbnN0LmN1cnJlbnRNb250aCwgZHBfaW5zdC5jdXJyZW50RGF5KSA6XG5cdFx0XHRcdFx0XHRcdG5ldyBEYXRlKGRwX2luc3Quc2VsZWN0ZWRZZWFyLCBkcF9pbnN0LnNlbGVjdGVkTW9udGgsIGRwX2luc3Quc2VsZWN0ZWREYXkpKSxcblx0XHRcdFx0ZHQgPSAkLmRhdGVwaWNrZXIuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KGR0VG1wKSxcblx0XHRcdFx0Ly9kdCA9ICQuZGF0ZXBpY2tlci5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHBfaW5zdC5zZWxlY3RlZFllYXIsIGRwX2luc3Quc2VsZWN0ZWRNb250aCwgZHBfaW5zdC5zZWxlY3RlZERheSkpLFxuXHRcdFx0XHQvL2R0ID0gJC5kYXRlcGlja2VyLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShkcF9pbnN0LmN1cnJlbnRZZWFyLCBkcF9pbnN0LmN1cnJlbnRNb250aCwgZHBfaW5zdC5jdXJyZW50RGF5KSksXG5cdFx0XHRcdGRhdGVGbXQgPSAkLmRhdGVwaWNrZXIuX2dldChkcF9pbnN0LCAnZGF0ZUZvcm1hdCcpLFxuXHRcdFx0XHRmb3JtYXRDZmcgPSAkLmRhdGVwaWNrZXIuX2dldEZvcm1hdENvbmZpZyhkcF9pbnN0KSxcblx0XHRcdFx0dGltZUF2YWlsYWJsZSA9IGR0ICE9PSBudWxsICYmIHRoaXMudGltZURlZmluZWQ7XG5cdFx0XHR0aGlzLmZvcm1hdHRlZERhdGUgPSAkLmRhdGVwaWNrZXIuZm9ybWF0RGF0ZShkYXRlRm10LCAoZHQgPT09IG51bGwgPyBuZXcgRGF0ZSgpIDogZHQpLCBmb3JtYXRDZmcpO1xuXHRcdFx0dmFyIGZvcm1hdHRlZERhdGVUaW1lID0gdGhpcy5mb3JtYXR0ZWREYXRlO1xuXG5cdFx0XHQvLyBpZiBhIHNsaWRlciB3YXMgY2hhbmdlZCBidXQgZGF0ZXBpY2tlciBkb2Vzbid0IGhhdmUgYSB2YWx1ZSB5ZXQsIHNldCBpdFxuXHRcdFx0aWYgKGRwX2luc3QubGFzdFZhbCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGRwX2luc3QuY3VycmVudFllYXIgPSBkcF9pbnN0LnNlbGVjdGVkWWVhcjtcbiAgICAgICAgICAgICAgICBkcF9pbnN0LmN1cnJlbnRNb250aCA9IGRwX2luc3Quc2VsZWN0ZWRNb250aDtcbiAgICAgICAgICAgICAgICBkcF9pbnN0LmN1cnJlbnREYXkgPSBkcF9pbnN0LnNlbGVjdGVkRGF5O1xuICAgICAgICAgICAgfVxuXG5cdFx0XHQvKlxuXHRcdFx0KiByZW1vdmUgZm9sbG93aW5nIGxpbmVzIHRvIGZvcmNlIGV2ZXJ5IGNoYW5nZXMgaW4gZGF0ZSBwaWNrZXIgdG8gY2hhbmdlIHRoZSBpbnB1dCB2YWx1ZVxuXHRcdFx0KiBCdWcgZGVzY3JpcHRpb25zOiB3aGVuIGFuIGlucHV0IGZpZWxkIGhhcyBhIGRlZmF1bHQgdmFsdWUsIGFuZCBjbGljayBvbiB0aGUgZmllbGQgdG8gcG9wIHVwIHRoZSBkYXRlIHBpY2tlci5cblx0XHRcdCogSWYgdGhlIHVzZXIgbWFudWFsbHkgZW1wdHkgdGhlIHZhbHVlIGluIHRoZSBpbnB1dCBmaWVsZCwgdGhlIGRhdGUgcGlja2VyIHdpbGwgbmV2ZXIgY2hhbmdlIHNlbGVjdGVkIHZhbHVlLlxuXHRcdFx0Ki9cblx0XHRcdC8vaWYgKGRwX2luc3QubGFzdFZhbCAhPT0gdW5kZWZpbmVkICYmIChkcF9pbnN0Lmxhc3RWYWwubGVuZ3RoID4gMCAmJiB0aGlzLiRpbnB1dC52YWwoKS5sZW5ndGggPT09IDApKSB7XG5cdFx0XHQvL1x0cmV0dXJuO1xuXHRcdFx0Ly99XG5cblx0XHRcdGlmICh0aGlzLl9kZWZhdWx0cy50aW1lT25seSA9PT0gdHJ1ZSAmJiB0aGlzLl9kZWZhdWx0cy50aW1lT25seVNob3dEYXRlID09PSBmYWxzZSkge1xuXHRcdFx0XHRmb3JtYXR0ZWREYXRlVGltZSA9IHRoaXMuZm9ybWF0dGVkVGltZTtcblx0XHRcdH0gZWxzZSBpZiAoKHRoaXMuX2RlZmF1bHRzLnRpbWVPbmx5ICE9PSB0cnVlICYmICh0aGlzLl9kZWZhdWx0cy5hbHdheXNTZXRUaW1lIHx8IHRpbWVBdmFpbGFibGUpKSB8fCAodGhpcy5fZGVmYXVsdHMudGltZU9ubHkgPT09IHRydWUgJiYgdGhpcy5fZGVmYXVsdHMudGltZU9ubHlTaG93RGF0ZSA9PT0gdHJ1ZSkpIHtcblx0XHRcdFx0Zm9ybWF0dGVkRGF0ZVRpbWUgKz0gdGhpcy5fZGVmYXVsdHMuc2VwYXJhdG9yICsgdGhpcy5mb3JtYXR0ZWRUaW1lICsgdGhpcy5fZGVmYXVsdHMudGltZVN1ZmZpeDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5mb3JtYXR0ZWREYXRlVGltZSA9IGZvcm1hdHRlZERhdGVUaW1lO1xuXG5cdFx0XHRpZiAoIXRoaXMuX2RlZmF1bHRzLnNob3dUaW1lcGlja2VyKSB7XG5cdFx0XHRcdHRoaXMuJGlucHV0LnZhbCh0aGlzLmZvcm1hdHRlZERhdGUpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLiRhbHRJbnB1dCAmJiB0aGlzLl9kZWZhdWx0cy50aW1lT25seSA9PT0gZmFsc2UgJiYgdGhpcy5fZGVmYXVsdHMuYWx0RmllbGRUaW1lT25seSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR0aGlzLiRhbHRJbnB1dC52YWwodGhpcy5mb3JtYXR0ZWRUaW1lKTtcblx0XHRcdFx0dGhpcy4kaW5wdXQudmFsKHRoaXMuZm9ybWF0dGVkRGF0ZSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuJGFsdElucHV0KSB7XG5cdFx0XHRcdHRoaXMuJGlucHV0LnZhbChmb3JtYXR0ZWREYXRlVGltZSk7XG5cdFx0XHRcdHZhciBhbHRGb3JtYXR0ZWREYXRlVGltZSA9ICcnLFxuXHRcdFx0XHRcdGFsdFNlcGFyYXRvciA9IHRoaXMuX2RlZmF1bHRzLmFsdFNlcGFyYXRvciAhPT0gbnVsbCA/IHRoaXMuX2RlZmF1bHRzLmFsdFNlcGFyYXRvciA6IHRoaXMuX2RlZmF1bHRzLnNlcGFyYXRvcixcblx0XHRcdFx0XHRhbHRUaW1lU3VmZml4ID0gdGhpcy5fZGVmYXVsdHMuYWx0VGltZVN1ZmZpeCAhPT0gbnVsbCA/IHRoaXMuX2RlZmF1bHRzLmFsdFRpbWVTdWZmaXggOiB0aGlzLl9kZWZhdWx0cy50aW1lU3VmZml4O1xuXG5cdFx0XHRcdGlmICghdGhpcy5fZGVmYXVsdHMudGltZU9ubHkpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fZGVmYXVsdHMuYWx0Rm9ybWF0KSB7XG5cdFx0XHRcdFx0XHRhbHRGb3JtYXR0ZWREYXRlVGltZSA9ICQuZGF0ZXBpY2tlci5mb3JtYXREYXRlKHRoaXMuX2RlZmF1bHRzLmFsdEZvcm1hdCwgKGR0ID09PSBudWxsID8gbmV3IERhdGUoKSA6IGR0KSwgZm9ybWF0Q2ZnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRhbHRGb3JtYXR0ZWREYXRlVGltZSA9IHRoaXMuZm9ybWF0dGVkRGF0ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoYWx0Rm9ybWF0dGVkRGF0ZVRpbWUpIHtcblx0XHRcdFx0XHRcdGFsdEZvcm1hdHRlZERhdGVUaW1lICs9IGFsdFNlcGFyYXRvcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5fZGVmYXVsdHMuYWx0VGltZUZvcm1hdCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGFsdEZvcm1hdHRlZERhdGVUaW1lICs9ICQuZGF0ZXBpY2tlci5mb3JtYXRUaW1lKHRoaXMuX2RlZmF1bHRzLmFsdFRpbWVGb3JtYXQsIHRoaXMsIHRoaXMuX2RlZmF1bHRzKSArIGFsdFRpbWVTdWZmaXg7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgKz0gdGhpcy5mb3JtYXR0ZWRUaW1lICsgYWx0VGltZVN1ZmZpeDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLiRhbHRJbnB1dC52YWwoYWx0Rm9ybWF0dGVkRGF0ZVRpbWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy4kaW5wdXQudmFsKGZvcm1hdHRlZERhdGVUaW1lKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy4kaW5wdXQudHJpZ2dlcihcImNoYW5nZVwiKTtcblx0XHR9LFxuXG5cdFx0X29uRm9jdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICghdGhpcy4kaW5wdXQudmFsKCkgJiYgdGhpcy5fZGVmYXVsdHMuZGVmYXVsdFZhbHVlKSB7XG5cdFx0XHRcdHRoaXMuJGlucHV0LnZhbCh0aGlzLl9kZWZhdWx0cy5kZWZhdWx0VmFsdWUpO1xuXHRcdFx0XHR2YXIgaW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdCh0aGlzLiRpbnB1dC5nZXQoMCkpLFxuXHRcdFx0XHRcdHRwX2luc3QgPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCAndGltZXBpY2tlcicpO1xuXHRcdFx0XHRpZiAodHBfaW5zdCkge1xuXHRcdFx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy50aW1lT25seSAmJiAoaW5zdC5pbnB1dC52YWwoKSAhPT0gaW5zdC5sYXN0VmFsKSkge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdCQudGltZXBpY2tlci5sb2coZXJyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Lypcblx0XHQqIFNtYWxsIGFic3RyYWN0aW9uIHRvIGNvbnRyb2wgdHlwZXNcblx0XHQqIFdlIGNhbiBhZGQgbW9yZSwganVzdCBiZSBzdXJlIHRvIGZvbGxvdyB0aGUgcGF0dGVybjogY3JlYXRlLCBvcHRpb25zLCB2YWx1ZVxuXHRcdCovXG5cdFx0X2NvbnRyb2xzOiB7XG5cdFx0XHQvLyBzbGlkZXIgbWV0aG9kc1xuXHRcdFx0c2xpZGVyOiB7XG5cdFx0XHRcdGNyZWF0ZTogZnVuY3Rpb24gKHRwX2luc3QsIG9iaiwgdW5pdCwgdmFsLCBtaW4sIG1heCwgc3RlcCkge1xuXHRcdFx0XHRcdHZhciBydGwgPSB0cF9pbnN0Ll9kZWZhdWx0cy5pc1JUTDsgLy8gaWYgcnRsIGdvIC02MC0+MCBpbnN0ZWFkIG9mIDAtPjYwXG5cdFx0XHRcdFx0cmV0dXJuIG9iai5wcm9wKCdzbGlkZScsIG51bGwpLnNsaWRlcih7XG5cdFx0XHRcdFx0XHRvcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXG5cdFx0XHRcdFx0XHR2YWx1ZTogcnRsID8gdmFsICogLTEgOiB2YWwsXG5cdFx0XHRcdFx0XHRtaW46IHJ0bCA/IG1heCAqIC0xIDogbWluLFxuXHRcdFx0XHRcdFx0bWF4OiBydGwgPyBtaW4gKiAtMSA6IG1heCxcblx0XHRcdFx0XHRcdHN0ZXA6IHN0ZXAsXG5cdFx0XHRcdFx0XHRzbGlkZTogZnVuY3Rpb24gKGV2ZW50LCB1aSkge1xuXHRcdFx0XHRcdFx0XHR0cF9pbnN0LmNvbnRyb2wudmFsdWUodHBfaW5zdCwgJCh0aGlzKSwgdW5pdCwgcnRsID8gdWkudmFsdWUgKiAtMSA6IHVpLnZhbHVlKTtcblx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fb25UaW1lQ2hhbmdlKCk7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0c3RvcDogZnVuY3Rpb24gKGV2ZW50LCB1aSkge1xuXHRcdFx0XHRcdFx0XHR0cF9pbnN0Ll9vblNlbGVjdEhhbmRsZXIoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0b3B0aW9uczogZnVuY3Rpb24gKHRwX2luc3QsIG9iaiwgdW5pdCwgb3B0cywgdmFsKSB7XG5cdFx0XHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLmlzUlRMKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKG9wdHMpID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0XHRpZiAob3B0cyA9PT0gJ21pbicgfHwgb3B0cyA9PT0gJ21heCcpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBvYmouc2xpZGVyKG9wdHMsIHZhbCAqIC0xKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIE1hdGguYWJzKG9iai5zbGlkZXIob3B0cykpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiBvYmouc2xpZGVyKG9wdHMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIG1pbiA9IG9wdHMubWluLFxuXHRcdFx0XHRcdFx0XHRtYXggPSBvcHRzLm1heDtcblx0XHRcdFx0XHRcdG9wdHMubWluID0gb3B0cy5tYXggPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKG1pbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdG9wdHMubWF4ID0gbWluICogLTE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAobWF4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0b3B0cy5taW4gPSBtYXggKiAtMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBvYmouc2xpZGVyKG9wdHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodHlwZW9mKG9wdHMpID09PSAnc3RyaW5nJyAmJiB2YWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9iai5zbGlkZXIob3B0cywgdmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG9iai5zbGlkZXIob3B0cyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHZhbHVlOiBmdW5jdGlvbiAodHBfaW5zdCwgb2JqLCB1bml0LCB2YWwpIHtcblx0XHRcdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMuaXNSVEwpIHtcblx0XHRcdFx0XHRcdGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcigndmFsdWUnLCB2YWwgKiAtMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gTWF0aC5hYnMob2JqLnNsaWRlcigndmFsdWUnKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9iai5zbGlkZXIoJ3ZhbHVlJywgdmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG9iai5zbGlkZXIoJ3ZhbHVlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvLyBzZWxlY3QgbWV0aG9kc1xuXHRcdFx0c2VsZWN0OiB7XG5cdFx0XHRcdGNyZWF0ZTogZnVuY3Rpb24gKHRwX2luc3QsIG9iaiwgdW5pdCwgdmFsLCBtaW4sIG1heCwgc3RlcCkge1xuXHRcdFx0XHRcdHZhciBzZWwgPSAnPHNlbGVjdCBjbGFzcz1cInVpLXRpbWVwaWNrZXItc2VsZWN0IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbFwiIGRhdGEtdW5pdD1cIicgKyB1bml0ICsgJ1wiIGRhdGEtbWluPVwiJyArIG1pbiArICdcIiBkYXRhLW1heD1cIicgKyBtYXggKyAnXCIgZGF0YS1zdGVwPVwiJyArIHN0ZXAgKyAnXCI+Jyxcblx0XHRcdFx0XHRcdGZvcm1hdCA9IHRwX2luc3QuX2RlZmF1bHRzLnBpY2tlclRpbWVGb3JtYXQgfHwgdHBfaW5zdC5fZGVmYXVsdHMudGltZUZvcm1hdDtcblxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSBtaW47IGkgPD0gbWF4OyBpICs9IHN0ZXApIHtcblx0XHRcdFx0XHRcdHNlbCArPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyBpICsgJ1wiJyArIChpID09PSB2YWwgPyAnIHNlbGVjdGVkJyA6ICcnKSArICc+Jztcblx0XHRcdFx0XHRcdGlmICh1bml0ID09PSAnaG91cicpIHtcblx0XHRcdFx0XHRcdFx0c2VsICs9ICQuZGF0ZXBpY2tlci5mb3JtYXRUaW1lKCQudHJpbShmb3JtYXQucmVwbGFjZSgvW15odCBdL2lnLCAnJykpLCB7aG91cjogaX0sIHRwX2luc3QuX2RlZmF1bHRzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKHVuaXQgPT09ICdtaWxsaXNlYycgfHwgdW5pdCA9PT0gJ21pY3Jvc2VjJyB8fCBpID49IDEwKSB7IHNlbCArPSBpOyB9XG5cdFx0XHRcdFx0XHRlbHNlIHtzZWwgKz0gJzAnICsgaS50b1N0cmluZygpOyB9XG5cdFx0XHRcdFx0XHRzZWwgKz0gJzwvb3B0aW9uPic7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbCArPSAnPC9zZWxlY3Q+JztcblxuXHRcdFx0XHRcdG9iai5jaGlsZHJlbignc2VsZWN0JykucmVtb3ZlKCk7XG5cblx0XHRcdFx0XHQkKHNlbCkuYXBwZW5kVG8ob2JqKS5jaGFuZ2UoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdHRwX2luc3QuX29uVGltZUNoYW5nZSgpO1xuXHRcdFx0XHRcdFx0dHBfaW5zdC5fb25TZWxlY3RIYW5kbGVyKCk7XG5cdFx0XHRcdFx0XHR0cF9pbnN0Ll9hZnRlckluamVjdCgpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0fSxcblx0XHRcdFx0b3B0aW9uczogZnVuY3Rpb24gKHRwX2luc3QsIG9iaiwgdW5pdCwgb3B0cywgdmFsKSB7XG5cdFx0XHRcdFx0dmFyIG8gPSB7fSxcblx0XHRcdFx0XHRcdCR0ID0gb2JqLmNoaWxkcmVuKCdzZWxlY3QnKTtcblx0XHRcdFx0XHRpZiAodHlwZW9mKG9wdHMpID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiAkdC5kYXRhKG9wdHMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0b1tvcHRzXSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7IG8gPSBvcHRzOyB9XG5cdFx0XHRcdFx0cmV0dXJuIHRwX2luc3QuY29udHJvbC5jcmVhdGUodHBfaW5zdCwgb2JqLCAkdC5kYXRhKCd1bml0JyksICR0LnZhbCgpLCBvLm1pbj49MCA/IG8ubWluIDogJHQuZGF0YSgnbWluJyksIG8ubWF4IHx8ICR0LmRhdGEoJ21heCcpLCBvLnN0ZXAgfHwgJHQuZGF0YSgnc3RlcCcpKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dmFsdWU6IGZ1bmN0aW9uICh0cF9pbnN0LCBvYmosIHVuaXQsIHZhbCkge1xuXHRcdFx0XHRcdHZhciAkdCA9IG9iai5jaGlsZHJlbignc2VsZWN0Jyk7XG5cdFx0XHRcdFx0aWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJHQudmFsKHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiAkdC52YWwoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gLy8gZW5kIF9jb250cm9sc1xuXG5cdH0pO1xuXG5cdCQuZm4uZXh0ZW5kKHtcblx0XHQvKlxuXHRcdCogc2hvcnRoYW5kIGp1c3QgdG8gdXNlIHRpbWVwaWNrZXIuXG5cdFx0Ki9cblx0XHR0aW1lcGlja2VyOiBmdW5jdGlvbiAobykge1xuXHRcdFx0byA9IG8gfHwge307XG5cdFx0XHR2YXIgdG1wX2FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG5cdFx0XHRpZiAodHlwZW9mIG8gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHRtcF9hcmdzWzBdID0gJC5leHRlbmQobywge1xuXHRcdFx0XHRcdHRpbWVPbmx5OiB0cnVlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0JC5mbi5kYXRldGltZXBpY2tlci5hcHBseSgkKHRoaXMpLCB0bXBfYXJncyk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Lypcblx0XHQqIGV4dGVuZCB0aW1lcGlja2VyIHRvIGRhdGVwaWNrZXJcblx0XHQqL1xuXHRcdGRhdGV0aW1lcGlja2VyOiBmdW5jdGlvbiAobykge1xuXHRcdFx0byA9IG8gfHwge307XG5cdFx0XHR2YXIgdG1wX2FyZ3MgPSBhcmd1bWVudHM7XG5cblx0XHRcdGlmICh0eXBlb2YobykgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGlmIChvID09PSAnZ2V0RGF0ZScgIHx8IChvID09PSAnb3B0aW9uJyAmJiB0bXBfYXJncy5sZW5ndGggPT09IDIgJiYgdHlwZW9mICh0bXBfYXJnc1sxXSkgPT09ICdzdHJpbmcnKSkge1xuXHRcdFx0XHRcdHJldHVybiAkLmZuLmRhdGVwaWNrZXIuYXBwbHkoJCh0aGlzWzBdKSwgdG1wX2FyZ3MpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dmFyICR0ID0gJCh0aGlzKTtcblx0XHRcdFx0XHRcdCR0LmRhdGVwaWNrZXIuYXBwbHkoJHQsIHRtcF9hcmdzKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyICR0ID0gJCh0aGlzKTtcblx0XHRcdFx0XHQkdC5kYXRlcGlja2VyKCQudGltZXBpY2tlci5fbmV3SW5zdCgkdCwgbykuX2RlZmF1bHRzKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQvKlxuXHQqIFB1YmxpYyBVdGlsaXR5IHRvIHBhcnNlIGRhdGUgYW5kIHRpbWVcblx0Ki9cblx0JC5kYXRlcGlja2VyLnBhcnNlRGF0ZVRpbWUgPSBmdW5jdGlvbiAoZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgZGF0ZVRpbWVTdHJpbmcsIGRhdGVTZXR0aW5ncywgdGltZVNldHRpbmdzKSB7XG5cdFx0dmFyIHBhcnNlUmVzID0gcGFyc2VEYXRlVGltZUludGVybmFsKGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIGRhdGVUaW1lU3RyaW5nLCBkYXRlU2V0dGluZ3MsIHRpbWVTZXR0aW5ncyk7XG5cdFx0aWYgKHBhcnNlUmVzLnRpbWVPYmopIHtcblx0XHRcdHZhciB0ID0gcGFyc2VSZXMudGltZU9iajtcblx0XHRcdHBhcnNlUmVzLmRhdGUuc2V0SG91cnModC5ob3VyLCB0Lm1pbnV0ZSwgdC5zZWNvbmQsIHQubWlsbGlzZWMpO1xuXHRcdFx0cGFyc2VSZXMuZGF0ZS5zZXRNaWNyb3NlY29uZHModC5taWNyb3NlYyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhcnNlUmVzLmRhdGU7XG5cdH07XG5cblx0Lypcblx0KiBQdWJsaWMgdXRpbGl0eSB0byBwYXJzZSB0aW1lXG5cdCovXG5cdCQuZGF0ZXBpY2tlci5wYXJzZVRpbWUgPSBmdW5jdGlvbiAodGltZUZvcm1hdCwgdGltZVN0cmluZywgb3B0aW9ucykge1xuXHRcdHZhciBvID0gZXh0ZW5kUmVtb3ZlKGV4dGVuZFJlbW92ZSh7fSwgJC50aW1lcGlja2VyLl9kZWZhdWx0cyksIG9wdGlvbnMgfHwge30pLFxuXHRcdFx0aXNvODYwMSA9ICh0aW1lRm9ybWF0LnJlcGxhY2UoL1xcJy4qP1xcJy9nLCAnJykuaW5kZXhPZignWicpICE9PSAtMSk7XG5cblx0XHQvLyBTdHJpY3QgcGFyc2UgcmVxdWlyZXMgdGhlIHRpbWVTdHJpbmcgdG8gbWF0Y2ggdGhlIHRpbWVGb3JtYXQgZXhhY3RseVxuXHRcdHZhciBzdHJpY3RQYXJzZSA9IGZ1bmN0aW9uIChmLCBzLCBvKSB7XG5cblx0XHRcdC8vIHBhdHRlcm4gZm9yIHN0YW5kYXJkIGFuZCBsb2NhbGl6ZWQgQU0vUE0gbWFya2Vyc1xuXHRcdFx0dmFyIGdldFBhdHRlcm5BbXBtID0gZnVuY3Rpb24gKGFtTmFtZXMsIHBtTmFtZXMpIHtcblx0XHRcdFx0dmFyIG1hcmtlcnMgPSBbXTtcblx0XHRcdFx0aWYgKGFtTmFtZXMpIHtcblx0XHRcdFx0XHQkLm1lcmdlKG1hcmtlcnMsIGFtTmFtZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwbU5hbWVzKSB7XG5cdFx0XHRcdFx0JC5tZXJnZShtYXJrZXJzLCBwbU5hbWVzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtYXJrZXJzID0gJC5tYXAobWFya2VycywgZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0XHRcdHJldHVybiB2YWwucmVwbGFjZSgvWy4qKz98KClcXFtcXF17fVxcXFxdL2csICdcXFxcJCYnKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiAnKCcgKyBtYXJrZXJzLmpvaW4oJ3wnKSArICcpPyc7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBmaWd1cmUgb3V0IHBvc2l0aW9uIG9mIHRpbWUgZWxlbWVudHMuLiBjYXVzZSBqcyBjYW50IGRvIG5hbWVkIGNhcHR1cmVzXG5cdFx0XHR2YXIgZ2V0Rm9ybWF0UG9zaXRpb25zID0gZnVuY3Rpb24gKHRpbWVGb3JtYXQpIHtcblx0XHRcdFx0dmFyIGZpbmRzID0gdGltZUZvcm1hdC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oaHsxLDJ9fG17MSwyfXxzezEsMn18bHsxfXxjezF9fHR7MSwyfXx6fCcuKj8nKS9nKSxcblx0XHRcdFx0XHRvcmRlcnMgPSB7XG5cdFx0XHRcdFx0XHRoOiAtMSxcblx0XHRcdFx0XHRcdG06IC0xLFxuXHRcdFx0XHRcdFx0czogLTEsXG5cdFx0XHRcdFx0XHRsOiAtMSxcblx0XHRcdFx0XHRcdGM6IC0xLFxuXHRcdFx0XHRcdFx0dDogLTEsXG5cdFx0XHRcdFx0XHR6OiAtMVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKGZpbmRzKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmaW5kcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKG9yZGVyc1tmaW5kc1tpXS50b1N0cmluZygpLmNoYXJBdCgwKV0gPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdG9yZGVyc1tmaW5kc1tpXS50b1N0cmluZygpLmNoYXJBdCgwKV0gPSBpICsgMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9yZGVycztcblx0XHRcdH07XG5cblx0XHRcdHZhciByZWdzdHIgPSAnXicgKyBmLnRvU3RyaW5nKClcblx0XHRcdFx0XHQucmVwbGFjZSgvKFtoSF17MSwyfXxtbT98c3M/fFt0VF17MSwyfXxbelpdfFtsY118Jy4qPycpL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbWwgPSBtYXRjaC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAobWF0Y2guY2hhckF0KDApLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSAnaCc6XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG1sID09PSAxID8gJyhcXFxcZD9cXFxcZCknIDogJyhcXFxcZHsnICsgbWwgKyAnfSknO1xuXHRcdFx0XHRcdFx0XHRjYXNlICdtJzpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbWwgPT09IDEgPyAnKFxcXFxkP1xcXFxkKScgOiAnKFxcXFxkeycgKyBtbCArICd9KSc7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3MnOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBtbCA9PT0gMSA/ICcoXFxcXGQ/XFxcXGQpJyA6ICcoXFxcXGR7JyArIG1sICsgJ30pJztcblx0XHRcdFx0XHRcdFx0Y2FzZSAnbCc6XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICcoXFxcXGQ/XFxcXGQ/XFxcXGQpJztcblx0XHRcdFx0XHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICcoXFxcXGQ/XFxcXGQ/XFxcXGQpJztcblx0XHRcdFx0XHRcdFx0Y2FzZSAneic6XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICcoenxbLStdXFxcXGRcXFxcZDo/XFxcXGRcXFxcZHxcXFxcUyspPyc7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3QnOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBnZXRQYXR0ZXJuQW1wbShvLmFtTmFtZXMsIG8ucG1OYW1lcyk7XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHQ6ICAgIC8vIGxpdGVyYWwgZXNjYXBlZCBpbiBxdW90ZXNcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gJygnICsgbWF0Y2gucmVwbGFjZSgvXFwnL2csIFwiXCIpLnJlcGxhY2UoLyhcXC58XFwkfFxcXnxcXFxcfFxcL3xcXCh8XFwpfFxcW3xcXF18XFw/fFxcK3xcXCopL2csIGZ1bmN0aW9uIChtKSB7IHJldHVybiBcIlxcXFxcIiArIG07IH0pICsgJyk/Jztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQucmVwbGFjZSgvXFxzL2csICdcXFxccz8nKSArXG5cdFx0XHRcdFx0by50aW1lU3VmZml4ICsgJyQnLFxuXHRcdFx0XHRvcmRlciA9IGdldEZvcm1hdFBvc2l0aW9ucyhmKSxcblx0XHRcdFx0YW1wbSA9ICcnLFxuXHRcdFx0XHR0cmVnO1xuXG5cdFx0XHR0cmVnID0gcy5tYXRjaChuZXcgUmVnRXhwKHJlZ3N0ciwgJ2knKSk7XG5cblx0XHRcdHZhciByZXNUaW1lID0ge1xuXHRcdFx0XHRob3VyOiAwLFxuXHRcdFx0XHRtaW51dGU6IDAsXG5cdFx0XHRcdHNlY29uZDogMCxcblx0XHRcdFx0bWlsbGlzZWM6IDAsXG5cdFx0XHRcdG1pY3Jvc2VjOiAwXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAodHJlZykge1xuXHRcdFx0XHRpZiAob3JkZXIudCAhPT0gLTEpIHtcblx0XHRcdFx0XHRpZiAodHJlZ1tvcmRlci50XSA9PT0gdW5kZWZpbmVkIHx8IHRyZWdbb3JkZXIudF0ubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRhbXBtID0gJyc7XG5cdFx0XHRcdFx0XHRyZXNUaW1lLmFtcG0gPSAnJztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YW1wbSA9ICQuaW5BcnJheSh0cmVnW29yZGVyLnRdLnRvVXBwZXJDYXNlKCksICQubWFwKG8uYW1OYW1lcywgZnVuY3Rpb24gKHgsaSkgeyByZXR1cm4geC50b1VwcGVyQ2FzZSgpOyB9KSkgIT09IC0xID8gJ0FNJyA6ICdQTSc7XG5cdFx0XHRcdFx0XHRyZXNUaW1lLmFtcG0gPSBvW2FtcG0gPT09ICdBTScgPyAnYW1OYW1lcycgOiAncG1OYW1lcyddWzBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChvcmRlci5oICE9PSAtMSkge1xuXHRcdFx0XHRcdGlmIChhbXBtID09PSAnQU0nICYmIHRyZWdbb3JkZXIuaF0gPT09ICcxMicpIHtcblx0XHRcdFx0XHRcdHJlc1RpbWUuaG91ciA9IDA7IC8vIDEyYW0gPSAwIGhvdXJcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKGFtcG0gPT09ICdQTScgJiYgdHJlZ1tvcmRlci5oXSAhPT0gJzEyJykge1xuXHRcdFx0XHRcdFx0XHRyZXNUaW1lLmhvdXIgPSBwYXJzZUludCh0cmVnW29yZGVyLmhdLCAxMCkgKyAxMjsgLy8gMTJwbSA9IDEyIGhvdXIsIGFueSBvdGhlciBwbSA9IGhvdXIgKyAxMlxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmVzVGltZS5ob3VyID0gTnVtYmVyKHRyZWdbb3JkZXIuaF0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChvcmRlci5tICE9PSAtMSkge1xuXHRcdFx0XHRcdHJlc1RpbWUubWludXRlID0gTnVtYmVyKHRyZWdbb3JkZXIubV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvcmRlci5zICE9PSAtMSkge1xuXHRcdFx0XHRcdHJlc1RpbWUuc2Vjb25kID0gTnVtYmVyKHRyZWdbb3JkZXIuc10pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvcmRlci5sICE9PSAtMSkge1xuXHRcdFx0XHRcdHJlc1RpbWUubWlsbGlzZWMgPSBOdW1iZXIodHJlZ1tvcmRlci5sXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9yZGVyLmMgIT09IC0xKSB7XG5cdFx0XHRcdFx0cmVzVGltZS5taWNyb3NlYyA9IE51bWJlcih0cmVnW29yZGVyLmNdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob3JkZXIueiAhPT0gLTEgJiYgdHJlZ1tvcmRlci56XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmVzVGltZS50aW1lem9uZSA9ICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldE51bWJlcih0cmVnW29yZGVyLnpdKTtcblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0cmV0dXJuIHJlc1RpbWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTsvLyBlbmQgc3RyaWN0UGFyc2VcblxuXHRcdC8vIEZpcnN0IHRyeSBKUyBEYXRlLCBpZiB0aGF0IGZhaWxzLCB1c2Ugc3RyaWN0UGFyc2Vcblx0XHR2YXIgbG9vc2VQYXJzZSA9IGZ1bmN0aW9uIChmLCBzLCBvKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgZCA9IG5ldyBEYXRlKCcyMDEyLTAxLTAxICcgKyBzKTtcblx0XHRcdFx0aWYgKGlzTmFOKGQuZ2V0VGltZSgpKSkge1xuXHRcdFx0XHRcdGQgPSBuZXcgRGF0ZSgnMjAxMi0wMS0wMVQnICsgcyk7XG5cdFx0XHRcdFx0aWYgKGlzTmFOKGQuZ2V0VGltZSgpKSkge1xuXHRcdFx0XHRcdFx0ZCA9IG5ldyBEYXRlKCcwMS8wMS8yMDEyICcgKyBzKTtcblx0XHRcdFx0XHRcdGlmIChpc05hTihkLmdldFRpbWUoKSkpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgXCJVbmFibGUgdG8gcGFyc2UgdGltZSB3aXRoIG5hdGl2ZSBEYXRlOiBcIiArIHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRob3VyOiBkLmdldEhvdXJzKCksXG5cdFx0XHRcdFx0bWludXRlOiBkLmdldE1pbnV0ZXMoKSxcblx0XHRcdFx0XHRzZWNvbmQ6IGQuZ2V0U2Vjb25kcygpLFxuXHRcdFx0XHRcdG1pbGxpc2VjOiBkLmdldE1pbGxpc2Vjb25kcygpLFxuXHRcdFx0XHRcdG1pY3Jvc2VjOiBkLmdldE1pY3Jvc2Vjb25kcygpLFxuXHRcdFx0XHRcdHRpbWV6b25lOiBkLmdldFRpbWV6b25lT2Zmc2V0KCkgKiAtMVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiBzdHJpY3RQYXJzZShmLCBzLCBvKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZXJyMikge1xuXHRcdFx0XHRcdCQudGltZXBpY2tlci5sb2coXCJVbmFibGUgdG8gcGFyc2UgXFxudGltZVN0cmluZzogXCIgKyBzICsgXCJcXG50aW1lRm9ybWF0OiBcIiArIGYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTsgLy8gZW5kIGxvb3NlUGFyc2VcblxuXHRcdGlmICh0eXBlb2Ygby5wYXJzZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRyZXR1cm4gby5wYXJzZSh0aW1lRm9ybWF0LCB0aW1lU3RyaW5nLCBvKTtcblx0XHR9XG5cdFx0aWYgKG8ucGFyc2UgPT09ICdsb29zZScpIHtcblx0XHRcdHJldHVybiBsb29zZVBhcnNlKHRpbWVGb3JtYXQsIHRpbWVTdHJpbmcsIG8pO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RyaWN0UGFyc2UodGltZUZvcm1hdCwgdGltZVN0cmluZywgbyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFB1YmxpYyB1dGlsaXR5IHRvIGZvcm1hdCB0aGUgdGltZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IGZvcm1hdCBvZiB0aGUgdGltZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGltZSBPYmplY3Qgbm90IGEgRGF0ZSBmb3IgdGltZXpvbmVzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gZXNzZW50aWFsbHkgdGhlIHJlZ2lvbmFsW10uLiBhbU5hbWVzLCBwbU5hbWVzLCBhbXBtXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBmb3JtYXR0ZWQgdGltZVxuXHQgKi9cblx0JC5kYXRlcGlja2VyLmZvcm1hdFRpbWUgPSBmdW5jdGlvbiAoZm9ybWF0LCB0aW1lLCBvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0b3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCAkLnRpbWVwaWNrZXIuX2RlZmF1bHRzLCBvcHRpb25zKTtcblx0XHR0aW1lID0gJC5leHRlbmQoe1xuXHRcdFx0aG91cjogMCxcblx0XHRcdG1pbnV0ZTogMCxcblx0XHRcdHNlY29uZDogMCxcblx0XHRcdG1pbGxpc2VjOiAwLFxuXHRcdFx0bWljcm9zZWM6IDAsXG5cdFx0XHR0aW1lem9uZTogbnVsbFxuXHRcdH0sIHRpbWUpO1xuXG5cdFx0dmFyIHRtcHRpbWUgPSBmb3JtYXQsXG5cdFx0XHRhbXBtTmFtZSA9IG9wdGlvbnMuYW1OYW1lc1swXSxcblx0XHRcdGhvdXIgPSBwYXJzZUludCh0aW1lLmhvdXIsIDEwKTtcblxuXHRcdGlmIChob3VyID4gMTEpIHtcblx0XHRcdGFtcG1OYW1lID0gb3B0aW9ucy5wbU5hbWVzWzBdO1xuXHRcdH1cblxuXHRcdHRtcHRpbWUgPSB0bXB0aW1lLnJlcGxhY2UoLyg/OkhIP3xoaD98bW0/fHNzP3xbdFRdezEsMn18W3paXXxbbGNdfCcuKj8nKS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcblx0XHRcdHN3aXRjaCAobWF0Y2gpIHtcblx0XHRcdGNhc2UgJ0hIJzpcblx0XHRcdFx0cmV0dXJuICgnMCcgKyBob3VyKS5zbGljZSgtMik7XG5cdFx0XHRjYXNlICdIJzpcblx0XHRcdFx0cmV0dXJuIGhvdXI7XG5cdFx0XHRjYXNlICdoaCc6XG5cdFx0XHRcdHJldHVybiAoJzAnICsgY29udmVydDI0dG8xMihob3VyKSkuc2xpY2UoLTIpO1xuXHRcdFx0Y2FzZSAnaCc6XG5cdFx0XHRcdHJldHVybiBjb252ZXJ0MjR0bzEyKGhvdXIpO1xuXHRcdFx0Y2FzZSAnbW0nOlxuXHRcdFx0XHRyZXR1cm4gKCcwJyArIHRpbWUubWludXRlKS5zbGljZSgtMik7XG5cdFx0XHRjYXNlICdtJzpcblx0XHRcdFx0cmV0dXJuIHRpbWUubWludXRlO1xuXHRcdFx0Y2FzZSAnc3MnOlxuXHRcdFx0XHRyZXR1cm4gKCcwJyArIHRpbWUuc2Vjb25kKS5zbGljZSgtMik7XG5cdFx0XHRjYXNlICdzJzpcblx0XHRcdFx0cmV0dXJuIHRpbWUuc2Vjb25kO1xuXHRcdFx0Y2FzZSAnbCc6XG5cdFx0XHRcdHJldHVybiAoJzAwJyArIHRpbWUubWlsbGlzZWMpLnNsaWNlKC0zKTtcblx0XHRcdGNhc2UgJ2MnOlxuXHRcdFx0XHRyZXR1cm4gKCcwMCcgKyB0aW1lLm1pY3Jvc2VjKS5zbGljZSgtMyk7XG5cdFx0XHRjYXNlICd6Jzpcblx0XHRcdFx0cmV0dXJuICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldFN0cmluZyh0aW1lLnRpbWV6b25lID09PSBudWxsID8gb3B0aW9ucy50aW1lem9uZSA6IHRpbWUudGltZXpvbmUsIGZhbHNlKTtcblx0XHRcdGNhc2UgJ1onOlxuXHRcdFx0XHRyZXR1cm4gJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0U3RyaW5nKHRpbWUudGltZXpvbmUgPT09IG51bGwgPyBvcHRpb25zLnRpbWV6b25lIDogdGltZS50aW1lem9uZSwgdHJ1ZSk7XG5cdFx0XHRjYXNlICdUJzpcblx0XHRcdFx0cmV0dXJuIGFtcG1OYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0Y2FzZSAnVFQnOlxuXHRcdFx0XHRyZXR1cm4gYW1wbU5hbWUudG9VcHBlckNhc2UoKTtcblx0XHRcdGNhc2UgJ3QnOlxuXHRcdFx0XHRyZXR1cm4gYW1wbU5hbWUuY2hhckF0KDApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRjYXNlICd0dCc6XG5cdFx0XHRcdHJldHVybiBhbXBtTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIG1hdGNoLnJlcGxhY2UoLycvZywgXCJcIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdG1wdGltZTtcblx0fTtcblxuXHQvKlxuXHQqIHRoZSBiYWQgaGFjayA6LyBvdmVycmlkZSBkYXRlcGlja2VyIHNvIGl0IGRvZXNuJ3QgY2xvc2Ugb24gc2VsZWN0XG5cdC8vIGluc3BpcmVkOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNTI1MTIvanF1ZXJ5LWRhdGVwaWNrZXItcHJldmVudC1jbG9zaW5nLXBpY2tlci13aGVuLWNsaWNraW5nLWEtZGF0ZS8xNzYyMzc4IzE3NjIzNzhcblx0Ki9cblx0JC5kYXRlcGlja2VyLl9iYXNlX3NlbGVjdERhdGUgPSAkLmRhdGVwaWNrZXIuX3NlbGVjdERhdGU7XG5cdCQuZGF0ZXBpY2tlci5fc2VsZWN0RGF0ZSA9IGZ1bmN0aW9uIChpZCwgZGF0ZVN0cikge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCgkKGlkKVswXSksXG5cdFx0XHR0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyksXG5cdFx0XHR3YXNfaW5saW5lO1xuXG5cdFx0aWYgKHRwX2luc3QgJiYgaW5zdC5zZXR0aW5ncy5zaG93VGltZXBpY2tlcikge1xuXHRcdFx0dHBfaW5zdC5fbGltaXRNaW5NYXhEYXRlVGltZShpbnN0LCB0cnVlKTtcblx0XHRcdHdhc19pbmxpbmUgPSBpbnN0LmlubGluZTtcblx0XHRcdGluc3QuaW5saW5lID0gaW5zdC5zdGF5X29wZW4gPSB0cnVlO1xuXHRcdFx0Ly9UaGlzIHdheSB0aGUgb25TZWxlY3QgaGFuZGxlciBjYWxsZWQgZnJvbSBjYWxlbmRhcnBpY2tlciBnZXQgdGhlIGZ1bGwgZGF0ZVRpbWVcblx0XHRcdHRoaXMuX2Jhc2Vfc2VsZWN0RGF0ZShpZCwgZGF0ZVN0cik7XG5cdFx0XHRpbnN0LmlubGluZSA9IHdhc19pbmxpbmU7XG5cdFx0XHRpbnN0LnN0YXlfb3BlbiA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKGluc3QpO1xuXHRcdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fYmFzZV9zZWxlY3REYXRlKGlkLCBkYXRlU3RyKTtcblx0XHR9XG5cdH07XG5cblx0Lypcblx0KiBzZWNvbmQgYmFkIGhhY2sgOi8gb3ZlcnJpZGUgZGF0ZXBpY2tlciBzbyBpdCB0cmlnZ2VycyBhbiBldmVudCB3aGVuIGNoYW5naW5nIHRoZSBpbnB1dCBmaWVsZFxuXHQqIGFuZCBkb2VzIG5vdCByZWRyYXcgdGhlIGRhdGVwaWNrZXIgb24gZXZlcnkgc2VsZWN0RGF0ZSBldmVudFxuXHQqL1xuXHQkLmRhdGVwaWNrZXIuX2Jhc2VfdXBkYXRlRGF0ZXBpY2tlciA9ICQuZGF0ZXBpY2tlci5fdXBkYXRlRGF0ZXBpY2tlcjtcblx0JC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyID0gZnVuY3Rpb24gKGluc3QpIHtcblxuXHRcdC8vIGRvbid0IHBvcHVwIHRoZSBkYXRlcGlja2VyIGlmIHRoZXJlIGlzIGFub3RoZXIgaW5zdGFuY2UgYWxyZWFkeSBvcGVuZWRcblx0XHR2YXIgaW5wdXQgPSBpbnN0LmlucHV0WzBdO1xuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2N1ckluc3QgJiYgJC5kYXRlcGlja2VyLl9jdXJJbnN0ICE9PSBpbnN0ICYmICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgJiYgJC5kYXRlcGlja2VyLl9sYXN0SW5wdXQgIT09IGlucHV0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZihpbnN0LnN0YXlfb3BlbikgIT09ICdib29sZWFuJyB8fCBpbnN0LnN0YXlfb3BlbiA9PT0gZmFsc2UpIHtcblxuXHRcdFx0dGhpcy5fYmFzZV91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXG5cdFx0XHQvLyBSZWxvYWQgdGhlIHRpbWUgY29udHJvbCB3aGVuIGNoYW5naW5nIHNvbWV0aGluZyBpbiB0aGUgaW5wdXQgdGV4dCBmaWVsZC5cblx0XHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XG5cdFx0XHRpZiAodHBfaW5zdCkge1xuXHRcdFx0XHR0cF9pbnN0Ll9hZGRUaW1lUGlja2VyKGluc3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKlxuXHQqIHRoaXJkIGJhZCBoYWNrIDovIG92ZXJyaWRlIGRhdGVwaWNrZXIgc28gaXQgYWxsb3dzIHNwYWNlcyBhbmQgY29sb24gaW4gdGhlIGlucHV0IGZpZWxkXG5cdCovXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV9kb0tleVByZXNzID0gJC5kYXRlcGlja2VyLl9kb0tleVByZXNzO1xuXHQkLmRhdGVwaWNrZXIuX2RvS2V5UHJlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgaW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChldmVudC50YXJnZXQpLFxuXHRcdFx0dHBfaW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XG5cblx0XHRpZiAodHBfaW5zdCkge1xuXHRcdFx0aWYgKCQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICdjb25zdHJhaW5JbnB1dCcpKSB7XG5cdFx0XHRcdHZhciBhbXBtID0gdHBfaW5zdC5zdXBwb3J0LmFtcG0sXG5cdFx0XHRcdFx0dHogPSB0cF9pbnN0Ll9kZWZhdWx0cy5zaG93VGltZXpvbmUgIT09IG51bGwgPyB0cF9pbnN0Ll9kZWZhdWx0cy5zaG93VGltZXpvbmUgOiB0cF9pbnN0LnN1cHBvcnQudGltZXpvbmUsXG5cdFx0XHRcdFx0ZGF0ZUNoYXJzID0gJC5kYXRlcGlja2VyLl9wb3NzaWJsZUNoYXJzKCQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICdkYXRlRm9ybWF0JykpLFxuXHRcdFx0XHRcdGRhdGV0aW1lQ2hhcnMgPSB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lRm9ybWF0LnRvU3RyaW5nKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvW2htc10vZywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1RUL2csIGFtcG0gPyAnQVBNJyA6ICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9UdC9nLCBhbXBtID8gJ0FhUHBNbScgOiAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvdFQvZywgYW1wbSA/ICdBYVBwTW0nIDogJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1QvZywgYW1wbSA/ICdBUCcgOiAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvdHQvZywgYW1wbSA/ICdhcG0nIDogJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL3QvZywgYW1wbSA/ICdhcCcgOiAnJykgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiIFwiICsgdHBfaW5zdC5fZGVmYXVsdHMuc2VwYXJhdG9yICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy50aW1lU3VmZml4ICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQodHogPyB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZUxpc3Quam9pbignJykgOiAnJykgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCh0cF9pbnN0Ll9kZWZhdWx0cy5hbU5hbWVzLmpvaW4oJycpKSArICh0cF9pbnN0Ll9kZWZhdWx0cy5wbU5hbWVzLmpvaW4oJycpKSArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0ZUNoYXJzLFxuXHRcdFx0XHRcdGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUgPT09IHVuZGVmaW5lZCA/IGV2ZW50LmtleUNvZGUgOiBldmVudC5jaGFyQ29kZSk7XG5cdFx0XHRcdHJldHVybiBldmVudC5jdHJsS2V5IHx8IChjaHIgPCAnICcgfHwgIWRhdGVDaGFycyB8fCBkYXRldGltZUNoYXJzLmluZGV4T2YoY2hyKSA+IC0xKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gJC5kYXRlcGlja2VyLl9iYXNlX2RvS2V5UHJlc3MoZXZlbnQpO1xuXHR9O1xuXG5cdC8qXG5cdCogRm91cnRoIGJhZCBoYWNrIDovIG92ZXJyaWRlIF91cGRhdGVBbHRlcm5hdGUgZnVuY3Rpb24gdXNlZCBpbiBpbmxpbmUgbW9kZSB0byBpbml0IGFsdEZpZWxkXG5cdCogVXBkYXRlIGFueSBhbHRlcm5hdGUgZmllbGQgdG8gc3luY2hyb25pc2Ugd2l0aCB0aGUgbWFpbiBmaWVsZC5cblx0Ki9cblx0JC5kYXRlcGlja2VyLl9iYXNlX3VwZGF0ZUFsdGVybmF0ZSA9ICQuZGF0ZXBpY2tlci5fdXBkYXRlQWx0ZXJuYXRlO1xuXHQkLmRhdGVwaWNrZXIuX3VwZGF0ZUFsdGVybmF0ZSA9IGZ1bmN0aW9uIChpbnN0KSB7XG5cdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcblx0XHRpZiAodHBfaW5zdCkge1xuXHRcdFx0dmFyIGFsdEZpZWxkID0gdHBfaW5zdC5fZGVmYXVsdHMuYWx0RmllbGQ7XG5cdFx0XHRpZiAoYWx0RmllbGQpIHsgLy8gdXBkYXRlIGFsdGVybmF0ZSBmaWVsZCB0b29cblx0XHRcdFx0dmFyIGFsdEZvcm1hdCA9IHRwX2luc3QuX2RlZmF1bHRzLmFsdEZvcm1hdCB8fCB0cF9pbnN0Ll9kZWZhdWx0cy5kYXRlRm9ybWF0LFxuXHRcdFx0XHRcdGRhdGUgPSB0aGlzLl9nZXREYXRlKGluc3QpLFxuXHRcdFx0XHRcdGZvcm1hdENmZyA9ICQuZGF0ZXBpY2tlci5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpLFxuXHRcdFx0XHRcdGFsdEZvcm1hdHRlZERhdGVUaW1lID0gJycsXG5cdFx0XHRcdFx0YWx0U2VwYXJhdG9yID0gdHBfaW5zdC5fZGVmYXVsdHMuYWx0U2VwYXJhdG9yID8gdHBfaW5zdC5fZGVmYXVsdHMuYWx0U2VwYXJhdG9yIDogdHBfaW5zdC5fZGVmYXVsdHMuc2VwYXJhdG9yLFxuXHRcdFx0XHRcdGFsdFRpbWVTdWZmaXggPSB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRUaW1lU3VmZml4ID8gdHBfaW5zdC5fZGVmYXVsdHMuYWx0VGltZVN1ZmZpeCA6IHRwX2luc3QuX2RlZmF1bHRzLnRpbWVTdWZmaXgsXG5cdFx0XHRcdFx0YWx0VGltZUZvcm1hdCA9IHRwX2luc3QuX2RlZmF1bHRzLmFsdFRpbWVGb3JtYXQgIT09IG51bGwgPyB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRUaW1lRm9ybWF0IDogdHBfaW5zdC5fZGVmYXVsdHMudGltZUZvcm1hdDtcblxuXHRcdFx0XHRhbHRGb3JtYXR0ZWREYXRlVGltZSArPSAkLmRhdGVwaWNrZXIuZm9ybWF0VGltZShhbHRUaW1lRm9ybWF0LCB0cF9pbnN0LCB0cF9pbnN0Ll9kZWZhdWx0cykgKyBhbHRUaW1lU3VmZml4O1xuXHRcdFx0XHRpZiAoIXRwX2luc3QuX2RlZmF1bHRzLnRpbWVPbmx5ICYmICF0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGaWVsZFRpbWVPbmx5ICYmIGRhdGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMuYWx0Rm9ybWF0KSB7XG5cdFx0XHRcdFx0XHRhbHRGb3JtYXR0ZWREYXRlVGltZSA9ICQuZGF0ZXBpY2tlci5mb3JtYXREYXRlKHRwX2luc3QuX2RlZmF1bHRzLmFsdEZvcm1hdCwgZGF0ZSwgZm9ybWF0Q2ZnKSArIGFsdFNlcGFyYXRvciArIGFsdEZvcm1hdHRlZERhdGVUaW1lO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGFsdEZvcm1hdHRlZERhdGVUaW1lID0gdHBfaW5zdC5mb3JtYXR0ZWREYXRlICsgYWx0U2VwYXJhdG9yICsgYWx0Rm9ybWF0dGVkRGF0ZVRpbWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdCQoYWx0RmllbGQpLnZhbCggaW5zdC5pbnB1dC52YWwoKSA/IGFsdEZvcm1hdHRlZERhdGVUaW1lIDogXCJcIik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0JC5kYXRlcGlja2VyLl9iYXNlX3VwZGF0ZUFsdGVybmF0ZShpbnN0KTtcblx0XHR9XG5cdH07XG5cblx0Lypcblx0KiBPdmVycmlkZSBrZXkgdXAgZXZlbnQgdG8gc3luYyBtYW51YWwgaW5wdXQgY2hhbmdlcy5cblx0Ki9cblx0JC5kYXRlcGlja2VyLl9iYXNlX2RvS2V5VXAgPSAkLmRhdGVwaWNrZXIuX2RvS2V5VXA7XG5cdCQuZGF0ZXBpY2tlci5fZG9LZXlVcCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KGV2ZW50LnRhcmdldCksXG5cdFx0XHR0cF9pbnN0ID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcblxuXHRcdGlmICh0cF9pbnN0KSB7XG5cdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMudGltZU9ubHkgJiYgKGluc3QuaW5wdXQudmFsKCkgIT09IGluc3QubGFzdFZhbCkpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdCQudGltZXBpY2tlci5sb2coZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAkLmRhdGVwaWNrZXIuX2Jhc2VfZG9LZXlVcChldmVudCk7XG5cdH07XG5cblx0Lypcblx0KiBvdmVycmlkZSBcIlRvZGF5XCIgYnV0dG9uIHRvIGFsc28gZ3JhYiB0aGUgdGltZSBhbmQgc2V0IGl0IHRvIGlucHV0IGZpZWxkLlxuXHQqL1xuXHQkLmRhdGVwaWNrZXIuX2Jhc2VfZ290b1RvZGF5ID0gJC5kYXRlcGlja2VyLl9nb3RvVG9kYXk7XG5cdCQuZGF0ZXBpY2tlci5fZ290b1RvZGF5ID0gZnVuY3Rpb24gKGlkKSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KCQoaWQpWzBdKTtcblx0XHR0aGlzLl9iYXNlX2dvdG9Ub2RheShpZCk7XG5cdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcblx0XHRpZiAoIXRwX2luc3QpIHtcblx0XHQgIHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdHpvZmZzZXQgPSAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXROdW1iZXIodHBfaW5zdC50aW1lem9uZSk7XG5cdFx0dmFyIG5vdyA9IG5ldyBEYXRlKCk7XG5cdFx0bm93LnNldE1pbnV0ZXMobm93LmdldE1pbnV0ZXMoKSArIG5vdy5nZXRUaW1lem9uZU9mZnNldCgpICsgcGFyc2VJbnQodHpvZmZzZXQsIDEwKSk7XG5cdFx0dGhpcy5fc2V0VGltZShpbnN0LCBub3cpO1xuXHRcdHRoaXMuX3NldERhdGUoaW5zdCwgbm93KTtcblx0XHR0cF9pbnN0Ll9vblNlbGVjdEhhbmRsZXIoKTtcblx0fTtcblxuXHQvKlxuXHQqIERpc2FibGUgJiBlbmFibGUgdGhlIFRpbWUgaW4gdGhlIGRhdGV0aW1lcGlja2VyXG5cdCovXG5cdCQuZGF0ZXBpY2tlci5fZGlzYWJsZVRpbWVwaWNrZXJEYXRlcGlja2VyID0gZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xuXHRcdGlmICghaW5zdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XG5cdFx0JCh0YXJnZXQpLmRhdGVwaWNrZXIoJ2dldERhdGUnKTsgLy8gSW5pdCBzZWxlY3RlZFtZZWFyfE1vbnRofERheV1cblx0XHRpZiAodHBfaW5zdCkge1xuXHRcdFx0aW5zdC5zZXR0aW5ncy5zaG93VGltZXBpY2tlciA9IGZhbHNlO1xuXHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMuc2hvd1RpbWVwaWNrZXIgPSBmYWxzZTtcblx0XHRcdHRwX2luc3QuX3VwZGF0ZURhdGVUaW1lKGluc3QpO1xuXHRcdH1cblx0fTtcblxuXHQkLmRhdGVwaWNrZXIuX2VuYWJsZVRpbWVwaWNrZXJEYXRlcGlja2VyID0gZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xuXHRcdGlmICghaW5zdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XG5cdFx0JCh0YXJnZXQpLmRhdGVwaWNrZXIoJ2dldERhdGUnKTsgLy8gSW5pdCBzZWxlY3RlZFtZZWFyfE1vbnRofERheV1cblx0XHRpZiAodHBfaW5zdCkge1xuXHRcdFx0aW5zdC5zZXR0aW5ncy5zaG93VGltZXBpY2tlciA9IHRydWU7XG5cdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5zaG93VGltZXBpY2tlciA9IHRydWU7XG5cdFx0XHR0cF9pbnN0Ll9hZGRUaW1lUGlja2VyKGluc3QpOyAvLyBDb3VsZCBiZSBkaXNhYmxlZCBvbiBwYWdlIGxvYWRcblx0XHRcdHRwX2luc3QuX3VwZGF0ZURhdGVUaW1lKGluc3QpO1xuXHRcdH1cblx0fTtcblxuXHQvKlxuXHQqIENyZWF0ZSBvdXIgb3duIHNldCB0aW1lIGZ1bmN0aW9uXG5cdCovXG5cdCQuZGF0ZXBpY2tlci5fc2V0VGltZSA9IGZ1bmN0aW9uIChpbnN0LCBkYXRlKSB7XG5cdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcblx0XHRpZiAodHBfaW5zdCkge1xuXHRcdFx0dmFyIGRlZmF1bHRzID0gdHBfaW5zdC5fZGVmYXVsdHM7XG5cblx0XHRcdC8vIGNhbGxpbmcgX3NldFRpbWUgd2l0aCBubyBkYXRlIHNldHMgdGltZSB0byBkZWZhdWx0c1xuXHRcdFx0dHBfaW5zdC5ob3VyID0gZGF0ZSA/IGRhdGUuZ2V0SG91cnMoKSA6IGRlZmF1bHRzLmhvdXI7XG5cdFx0XHR0cF9pbnN0Lm1pbnV0ZSA9IGRhdGUgPyBkYXRlLmdldE1pbnV0ZXMoKSA6IGRlZmF1bHRzLm1pbnV0ZTtcblx0XHRcdHRwX2luc3Quc2Vjb25kID0gZGF0ZSA/IGRhdGUuZ2V0U2Vjb25kcygpIDogZGVmYXVsdHMuc2Vjb25kO1xuXHRcdFx0dHBfaW5zdC5taWxsaXNlYyA9IGRhdGUgPyBkYXRlLmdldE1pbGxpc2Vjb25kcygpIDogZGVmYXVsdHMubWlsbGlzZWM7XG5cdFx0XHR0cF9pbnN0Lm1pY3Jvc2VjID0gZGF0ZSA/IGRhdGUuZ2V0TWljcm9zZWNvbmRzKCkgOiBkZWZhdWx0cy5taWNyb3NlYztcblxuXHRcdFx0Ly9jaGVjayBpZiB3aXRoaW4gbWluL21heCB0aW1lcy4uXG5cdFx0XHR0cF9pbnN0Ll9saW1pdE1pbk1heERhdGVUaW1lKGluc3QsIHRydWUpO1xuXG5cdFx0XHR0cF9pbnN0Ll9vblRpbWVDaGFuZ2UoKTtcblx0XHRcdHRwX2luc3QuX3VwZGF0ZURhdGVUaW1lKGluc3QpO1xuXHRcdH1cblx0fTtcblxuXHQvKlxuXHQqIENyZWF0ZSBuZXcgcHVibGljIG1ldGhvZCB0byBzZXQgb25seSB0aW1lLCBjYWxsYWJsZSBhcyAkKCkuZGF0ZXBpY2tlcignc2V0VGltZScsIGRhdGUpXG5cdCovXG5cdCQuZGF0ZXBpY2tlci5fc2V0VGltZURhdGVwaWNrZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBkYXRlLCB3aXRoRGF0ZSkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xuXHRcdGlmICghaW5zdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XG5cblx0XHRpZiAodHBfaW5zdCkge1xuXHRcdFx0dGhpcy5fc2V0RGF0ZUZyb21GaWVsZChpbnN0KTtcblx0XHRcdHZhciB0cF9kYXRlO1xuXHRcdFx0aWYgKGRhdGUpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBkYXRlID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0dHBfaW5zdC5fcGFyc2VUaW1lKGRhdGUsIHdpdGhEYXRlKTtcblx0XHRcdFx0XHR0cF9kYXRlID0gbmV3IERhdGUoKTtcblx0XHRcdFx0XHR0cF9kYXRlLnNldEhvdXJzKHRwX2luc3QuaG91ciwgdHBfaW5zdC5taW51dGUsIHRwX2luc3Quc2Vjb25kLCB0cF9pbnN0Lm1pbGxpc2VjKTtcblx0XHRcdFx0XHR0cF9kYXRlLnNldE1pY3Jvc2Vjb25kcyh0cF9pbnN0Lm1pY3Jvc2VjKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0cF9kYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xuXHRcdFx0XHRcdHRwX2RhdGUuc2V0TWljcm9zZWNvbmRzKGRhdGUuZ2V0TWljcm9zZWNvbmRzKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0cF9kYXRlLnRvU3RyaW5nKCkgPT09ICdJbnZhbGlkIERhdGUnKSB7XG5cdFx0XHRcdFx0dHBfZGF0ZSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9zZXRUaW1lKGluc3QsIHRwX2RhdGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9O1xuXG5cdC8qXG5cdCogb3ZlcnJpZGUgc2V0RGF0ZSgpIHRvIGFsbG93IHNldHRpbmcgdGltZSB0b28gd2l0aGluIERhdGUgb2JqZWN0XG5cdCovXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV9zZXREYXRlRGF0ZXBpY2tlciA9ICQuZGF0ZXBpY2tlci5fc2V0RGF0ZURhdGVwaWNrZXI7XG5cdCQuZGF0ZXBpY2tlci5fc2V0RGF0ZURhdGVwaWNrZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBfZGF0ZSkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xuXHRcdHZhciBkYXRlID0gX2RhdGU7XG5cdFx0aWYgKCFpbnN0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZihfZGF0ZSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRkYXRlID0gbmV3IERhdGUoX2RhdGUpO1xuXHRcdFx0aWYgKCFkYXRlLmdldFRpbWUoKSkge1xuXHRcdFx0XHR0aGlzLl9iYXNlX3NldERhdGVEYXRlcGlja2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdGRhdGUgPSAkKHRhcmdldCkuZGF0ZXBpY2tlcignZ2V0RGF0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XG5cdFx0dmFyIHRwX2RhdGU7XG5cdFx0aWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0XHR0cF9kYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xuXHRcdFx0dHBfZGF0ZS5zZXRNaWNyb3NlY29uZHMoZGF0ZS5nZXRNaWNyb3NlY29uZHMoKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRwX2RhdGUgPSBkYXRlO1xuXHRcdH1cblxuXHRcdC8vIFRoaXMgaXMgaW1wb3J0YW50IGlmIHlvdSBhcmUgdXNpbmcgdGhlIHRpbWV6b25lIG9wdGlvbiwgamF2YXNjcmlwdCdzIERhdGVcblx0XHQvLyBvYmplY3Qgd2lsbCBvbmx5IHJldHVybiB0aGUgdGltZXpvbmUgb2Zmc2V0IGZvciB0aGUgY3VycmVudCBsb2NhbGUsIHNvIHdlXG5cdFx0Ly8gYWRqdXN0IGl0IGFjY29yZGluZ2x5LiAgSWYgbm90IHVzaW5nIHRpbWV6b25lIG9wdGlvbiB0aGlzIHdvbid0IG1hdHRlci4uXG5cdFx0Ly8gSWYgYSB0aW1lem9uZSBpcyBkaWZmZXJlbnQgaW4gdHAsIGtlZXAgdGhlIHRpbWV6b25lIGFzIGlzXG5cdFx0aWYgKHRwX2luc3QgJiYgdHBfZGF0ZSkge1xuXHRcdFx0Ly8gbG9vayBvdXQgZm9yIERTVCBpZiB0eiB3YXNuJ3Qgc3BlY2lmaWVkXG5cdFx0XHRpZiAoIXRwX2luc3Quc3VwcG9ydC50aW1lem9uZSAmJiB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZSA9PT0gbnVsbCkge1xuXHRcdFx0XHR0cF9pbnN0LnRpbWV6b25lID0gdHBfZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogLTE7XG5cdFx0XHR9XG5cdFx0XHRkYXRlID0gJC50aW1lcGlja2VyLnRpbWV6b25lQWRqdXN0KGRhdGUsICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldFN0cmluZygtZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpKSwgdHBfaW5zdC50aW1lem9uZSk7XG5cdFx0XHR0cF9kYXRlID0gJC50aW1lcGlja2VyLnRpbWV6b25lQWRqdXN0KHRwX2RhdGUsICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldFN0cmluZygtdHBfZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpKSwgdHBfaW5zdC50aW1lem9uZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHR0aGlzLl9iYXNlX3NldERhdGVEYXRlcGlja2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2V0VGltZURhdGVwaWNrZXIodGFyZ2V0LCB0cF9kYXRlLCB0cnVlKTtcblx0fTtcblxuXHQvKlxuXHQqIG92ZXJyaWRlIGdldERhdGUoKSB0byBhbGxvdyBnZXR0aW5nIHRpbWUgdG9vIHdpdGhpbiBEYXRlIG9iamVjdFxuXHQqL1xuXHQkLmRhdGVwaWNrZXIuX2Jhc2VfZ2V0RGF0ZURhdGVwaWNrZXIgPSAkLmRhdGVwaWNrZXIuX2dldERhdGVEYXRlcGlja2VyO1xuXHQkLmRhdGVwaWNrZXIuX2dldERhdGVEYXRlcGlja2VyID0gZnVuY3Rpb24gKHRhcmdldCwgbm9EZWZhdWx0KSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XG5cdFx0aWYgKCFpbnN0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcblxuXHRcdGlmICh0cF9pbnN0KSB7XG5cdFx0XHQvLyBpZiBpdCBoYXNuJ3QgeWV0IGJlZW4gZGVmaW5lZCwgZ3JhYiBmcm9tIGZpZWxkXG5cdFx0XHRpZiAoaW5zdC5sYXN0VmFsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5fc2V0RGF0ZUZyb21GaWVsZChpbnN0LCBub0RlZmF1bHQpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGF0ZSA9IHRoaXMuX2dldERhdGUoaW5zdCk7XG5cblx0XHRcdHZhciBjdXJyRFQgPSBudWxsO1xuXG5cdFx0XHRpZiAodHBfaW5zdC4kYWx0SW5wdXQgJiYgdHBfaW5zdC5fZGVmYXVsdHMuYWx0RmllbGRUaW1lT25seSkge1xuXHRcdFx0XHRjdXJyRFQgPSB0cF9pbnN0LiRpbnB1dC52YWwoKSArICcgJyArIHRwX2luc3QuJGFsdElucHV0LnZhbCgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodHBfaW5zdC4kaW5wdXQuZ2V0KDApLnRhZ05hbWUgIT09ICdJTlBVVCcgJiYgdHBfaW5zdC4kYWx0SW5wdXQpIHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIGluIGNhc2UgdGhlIGRhdGV0aW1lcGlja2VyIGhhcyBiZWVuIGFwcGxpZWQgdG8gYSBub24taW5wdXQgdGFnIGZvciBpbmxpbmUgVUksXG5cdFx0XHRcdCAqIGFuZCB0aGUgdXNlciBoYXMgbm90IGNvbmZpZ3VyZWQgdGhlIHBsdWdpbiB0byBkaXNwbGF5IG9ubHkgdGltZSBpbiBhbHRJbnB1dCxcblx0XHRcdFx0ICogcGljayBjdXJyZW50IGRhdGUgdGltZSBmcm9tIHRoZSBhbHRJbnB1dCAoYW5kIGhvcGUgZm9yIHRoZSBiZXN0LCBmb3Igbm93LCB1bnRpbCBcIkVSMVwiIGlzIGFwcGxpZWQpXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIEB0b2RvIEVSMS4gU2luY2UgYWx0SW5wdXQgY2FuIGhhdmUgYSB0b3RhbGx5IGRpZmZlcmVuY2UgZm9ybWF0LCBjb252ZXJ0IGl0IHRvIHN0YW5kYXJkIGZvcm1hdCBieSByZWFkaW5nIGlucHV0IGZvcm1hdCBmcm9tIFwiYWx0Rm9ybWF0XCIgYW5kIFwiYWx0VGltZUZvcm1hdFwiIG9wdGlvbiB2YWx1ZXNcblx0XHRcdFx0ICovXG5cdFx0XHRcdGN1cnJEVCA9IHRwX2luc3QuJGFsdElucHV0LnZhbCgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGN1cnJEVCA9IHRwX2luc3QuJGlucHV0LnZhbCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGF0ZSAmJiB0cF9pbnN0Ll9wYXJzZVRpbWUoY3VyckRULCAhaW5zdC5zZXR0aW5ncy50aW1lT25seSkpIHtcblx0XHRcdFx0ZGF0ZS5zZXRIb3Vycyh0cF9pbnN0LmhvdXIsIHRwX2luc3QubWludXRlLCB0cF9pbnN0LnNlY29uZCwgdHBfaW5zdC5taWxsaXNlYyk7XG5cdFx0XHRcdGRhdGUuc2V0TWljcm9zZWNvbmRzKHRwX2luc3QubWljcm9zZWMpO1xuXG5cdFx0XHRcdC8vIFRoaXMgaXMgaW1wb3J0YW50IGlmIHlvdSBhcmUgdXNpbmcgdGhlIHRpbWV6b25lIG9wdGlvbiwgamF2YXNjcmlwdCdzIERhdGVcblx0XHRcdFx0Ly8gb2JqZWN0IHdpbGwgb25seSByZXR1cm4gdGhlIHRpbWV6b25lIG9mZnNldCBmb3IgdGhlIGN1cnJlbnQgbG9jYWxlLCBzbyB3ZVxuXHRcdFx0XHQvLyBhZGp1c3QgaXQgYWNjb3JkaW5nbHkuICBJZiBub3QgdXNpbmcgdGltZXpvbmUgb3B0aW9uIHRoaXMgd29uJ3QgbWF0dGVyLi5cblx0XHRcdFx0aWYgKHRwX2luc3QudGltZXpvbmUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdC8vIGxvb2sgb3V0IGZvciBEU1QgaWYgdHogd2Fzbid0IHNwZWNpZmllZFxuXHRcdFx0XHRcdGlmICghdHBfaW5zdC5zdXBwb3J0LnRpbWV6b25lICYmIHRwX2luc3QuX2RlZmF1bHRzLnRpbWV6b25lID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHR0cF9pbnN0LnRpbWV6b25lID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogLTE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGUgPSAkLnRpbWVwaWNrZXIudGltZXpvbmVBZGp1c3QoZGF0ZSwgdHBfaW5zdC50aW1lem9uZSwgJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0U3RyaW5nKC1kYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRhdGU7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9iYXNlX2dldERhdGVEYXRlcGlja2VyKHRhcmdldCwgbm9EZWZhdWx0KTtcblx0fTtcblxuXHQvKlxuXHQqIG92ZXJyaWRlIHBhcnNlRGF0ZSgpIGJlY2F1c2UgVUkgMS44LjE0IHRocm93cyBhbiBlcnJvciBhYm91dCBcIkV4dHJhIGNoYXJhY3RlcnNcIlxuXHQqIEFuIG9wdGlvbiBpbiBkYXRhcGlja2VyIHRvIGlnbm9yZSBleHRyYSBmb3JtYXQgY2hhcmFjdGVycyB3b3VsZCBiZSBuaWNlci5cblx0Ki9cblx0JC5kYXRlcGlja2VyLl9iYXNlX3BhcnNlRGF0ZSA9ICQuZGF0ZXBpY2tlci5wYXJzZURhdGU7XG5cdCQuZGF0ZXBpY2tlci5wYXJzZURhdGUgPSBmdW5jdGlvbiAoZm9ybWF0LCB2YWx1ZSwgc2V0dGluZ3MpIHtcblx0XHR2YXIgZGF0ZTtcblx0XHR0cnkge1xuXHRcdFx0ZGF0ZSA9IHRoaXMuX2Jhc2VfcGFyc2VEYXRlKGZvcm1hdCwgdmFsdWUsIHNldHRpbmdzKTtcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdC8vIEhhY2shICBUaGUgZXJyb3IgbWVzc2FnZSBlbmRzIHdpdGggYSBjb2xvbiwgYSBzcGFjZSwgYW5kXG5cdFx0XHQvLyB0aGUgXCJleHRyYVwiIGNoYXJhY3RlcnMuICBXZSByZWx5IG9uIHRoYXQgaW5zdGVhZCBvZlxuXHRcdFx0Ly8gYXR0ZW1wdGluZyB0byBwZXJmZWN0bHkgcmVwcm9kdWNlIHRoZSBwYXJzaW5nIGFsZ29yaXRobS5cblx0XHRcdGlmIChlcnIuaW5kZXhPZihcIjpcIikgPj0gMCkge1xuXHRcdFx0XHRkYXRlID0gdGhpcy5fYmFzZV9wYXJzZURhdGUoZm9ybWF0LCB2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gKGVyci5sZW5ndGggLSBlcnIuaW5kZXhPZignOicpIC0gMikpLCBzZXR0aW5ncyk7XG5cdFx0XHRcdCQudGltZXBpY2tlci5sb2coXCJFcnJvciBwYXJzaW5nIHRoZSBkYXRlIHN0cmluZzogXCIgKyBlcnIgKyBcIlxcbmRhdGUgc3RyaW5nID0gXCIgKyB2YWx1ZSArIFwiXFxuZGF0ZSBmb3JtYXQgPSBcIiArIGZvcm1hdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkYXRlO1xuXHR9O1xuXG5cdC8qXG5cdCogb3ZlcnJpZGUgZm9ybWF0RGF0ZSB0byBzZXQgZGF0ZSB3aXRoIHRpbWUgdG8gdGhlIGlucHV0XG5cdCovXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV9mb3JtYXREYXRlID0gJC5kYXRlcGlja2VyLl9mb3JtYXREYXRlO1xuXHQkLmRhdGVwaWNrZXIuX2Zvcm1hdERhdGUgPSBmdW5jdGlvbiAoaW5zdCwgZGF5LCBtb250aCwgeWVhcikge1xuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XG5cdFx0aWYgKHRwX2luc3QpIHtcblx0XHRcdHRwX2luc3QuX3VwZGF0ZURhdGVUaW1lKGluc3QpO1xuXHRcdFx0cmV0dXJuIHRwX2luc3QuJGlucHV0LnZhbCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fYmFzZV9mb3JtYXREYXRlKGluc3QpO1xuXHR9O1xuXG5cdC8qXG5cdCogb3ZlcnJpZGUgb3B0aW9ucyBzZXR0ZXIgdG8gYWRkIHRpbWUgdG8gbWF4RGF0ZShUaW1lKSBhbmQgbWluRGF0ZShUaW1lKS4gTWF4RGF0ZVxuXHQqL1xuXHQkLmRhdGVwaWNrZXIuX2Jhc2Vfb3B0aW9uRGF0ZXBpY2tlciA9ICQuZGF0ZXBpY2tlci5fb3B0aW9uRGF0ZXBpY2tlcjtcblx0JC5kYXRlcGlja2VyLl9vcHRpb25EYXRlcGlja2VyID0gZnVuY3Rpb24gKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KSxcblx0XHRcdG5hbWVfY2xvbmU7XG5cdFx0aWYgKCFpbnN0KSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgdHBfaW5zdCA9IHRoaXMuX2dldChpbnN0LCAndGltZXBpY2tlcicpO1xuXHRcdGlmICh0cF9pbnN0KSB7XG5cdFx0XHR2YXIgbWluID0gbnVsbCxcblx0XHRcdFx0bWF4ID0gbnVsbCxcblx0XHRcdFx0b25zZWxlY3QgPSBudWxsLFxuXHRcdFx0XHRvdmVycmlkZXMgPSB0cF9pbnN0Ll9kZWZhdWx0cy5ldm50cyxcblx0XHRcdFx0Zm5zID0ge30sXG5cdFx0XHRcdHByb3AsXG5cdFx0XHRcdHJldCxcblx0XHRcdFx0b2xkVmFsLFxuXHRcdFx0XHQkdGFyZ2V0O1xuXHRcdFx0aWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykgeyAvLyBpZiBtaW4vbWF4IHdhcyBzZXQgd2l0aCB0aGUgc3RyaW5nXG5cdFx0XHRcdGlmIChuYW1lID09PSAnbWluRGF0ZScgfHwgbmFtZSA9PT0gJ21pbkRhdGVUaW1lJykge1xuXHRcdFx0XHRcdG1pbiA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG5hbWUgPT09ICdtYXhEYXRlJyB8fCBuYW1lID09PSAnbWF4RGF0ZVRpbWUnKSB7XG5cdFx0XHRcdFx0bWF4ID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAobmFtZSA9PT0gJ29uU2VsZWN0Jykge1xuXHRcdFx0XHRcdG9uc2VsZWN0ID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAob3ZlcnJpZGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiAodmFsdWUpID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG92ZXJyaWRlc1tuYW1lXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Zm5zW25hbWVdID0gdmFsdWU7XG5cdFx0XHRcdFx0bmFtZV9jbG9uZSA9IHt9OyAvL2VtcHR5IHJlc3VsdHMgaW4gZXhpdGluZyBmdW5jdGlvbiBhZnRlciBvdmVycmlkZXMgdXBkYXRlZFxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JykgeyAvL2lmIG1pbi9tYXggd2FzIHNldCB3aXRoIHRoZSBKU09OXG5cdFx0XHRcdGlmIChuYW1lLm1pbkRhdGUpIHtcblx0XHRcdFx0XHRtaW4gPSBuYW1lLm1pbkRhdGU7XG5cdFx0XHRcdH0gZWxzZSBpZiAobmFtZS5taW5EYXRlVGltZSkge1xuXHRcdFx0XHRcdG1pbiA9IG5hbWUubWluRGF0ZVRpbWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAobmFtZS5tYXhEYXRlKSB7XG5cdFx0XHRcdFx0bWF4ID0gbmFtZS5tYXhEYXRlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG5hbWUubWF4RGF0ZVRpbWUpIHtcblx0XHRcdFx0XHRtYXggPSBuYW1lLm1heERhdGVUaW1lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAocHJvcCBpbiBvdmVycmlkZXMpIHtcblx0XHRcdFx0XHRpZiAob3ZlcnJpZGVzLmhhc093blByb3BlcnR5KHByb3ApICYmIG5hbWVbcHJvcF0pIHtcblx0XHRcdFx0XHRcdGZuc1twcm9wXSA9IG5hbWVbcHJvcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHByb3AgaW4gZm5zKSB7XG5cdFx0XHRcdGlmIChmbnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0XHRvdmVycmlkZXNbcHJvcF0gPSBmbnNbcHJvcF07XG5cdFx0XHRcdFx0aWYgKCFuYW1lX2Nsb25lKSB7IG5hbWVfY2xvbmUgPSAkLmV4dGVuZCh7fSwgbmFtZSk7IH1cblx0XHRcdFx0XHRkZWxldGUgbmFtZV9jbG9uZVtwcm9wXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKG5hbWVfY2xvbmUgJiYgaXNFbXB0eU9iamVjdChuYW1lX2Nsb25lKSkgeyByZXR1cm47IH1cblx0XHRcdGlmIChtaW4pIHsgLy9pZiBtaW4gd2FzIHNldFxuXHRcdFx0XHRpZiAobWluID09PSAwKSB7XG5cdFx0XHRcdFx0bWluID0gbmV3IERhdGUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtaW4gPSBuZXcgRGF0ZShtaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGUgPSBtaW47XG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGVUaW1lID0gbWluO1xuXHRcdFx0fSBlbHNlIGlmIChtYXgpIHsgLy9pZiBtYXggd2FzIHNldFxuXHRcdFx0XHRpZiAobWF4ID09PSAwKSB7XG5cdFx0XHRcdFx0bWF4ID0gbmV3IERhdGUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtYXggPSBuZXcgRGF0ZShtYXgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGUgPSBtYXg7XG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGVUaW1lID0gbWF4O1xuXHRcdFx0fSBlbHNlIGlmIChvbnNlbGVjdCkge1xuXHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5vblNlbGVjdCA9IG9uc2VsZWN0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEYXRlcGlja2VyIHdpbGwgb3ZlcnJpZGUgb3VyIGRhdGUgd2hlbiB3ZSBjYWxsIF9iYXNlX29wdGlvbkRhdGVwaWNrZXIgd2hlblxuXHRcdFx0Ly8gY2FsbGluZyBtaW5EYXRlL21heERhdGUsIHNvIHdlIHdpbGwgZmlyc3QgZ3JhYiB0aGUgdmFsdWUsIGNhbGxcblx0XHRcdC8vIF9iYXNlX29wdGlvbkRhdGVwaWNrZXIsIHRoZW4gc2V0IG91ciB2YWx1ZSBiYWNrLlxuXHRcdFx0aWYobWluIHx8IG1heCl7XG5cdFx0XHRcdCR0YXJnZXQgPSAkKHRhcmdldCk7XG5cdFx0XHRcdG9sZFZhbCA9ICR0YXJnZXQuZGF0ZXRpbWVwaWNrZXIoJ2dldERhdGUnKTtcblx0XHRcdFx0cmV0ID0gdGhpcy5fYmFzZV9vcHRpb25EYXRlcGlja2VyLmNhbGwoJC5kYXRlcGlja2VyLCB0YXJnZXQsIG5hbWVfY2xvbmUgfHwgbmFtZSwgdmFsdWUpO1xuXHRcdFx0XHQkdGFyZ2V0LmRhdGV0aW1lcGlja2VyKCdzZXREYXRlJywgb2xkVmFsKTtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLl9iYXNlX29wdGlvbkRhdGVwaWNrZXIuY2FsbCgkLmRhdGVwaWNrZXIsIHRhcmdldCwgbmFtZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9iYXNlX29wdGlvbkRhdGVwaWNrZXIuY2FsbCgkLmRhdGVwaWNrZXIsIHRhcmdldCwgbmFtZV9jbG9uZSB8fCBuYW1lLCB2YWx1ZSk7XG5cdH07XG5cblx0Lypcblx0KiBqUXVlcnkgaXNFbXB0eU9iamVjdCBkb2VzIG5vdCBjaGVjayBoYXNPd25Qcm9wZXJ0eSAtIGlmIHNvbWVvbmUgaGFzIGFkZGVkIHRvIHRoZSBvYmplY3QgcHJvdG90eXBlLFxuXHQqIGl0IHdpbGwgcmV0dXJuIGZhbHNlIGZvciBhbGwgb2JqZWN0c1xuXHQqL1xuXHR2YXIgaXNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcblx0XHR2YXIgcHJvcDtcblx0XHRmb3IgKHByb3AgaW4gb2JqKSB7XG5cdFx0XHRpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0Lypcblx0KiBqUXVlcnkgZXh0ZW5kIG5vdyBpZ25vcmVzIG51bGxzIVxuXHQqL1xuXHR2YXIgZXh0ZW5kUmVtb3ZlID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcHMpIHtcblx0XHQkLmV4dGVuZCh0YXJnZXQsIHByb3BzKTtcblx0XHRmb3IgKHZhciBuYW1lIGluIHByb3BzKSB7XG5cdFx0XHRpZiAocHJvcHNbbmFtZV0gPT09IG51bGwgfHwgcHJvcHNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0YXJnZXRbbmFtZV0gPSBwcm9wc1tuYW1lXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHQvKlxuXHQqIERldGVybWluZSBieSB0aGUgdGltZSBmb3JtYXQgd2hpY2ggdW5pdHMgYXJlIHN1cHBvcnRlZFxuXHQqIFJldHVybnMgYW4gb2JqZWN0IG9mIGJvb2xlYW5zIGZvciBlYWNoIHVuaXRcblx0Ki9cblx0dmFyIGRldGVjdFN1cHBvcnQgPSBmdW5jdGlvbiAodGltZUZvcm1hdCkge1xuXHRcdHZhciB0ZiA9IHRpbWVGb3JtYXQucmVwbGFjZSgvJy4qPycvZywgJycpLnRvTG93ZXJDYXNlKCksIC8vIHJlbW92ZXMgbGl0ZXJhbHNcblx0XHRcdGlzSW4gPSBmdW5jdGlvbiAoZiwgdCkgeyAvLyBkb2VzIHRoZSBmb3JtYXQgY29udGFpbiB0aGUgdG9rZW4/XG5cdFx0XHRcdFx0cmV0dXJuIGYuaW5kZXhPZih0KSAhPT0gLTEgPyB0cnVlIDogZmFsc2U7XG5cdFx0XHRcdH07XG5cdFx0cmV0dXJuIHtcblx0XHRcdFx0aG91cjogaXNJbih0ZiwgJ2gnKSxcblx0XHRcdFx0bWludXRlOiBpc0luKHRmLCAnbScpLFxuXHRcdFx0XHRzZWNvbmQ6IGlzSW4odGYsICdzJyksXG5cdFx0XHRcdG1pbGxpc2VjOiBpc0luKHRmLCAnbCcpLFxuXHRcdFx0XHRtaWNyb3NlYzogaXNJbih0ZiwgJ2MnKSxcblx0XHRcdFx0dGltZXpvbmU6IGlzSW4odGYsICd6JyksXG5cdFx0XHRcdGFtcG06IGlzSW4odGYsICd0JykgJiYgaXNJbih0aW1lRm9ybWF0LCAnaCcpLFxuXHRcdFx0XHRpc284NjAxOiBpc0luKHRpbWVGb3JtYXQsICdaJylcblx0XHRcdH07XG5cdH07XG5cblx0Lypcblx0KiBDb252ZXJ0cyAyNCBob3VyIGZvcm1hdCBpbnRvIDEyIGhvdXJcblx0KiBSZXR1cm5zIDEyIGhvdXIgd2l0aG91dCBsZWFkaW5nIDBcblx0Ki9cblx0dmFyIGNvbnZlcnQyNHRvMTIgPSBmdW5jdGlvbiAoaG91cikge1xuXHRcdGhvdXIgJT0gMTI7XG5cblx0XHRpZiAoaG91ciA9PT0gMCkge1xuXHRcdFx0aG91ciA9IDEyO1xuXHRcdH1cblxuXHRcdHJldHVybiBTdHJpbmcoaG91cik7XG5cdH07XG5cblx0dmFyIGNvbXB1dGVFZmZlY3RpdmVTZXR0aW5nID0gZnVuY3Rpb24gKHNldHRpbmdzLCBwcm9wZXJ0eSkge1xuXHRcdHJldHVybiBzZXR0aW5ncyAmJiBzZXR0aW5nc1twcm9wZXJ0eV0gPyBzZXR0aW5nc1twcm9wZXJ0eV0gOiAkLnRpbWVwaWNrZXIuX2RlZmF1bHRzW3Byb3BlcnR5XTtcblx0fTtcblxuXHQvKlxuXHQqIFNwbGl0cyBkYXRldGltZSBzdHJpbmcgaW50byBkYXRlIGFuZCB0aW1lIHN1YnN0cmluZ3MuXG5cdCogVGhyb3dzIGV4Y2VwdGlvbiB3aGVuIGRhdGUgY2FuJ3QgYmUgcGFyc2VkXG5cdCogUmV0dXJucyB7ZGF0ZVN0cmluZzogZGF0ZVN0cmluZywgdGltZVN0cmluZzogdGltZVN0cmluZ31cblx0Ki9cblx0dmFyIHNwbGl0RGF0ZVRpbWUgPSBmdW5jdGlvbiAoZGF0ZVRpbWVTdHJpbmcsIHRpbWVTZXR0aW5ncykge1xuXHRcdC8vIFRoZSBpZGVhIGlzIHRvIGdldCB0aGUgbnVtYmVyIHNlcGFyYXRvciBvY2N1cnJlbmNlcyBpbiBkYXRldGltZSBhbmQgdGhlIHRpbWUgZm9ybWF0IHJlcXVlc3RlZCAoc2luY2UgdGltZSBoYXNcblx0XHQvLyBmZXdlciB1bmtub3ducywgbW9zdGx5IG51bWJlcnMgYW5kIGFtL3BtKS4gV2Ugd2lsbCB1c2UgdGhlIHRpbWUgcGF0dGVybiB0byBzcGxpdC5cblx0XHR2YXIgc2VwYXJhdG9yID0gY29tcHV0ZUVmZmVjdGl2ZVNldHRpbmcodGltZVNldHRpbmdzLCAnc2VwYXJhdG9yJyksXG5cdFx0XHRmb3JtYXQgPSBjb21wdXRlRWZmZWN0aXZlU2V0dGluZyh0aW1lU2V0dGluZ3MsICd0aW1lRm9ybWF0JyksXG5cdFx0XHR0aW1lUGFydHMgPSBmb3JtYXQuc3BsaXQoc2VwYXJhdG9yKSwgLy8gaG93IG1hbnkgb2NjdXJyZW5jZXMgb2Ygc2VwYXJhdG9yIG1heSBiZSBpbiBvdXIgZm9ybWF0P1xuXHRcdFx0dGltZVBhcnRzTGVuID0gdGltZVBhcnRzLmxlbmd0aCxcblx0XHRcdGFsbFBhcnRzID0gZGF0ZVRpbWVTdHJpbmcuc3BsaXQoc2VwYXJhdG9yKSxcblx0XHRcdGFsbFBhcnRzTGVuID0gYWxsUGFydHMubGVuZ3RoO1xuXG5cdFx0aWYgKGFsbFBhcnRzTGVuID4gMSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0ZVN0cmluZzogYWxsUGFydHMuc3BsaWNlKDAsIGFsbFBhcnRzTGVuIC0gdGltZVBhcnRzTGVuKS5qb2luKHNlcGFyYXRvciksXG5cdFx0XHRcdHRpbWVTdHJpbmc6IGFsbFBhcnRzLnNwbGljZSgwLCB0aW1lUGFydHNMZW4pLmpvaW4oc2VwYXJhdG9yKVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGF0ZVN0cmluZzogZGF0ZVRpbWVTdHJpbmcsXG5cdFx0XHR0aW1lU3RyaW5nOiAnJ1xuXHRcdH07XG5cdH07XG5cblx0Lypcblx0KiBJbnRlcm5hbCBmdW5jdGlvbiB0byBwYXJzZSBkYXRldGltZSBpbnRlcnZhbFxuXHQqIFJldHVybnM6IHtkYXRlOiBEYXRlLCB0aW1lT2JqOiBPYmplY3R9LCB3aGVyZVxuXHQqICAgZGF0ZSAtIHBhcnNlZCBkYXRlIHdpdGhvdXQgdGltZSAodHlwZSBEYXRlKVxuXHQqICAgdGltZU9iaiA9IHtob3VyOiAsIG1pbnV0ZTogLCBzZWNvbmQ6ICwgbWlsbGlzZWM6ICwgbWljcm9zZWM6IH0gLSBwYXJzZWQgdGltZS4gT3B0aW9uYWxcblx0Ki9cblx0dmFyIHBhcnNlRGF0ZVRpbWVJbnRlcm5hbCA9IGZ1bmN0aW9uIChkYXRlRm9ybWF0LCB0aW1lRm9ybWF0LCBkYXRlVGltZVN0cmluZywgZGF0ZVNldHRpbmdzLCB0aW1lU2V0dGluZ3MpIHtcblx0XHR2YXIgZGF0ZSxcblx0XHRcdHBhcnRzLFxuXHRcdFx0cGFyc2VkVGltZTtcblxuXHRcdHBhcnRzID0gc3BsaXREYXRlVGltZShkYXRlVGltZVN0cmluZywgdGltZVNldHRpbmdzKTtcblx0XHRkYXRlID0gJC5kYXRlcGlja2VyLl9iYXNlX3BhcnNlRGF0ZShkYXRlRm9ybWF0LCBwYXJ0cy5kYXRlU3RyaW5nLCBkYXRlU2V0dGluZ3MpO1xuXG5cdFx0aWYgKHBhcnRzLnRpbWVTdHJpbmcgPT09ICcnKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRlOiBkYXRlXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHBhcnNlZFRpbWUgPSAkLmRhdGVwaWNrZXIucGFyc2VUaW1lKHRpbWVGb3JtYXQsIHBhcnRzLnRpbWVTdHJpbmcsIHRpbWVTZXR0aW5ncyk7XG5cblx0XHRpZiAoIXBhcnNlZFRpbWUpIHtcblx0XHRcdHRocm93ICdXcm9uZyB0aW1lIGZvcm1hdCc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGRhdGU6IGRhdGUsXG5cdFx0XHR0aW1lT2JqOiBwYXJzZWRUaW1lXG5cdFx0fTtcblx0fTtcblxuXHQvKlxuXHQqIEludGVybmFsIGZ1bmN0aW9uIHRvIHNldCB0aW1lem9uZV9zZWxlY3QgdG8gdGhlIGxvY2FsIHRpbWV6b25lXG5cdCovXG5cdHZhciBzZWxlY3RMb2NhbFRpbWV6b25lID0gZnVuY3Rpb24gKHRwX2luc3QsIGRhdGUpIHtcblx0XHRpZiAodHBfaW5zdCAmJiB0cF9pbnN0LnRpbWV6b25lX3NlbGVjdCkge1xuXHRcdFx0dmFyIG5vdyA9IGRhdGUgfHwgbmV3IERhdGUoKTtcblx0XHRcdHRwX2luc3QudGltZXpvbmVfc2VsZWN0LnZhbCgtbm93LmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuXHRcdH1cblx0fTtcblxuXHQvKlxuXHQqIENyZWF0ZSBhIFNpbmdsZXRvbiBJbnN0YW5jZVxuXHQqL1xuXHQkLnRpbWVwaWNrZXIgPSBuZXcgVGltZXBpY2tlcigpO1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHRpbWV6b25lIG9mZnNldCBhcyBzdHJpbmcgZnJvbSBhIGRhdGUgb2JqZWN0IChlZyAnKzA1MzAnIGZvciBVVEMrNS41KVxuXHQgKiBAcGFyYW0ge251bWJlcn0gdHpNaW51dGVzIGlmIG5vdCBhIG51bWJlciwgbGVzcyB0aGFuIC03MjAgKC0xMjAwKSwgb3IgZ3JlYXRlciB0aGFuIDg0MCAoKzE0MDApIHRoaXMgdmFsdWUgaXMgcmV0dXJuZWRcblx0ICogQHBhcmFtIHtib29sZWFufSBpc284NjAxIGlmIHRydWUgZm9ybWF0cyBpbiBhY2NvcmRhbmNlIHRvIGlzbzg2MDEgXCIrMTI6NDVcIlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHQkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXRTdHJpbmcgPSBmdW5jdGlvbiAodHpNaW51dGVzLCBpc284NjAxKSB7XG5cdFx0aWYgKGlzTmFOKHR6TWludXRlcykgfHwgdHpNaW51dGVzID4gODQwIHx8IHR6TWludXRlcyA8IC03MjApIHtcblx0XHRcdHJldHVybiB0ek1pbnV0ZXM7XG5cdFx0fVxuXG5cdFx0dmFyIG9mZiA9IHR6TWludXRlcyxcblx0XHRcdG1pbnV0ZXMgPSBvZmYgJSA2MCxcblx0XHRcdGhvdXJzID0gKG9mZiAtIG1pbnV0ZXMpIC8gNjAsXG5cdFx0XHRpc28gPSBpc284NjAxID8gJzonIDogJycsXG5cdFx0XHR0eiA9IChvZmYgPj0gMCA/ICcrJyA6ICctJykgKyAoJzAnICsgTWF0aC5hYnMoaG91cnMpKS5zbGljZSgtMikgKyBpc28gKyAoJzAnICsgTWF0aC5hYnMobWludXRlcykpLnNsaWNlKC0yKTtcblxuXHRcdGlmICh0eiA9PT0gJyswMDowMCcpIHtcblx0XHRcdHJldHVybiAnWic7XG5cdFx0fVxuXHRcdHJldHVybiB0ejtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBudW1iZXIgaW4gbWludXRlcyB0aGF0IHJlcHJlc2VudHMgYSB0aW1lem9uZSBzdHJpbmdcblx0ICogQHBhcmFtICB7c3RyaW5nfSB0elN0cmluZyBmb3JtYXR0ZWQgbGlrZSBcIiswNTAwXCIsIFwiLTEyNDVcIiwgXCJaXCJcblx0ICogQHJldHVybiB7bnVtYmVyfSB0aGUgb2Zmc2V0IG1pbnV0ZXMgb3IgdGhlIG9yaWdpbmFsIHN0cmluZyBpZiBpdCBkb2Vzbid0IG1hdGNoIGV4cGVjdGF0aW9uc1xuXHQgKi9cblx0JC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0TnVtYmVyID0gZnVuY3Rpb24gKHR6U3RyaW5nKSB7XG5cdFx0dmFyIG5vcm1hbGl6ZWQgPSB0elN0cmluZy50b1N0cmluZygpLnJlcGxhY2UoJzonLCAnJyk7IC8vIGV4Y3VzZSBhbnkgaXNvODYwMSwgZW5kIHVwIHdpdGggXCIrMTI0NVwiXG5cblx0XHRpZiAobm9ybWFsaXplZC50b1VwcGVyQ2FzZSgpID09PSAnWicpIHsgLy8gaWYgaXNvODYwMSB3aXRoIFosIGl0cyAwIG1pbnV0ZSBvZmZzZXRcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdGlmICghL14oXFwtfFxcKylcXGR7NH0kLy50ZXN0KG5vcm1hbGl6ZWQpKSB7IC8vIHBvc3NpYmx5IGEgdXNlciBkZWZpbmVkIHR6LCBzbyBqdXN0IGdpdmUgaXQgYmFja1xuXHRcdFx0cmV0dXJuIHBhcnNlSW50KHR6U3RyaW5nLCAxMCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgobm9ybWFsaXplZC5zdWJzdHIoMCwgMSkgPT09ICctJyA/IC0xIDogMSkgKiAvLyBwbHVzIG9yIG1pbnVzXG5cdFx0XHRcdFx0KChwYXJzZUludChub3JtYWxpemVkLnN1YnN0cigxLCAyKSwgMTApICogNjApICsgLy8gaG91cnMgKGNvbnZlcnRlZCB0byBtaW51dGVzKVxuXHRcdFx0XHRcdHBhcnNlSW50KG5vcm1hbGl6ZWQuc3Vic3RyKDMsIDIpLCAxMCkpKTsgLy8gbWludXRlc1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBObyB3YXkgdG8gc2V0IHRpbWV6b25lIGluIGpzIERhdGUsIHNvIHdlIG11c3QgYWRqdXN0IHRoZSBtaW51dGVzIHRvIGNvbXBlbnNhdGUuICh0aGluayBzZXREYXRlLCBnZXREYXRlKVxuXHQgKiBAcGFyYW0gIHtEYXRlfSBkYXRlXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gZnJvbVRpbWV6b25lIGZvcm1hdHRlZCBsaWtlIFwiKzA1MDBcIiwgXCItMTI0NVwiXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gdG9UaW1lem9uZSBmb3JtYXR0ZWQgbGlrZSBcIiswNTAwXCIsIFwiLTEyNDVcIlxuXHQgKiBAcmV0dXJuIHtEYXRlfVxuXHQgKi9cblx0JC50aW1lcGlja2VyLnRpbWV6b25lQWRqdXN0ID0gZnVuY3Rpb24gKGRhdGUsIGZyb21UaW1lem9uZSwgdG9UaW1lem9uZSkge1xuXHRcdHZhciBmcm9tVHogPSAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXROdW1iZXIoZnJvbVRpbWV6b25lKTtcblx0XHR2YXIgdG9UeiA9ICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldE51bWJlcih0b1RpbWV6b25lKTtcblx0XHRpZiAoIWlzTmFOKHRvVHopKSB7XG5cdFx0XHRkYXRlLnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkgKyAoLWZyb21UeikgLSAoLXRvVHopKTtcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGU7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxzIGB0aW1lcGlja2VyKClgIG9uIHRoZSBgc3RhcnRUaW1lYCBhbmQgYGVuZFRpbWVgIGVsZW1lbnRzLCBhbmQgY29uZmlndXJlcyB0aGVtIHRvXG5cdCAqIGVuZm9yY2UgZGF0ZSByYW5nZSBsaW1pdHMuXG5cdCAqIG4uYi4gVGhlIGlucHV0IHZhbHVlIG11c3QgYmUgY29ycmVjdGx5IGZvcm1hdHRlZCAocmVmb3JtYXR0aW5nIGlzIG5vdCBzdXBwb3J0ZWQpXG5cdCAqIEBwYXJhbSAge0VsZW1lbnR9IHN0YXJ0VGltZVxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBlbmRUaW1lXG5cdCAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgdGltZXBpY2tlcigpIGNhbGxcblx0ICogQHJldHVybiB7alF1ZXJ5fVxuXHQgKi9cblx0JC50aW1lcGlja2VyLnRpbWVSYW5nZSA9IGZ1bmN0aW9uIChzdGFydFRpbWUsIGVuZFRpbWUsIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gJC50aW1lcGlja2VyLmhhbmRsZVJhbmdlKCd0aW1lcGlja2VyJywgc3RhcnRUaW1lLCBlbmRUaW1lLCBvcHRpb25zKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbHMgYGRhdGV0aW1lcGlja2VyYCBvbiB0aGUgYHN0YXJ0VGltZWAgYW5kIGBlbmRUaW1lYCBlbGVtZW50cywgYW5kIGNvbmZpZ3VyZXMgdGhlbSB0b1xuXHQgKiBlbmZvcmNlIGRhdGUgcmFuZ2UgbGltaXRzLlxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBzdGFydFRpbWVcblx0ICogQHBhcmFtICB7RWxlbWVudH0gZW5kVGltZVxuXHQgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIGB0aW1lcGlja2VyKClgIGNhbGwuIEFsc28gc3VwcG9ydHMgYHJlZm9ybWF0YCxcblx0ICogICBhIGJvb2xlYW4gdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZvcm1hdCB0aGUgaW5wdXQgdmFsdWVzIHRvIHRoZSBgZGF0ZUZvcm1hdGAuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gbWV0aG9kIENhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIHR5cGUgb2YgcGlja2VyIHRvIGJlIGFkZGVkXG5cdCAqIEByZXR1cm4ge2pRdWVyeX1cblx0ICovXG5cdCQudGltZXBpY2tlci5kYXRldGltZVJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0VGltZSwgZW5kVGltZSwgb3B0aW9ucykge1xuXHRcdCQudGltZXBpY2tlci5oYW5kbGVSYW5nZSgnZGF0ZXRpbWVwaWNrZXInLCBzdGFydFRpbWUsIGVuZFRpbWUsIG9wdGlvbnMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxscyBgZGF0ZXBpY2tlcmAgb24gdGhlIGBzdGFydFRpbWVgIGFuZCBgZW5kVGltZWAgZWxlbWVudHMsIGFuZCBjb25maWd1cmVzIHRoZW0gdG9cblx0ICogZW5mb3JjZSBkYXRlIHJhbmdlIGxpbWl0cy5cblx0ICogQHBhcmFtICB7RWxlbWVudH0gc3RhcnRUaW1lXG5cdCAqIEBwYXJhbSAge0VsZW1lbnR9IGVuZFRpbWVcblx0ICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBgdGltZXBpY2tlcigpYCBjYWxsLiBBbHNvIHN1cHBvcnRzIGByZWZvcm1hdGAsXG5cdCAqICAgYSBib29sZWFuIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVmb3JtYXQgdGhlIGlucHV0IHZhbHVlcyB0byB0aGUgYGRhdGVGb3JtYXRgLlxuXHQgKiBAcmV0dXJuIHtqUXVlcnl9XG5cdCAqL1xuXHQkLnRpbWVwaWNrZXIuZGF0ZVJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0VGltZSwgZW5kVGltZSwgb3B0aW9ucykge1xuXHRcdCQudGltZXBpY2tlci5oYW5kbGVSYW5nZSgnZGF0ZXBpY2tlcicsIHN0YXJ0VGltZSwgZW5kVGltZSwgb3B0aW9ucyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxzIGBtZXRob2RgIG9uIHRoZSBgc3RhcnRUaW1lYCBhbmQgYGVuZFRpbWVgIGVsZW1lbnRzLCBhbmQgY29uZmlndXJlcyB0aGVtIHRvXG5cdCAqIGVuZm9yY2UgZGF0ZSByYW5nZSBsaW1pdHMuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gbWV0aG9kIENhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIHR5cGUgb2YgcGlja2VyIHRvIGJlIGFkZGVkXG5cdCAqIEBwYXJhbSAge0VsZW1lbnR9IHN0YXJ0VGltZVxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBlbmRUaW1lXG5cdCAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgYHRpbWVwaWNrZXIoKWAgY2FsbC4gQWxzbyBzdXBwb3J0cyBgcmVmb3JtYXRgLFxuXHQgKiAgIGEgYm9vbGVhbiB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZm9ybWF0IHRoZSBpbnB1dCB2YWx1ZXMgdG8gdGhlIGBkYXRlRm9ybWF0YC5cblx0ICogQHJldHVybiB7alF1ZXJ5fVxuXHQgKi9cblx0JC50aW1lcGlja2VyLmhhbmRsZVJhbmdlID0gZnVuY3Rpb24gKG1ldGhvZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB7XG5cdFx0XHRtaW5JbnRlcnZhbDogMCwgLy8gbWluIGFsbG93ZWQgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXG5cdFx0XHRtYXhJbnRlcnZhbDogMCwgLy8gbWF4IGFsbG93ZWQgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXG5cdFx0XHRzdGFydDoge30sICAgICAgLy8gb3B0aW9ucyBmb3Igc3RhcnQgcGlja2VyXG5cdFx0XHRlbmQ6IHt9ICAgICAgICAgLy8gb3B0aW9ucyBmb3IgZW5kIHBpY2tlclxuXHRcdH0sIG9wdGlvbnMpO1xuXG5cdFx0Ly8gZm9yIHRoZSBtZWFuIHRpbWUgdGhpcyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGNhbGxpbmcgZ2V0RGF0ZSB3aXRoIHRpbWVwaWNrZXIoKVxuXHRcdHZhciB0aW1lT25seSA9IGZhbHNlO1xuXHRcdGlmKG1ldGhvZCA9PT0gJ3RpbWVwaWNrZXInKXtcblx0XHRcdHRpbWVPbmx5ID0gdHJ1ZTtcblx0XHRcdG1ldGhvZCA9ICdkYXRldGltZXBpY2tlcic7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tEYXRlcyhjaGFuZ2VkLCBvdGhlcikge1xuXHRcdFx0dmFyIHN0YXJ0ZHQgPSBzdGFydFRpbWVbbWV0aG9kXSgnZ2V0RGF0ZScpLFxuXHRcdFx0XHRlbmRkdCA9IGVuZFRpbWVbbWV0aG9kXSgnZ2V0RGF0ZScpLFxuXHRcdFx0XHRjaGFuZ2VkZHQgPSBjaGFuZ2VkW21ldGhvZF0oJ2dldERhdGUnKTtcblxuXHRcdFx0aWYgKHN0YXJ0ZHQgIT09IG51bGwpIHtcblx0XHRcdFx0dmFyIG1pbkRhdGUgPSBuZXcgRGF0ZShzdGFydGR0LmdldFRpbWUoKSksXG5cdFx0XHRcdFx0bWF4RGF0ZSA9IG5ldyBEYXRlKHN0YXJ0ZHQuZ2V0VGltZSgpKTtcblxuXHRcdFx0XHRtaW5EYXRlLnNldE1pbGxpc2Vjb25kcyhtaW5EYXRlLmdldE1pbGxpc2Vjb25kcygpICsgb3B0aW9ucy5taW5JbnRlcnZhbCk7XG5cdFx0XHRcdG1heERhdGUuc2V0TWlsbGlzZWNvbmRzKG1heERhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgKyBvcHRpb25zLm1heEludGVydmFsKTtcblxuXHRcdFx0XHRpZiAob3B0aW9ucy5taW5JbnRlcnZhbCA+IDAgJiYgbWluRGF0ZSA+IGVuZGR0KSB7IC8vIG1pbkludGVydmFsIGNoZWNrXG5cdFx0XHRcdFx0ZW5kVGltZVttZXRob2RdKCdzZXREYXRlJywgbWluRGF0ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAob3B0aW9ucy5tYXhJbnRlcnZhbCA+IDAgJiYgbWF4RGF0ZSA8IGVuZGR0KSB7IC8vIG1heCBpbnRlcnZhbCBjaGVja1xuXHRcdFx0XHRcdGVuZFRpbWVbbWV0aG9kXSgnc2V0RGF0ZScsIG1heERhdGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKHN0YXJ0ZHQgPiBlbmRkdCkge1xuXHRcdFx0XHRcdG90aGVyW21ldGhvZF0oJ3NldERhdGUnLCBjaGFuZ2VkZHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2VsZWN0ZWQoY2hhbmdlZCwgb3RoZXIsIG9wdGlvbikge1xuXHRcdFx0aWYgKCFjaGFuZ2VkLnZhbCgpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBkYXRlID0gY2hhbmdlZFttZXRob2RdLmNhbGwoY2hhbmdlZCwgJ2dldERhdGUnKTtcblx0XHRcdGlmIChkYXRlICE9PSBudWxsICYmIG9wdGlvbnMubWluSW50ZXJ2YWwgPiAwKSB7XG5cdFx0XHRcdGlmIChvcHRpb24gPT09ICdtaW5EYXRlJykge1xuXHRcdFx0XHRcdGRhdGUuc2V0TWlsbGlzZWNvbmRzKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgKyBvcHRpb25zLm1pbkludGVydmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob3B0aW9uID09PSAnbWF4RGF0ZScpIHtcblx0XHRcdFx0XHRkYXRlLnNldE1pbGxpc2Vjb25kcyhkYXRlLmdldE1pbGxpc2Vjb25kcygpIC0gb3B0aW9ucy5taW5JbnRlcnZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGRhdGUuZ2V0VGltZSkge1xuXHRcdFx0XHRvdGhlclttZXRob2RdLmNhbGwob3RoZXIsICdvcHRpb24nLCBvcHRpb24sIGRhdGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdCQuZm5bbWV0aG9kXS5jYWxsKHN0YXJ0VGltZSwgJC5leHRlbmQoe1xuXHRcdFx0dGltZU9ubHk6IHRpbWVPbmx5LFxuXHRcdFx0b25DbG9zZTogZnVuY3Rpb24gKGRhdGVUZXh0LCBpbnN0KSB7XG5cdFx0XHRcdGNoZWNrRGF0ZXMoJCh0aGlzKSwgZW5kVGltZSk7XG5cdFx0XHR9LFxuXHRcdFx0b25TZWxlY3Q6IGZ1bmN0aW9uIChzZWxlY3RlZERhdGVUaW1lKSB7XG5cdFx0XHRcdHNlbGVjdGVkKCQodGhpcyksIGVuZFRpbWUsICdtaW5EYXRlJyk7XG5cdFx0XHR9XG5cdFx0fSwgb3B0aW9ucywgb3B0aW9ucy5zdGFydCkpO1xuXHRcdCQuZm5bbWV0aG9kXS5jYWxsKGVuZFRpbWUsICQuZXh0ZW5kKHtcblx0XHRcdHRpbWVPbmx5OiB0aW1lT25seSxcblx0XHRcdG9uQ2xvc2U6IGZ1bmN0aW9uIChkYXRlVGV4dCwgaW5zdCkge1xuXHRcdFx0XHRjaGVja0RhdGVzKCQodGhpcyksIHN0YXJ0VGltZSk7XG5cdFx0XHR9LFxuXHRcdFx0b25TZWxlY3Q6IGZ1bmN0aW9uIChzZWxlY3RlZERhdGVUaW1lKSB7XG5cdFx0XHRcdHNlbGVjdGVkKCQodGhpcyksIHN0YXJ0VGltZSwgJ21heERhdGUnKTtcblx0XHRcdH1cblx0XHR9LCBvcHRpb25zLCBvcHRpb25zLmVuZCkpO1xuXG5cdFx0Y2hlY2tEYXRlcyhzdGFydFRpbWUsIGVuZFRpbWUpO1xuXG5cdFx0c2VsZWN0ZWQoc3RhcnRUaW1lLCBlbmRUaW1lLCAnbWluRGF0ZScpO1xuXHRcdHNlbGVjdGVkKGVuZFRpbWUsIHN0YXJ0VGltZSwgJ21heERhdGUnKTtcblxuXHRcdHJldHVybiAkKFtzdGFydFRpbWUuZ2V0KDApLCBlbmRUaW1lLmdldCgwKV0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBMb2cgZXJyb3Igb3IgZGF0YSB0byB0aGUgY29uc29sZSBkdXJpbmcgZXJyb3Igb3IgZGVidWdnaW5nXG5cdCAqIEBwYXJhbSAge09iamVjdH0gZXJyIHBhc3MgYW55IHR5cGUgb2JqZWN0IHRvIGxvZyB0byB0aGUgY29uc29sZSBkdXJpbmcgZXJyb3Igb3IgZGVidWdnaW5nXG5cdCAqIEByZXR1cm4ge3ZvaWR9XG5cdCAqL1xuXHQkLnRpbWVwaWNrZXIubG9nID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIE9sZGVyIElFICg5LCBtYXliZSAxMCkgdGhyb3cgZXJyb3Igb24gYWNjZXNzaW5nIGB3aW5kb3cuY29uc29sZS5sb2cuYXBwbHlgLCBzbyBjaGVjayBmaXJzdC5cblx0XHRpZiAod2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUubG9nICYmIHdpbmRvdy5jb25zb2xlLmxvZy5hcHBseSkge1xuXHRcdFx0d2luZG93LmNvbnNvbGUubG9nLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcblx0XHR9XG5cdH07XG5cblx0Lypcblx0ICogQWRkIHV0aWwgb2JqZWN0IHRvIGFsbG93IGFjY2VzcyB0byBwcml2YXRlIG1ldGhvZHMgZm9yIHRlc3RhYmlsaXR5LlxuXHQgKi9cblx0JC50aW1lcGlja2VyLl91dGlsID0ge1xuXHRcdF9leHRlbmRSZW1vdmU6IGV4dGVuZFJlbW92ZSxcblx0XHRfaXNFbXB0eU9iamVjdDogaXNFbXB0eU9iamVjdCxcblx0XHRfY29udmVydDI0dG8xMjogY29udmVydDI0dG8xMixcblx0XHRfZGV0ZWN0U3VwcG9ydDogZGV0ZWN0U3VwcG9ydCxcblx0XHRfc2VsZWN0TG9jYWxUaW1lem9uZTogc2VsZWN0TG9jYWxUaW1lem9uZSxcblx0XHRfY29tcHV0ZUVmZmVjdGl2ZVNldHRpbmc6IGNvbXB1dGVFZmZlY3RpdmVTZXR0aW5nLFxuXHRcdF9zcGxpdERhdGVUaW1lOiBzcGxpdERhdGVUaW1lLFxuXHRcdF9wYXJzZURhdGVUaW1lSW50ZXJuYWw6IHBhcnNlRGF0ZVRpbWVJbnRlcm5hbFxuXHR9O1xuXG5cdC8qXG5cdCogTWljcm9zZWNvbmQgc3VwcG9ydFxuXHQqL1xuXHRpZiAoIURhdGUucHJvdG90eXBlLmdldE1pY3Jvc2Vjb25kcykge1xuXHRcdERhdGUucHJvdG90eXBlLm1pY3Jvc2Vjb25kcyA9IDA7XG5cdFx0RGF0ZS5wcm90b3R5cGUuZ2V0TWljcm9zZWNvbmRzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5taWNyb3NlY29uZHM7IH07XG5cdFx0RGF0ZS5wcm90b3R5cGUuc2V0TWljcm9zZWNvbmRzID0gZnVuY3Rpb24gKG0pIHtcblx0XHRcdHRoaXMuc2V0TWlsbGlzZWNvbmRzKHRoaXMuZ2V0TWlsbGlzZWNvbmRzKCkgKyBNYXRoLmZsb29yKG0gLyAxMDAwKSk7XG5cdFx0XHR0aGlzLm1pY3Jvc2Vjb25kcyA9IG0gJSAxMDAwO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fVxuXG5cdC8qXG5cdCogS2VlcCB1cCB3aXRoIHRoZSB2ZXJzaW9uXG5cdCovXG5cdCQudGltZXBpY2tlci52ZXJzaW9uID0gXCIxLjYuM1wiO1xuXG59KSk7XG4iLCIvKiBSdXNzaWFuIHRyYW5zbGF0aW9uIGZvciB0aGUgalF1ZXJ5IFRpbWVwaWNrZXIgQWRkb24gKi9cbi8qIFdyaXR0ZW4gYnkgVHJlbnQgUmljaGFyZHNvbiAqL1xuKGZ1bmN0aW9uKCQpIHtcblx0JC50aW1lcGlja2VyLnJlZ2lvbmFsWydydSddID0ge1xuXHRcdHRpbWVPbmx5VGl0bGU6ICfQktGL0LHQtdGA0LjRgtC1INCy0YDQtdC80Y8nLFxuXHRcdHRpbWVUZXh0OiAn0JLRgNC10LzRjycsXG5cdFx0aG91clRleHQ6ICfQp9Cw0YHRiycsXG5cdFx0bWludXRlVGV4dDogJ9Cc0LjQvdGD0YLRiycsXG5cdFx0c2Vjb25kVGV4dDogJ9Ch0LXQutGD0L3QtNGLJyxcblx0XHRtaWxsaXNlY1RleHQ6ICfQnNC40LvQu9C40YHQtdC60YPQvdC00YsnLFxuXHRcdG1pY3Jvc2VjVGV4dDogJ9Cc0LjQutGA0L7RgdC10LrRg9C90LTRiycsXG5cdFx0dGltZXpvbmVUZXh0OiAn0KfQsNGB0L7QstC+0Lkg0L/QvtGP0YEnLFxuXHRcdGN1cnJlbnRUZXh0OiAn0KHQtdC50YfQsNGBJyxcblx0XHRjbG9zZVRleHQ6ICfQl9Cw0LrRgNGL0YLRjCcsXG5cdFx0dGltZUZvcm1hdDogJ0hIOm1tJyxcblx0XHR0aW1lU3VmZml4OiAnJyxcblx0XHRhbU5hbWVzOiBbJ0FNJywgJ0EnXSxcblx0XHRwbU5hbWVzOiBbJ1BNJywgJ1AnXSxcblx0XHRpc1JUTDogZmFsc2Vcblx0fTtcblx0JC50aW1lcGlja2VyLnNldERlZmF1bHRzKCQudGltZXBpY2tlci5yZWdpb25hbFsncnUnXSk7XG59KShqUXVlcnkpO1xuIiwiLyogXHJcbiAgQHBhY2thZ2UgTk9UWSAtIERlcGVuZGVuY3ktZnJlZSBub3RpZmljYXRpb24gbGlicmFyeSBcclxuICBAdmVyc2lvbiB2ZXJzaW9uOiAzLjIuMC1iZXRhIFxyXG4gIEBjb250cmlidXRvcnMgaHR0cHM6Ly9naXRodWIuY29tL25lZWRpbS9ub3R5L2dyYXBocy9jb250cmlidXRvcnMgXHJcbiAgQGRvY3VtZW50YXRpb24gRXhhbXBsZXMgYW5kIERvY3VtZW50YXRpb24gLSBodHRwczovL25lZC5pbS9ub3R5IFxyXG4gIEBsaWNlbnNlIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZXM6IGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwIFxyXG4qL1xyXG5cclxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJOb3R5XCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIk5vdHlcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiTm90eVwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDYpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jc3MgPSBleHBvcnRzLmRlZXBFeHRlbmQgPSBleHBvcnRzLmFuaW1hdGlvbkVuZEV2ZW50cyA9IHVuZGVmaW5lZDtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmluQXJyYXkgPSBpbkFycmF5O1xuZXhwb3J0cy5zdG9wUHJvcGFnYXRpb24gPSBzdG9wUHJvcGFnYXRpb247XG5leHBvcnRzLmdlbmVyYXRlSUQgPSBnZW5lcmF0ZUlEO1xuZXhwb3J0cy5vdXRlckhlaWdodCA9IG91dGVySGVpZ2h0O1xuZXhwb3J0cy5hZGRMaXN0ZW5lciA9IGFkZExpc3RlbmVyO1xuZXhwb3J0cy5oYXNDbGFzcyA9IGhhc0NsYXNzO1xuZXhwb3J0cy5hZGRDbGFzcyA9IGFkZENsYXNzO1xuZXhwb3J0cy5yZW1vdmVDbGFzcyA9IHJlbW92ZUNsYXNzO1xuZXhwb3J0cy5yZW1vdmUgPSByZW1vdmU7XG5leHBvcnRzLmNsYXNzTGlzdCA9IGNsYXNzTGlzdDtcbmV4cG9ydHMudmlzaWJpbGl0eUNoYW5nZUZsb3cgPSB2aXNpYmlsaXR5Q2hhbmdlRmxvdztcbmV4cG9ydHMuY3JlYXRlQXVkaW9FbGVtZW50cyA9IGNyZWF0ZUF1ZGlvRWxlbWVudHM7XG5cbnZhciBfYXBpID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEFQSSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9hcGkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG52YXIgYW5pbWF0aW9uRW5kRXZlbnRzID0gZXhwb3J0cy5hbmltYXRpb25FbmRFdmVudHMgPSAnd2Via2l0QW5pbWF0aW9uRW5kIG1vekFuaW1hdGlvbkVuZCBNU0FuaW1hdGlvbkVuZCBvYW5pbWF0aW9uZW5kIGFuaW1hdGlvbmVuZCc7XG5cbmZ1bmN0aW9uIGluQXJyYXkobmVlZGxlLCBoYXlzdGFjaywgYXJnU3RyaWN0KSB7XG4gIHZhciBrZXkgPSB2b2lkIDA7XG4gIHZhciBzdHJpY3QgPSAhIWFyZ1N0cmljdDtcblxuICBpZiAoc3RyaWN0KSB7XG4gICAgZm9yIChrZXkgaW4gaGF5c3RhY2spIHtcbiAgICAgIGlmIChoYXlzdGFjay5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGhheXN0YWNrW2tleV0gPT09IG5lZWRsZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChrZXkgaW4gaGF5c3RhY2spIHtcbiAgICAgIGlmIChoYXlzdGFjay5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGhheXN0YWNrW2tleV0gPT09IG5lZWRsZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXZ0KSB7XG4gIGV2dCA9IGV2dCB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgaWYgKHR5cGVvZiBldnQuc3RvcFByb3BhZ2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSBlbHNlIHtcbiAgICBldnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgfVxufVxuXG52YXIgZGVlcEV4dGVuZCA9IGV4cG9ydHMuZGVlcEV4dGVuZCA9IGZ1bmN0aW9uIGRlZXBFeHRlbmQob3V0KSB7XG4gIG91dCA9IG91dCB8fCB7fTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvYmogPSBhcmd1bWVudHNbaV07XG5cbiAgICBpZiAoIW9iaikgY29udGludWU7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tleV0pKSB7XG4gICAgICAgICAgb3V0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9ialtrZXldKSA9PT0gJ29iamVjdCcgJiYgb2JqW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICBvdXRba2V5XSA9IGRlZXBFeHRlbmQob3V0W2tleV0sIG9ialtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbmZ1bmN0aW9uIGdlbmVyYXRlSUQoKSB7XG4gIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuXG4gIHZhciBpZCA9ICdub3R5XycgKyBwcmVmaXggKyAnXyc7XG5cbiAgaWQgKz0gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMDtcbiAgICB2YXIgdiA9IGMgPT09ICd4JyA/IHIgOiByICYgMHgzIHwgMHg4O1xuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBvdXRlckhlaWdodChlbCkge1xuICB2YXIgaGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xuICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cbiAgaGVpZ2h0ICs9IHBhcnNlSW50KHN0eWxlLm1hcmdpblRvcCkgKyBwYXJzZUludChzdHlsZS5tYXJnaW5Cb3R0b20pO1xuICByZXR1cm4gaGVpZ2h0O1xufVxuXG52YXIgY3NzID0gZXhwb3J0cy5jc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjc3NQcmVmaXhlcyA9IFsnV2Via2l0JywgJ08nLCAnTW96JywgJ21zJ107XG4gIHZhciBjc3NQcm9wcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL14tbXMtLywgJ21zLScpLnJlcGxhY2UoLy0oW1xcZGEtel0pL2dpLCBmdW5jdGlvbiAobWF0Y2gsIGxldHRlcikge1xuICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VmVuZG9yUHJvcChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICBpZiAobmFtZSBpbiBzdHlsZSkgcmV0dXJuIG5hbWU7XG5cbiAgICB2YXIgaSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcbiAgICB2YXIgY2FwTmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICAgIHZhciB2ZW5kb3JOYW1lID0gdm9pZCAwO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmVuZG9yTmFtZSA9IGNzc1ByZWZpeGVzW2ldICsgY2FwTmFtZTtcbiAgICAgIGlmICh2ZW5kb3JOYW1lIGluIHN0eWxlKSByZXR1cm4gdmVuZG9yTmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFN0eWxlUHJvcChuYW1lKSB7XG4gICAgbmFtZSA9IGNhbWVsQ2FzZShuYW1lKTtcbiAgICByZXR1cm4gY3NzUHJvcHNbbmFtZV0gfHwgKGNzc1Byb3BzW25hbWVdID0gZ2V0VmVuZG9yUHJvcChuYW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseUNzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSkge1xuICAgIHByb3AgPSBnZXRTdHlsZVByb3AocHJvcCk7XG4gICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHByb3AgPSB2b2lkIDA7XG4gICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICBmb3IgKHByb3AgaW4gcHJvcGVydGllcykge1xuICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgIHZhbHVlID0gcHJvcGVydGllc1twcm9wXTtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICBhcHBseUNzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGx5Q3NzKGVsZW1lbnQsIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZWwsIGV2ZW50cywgY2IpIHtcbiAgdmFyIHVzZUNhcHR1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gIGV2ZW50cyA9IGV2ZW50cy5zcGxpdCgnICcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50c1tpXSwgY2IsIHVzZUNhcHR1cmUpO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudHNbaV0sIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICB2YXIgbGlzdCA9IHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyA/IGVsZW1lbnQgOiBjbGFzc0xpc3QoZWxlbWVudCk7XG4gIHJldHVybiBsaXN0LmluZGV4T2YoJyAnICsgbmFtZSArICcgJykgPj0gMDtcbn1cblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICB2YXIgb2xkTGlzdCA9IGNsYXNzTGlzdChlbGVtZW50KTtcbiAgdmFyIG5ld0xpc3QgPSBvbGRMaXN0ICsgbmFtZTtcblxuICBpZiAoaGFzQ2xhc3Mob2xkTGlzdCwgbmFtZSkpIHJldHVybjtcblxuICAvLyBUcmltIHRoZSBvcGVuaW5nIHNwYWNlLlxuICBlbGVtZW50LmNsYXNzTmFtZSA9IG5ld0xpc3Quc3Vic3RyaW5nKDEpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBuYW1lKSB7XG4gIHZhciBvbGRMaXN0ID0gY2xhc3NMaXN0KGVsZW1lbnQpO1xuICB2YXIgbmV3TGlzdCA9IHZvaWQgMDtcblxuICBpZiAoIWhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpKSByZXR1cm47XG5cbiAgLy8gUmVwbGFjZSB0aGUgY2xhc3MgbmFtZS5cbiAgbmV3TGlzdCA9IG9sZExpc3QucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpO1xuXG4gIC8vIFRyaW0gdGhlIG9wZW5pbmcgYW5kIGNsb3Npbmcgc3BhY2VzLlxuICBlbGVtZW50LmNsYXNzTmFtZSA9IG5ld0xpc3Quc3Vic3RyaW5nKDEsIG5ld0xpc3QubGVuZ3RoIC0gMSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xhc3NMaXN0KGVsZW1lbnQpIHtcbiAgcmV0dXJuICgnICcgKyAoZWxlbWVudCAmJiBlbGVtZW50LmNsYXNzTmFtZSB8fCAnJykgKyAnICcpLnJlcGxhY2UoL1xccysvZ2ksICcgJyk7XG59XG5cbmZ1bmN0aW9uIHZpc2liaWxpdHlDaGFuZ2VGbG93KCkge1xuICB2YXIgaGlkZGVuID0gdm9pZCAwO1xuICB2YXIgdmlzaWJpbGl0eUNoYW5nZSA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudC5oaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gT3BlcmEgMTIuMTAgYW5kIEZpcmVmb3ggMTggYW5kIGxhdGVyIHN1cHBvcnRcbiAgICBoaWRkZW4gPSAnaGlkZGVuJztcbiAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC5tc0hpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBoaWRkZW4gPSAnbXNIaWRkZW4nO1xuICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnbXN2aXNpYmlsaXR5Y2hhbmdlJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQud2Via2l0SGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xuICAgIGhpZGRlbiA9ICd3ZWJraXRIaWRkZW4nO1xuICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnd2Via2l0dmlzaWJpbGl0eWNoYW5nZSc7XG4gIH1cblxuICBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgQVBJLlBhZ2VIaWRkZW4gPSBkb2N1bWVudFtoaWRkZW5dO1xuICAgIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICBBUEkuUGFnZUhpZGRlbiA9IHRydWU7XG4gICAgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Gb2N1cygpIHtcbiAgICBBUEkuUGFnZUhpZGRlbiA9IGZhbHNlO1xuICAgIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgaWYgKEFQSS5QYWdlSGlkZGVuKSBzdG9wQWxsKCk7ZWxzZSByZXN1bWVBbGwoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3BBbGwoKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBPYmplY3Qua2V5cyhBUEkuU3RvcmUpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChBUEkuU3RvcmUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgaWYgKEFQSS5TdG9yZVtpZF0ub3B0aW9ucy52aXNpYmlsaXR5Q29udHJvbCkge1xuICAgICAgICAgICAgQVBJLlN0b3JlW2lkXS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCAxMDApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzdW1lQWxsKCkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgT2JqZWN0LmtleXMoQVBJLlN0b3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoQVBJLlN0b3JlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIGlmIChBUEkuU3RvcmVbaWRdLm9wdGlvbnMudmlzaWJpbGl0eUNvbnRyb2wpIHtcbiAgICAgICAgICAgIEFQSS5TdG9yZVtpZF0ucmVzdW1lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIEFQSS5xdWV1ZVJlbmRlckFsbCgpO1xuICAgIH0sIDEwMCk7XG4gIH1cblxuICBpZiAodmlzaWJpbGl0eUNoYW5nZSkge1xuICAgIGFkZExpc3RlbmVyKGRvY3VtZW50LCB2aXNpYmlsaXR5Q2hhbmdlLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICB9XG5cbiAgYWRkTGlzdGVuZXIod2luZG93LCAnYmx1cicsIG9uQmx1cik7XG4gIGFkZExpc3RlbmVyKHdpbmRvdywgJ2ZvY3VzJywgb25Gb2N1cyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUF1ZGlvRWxlbWVudHMocmVmKSB7XG4gIGlmIChyZWYuaGFzU291bmQpIHtcbiAgICB2YXIgYXVkaW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcblxuICAgIHJlZi5vcHRpb25zLnNvdW5kcy5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKTtcbiAgICAgIHNvdXJjZS5zcmMgPSBzO1xuICAgICAgc291cmNlLnR5cGUgPSAnYXVkaW8vJyArIGdldEV4dGVuc2lvbihzKTtcbiAgICAgIGF1ZGlvRWxlbWVudC5hcHBlbmRDaGlsZChzb3VyY2UpO1xuICAgIH0pO1xuXG4gICAgaWYgKHJlZi5iYXJEb20pIHtcbiAgICAgIHJlZi5iYXJEb20uYXBwZW5kQ2hpbGQoYXVkaW9FbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLmFwcGVuZENoaWxkKGF1ZGlvRWxlbWVudCk7XG4gICAgfVxuXG4gICAgYXVkaW9FbGVtZW50LnZvbHVtZSA9IHJlZi5vcHRpb25zLnNvdW5kcy52b2x1bWU7XG5cbiAgICBpZiAoIXJlZi5zb3VuZFBsYXllZCkge1xuICAgICAgYXVkaW9FbGVtZW50LnBsYXkoKTtcbiAgICAgIHJlZi5zb3VuZFBsYXllZCA9IHRydWU7XG4gICAgfVxuXG4gICAgYXVkaW9FbGVtZW50Lm9uZW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmUoYXVkaW9FbGVtZW50KTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbihmaWxlTmFtZSkge1xuICByZXR1cm4gZmlsZU5hbWUubWF0Y2goL1xcLihbXi5dKykkLylbMV07XG59XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5EZWZhdWx0cyA9IGV4cG9ydHMuU3RvcmUgPSBleHBvcnRzLlF1ZXVlcyA9IGV4cG9ydHMuRGVmYXVsdE1heFZpc2libGUgPSBleHBvcnRzLmRvY1RpdGxlID0gZXhwb3J0cy5Eb2NNb2RhbENvdW50ID0gZXhwb3J0cy5QYWdlSGlkZGVuID0gdW5kZWZpbmVkO1xuZXhwb3J0cy5nZXRRdWV1ZUNvdW50cyA9IGdldFF1ZXVlQ291bnRzO1xuZXhwb3J0cy5hZGRUb1F1ZXVlID0gYWRkVG9RdWV1ZTtcbmV4cG9ydHMucmVtb3ZlRnJvbVF1ZXVlID0gcmVtb3ZlRnJvbVF1ZXVlO1xuZXhwb3J0cy5xdWV1ZVJlbmRlciA9IHF1ZXVlUmVuZGVyO1xuZXhwb3J0cy5xdWV1ZVJlbmRlckFsbCA9IHF1ZXVlUmVuZGVyQWxsO1xuZXhwb3J0cy5naG9zdEZpeCA9IGdob3N0Rml4O1xuZXhwb3J0cy5idWlsZCA9IGJ1aWxkO1xuZXhwb3J0cy5oYXNCdXR0b25zID0gaGFzQnV0dG9ucztcbmV4cG9ydHMuaGFuZGxlTW9kYWwgPSBoYW5kbGVNb2RhbDtcbmV4cG9ydHMuaGFuZGxlTW9kYWxDbG9zZSA9IGhhbmRsZU1vZGFsQ2xvc2U7XG5leHBvcnRzLnF1ZXVlQ2xvc2UgPSBxdWV1ZUNsb3NlO1xuZXhwb3J0cy5kZXF1ZXVlQ2xvc2UgPSBkZXF1ZXVlQ2xvc2U7XG5leHBvcnRzLmZpcmUgPSBmaXJlO1xuZXhwb3J0cy5vcGVuRmxvdyA9IG9wZW5GbG93O1xuZXhwb3J0cy5jbG9zZUZsb3cgPSBjbG9zZUZsb3c7XG5cbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgVXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG52YXIgUGFnZUhpZGRlbiA9IGV4cG9ydHMuUGFnZUhpZGRlbiA9IGZhbHNlO1xudmFyIERvY01vZGFsQ291bnQgPSBleHBvcnRzLkRvY01vZGFsQ291bnQgPSAwO1xuXG52YXIgRG9jVGl0bGVQcm9wcyA9IHtcbiAgb3JpZ2luYWxUaXRsZTogbnVsbCxcbiAgY291bnQ6IDAsXG4gIGNoYW5nZWQ6IGZhbHNlLFxuICB0aW1lcjogLTFcbn07XG5cbnZhciBkb2NUaXRsZSA9IGV4cG9ydHMuZG9jVGl0bGUgPSB7XG4gIGluY3JlbWVudDogZnVuY3Rpb24gaW5jcmVtZW50KCkge1xuICAgIERvY1RpdGxlUHJvcHMuY291bnQrKztcblxuICAgIGRvY1RpdGxlLl91cGRhdGUoKTtcbiAgfSxcblxuICBkZWNyZW1lbnQ6IGZ1bmN0aW9uIGRlY3JlbWVudCgpIHtcbiAgICBEb2NUaXRsZVByb3BzLmNvdW50LS07XG5cbiAgICBpZiAoRG9jVGl0bGVQcm9wcy5jb3VudCA8PSAwKSB7XG4gICAgICBkb2NUaXRsZS5fY2xlYXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkb2NUaXRsZS5fdXBkYXRlKCk7XG4gIH0sXG5cbiAgX3VwZGF0ZTogZnVuY3Rpb24gX3VwZGF0ZSgpIHtcbiAgICB2YXIgdGl0bGUgPSBkb2N1bWVudC50aXRsZTtcblxuICAgIGlmICghRG9jVGl0bGVQcm9wcy5jaGFuZ2VkKSB7XG4gICAgICBEb2NUaXRsZVByb3BzLm9yaWdpbmFsVGl0bGUgPSB0aXRsZTtcbiAgICAgIGRvY3VtZW50LnRpdGxlID0gJygnICsgRG9jVGl0bGVQcm9wcy5jb3VudCArICcpICcgKyB0aXRsZTtcbiAgICAgIERvY1RpdGxlUHJvcHMuY2hhbmdlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LnRpdGxlID0gJygnICsgRG9jVGl0bGVQcm9wcy5jb3VudCArICcpICcgKyBEb2NUaXRsZVByb3BzLm9yaWdpbmFsVGl0bGU7XG4gICAgfVxuICB9LFxuXG4gIF9jbGVhcjogZnVuY3Rpb24gX2NsZWFyKCkge1xuICAgIGlmIChEb2NUaXRsZVByb3BzLmNoYW5nZWQpIHtcbiAgICAgIERvY1RpdGxlUHJvcHMuY291bnQgPSAwO1xuICAgICAgZG9jdW1lbnQudGl0bGUgPSBEb2NUaXRsZVByb3BzLm9yaWdpbmFsVGl0bGU7XG4gICAgICBEb2NUaXRsZVByb3BzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBEZWZhdWx0TWF4VmlzaWJsZSA9IGV4cG9ydHMuRGVmYXVsdE1heFZpc2libGUgPSA1O1xuXG52YXIgUXVldWVzID0gZXhwb3J0cy5RdWV1ZXMgPSB7XG4gIGdsb2JhbDoge1xuICAgIG1heFZpc2libGU6IERlZmF1bHRNYXhWaXNpYmxlLFxuICAgIHF1ZXVlOiBbXVxuICB9XG59O1xuXG52YXIgU3RvcmUgPSBleHBvcnRzLlN0b3JlID0ge307XG5cbnZhciBEZWZhdWx0cyA9IGV4cG9ydHMuRGVmYXVsdHMgPSB7XG4gIHR5cGU6ICdhbGVydCcsXG4gIGxheW91dDogJ3RvcFJpZ2h0JyxcbiAgdGhlbWU6ICdtaW50JyxcbiAgdGV4dDogJycsXG4gIHRpbWVvdXQ6IGZhbHNlLFxuICBwcm9ncmVzc0JhcjogdHJ1ZSxcbiAgY2xvc2VXaXRoOiBbJ2NsaWNrJ10sXG4gIGFuaW1hdGlvbjoge1xuICAgIG9wZW46ICdub3R5X2VmZmVjdHNfb3BlbicsXG4gICAgY2xvc2U6ICdub3R5X2VmZmVjdHNfY2xvc2UnXG4gIH0sXG4gIGlkOiBmYWxzZSxcbiAgZm9yY2U6IGZhbHNlLFxuICBraWxsZXI6IGZhbHNlLFxuICBxdWV1ZTogJ2dsb2JhbCcsXG4gIGNvbnRhaW5lcjogZmFsc2UsXG4gIGJ1dHRvbnM6IFtdLFxuICBjYWxsYmFja3M6IHtcbiAgICBiZWZvcmVTaG93OiBudWxsLFxuICAgIG9uU2hvdzogbnVsbCxcbiAgICBhZnRlclNob3c6IG51bGwsXG4gICAgb25DbG9zZTogbnVsbCxcbiAgICBhZnRlckNsb3NlOiBudWxsLFxuICAgIG9uQ2xpY2s6IG51bGwsXG4gICAgb25Ib3ZlcjogbnVsbCxcbiAgICBvblRlbXBsYXRlOiBudWxsXG4gIH0sXG4gIHNvdW5kczoge1xuICAgIHNvdXJjZXM6IFtdLFxuICAgIHZvbHVtZTogMSxcbiAgICBjb25kaXRpb25zOiBbXVxuICB9LFxuICB0aXRsZUNvdW50OiB7XG4gICAgY29uZGl0aW9uczogW11cbiAgfSxcbiAgbW9kYWw6IGZhbHNlLFxuICB2aXNpYmlsaXR5Q29udHJvbDogZmFsc2VcblxuICAvKipcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVldWVOYW1lXHJcbiAgICogQHJldHVybiB7b2JqZWN0fVxyXG4gICAqL1xufTtmdW5jdGlvbiBnZXRRdWV1ZUNvdW50cygpIHtcbiAgdmFyIHF1ZXVlTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ2dsb2JhbCc7XG5cbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIG1heCA9IERlZmF1bHRNYXhWaXNpYmxlO1xuXG4gIGlmIChRdWV1ZXMuaGFzT3duUHJvcGVydHkocXVldWVOYW1lKSkge1xuICAgIG1heCA9IFF1ZXVlc1txdWV1ZU5hbWVdLm1heFZpc2libGU7XG4gICAgT2JqZWN0LmtleXMoU3RvcmUpLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgIGlmIChTdG9yZVtpXS5vcHRpb25zLnF1ZXVlID09PSBxdWV1ZU5hbWUgJiYgIVN0b3JlW2ldLmNsb3NlZCkgY291bnQrKztcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3VycmVudDogY291bnQsXG4gICAgbWF4VmlzaWJsZTogbWF4XG4gIH07XG59XG5cbi8qKlxyXG4gKiBAcGFyYW0ge05vdHl9IHJlZlxyXG4gKiBAcmV0dXJuIHt2b2lkfVxyXG4gKi9cbmZ1bmN0aW9uIGFkZFRvUXVldWUocmVmKSB7XG4gIGlmICghUXVldWVzLmhhc093blByb3BlcnR5KHJlZi5vcHRpb25zLnF1ZXVlKSkge1xuICAgIFF1ZXVlc1tyZWYub3B0aW9ucy5xdWV1ZV0gPSB7IG1heFZpc2libGU6IERlZmF1bHRNYXhWaXNpYmxlLCBxdWV1ZTogW10gfTtcbiAgfVxuXG4gIFF1ZXVlc1tyZWYub3B0aW9ucy5xdWV1ZV0ucXVldWUucHVzaChyZWYpO1xufVxuXG4vKipcclxuICogQHBhcmFtIHtOb3R5fSByZWZcclxuICogQHJldHVybiB7dm9pZH1cclxuICovXG5mdW5jdGlvbiByZW1vdmVGcm9tUXVldWUocmVmKSB7XG4gIGlmIChRdWV1ZXMuaGFzT3duUHJvcGVydHkocmVmLm9wdGlvbnMucXVldWUpKSB7XG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgT2JqZWN0LmtleXMoUXVldWVzW3JlZi5vcHRpb25zLnF1ZXVlXS5xdWV1ZSkuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgaWYgKFF1ZXVlc1tyZWYub3B0aW9ucy5xdWV1ZV0ucXVldWVbaV0uaWQgIT09IHJlZi5pZCkge1xuICAgICAgICBxdWV1ZS5wdXNoKFF1ZXVlc1tyZWYub3B0aW9ucy5xdWV1ZV0ucXVldWVbaV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFF1ZXVlc1tyZWYub3B0aW9ucy5xdWV1ZV0ucXVldWUgPSBxdWV1ZTtcbiAgfVxufVxuXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXVlTmFtZVxyXG4gKiBAcmV0dXJuIHt2b2lkfVxyXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlUmVuZGVyKCkge1xuICB2YXIgcXVldWVOYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnZ2xvYmFsJztcblxuICBpZiAoUXVldWVzLmhhc093blByb3BlcnR5KHF1ZXVlTmFtZSkpIHtcbiAgICB2YXIgbm90eSA9IFF1ZXVlc1txdWV1ZU5hbWVdLnF1ZXVlLnNoaWZ0KCk7XG5cbiAgICBpZiAobm90eSkgbm90eS5zaG93KCk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIEByZXR1cm4ge3ZvaWR9XHJcbiAqL1xuZnVuY3Rpb24gcXVldWVSZW5kZXJBbGwoKSB7XG4gIE9iamVjdC5rZXlzKFF1ZXVlcykuZm9yRWFjaChmdW5jdGlvbiAocXVldWVOYW1lKSB7XG4gICAgcXVldWVSZW5kZXIocXVldWVOYW1lKTtcbiAgfSk7XG59XG5cbi8qKlxyXG4gKiBAcGFyYW0ge05vdHl9IHJlZlxyXG4gKiBAcmV0dXJuIHt2b2lkfVxyXG4gKi9cbmZ1bmN0aW9uIGdob3N0Rml4KHJlZikge1xuICB2YXIgZ2hvc3RJRCA9IFV0aWxzLmdlbmVyYXRlSUQoJ2dob3N0Jyk7XG4gIHZhciBnaG9zdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBnaG9zdC5zZXRBdHRyaWJ1dGUoJ2lkJywgZ2hvc3RJRCk7XG4gIFV0aWxzLmNzcyhnaG9zdCwge1xuICAgIGhlaWdodDogVXRpbHMub3V0ZXJIZWlnaHQocmVmLmJhckRvbSkgKyAncHgnXG4gIH0pO1xuXG4gIHJlZi5iYXJEb20uaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmVuZCcsIGdob3N0Lm91dGVySFRNTCk7XG5cbiAgVXRpbHMucmVtb3ZlKHJlZi5iYXJEb20pO1xuICBnaG9zdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGdob3N0SUQpO1xuICBVdGlscy5hZGRDbGFzcyhnaG9zdCwgJ25vdHlfZml4X2VmZmVjdHNfaGVpZ2h0Jyk7XG4gIFV0aWxzLmFkZExpc3RlbmVyKGdob3N0LCBVdGlscy5hbmltYXRpb25FbmRFdmVudHMsIGZ1bmN0aW9uICgpIHtcbiAgICBVdGlscy5yZW1vdmUoZ2hvc3QpO1xuICB9KTtcbn1cblxuLyoqXHJcbiAqIEBwYXJhbSB7Tm90eX0gcmVmXHJcbiAqIEByZXR1cm4ge3ZvaWR9XHJcbiAqL1xuZnVuY3Rpb24gYnVpbGQocmVmKSB7XG4gIGZpbmRPckNyZWF0ZUNvbnRhaW5lcihyZWYpO1xuXG4gIHZhciBtYXJrdXAgPSAnPGRpdiBjbGFzcz1cIm5vdHlfYm9keVwiPicgKyByZWYub3B0aW9ucy50ZXh0ICsgJzwvZGl2PicgKyBidWlsZEJ1dHRvbnMocmVmKSArICc8ZGl2IGNsYXNzPVwibm90eV9wcm9ncmVzc2JhclwiPjwvZGl2Pic7XG5cbiAgcmVmLmJhckRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICByZWYuYmFyRG9tLnNldEF0dHJpYnV0ZSgnaWQnLCByZWYuaWQpO1xuICBVdGlscy5hZGRDbGFzcyhyZWYuYmFyRG9tLCAnbm90eV9iYXIgbm90eV90eXBlX18nICsgcmVmLm9wdGlvbnMudHlwZSArICcgbm90eV90aGVtZV9fJyArIHJlZi5vcHRpb25zLnRoZW1lKTtcblxuICByZWYuYmFyRG9tLmlubmVySFRNTCA9IG1hcmt1cDtcblxuICBmaXJlKHJlZiwgJ29uVGVtcGxhdGUnKTtcbn1cblxuLyoqXHJcbiAqIEBwYXJhbSB7Tm90eX0gcmVmXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xuZnVuY3Rpb24gaGFzQnV0dG9ucyhyZWYpIHtcbiAgcmV0dXJuICEhKHJlZi5vcHRpb25zLmJ1dHRvbnMgJiYgT2JqZWN0LmtleXMocmVmLm9wdGlvbnMuYnV0dG9ucykubGVuZ3RoKTtcbn1cblxuLyoqXHJcbiAqIEBwYXJhbSB7Tm90eX0gcmVmXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICovXG5mdW5jdGlvbiBidWlsZEJ1dHRvbnMocmVmKSB7XG4gIGlmIChoYXNCdXR0b25zKHJlZikpIHtcbiAgICB2YXIgYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIFV0aWxzLmFkZENsYXNzKGJ1dHRvbnMsICdub3R5X2J1dHRvbnMnKTtcblxuICAgIE9iamVjdC5rZXlzKHJlZi5vcHRpb25zLmJ1dHRvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgYnV0dG9ucy5hcHBlbmRDaGlsZChyZWYub3B0aW9ucy5idXR0b25zW2tleV0uZG9tKTtcbiAgICB9KTtcblxuICAgIHJlZi5vcHRpb25zLmJ1dHRvbnMuZm9yRWFjaChmdW5jdGlvbiAoYnRuKSB7XG4gICAgICBidXR0b25zLmFwcGVuZENoaWxkKGJ0bi5kb20pO1xuICAgIH0pO1xuICAgIHJldHVybiBidXR0b25zLm91dGVySFRNTDtcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxyXG4gKiBAcGFyYW0ge05vdHl9IHJlZlxyXG4gKiBAcmV0dXJuIHt2b2lkfVxyXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU1vZGFsKHJlZikge1xuICBpZiAocmVmLm9wdGlvbnMubW9kYWwpIHtcbiAgICBpZiAoRG9jTW9kYWxDb3VudCA9PT0gMCkge1xuICAgICAgY3JlYXRlTW9kYWwocmVmKTtcbiAgICB9XG5cbiAgICBleHBvcnRzLkRvY01vZGFsQ291bnQgPSBEb2NNb2RhbENvdW50ICs9IDE7XG4gIH1cbn1cblxuLyoqXHJcbiAqIEBwYXJhbSB7Tm90eX0gcmVmXHJcbiAqIEByZXR1cm4ge3ZvaWR9XHJcbiAqL1xuZnVuY3Rpb24gaGFuZGxlTW9kYWxDbG9zZShyZWYpIHtcbiAgaWYgKHJlZi5vcHRpb25zLm1vZGFsICYmIERvY01vZGFsQ291bnQgPiAwKSB7XG4gICAgZXhwb3J0cy5Eb2NNb2RhbENvdW50ID0gRG9jTW9kYWxDb3VudCAtPSAxO1xuXG4gICAgaWYgKERvY01vZGFsQ291bnQgPD0gMCkge1xuICAgICAgdmFyIG1vZGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm5vdHlfbW9kYWwnKTtcblxuICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgIFV0aWxzLnJlbW92ZUNsYXNzKG1vZGFsLCAnbm90eV9tb2RhbF9vcGVuJyk7XG4gICAgICAgIFV0aWxzLmFkZENsYXNzKG1vZGFsLCAnbm90eV9tb2RhbF9jbG9zZScpO1xuICAgICAgICBVdGlscy5hZGRMaXN0ZW5lcihtb2RhbCwgVXRpbHMuYW5pbWF0aW9uRW5kRXZlbnRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgVXRpbHMucmVtb3ZlKG1vZGFsKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxyXG4gKiBAcmV0dXJuIHt2b2lkfVxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vZGFsKCkge1xuICB2YXIgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcbiAgdmFyIG1vZGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIFV0aWxzLmFkZENsYXNzKG1vZGFsLCAnbm90eV9tb2RhbCcpO1xuICBib2R5Lmluc2VydEJlZm9yZShtb2RhbCwgYm9keS5maXJzdENoaWxkKTtcbiAgVXRpbHMuYWRkQ2xhc3MobW9kYWwsICdub3R5X21vZGFsX29wZW4nKTtcblxuICBVdGlscy5hZGRMaXN0ZW5lcihtb2RhbCwgVXRpbHMuYW5pbWF0aW9uRW5kRXZlbnRzLCBmdW5jdGlvbiAoKSB7XG4gICAgVXRpbHMucmVtb3ZlQ2xhc3MobW9kYWwsICdub3R5X21vZGFsX29wZW4nKTtcbiAgfSk7XG59XG5cbi8qKlxyXG4gKiBAcGFyYW0ge05vdHl9IHJlZlxyXG4gKiBAcmV0dXJuIHt2b2lkfVxyXG4gKi9cbmZ1bmN0aW9uIGZpbmRPckNyZWF0ZUNvbnRhaW5lcihyZWYpIHtcbiAgaWYgKHJlZi5vcHRpb25zLmNvbnRhaW5lcikge1xuICAgIHJlZi5sYXlvdXREb20gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJlZi5vcHRpb25zLmNvbnRhaW5lcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxheW91dElEID0gJ25vdHlfbGF5b3V0X18nICsgcmVmLm9wdGlvbnMubGF5b3V0O1xuICByZWYubGF5b3V0RG9tID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZGl2IycgKyBsYXlvdXRJRCk7XG5cbiAgaWYgKCFyZWYubGF5b3V0RG9tKSB7XG4gICAgcmVmLmxheW91dERvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJlZi5sYXlvdXREb20uc2V0QXR0cmlidXRlKCdpZCcsIGxheW91dElEKTtcbiAgICByZWYubGF5b3V0RG9tLnNldEF0dHJpYnV0ZSgncm9sZScsICdhbGVydCcpO1xuICAgIHJlZi5sYXlvdXREb20uc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XG4gICAgVXRpbHMuYWRkQ2xhc3MocmVmLmxheW91dERvbSwgJ25vdHlfbGF5b3V0Jyk7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLmFwcGVuZENoaWxkKHJlZi5sYXlvdXREb20pO1xuICB9XG59XG5cbi8qKlxyXG4gKiBAcGFyYW0ge05vdHl9IHJlZlxyXG4gKiBAcmV0dXJuIHt2b2lkfVxyXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQ2xvc2UocmVmKSB7XG4gIGlmIChyZWYub3B0aW9ucy50aW1lb3V0KSB7XG4gICAgaWYgKHJlZi5vcHRpb25zLnByb2dyZXNzQmFyICYmIHJlZi5wcm9ncmVzc0RvbSkge1xuICAgICAgVXRpbHMuY3NzKHJlZi5wcm9ncmVzc0RvbSwge1xuICAgICAgICB0cmFuc2l0aW9uOiAnd2lkdGggJyArIHJlZi5vcHRpb25zLnRpbWVvdXQgKyAnbXMgbGluZWFyJyxcbiAgICAgICAgd2lkdGg6ICcwJSdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsZWFyVGltZW91dChyZWYuY2xvc2VUaW1lcik7XG5cbiAgICByZWYuY2xvc2VUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmVmLmNsb3NlKCk7XG4gICAgfSwgcmVmLm9wdGlvbnMudGltZW91dCk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIEBwYXJhbSB7Tm90eX0gcmVmXHJcbiAqIEByZXR1cm4ge3ZvaWR9XHJcbiAqL1xuZnVuY3Rpb24gZGVxdWV1ZUNsb3NlKHJlZikge1xuICBpZiAocmVmLm9wdGlvbnMudGltZW91dCAmJiByZWYuY2xvc2VUaW1lcikge1xuICAgIGNsZWFyVGltZW91dChyZWYuY2xvc2VUaW1lcik7XG4gICAgcmVmLmNsb3NlVGltZXIgPSAtMTtcblxuICAgIGlmIChyZWYub3B0aW9ucy5wcm9ncmVzc0JhciAmJiByZWYucHJvZ3Jlc3NEb20pIHtcbiAgICAgIFV0aWxzLmNzcyhyZWYucHJvZ3Jlc3NEb20sIHtcbiAgICAgICAgdHJhbnNpdGlvbjogJ3dpZHRoIDBtcyBsaW5lYXInLFxuICAgICAgICB3aWR0aDogJzEwMCUnXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXHJcbiAqIEBwYXJhbSB7Tm90eX0gcmVmXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcclxuICogQHJldHVybiB7dm9pZH1cclxuICovXG5mdW5jdGlvbiBmaXJlKHJlZiwgZXZlbnROYW1lKSB7XG4gIGlmIChyZWYubGlzdGVuZXJzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICByZWYubGlzdGVuZXJzW2V2ZW50TmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2IuYXBwbHkocmVmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcclxuICogQHBhcmFtIHtOb3R5fSByZWZcclxuICogQHJldHVybiB7dm9pZH1cclxuICovXG5mdW5jdGlvbiBvcGVuRmxvdyhyZWYpIHtcbiAgZmlyZShyZWYsICdhZnRlclNob3cnKTtcbiAgcXVldWVDbG9zZShyZWYpO1xuXG4gIFV0aWxzLmFkZExpc3RlbmVyKHJlZi5iYXJEb20sICdtb3VzZWVudGVyJywgZnVuY3Rpb24gKCkge1xuICAgIGRlcXVldWVDbG9zZShyZWYpO1xuICB9KTtcblxuICBVdGlscy5hZGRMaXN0ZW5lcihyZWYuYmFyRG9tLCAnbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICBxdWV1ZUNsb3NlKHJlZik7XG4gIH0pO1xufVxuXG4vKipcclxuICogQHBhcmFtIHtOb3R5fSByZWZcclxuICogQHJldHVybiB7dm9pZH1cclxuICovXG5mdW5jdGlvbiBjbG9zZUZsb3cocmVmKSB7XG4gIGRlbGV0ZSBTdG9yZVtyZWYuaWRdO1xuICByZWYuY2xvc2luZyA9IGZhbHNlO1xuICBmaXJlKHJlZiwgJ2FmdGVyQ2xvc2UnKTtcblxuICBVdGlscy5yZW1vdmUocmVmLmJhckRvbSk7XG5cbiAgaWYgKHJlZi5sYXlvdXREb20ucXVlcnlTZWxlY3RvckFsbCgnLm5vdHlfYmFyJykubGVuZ3RoID09PSAwICYmICFyZWYub3B0aW9ucy5jb250YWluZXIpIHtcbiAgICBVdGlscy5yZW1vdmUocmVmLmxheW91dERvbSk7XG4gIH1cblxuICBpZiAoVXRpbHMuaW5BcnJheSgnZG9jVmlzaWJsZScsIHJlZi5vcHRpb25zLnRpdGxlQ291bnQuY29uZGl0aW9ucykgfHwgVXRpbHMuaW5BcnJheSgnZG9jSGlkZGVuJywgcmVmLm9wdGlvbnMudGl0bGVDb3VudC5jb25kaXRpb25zKSkge1xuICAgIGRvY1RpdGxlLmRlY3JlbWVudCgpO1xuICB9XG5cbiAgcXVldWVSZW5kZXIocmVmLm9wdGlvbnMucXVldWUpO1xufVxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTm90eUJ1dHRvbiA9IHVuZGVmaW5lZDtcblxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBVdGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBOb3R5QnV0dG9uID0gZXhwb3J0cy5Ob3R5QnV0dG9uID0gZnVuY3Rpb24gTm90eUJ1dHRvbihodG1sLCBjbGFzc2VzLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm90eUJ1dHRvbik7XG5cbiAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgdGhpcy5kb20uaW5uZXJIVE1MID0gaHRtbDtcbiAgdGhpcy5pZCA9IGF0dHJpYnV0ZXMuaWQgPSBhdHRyaWJ1dGVzLmlkIHx8IFV0aWxzLmdlbmVyYXRlSUQoJ2J1dHRvbicpO1xuICB0aGlzLmNiID0gY2I7XG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgIF90aGlzLmRvbS5zZXRBdHRyaWJ1dGUocHJvcGVydHlOYW1lLCBhdHRyaWJ1dGVzW3Byb3BlcnR5TmFtZV0pO1xuICB9KTtcbiAgVXRpbHMuYWRkQ2xhc3ModGhpcy5kb20sIGNsYXNzZXMgfHwgJ25vdHlfYnRuJyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFB1c2ggPSBleHBvcnRzLlB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFB1c2goKSB7XG4gICAgdmFyIHdvcmtlclBhdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcvc2VydmljZS13b3JrZXIuanMnO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFB1c2gpO1xuXG4gICAgdGhpcy5zdWJEYXRhID0ge307XG4gICAgdGhpcy53b3JrZXJQYXRoID0gd29ya2VyUGF0aDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHtcbiAgICAgIG9uUGVybWlzc2lvbkdyYW50ZWQ6IFtdLFxuICAgICAgb25QZXJtaXNzaW9uRGVuaWVkOiBbXSxcbiAgICAgIG9uU3Vic2NyaXB0aW9uU3VjY2VzczogW10sXG4gICAgICBvblN1YnNjcmlwdGlvbkNhbmNlbDogW10sXG4gICAgICBvbldvcmtlckVycm9yOiBbXSxcbiAgICAgIG9uV29ya2VyU3VjY2VzczogW10sXG4gICAgICBvbldvcmtlck5vdFN1cHBvcnRlZDogW11cbiAgICB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiXHJcbiAgICogQHJldHVybiB7UHVzaH1cclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhQdXNoLCBbe1xuICAgIGtleTogJ29uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnROYW1lKSB7XG4gICAgICB2YXIgY2IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nICYmIHRoaXMubGlzdGVuZXJzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXS5wdXNoKGNiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZmlyZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcmUoZXZlbnROYW1lKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcblxuICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiLmFwcGx5KF90aGlzLCBwYXJhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgY29uc29sZS5sb2coJ05PVCBJTVBMRU1FTlRFRCBZRVQnKTtcbiAgICB9XG5cbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXNTdXBwb3J0ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gd2luZG93Lk5vdGlmaWNhdGlvbiB8fCB3aW5kb3cud2Via2l0Tm90aWZpY2F0aW9ucyB8fCBuYXZpZ2F0b3IubW96Tm90aWZpY2F0aW9uIHx8IHdpbmRvdy5leHRlcm5hbCAmJiB3aW5kb3cuZXh0ZXJuYWwubXNJc1NpdGVNb2RlKCkgIT09IHVuZGVmaW5lZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0UGVybWlzc2lvblN0YXR1cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBlcm1pc3Npb25TdGF0dXMoKSB7XG4gICAgICB2YXIgcGVybSA9ICdkZWZhdWx0JztcblxuICAgICAgaWYgKHdpbmRvdy5Ob3RpZmljYXRpb24gJiYgd2luZG93Lk5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uTGV2ZWwpIHtcbiAgICAgICAgcGVybSA9IHdpbmRvdy5Ob3RpZmljYXRpb24ucGVybWlzc2lvbkxldmVsO1xuICAgICAgfSBlbHNlIGlmICh3aW5kb3cud2Via2l0Tm90aWZpY2F0aW9ucyAmJiB3aW5kb3cud2Via2l0Tm90aWZpY2F0aW9ucy5jaGVja1Blcm1pc3Npb24pIHtcbiAgICAgICAgc3dpdGNoICh3aW5kb3cud2Via2l0Tm90aWZpY2F0aW9ucy5jaGVja1Blcm1pc3Npb24oKSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHBlcm0gPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBwZXJtID0gJ2dyYW50ZWQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHBlcm0gPSAnZGVuaWVkJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh3aW5kb3cuTm90aWZpY2F0aW9uICYmIHdpbmRvdy5Ob3RpZmljYXRpb24ucGVybWlzc2lvbikge1xuICAgICAgICBwZXJtID0gd2luZG93Lk5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uO1xuICAgICAgfSBlbHNlIGlmIChuYXZpZ2F0b3IubW96Tm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHBlcm0gPSAnZ3JhbnRlZCc7XG4gICAgICB9IGVsc2UgaWYgKHdpbmRvdy5leHRlcm5hbCAmJiB3aW5kb3cuZXh0ZXJuYWwubXNJc1NpdGVNb2RlKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwZXJtID0gd2luZG93LmV4dGVybmFsLm1zSXNTaXRlTW9kZSgpID8gJ2dyYW50ZWQnIDogJ2RlZmF1bHQnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGVybS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0RW5kcG9pbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbmRwb2ludChzdWJzY3JpcHRpb24pIHtcbiAgICAgIHZhciBlbmRwb2ludCA9IHN1YnNjcmlwdGlvbi5lbmRwb2ludDtcbiAgICAgIHZhciBzdWJzY3JpcHRpb25JZCA9IHN1YnNjcmlwdGlvbi5zdWJzY3JpcHRpb25JZDtcblxuICAgICAgLy8gZml4IGZvciBDaHJvbWUgPCA0NVxuICAgICAgaWYgKHN1YnNjcmlwdGlvbklkICYmIGVuZHBvaW50LmluZGV4T2Yoc3Vic2NyaXB0aW9uSWQpID09PSAtMSkge1xuICAgICAgICBlbmRwb2ludCArPSAnLycgKyBzdWJzY3JpcHRpb25JZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVuZHBvaW50O1xuICAgIH1cblxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpc1NXUmVnaXN0ZXJlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU1dSZWdpc3RlcmVkKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXIuc3RhdGUgPT09ICdhY3RpdmF0ZWQnO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VucmVnaXN0ZXJXb3JrZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnJlZ2lzdGVyV29ya2VyKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKCdzZXJ2aWNlV29ya2VyJyBpbiBuYXZpZ2F0b3IpIHtcbiAgICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuZ2V0UmVnaXN0cmF0aW9ucygpLnRoZW4oZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHJlZ2lzdHJhdGlvbnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgIHZhciByZWdpc3RyYXRpb24gPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgICByZWdpc3RyYXRpb24udW5yZWdpc3RlcigpO1xuICAgICAgICAgICAgICBzZWxmLmZpcmUoJ29uU3Vic2NyaXB0aW9uQ2FuY2VsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVxdWVzdFN1YnNjcmlwdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcXVlc3RTdWJzY3JpcHRpb24oKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHVzZXJWaXNpYmxlT25seSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcblxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFBlcm1pc3Npb25TdGF0dXMoKTtcbiAgICAgIHZhciBjYiA9IGZ1bmN0aW9uIGNiKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0ID09PSAnZ3JhbnRlZCcpIHtcbiAgICAgICAgICBfdGhpczIuZmlyZSgnb25QZXJtaXNzaW9uR3JhbnRlZCcpO1xuXG4gICAgICAgICAgaWYgKCdzZXJ2aWNlV29ya2VyJyBpbiBuYXZpZ2F0b3IpIHtcbiAgICAgICAgICAgIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKF90aGlzMi53b3JrZXJQYXRoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVhZHkudGhlbihmdW5jdGlvbiAoc2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbikge1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyZSgnb25Xb3JrZXJTdWNjZXNzJyk7XG4gICAgICAgICAgICAgICAgc2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbi5wdXNoTWFuYWdlci5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgICAgdXNlclZpc2libGVPbmx5OiB1c2VyVmlzaWJsZU9ubHlcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBzdWJzY3JpcHRpb24uZ2V0S2V5KCdwMjU2ZGgnKTtcbiAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHN1YnNjcmlwdGlvbi5nZXRLZXkoJ2F1dGgnKTtcblxuICAgICAgICAgICAgICAgICAgc2VsZi5zdWJEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogc2VsZi5nZXRFbmRwb2ludChzdWJzY3JpcHRpb24pLFxuICAgICAgICAgICAgICAgICAgICBwMjU2ZGg6IGtleSA/IHdpbmRvdy5idG9hKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoa2V5KSkpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYXV0aDogdG9rZW4gPyB3aW5kb3cuYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHRva2VuKSkpIDogbnVsbFxuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgc2VsZi5maXJlKCdvblN1YnNjcmlwdGlvblN1Y2Nlc3MnLCBbc2VsZi5zdWJEYXRhXSk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgc2VsZi5maXJlKCdvbldvcmtlckVycm9yJywgW2Vycl0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmZpcmUoJ29uV29ya2VyTm90U3VwcG9ydGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gJ2RlbmllZCcpIHtcbiAgICAgICAgICBfdGhpczIuZmlyZSgnb25QZXJtaXNzaW9uRGVuaWVkJyk7XG4gICAgICAgICAgX3RoaXMyLnVucmVnaXN0ZXJXb3JrZXIoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGN1cnJlbnQgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICBpZiAod2luZG93Lk5vdGlmaWNhdGlvbiAmJiB3aW5kb3cuTm90aWZpY2F0aW9uLnJlcXVlc3RQZXJtaXNzaW9uKSB7XG4gICAgICAgICAgd2luZG93Lk5vdGlmaWNhdGlvbi5yZXF1ZXN0UGVybWlzc2lvbihjYik7XG4gICAgICAgIH0gZWxzZSBpZiAod2luZG93LndlYmtpdE5vdGlmaWNhdGlvbnMgJiYgd2luZG93LndlYmtpdE5vdGlmaWNhdGlvbnMuY2hlY2tQZXJtaXNzaW9uKSB7XG4gICAgICAgICAgd2luZG93LndlYmtpdE5vdGlmaWNhdGlvbnMucmVxdWVzdFBlcm1pc3Npb24oY2IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUHVzaDtcbn0oKTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzLCBnbG9iYWwpIHt2YXIgcmVxdWlyZTsvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIDQuMS4xXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0IHRydWUgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuRVM2UHJvbWlzZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHg7XG4gIHJldHVybiB4ICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIF9pc0FycmF5ID0gdW5kZWZpbmVkO1xuaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG59XG5cbnZhciBpc0FycmF5ID0gX2lzQXJyYXk7XG5cbnZhciBsZW4gPSAwO1xudmFyIHZlcnR4TmV4dCA9IHVuZGVmaW5lZDtcbnZhciBjdXN0b21TY2hlZHVsZXJGbiA9IHVuZGVmaW5lZDtcblxudmFyIGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgcXVldWVbbGVuXSA9IGNhbGxiYWNrO1xuICBxdWV1ZVtsZW4gKyAxXSA9IGFyZztcbiAgbGVuICs9IDI7XG4gIGlmIChsZW4gPT09IDIpIHtcbiAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgaWYgKGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICBjdXN0b21TY2hlZHVsZXJGbihmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gIGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbn1cblxuZnVuY3Rpb24gc2V0QXNhcChhc2FwRm4pIHtcbiAgYXNhcCA9IGFzYXBGbjtcbn1cblxudmFyIGJyb3dzZXJXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbnZhciBicm93c2VyR2xvYmFsID0gYnJvd3NlcldpbmRvdyB8fCB7fTtcbnZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAoe30pLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJztcblxuLy8gdGVzdCBmb3Igd2ViIHdvcmtlciBidXQgbm90IGluIElFMTBcbnZhciBpc1dvcmtlciA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIG5vZGVcbmZ1bmN0aW9uIHVzZU5leHRUaWNrKCkge1xuICAvLyBub2RlIHZlcnNpb24gMC4xMC54IGRpc3BsYXlzIGEgZGVwcmVjYXRpb24gd2FybmluZyB3aGVuIG5leHRUaWNrIGlzIHVzZWQgcmVjdXJzaXZlbHlcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jdWpvanMvd2hlbi9pc3N1ZXMvNDEwIGZvciBkZXRhaWxzXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICB9O1xufVxuXG4vLyB2ZXJ0eFxuZnVuY3Rpb24gdXNlVmVydHhUaW1lcigpIHtcbiAgaWYgKHR5cGVvZiB2ZXJ0eE5leHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZlcnR4TmV4dChmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgbm9kZS5kYXRhID0gaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDI7XG4gIH07XG59XG5cbi8vIHdlYiB3b3JrZXJcbmZ1bmN0aW9uIHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBlczYtcHJvbWlzZSB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbiAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG4gIHZhciBnbG9iYWxTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsU2V0VGltZW91dChmbHVzaCwgMSk7XG4gIH07XG59XG5cbnZhciBxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbmZ1bmN0aW9uIGZsdXNoKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG4gICAgdmFyIGFyZyA9IHF1ZXVlW2kgKyAxXTtcblxuICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICBxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICBxdWV1ZVtpICsgMV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0VmVydHgoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHIgPSByZXF1aXJlO1xuICAgIHZhciB2ZXJ0eCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4gICAgdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICByZXR1cm4gdXNlVmVydHhUaW1lcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG52YXIgc2NoZWR1bGVGbHVzaCA9IHVuZGVmaW5lZDtcbi8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG5pZiAoaXNOb2RlKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xufSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xufSBlbHNlIGlmIChpc1dvcmtlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTWVzc2FnZUNoYW5uZWwoKTtcbn0gZWxzZSBpZiAoYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIFwiZnVuY3Rpb25cIiA9PT0gJ2Z1bmN0aW9uJykge1xuICBzY2hlZHVsZUZsdXNoID0gYXR0ZW1wdFZlcnR4KCk7XG59IGVsc2Uge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB0aGVuKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBfYXJndW1lbnRzID0gYXJndW1lbnRzO1xuXG4gIHZhciBwYXJlbnQgPSB0aGlzO1xuXG4gIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmIChjaGlsZFtQUk9NSVNFX0lEXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWFrZVByb21pc2UoY2hpbGQpO1xuICB9XG5cbiAgdmFyIF9zdGF0ZSA9IHBhcmVudC5fc3RhdGU7XG5cbiAgaWYgKF9zdGF0ZSkge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBfYXJndW1lbnRzW19zdGF0ZSAtIDFdO1xuICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjayhfc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcGFyZW50Ll9yZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkO1xufVxuXG4vKipcbiAgYFByb21pc2UucmVzb2x2ZWAgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSByZXNvbHZlZCB3aXRoIHRoZVxuICBwYXNzZWQgYHZhbHVlYC4gSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlc29sdmUoMSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKDEpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVzb2x2ZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgd2l0aFxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIGZ1bGZpbGxlZCB3aXRoIHRoZSBnaXZlblxuICBgdmFsdWVgXG4qL1xuZnVuY3Rpb24gcmVzb2x2ZSQxKG9iamVjdCkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIFBST01JU0VfSUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMTYpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIFBFTkRJTkcgPSB2b2lkIDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG5cbnZhciBHRVRfVEhFTl9FUlJPUiA9IG5ldyBFcnJvck9iamVjdCgpO1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKHByb21pc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG4gICAgcmV0dXJuIEdFVF9USEVOX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRoZW4odGhlbiQkMSwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICB0cnkge1xuICAgIHRoZW4kJDEuY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbiQkMSkge1xuICBhc2FwKGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHRyeVRoZW4odGhlbiQkMSwgdGhlbmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9XG4gIH0sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpIHtcbiAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IgJiYgdGhlbiQkMSA9PT0gdGhlbiAmJiBtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yLnJlc29sdmUgPT09IHJlc29sdmUkMSkge1xuICAgIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGVuJCQxID09PSBHRVRfVEhFTl9FUlJPUikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIEdFVF9USEVOX0VSUk9SLmVycm9yKTtcbiAgICAgIEdFVF9USEVOX0VSUk9SLmVycm9yID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHRoZW4kJDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odGhlbiQkMSkpIHtcbiAgICAgIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgc2VsZkZ1bGZpbGxtZW50KCkpO1xuICB9IGVsc2UgaWYgKG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSwgZ2V0VGhlbih2YWx1ZSkpO1xuICB9IGVsc2Uge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgfVxuXG4gIHB1Ymxpc2gocHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gIHByb21pc2UuX3N0YXRlID0gRlVMRklMTEVEO1xuXG4gIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggIT09IDApIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHByb21pc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb21pc2UuX3N0YXRlID0gUkVKRUNURUQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcblxuICBhc2FwKHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIF9zdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gIHZhciBsZW5ndGggPSBfc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gIHBhcmVudC5fb25lcnJvciA9IG51bGw7XG5cbiAgX3N1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIEZVTEZJTExFRF0gPSBvbkZ1bGZpbGxtZW50O1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgUkVKRUNURURdID0gb25SZWplY3Rpb247XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCAmJiBwYXJlbnQuX3N0YXRlKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwYXJlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2gocHJvbWlzZSkge1xuICB2YXIgc3Vic2NyaWJlcnMgPSBwcm9taXNlLl9zdWJzY3JpYmVycztcbiAgdmFyIHNldHRsZWQgPSBwcm9taXNlLl9zdGF0ZTtcblxuICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gdW5kZWZpbmVkLFxuICAgICAgY2FsbGJhY2sgPSB1bmRlZmluZWQsXG4gICAgICBkZXRhaWwgPSBwcm9taXNlLl9yZXN1bHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICB9XG4gIH1cblxuICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBFcnJvck9iamVjdCgpIHtcbiAgdGhpcy5lcnJvciA9IG51bGw7XG59XG5cbnZhciBUUllfQ0FUQ0hfRVJST1IgPSBuZXcgRXJyb3JPYmplY3QoKTtcblxuZnVuY3Rpb24gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICByZXR1cm4gVFJZX0NBVENIX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICB2YWx1ZSA9IHVuZGVmaW5lZCxcbiAgICAgIGVycm9yID0gdW5kZWZpbmVkLFxuICAgICAgc3VjY2VlZGVkID0gdW5kZWZpbmVkLFxuICAgICAgZmFpbGVkID0gdW5kZWZpbmVkO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHZhbHVlID0gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCk7XG5cbiAgICBpZiAodmFsdWUgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgIGVycm9yID0gdmFsdWUuZXJyb3I7XG4gICAgICB2YWx1ZS5lcnJvciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChmYWlsZWQpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBGVUxGSUxMRUQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICB0cnkge1xuICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG4gICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgZSk7XG4gIH1cbn1cblxudmFyIGlkID0gMDtcbmZ1bmN0aW9uIG5leHRJZCgpIHtcbiAgcmV0dXJuIGlkKys7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcm9taXNlKHByb21pc2UpIHtcbiAgcHJvbWlzZVtQUk9NSVNFX0lEXSA9IGlkKys7XG4gIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG59XG5cbmZ1bmN0aW9uIEVudW1lcmF0b3IkMShDb25zdHJ1Y3RvciwgaW5wdXQpIHtcbiAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICB0aGlzLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG5cbiAgaWYgKCF0aGlzLnByb21pc2VbUFJPTUlTRV9JRF0pIHtcbiAgICBtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgdGhpcy5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgIHRoaXMuX2VudW1lcmF0ZShpbnB1dCk7XG4gICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZWplY3QodGhpcy5wcm9taXNlLCB2YWxpZGF0aW9uRXJyb3IoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbn1cblxuRW51bWVyYXRvciQxLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICB9XG59O1xuXG5FbnVtZXJhdG9yJDEucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbiAoZW50cnksIGkpIHtcbiAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICB2YXIgcmVzb2x2ZSQkMSA9IGMucmVzb2x2ZTtcblxuICBpZiAocmVzb2x2ZSQkMSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgdmFyIF90aGVuID0gZ2V0VGhlbihlbnRyeSk7XG5cbiAgICBpZiAoX3RoZW4gPT09IHRoZW4gJiYgZW50cnkuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IFByb21pc2UkMikge1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgYyhub29wKTtcbiAgICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIF90aGVuKTtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uIChyZXNvbHZlJCQxKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlJCQxKGVudHJ5KTtcbiAgICAgIH0pLCBpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fd2lsbFNldHRsZUF0KHJlc29sdmUkJDEoZW50cnkpLCBpKTtcbiAgfVxufTtcblxuRW51bWVyYXRvciQxLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24gKHN0YXRlLCBpLCB2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcblxuICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgIGlmIChzdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IkMS5wcm90b3R5cGUuX3dpbGxTZXR0bGVBdCA9IGZ1bmN0aW9uIChwcm9taXNlLCBpKSB7XG4gIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICBzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgfSk7XG59O1xuXG4vKipcbiAgYFByb21pc2UuYWxsYCBhY2NlcHRzIGFuIGFycmF5IG9mIHByb21pc2VzLCBhbmQgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoXG4gIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGFycmF5IG9mIGZ1bGZpbGxtZW50IHZhbHVlcyBmb3IgdGhlIHBhc3NlZCBwcm9taXNlcywgb3JcbiAgcmVqZWN0ZWQgd2l0aCB0aGUgcmVhc29uIG9mIHRoZSBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBiZSByZWplY3RlZC4gSXQgY2FzdHMgYWxsXG4gIGVsZW1lbnRzIG9mIHRoZSBwYXNzZWQgaXRlcmFibGUgdG8gcHJvbWlzZXMgYXMgaXQgcnVucyB0aGlzIGFsZ29yaXRobS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcbiAgbGV0IHByb21pc2UyID0gcmVzb2x2ZSgyKTtcbiAgbGV0IHByb21pc2UzID0gcmVzb2x2ZSgzKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIFRoZSBhcnJheSBoZXJlIHdvdWxkIGJlIFsgMSwgMiwgMyBdO1xuICB9KTtcbiAgYGBgXG5cbiAgSWYgYW55IG9mIHRoZSBgcHJvbWlzZXNgIGdpdmVuIHRvIGBhbGxgIGFyZSByZWplY3RlZCwgdGhlIGZpcnN0IHByb21pc2VcbiAgdGhhdCBpcyByZWplY3RlZCB3aWxsIGJlIGdpdmVuIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSByZXR1cm5lZCBwcm9taXNlcydzXG4gIHJlamVjdGlvbiBoYW5kbGVyLiBGb3IgZXhhbXBsZTpcblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcbiAgbGV0IHByb21pc2UyID0gcmVqZWN0KG5ldyBFcnJvcihcIjJcIikpO1xuICBsZXQgcHJvbWlzZTMgPSByZWplY3QobmV3IEVycm9yKFwiM1wiKSk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVucyBiZWNhdXNlIHRoZXJlIGFyZSByZWplY3RlZCBwcm9taXNlcyFcbiAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAvLyBlcnJvci5tZXNzYWdlID09PSBcIjJcIlxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCBhbGxcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBlbnRyaWVzIGFycmF5IG9mIHByb21pc2VzXG4gIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBvcHRpb25hbCBzdHJpbmcgZm9yIGxhYmVsaW5nIHRoZSBwcm9taXNlLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiBhbGwgYHByb21pc2VzYCBoYXZlIGJlZW5cbiAgZnVsZmlsbGVkLCBvciByZWplY3RlZCBpZiBhbnkgb2YgdGhlbSBiZWNvbWUgcmVqZWN0ZWQuXG4gIEBzdGF0aWNcbiovXG5mdW5jdGlvbiBhbGwkMShlbnRyaWVzKSB7XG4gIHJldHVybiBuZXcgRW51bWVyYXRvciQxKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlJDEoZW50cmllcykge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmICghaXNBcnJheShlbnRyaWVzKSkge1xuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5yZXNvbHZlKGVudHJpZXNbaV0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAgYFByb21pc2UucmVqZWN0YCByZXR1cm5zIGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBwYXNzZWQgYHJlYXNvbmAuXG4gIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlamVjdFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSByZWFzb24gdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGguXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuIGByZWFzb25gLlxuKi9cbmZ1bmN0aW9uIHJlamVjdCQxKHJlYXNvbikge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBuZWVkc1Jlc29sdmVyKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG59XG5cbmZ1bmN0aW9uIG5lZWRzTmV3KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xufVxuXG4vKipcbiAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgVGVybWlub2xvZ3lcbiAgLS0tLS0tLS0tLS1cblxuICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICBCYXNpYyBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tXG5cbiAgYGBganNcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBvbiBzdWNjZXNzXG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAvLyBvbiBmYWlsdXJlXG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgQWR2YW5jZWQgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLS0tLVxuXG4gIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgYGBganNcbiAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gIGBgYGpzXG4gIFByb21pc2UuYWxsKFtcbiAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0pO1xuICBgYGBcblxuICBAY2xhc3MgUHJvbWlzZVxuICBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlclxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEBjb25zdHJ1Y3RvclxuKi9cbmZ1bmN0aW9uIFByb21pc2UkMihyZXNvbHZlcikge1xuICB0aGlzW1BST01JU0VfSURdID0gbmV4dElkKCk7XG4gIHRoaXMuX3Jlc3VsdCA9IHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuXG4gIGlmIChub29wICE9PSByZXNvbHZlcikge1xuICAgIHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJyAmJiBuZWVkc1Jlc29sdmVyKCk7XG4gICAgdGhpcyBpbnN0YW5jZW9mIFByb21pc2UkMiA/IGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKSA6IG5lZWRzTmV3KCk7XG4gIH1cbn1cblxuUHJvbWlzZSQyLmFsbCA9IGFsbCQxO1xuUHJvbWlzZSQyLnJhY2UgPSByYWNlJDE7XG5Qcm9taXNlJDIucmVzb2x2ZSA9IHJlc29sdmUkMTtcblByb21pc2UkMi5yZWplY3QgPSByZWplY3QkMTtcblByb21pc2UkMi5fc2V0U2NoZWR1bGVyID0gc2V0U2NoZWR1bGVyO1xuUHJvbWlzZSQyLl9zZXRBc2FwID0gc2V0QXNhcDtcblByb21pc2UkMi5fYXNhcCA9IGFzYXA7XG5cblByb21pc2UkMi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQcm9taXNlJDIsXG5cbiAgLyoqXG4gICAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXIpe1xuICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gdXNlciBpcyB1bmF2YWlsYWJsZSwgYW5kIHlvdSBhcmUgZ2l2ZW4gdGhlIHJlYXNvbiB3aHlcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQ2hhaW5pbmdcbiAgICAtLS0tLS0tLVxuICBcbiAgICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuICdkZWZhdWx0IG5hbWUnO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgICAvLyB3aWxsIGJlIGAnZGVmYXVsdCBuYW1lJ2BcbiAgICB9KTtcbiAgXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gICAgfSk7XG4gICAgYGBgXG4gICAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEFzc2ltaWxhdGlvblxuICAgIC0tLS0tLS0tLS0tLVxuICBcbiAgICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICAgIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBTaW1wbGUgRXhhbXBsZVxuICAgIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGxldCByZXN1bHQ7XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9XG4gICAgYGBgXG4gIFxuICAgIEVycmJhY2sgRXhhbXBsZVxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIFByb21pc2UgRXhhbXBsZTtcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGZpbmRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQWR2YW5jZWQgRXhhbXBsZVxuICAgIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGxldCBhdXRob3IsIGJvb2tzO1xuICBcbiAgICB0cnkge1xuICAgICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgRXJyYmFjayBFeGFtcGxlXG4gIFxuICAgIGBgYGpzXG4gIFxuICAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcbiAgXG4gICAgfVxuICBcbiAgICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICBcbiAgICB9XG4gIFxuICAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgUHJvbWlzZSBFeGFtcGxlO1xuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgZmluZEF1dGhvcigpLlxuICAgICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgLy8gZm91bmQgYm9va3NcbiAgICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQG1ldGhvZCB0aGVuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIHRoZW46IHRoZW4sXG5cbiAgLyoqXG4gICAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICAgIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIFxuICAgIGBgYGpzXG4gICAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gICAgfVxuICBcbiAgICAvLyBzeW5jaHJvbm91c1xuICAgIHRyeSB7XG4gICAgICBmaW5kQXV0aG9yKCk7XG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgfVxuICBcbiAgICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIGNhdGNoXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgJ2NhdGNoJzogZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gIH1cbn07XG5cbi8qZ2xvYmFsIHNlbGYqL1xuZnVuY3Rpb24gcG9seWZpbGwkMSgpIHtcbiAgICB2YXIgbG9jYWwgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbG9jYWwgPSBnbG9iYWw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbG9jYWwgPSBzZWxmO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgICBpZiAoUCkge1xuICAgICAgICB2YXIgcHJvbWlzZVRvU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb21pc2VUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIHNpbGVudGx5IGlnbm9yZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9taXNlVG9TdHJpbmcgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb2NhbC5Qcm9taXNlID0gUHJvbWlzZSQyO1xufVxuXG4vLyBTdHJhbmdlIGNvbXBhdC4uXG5Qcm9taXNlJDIucG9seWZpbGwgPSBwb2x5ZmlsbCQxO1xuUHJvbWlzZSQyLlByb21pc2UgPSBQcm9taXNlJDI7XG5cbnJldHVybiBQcm9taXNlJDI7XG5cbn0pKSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzNi1wcm9taXNlLm1hcFxuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyg3KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg4KSkpXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyogZ2xvYmFsIFZFUlNJT04gKi9cblxuX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9lczZQcm9taXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9lczZQcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VzNlByb21pc2UpO1xuXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxudmFyIF9hcGkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgQVBJID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2FwaSk7XG5cbnZhciBfYnV0dG9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9wdXNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIE5vdHkgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtOb3R5fVxuICAgKi9cbiAgZnVuY3Rpb24gTm90eSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm90eSk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBVdGlscy5kZWVwRXh0ZW5kKHt9LCBBUEkuRGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKEFQSS5TdG9yZVt0aGlzLm9wdGlvbnMuaWRdKSB7XG4gICAgICByZXR1cm4gQVBJLlN0b3JlW3RoaXMub3B0aW9ucy5pZF07XG4gICAgfVxuXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0aW9ucy5pZCB8fCBVdGlscy5nZW5lcmF0ZUlEKCdiYXInKTtcbiAgICB0aGlzLmNsb3NlVGltZXIgPSAtMTtcbiAgICB0aGlzLmJhckRvbSA9IG51bGw7XG4gICAgdGhpcy5sYXlvdXREb20gPSBudWxsO1xuICAgIHRoaXMucHJvZ3Jlc3NEb20gPSBudWxsO1xuICAgIHRoaXMuc2hvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuc2hvd24gPSBmYWxzZTtcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xvc2luZyA9IGZhbHNlO1xuICAgIHRoaXMua2lsbGFibGUgPSB0aGlzLm9wdGlvbnMudGltZW91dCB8fCB0aGlzLm9wdGlvbnMuY2xvc2VXaXRoLmxlbmd0aCA+IDA7XG4gICAgdGhpcy5oYXNTb3VuZCA9IHRoaXMub3B0aW9ucy5zb3VuZHMuc291cmNlcy5sZW5ndGggPiAwO1xuICAgIHRoaXMuc291bmRQbGF5ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHtcbiAgICAgIGJlZm9yZVNob3c6IFtdLFxuICAgICAgb25TaG93OiBbXSxcbiAgICAgIGFmdGVyU2hvdzogW10sXG4gICAgICBvbkNsb3NlOiBbXSxcbiAgICAgIGFmdGVyQ2xvc2U6IFtdLFxuICAgICAgb25DbGljazogW10sXG4gICAgICBvbkhvdmVyOiBbXSxcbiAgICAgIG9uVGVtcGxhdGU6IFtdXG4gICAgfTtcbiAgICB0aGlzLnByb21pc2VzID0ge1xuICAgICAgc2hvdzogbnVsbCxcbiAgICAgIGNsb3NlOiBudWxsXG4gICAgfTtcbiAgICB0aGlzLm9uKCdiZWZvcmVTaG93JywgdGhpcy5vcHRpb25zLmNhbGxiYWNrcy5iZWZvcmVTaG93KTtcbiAgICB0aGlzLm9uKCdvblNob3cnLCB0aGlzLm9wdGlvbnMuY2FsbGJhY2tzLm9uU2hvdyk7XG4gICAgdGhpcy5vbignYWZ0ZXJTaG93JywgdGhpcy5vcHRpb25zLmNhbGxiYWNrcy5hZnRlclNob3cpO1xuICAgIHRoaXMub24oJ29uQ2xvc2UnLCB0aGlzLm9wdGlvbnMuY2FsbGJhY2tzLm9uQ2xvc2UpO1xuICAgIHRoaXMub24oJ2FmdGVyQ2xvc2UnLCB0aGlzLm9wdGlvbnMuY2FsbGJhY2tzLmFmdGVyQ2xvc2UpO1xuICAgIHRoaXMub24oJ29uQ2xpY2snLCB0aGlzLm9wdGlvbnMuY2FsbGJhY2tzLm9uQ2xpY2spO1xuICAgIHRoaXMub24oJ29uSG92ZXInLCB0aGlzLm9wdGlvbnMuY2FsbGJhY2tzLm9uSG92ZXIpO1xuICAgIHRoaXMub24oJ29uVGVtcGxhdGUnLCB0aGlzLm9wdGlvbnMuY2FsbGJhY2tzLm9uVGVtcGxhdGUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYlxuICAgKiBAcmV0dXJuIHtOb3R5fVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhOb3R5LCBbe1xuICAgIGtleTogJ29uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnROYW1lKSB7XG4gICAgICB2YXIgY2IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nICYmIHRoaXMubGlzdGVuZXJzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXS5wdXNoKGNiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Tm90eX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2hvdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5zaG93aW5nIHx8IHRoaXMuc2hvd24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIHByZXZlbnRpbmcgbXVsdGlwbGUgc2hvd1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmtpbGxlciA9PT0gdHJ1ZSkge1xuICAgICAgICBOb3R5LmNsb3NlQWxsKCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMua2lsbGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICBOb3R5LmNsb3NlQWxsKHRoaXMub3B0aW9ucy5raWxsZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcXVldWVDb3VudHMgPSBBUEkuZ2V0UXVldWVDb3VudHModGhpcy5vcHRpb25zLnF1ZXVlKTtcblxuICAgICAgaWYgKHF1ZXVlQ291bnRzLmN1cnJlbnQgPj0gcXVldWVDb3VudHMubWF4VmlzaWJsZSB8fCBBUEkuUGFnZUhpZGRlbiAmJiB0aGlzLm9wdGlvbnMudmlzaWJpbGl0eUNvbnRyb2wpIHtcbiAgICAgICAgQVBJLmFkZFRvUXVldWUodGhpcyk7XG5cbiAgICAgICAgaWYgKEFQSS5QYWdlSGlkZGVuICYmIHRoaXMuaGFzU291bmQgJiYgVXRpbHMuaW5BcnJheSgnZG9jSGlkZGVuJywgdGhpcy5vcHRpb25zLnNvdW5kcy5jb25kaXRpb25zKSkge1xuICAgICAgICAgIFV0aWxzLmNyZWF0ZUF1ZGlvRWxlbWVudHModGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQVBJLlBhZ2VIaWRkZW4gJiYgVXRpbHMuaW5BcnJheSgnZG9jSGlkZGVuJywgdGhpcy5vcHRpb25zLnRpdGxlQ291bnQuY29uZGl0aW9ucykpIHtcbiAgICAgICAgICBBUEkuZG9jVGl0bGUuaW5jcmVtZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgQVBJLlN0b3JlW3RoaXMuaWRdID0gdGhpcztcblxuICAgICAgQVBJLmZpcmUodGhpcywgJ2JlZm9yZVNob3cnKTtcblxuICAgICAgdGhpcy5zaG93aW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuY2xvc2luZykge1xuICAgICAgICB0aGlzLnNob3dpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIEFQSS5idWlsZCh0aGlzKTtcbiAgICAgIEFQSS5oYW5kbGVNb2RhbCh0aGlzKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb3JjZSkge1xuICAgICAgICB0aGlzLmxheW91dERvbS5pbnNlcnRCZWZvcmUodGhpcy5iYXJEb20sIHRoaXMubGF5b3V0RG9tLmZpcnN0Q2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYXlvdXREb20uYXBwZW5kQ2hpbGQodGhpcy5iYXJEb20pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oYXNTb3VuZCAmJiAhdGhpcy5zb3VuZFBsYXllZCAmJiBVdGlscy5pbkFycmF5KCdkb2NWaXNpYmxlJywgdGhpcy5vcHRpb25zLnNvdW5kcy5jb25kaXRpb25zKSkge1xuICAgICAgICBVdGlscy5jcmVhdGVBdWRpb0VsZW1lbnRzKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoVXRpbHMuaW5BcnJheSgnZG9jVmlzaWJsZScsIHRoaXMub3B0aW9ucy50aXRsZUNvdW50LmNvbmRpdGlvbnMpKSB7XG4gICAgICAgIEFQSS5kb2NUaXRsZS5pbmNyZW1lbnQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zaG93biA9IHRydWU7XG4gICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBiaW5kIGJ1dHRvbiBldmVudHMgaWYgYW55XG4gICAgICBpZiAoQVBJLmhhc0J1dHRvbnModGhpcykpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmJ1dHRvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHZhciBidG4gPSBfdGhpcy5iYXJEb20ucXVlcnlTZWxlY3RvcignIycgKyBfdGhpcy5vcHRpb25zLmJ1dHRvbnNba2V5XS5pZCk7XG4gICAgICAgICAgVXRpbHMuYWRkTGlzdGVuZXIoYnRuLCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgVXRpbHMuc3RvcFByb3BhZ2F0aW9uKGUpO1xuICAgICAgICAgICAgX3RoaXMub3B0aW9ucy5idXR0b25zW2tleV0uY2IoX3RoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9ncmVzc0RvbSA9IHRoaXMuYmFyRG9tLnF1ZXJ5U2VsZWN0b3IoJy5ub3R5X3Byb2dyZXNzYmFyJyk7XG5cbiAgICAgIGlmIChVdGlscy5pbkFycmF5KCdjbGljaycsIHRoaXMub3B0aW9ucy5jbG9zZVdpdGgpKSB7XG4gICAgICAgIFV0aWxzLmFkZENsYXNzKHRoaXMuYmFyRG9tLCAnbm90eV9jbG9zZV93aXRoX2NsaWNrJyk7XG4gICAgICAgIFV0aWxzLmFkZExpc3RlbmVyKHRoaXMuYmFyRG9tLCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIFV0aWxzLnN0b3BQcm9wYWdhdGlvbihlKTtcbiAgICAgICAgICBBUEkuZmlyZShfdGhpcywgJ29uQ2xpY2snKTtcbiAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIFV0aWxzLmFkZExpc3RlbmVyKHRoaXMuYmFyRG9tLCAnbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQVBJLmZpcmUoX3RoaXMsICdvbkhvdmVyJyk7XG4gICAgICB9LCBmYWxzZSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGltZW91dCkgVXRpbHMuYWRkQ2xhc3ModGhpcy5iYXJEb20sICdub3R5X2hhc190aW1lb3V0Jyk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnByb2dyZXNzQmFyKSB7XG4gICAgICAgIFV0aWxzLmFkZENsYXNzKHRoaXMuYmFyRG9tLCAnbm90eV9oYXNfcHJvZ3Jlc3NiYXInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFV0aWxzLmluQXJyYXkoJ2J1dHRvbicsIHRoaXMub3B0aW9ucy5jbG9zZVdpdGgpKSB7XG4gICAgICAgIFV0aWxzLmFkZENsYXNzKHRoaXMuYmFyRG9tLCAnbm90eV9jbG9zZV93aXRoX2J1dHRvbicpO1xuXG4gICAgICAgIHZhciBjbG9zZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBVdGlscy5hZGRDbGFzcyhjbG9zZUJ1dHRvbiwgJ25vdHlfY2xvc2VfYnV0dG9uJyk7XG4gICAgICAgIGNsb3NlQnV0dG9uLmlubmVySFRNTCA9ICfDlyc7XG4gICAgICAgIHRoaXMuYmFyRG9tLmFwcGVuZENoaWxkKGNsb3NlQnV0dG9uKTtcblxuICAgICAgICBVdGlscy5hZGRMaXN0ZW5lcihjbG9zZUJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBVdGlscy5zdG9wUHJvcGFnYXRpb24oZSk7XG4gICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBBUEkuZmlyZSh0aGlzLCAnb25TaG93Jyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uLm9wZW4gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlcy5zaG93ID0gbmV3IF9lczZQcm9taXNlMi5kZWZhdWx0KGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hbmltYXRpb24ub3BlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnByb21pc2VzLnNob3cgPSBuZXcgX2VzNlByb21pc2UyLmRlZmF1bHQodGhpcy5vcHRpb25zLmFuaW1hdGlvbi5vcGVuLmJpbmQodGhpcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVXRpbHMuYWRkQ2xhc3ModGhpcy5iYXJEb20sIHRoaXMub3B0aW9ucy5hbmltYXRpb24ub3Blbik7XG4gICAgICAgIHRoaXMucHJvbWlzZXMuc2hvdyA9IG5ldyBfZXM2UHJvbWlzZTIuZGVmYXVsdChmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIFV0aWxzLmFkZExpc3RlbmVyKF90aGlzLmJhckRvbSwgVXRpbHMuYW5pbWF0aW9uRW5kRXZlbnRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBVdGlscy5yZW1vdmVDbGFzcyhfdGhpcy5iYXJEb20sIF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uLm9wZW4pO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9taXNlcy5zaG93LnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3QgPSBfdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgQVBJLm9wZW5GbG93KF90KTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtOb3R5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzdG9wJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIEFQSS5kZXF1ZXVlQ2xvc2UodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtOb3R5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZXN1bWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgICBBUEkucXVldWVDbG9zZSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW50fGJvb2xlYW59IG1zXG4gICAgICogQHJldHVybiB7Tm90eX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0VGltZW91dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChfc2V0VGltZW91dCkge1xuICAgICAgZnVuY3Rpb24gc2V0VGltZW91dChfeCkge1xuICAgICAgICByZXR1cm4gX3NldFRpbWVvdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgc2V0VGltZW91dC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zZXRUaW1lb3V0LnRvU3RyaW5nKCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gc2V0VGltZW91dDtcbiAgICB9KGZ1bmN0aW9uIChtcykge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB0aGlzLm9wdGlvbnMudGltZW91dCA9IG1zO1xuXG4gICAgICBpZiAodGhpcy5iYXJEb20pIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICAgICAgVXRpbHMuYWRkQ2xhc3ModGhpcy5iYXJEb20sICdub3R5X2hhc190aW1lb3V0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgVXRpbHMucmVtb3ZlQ2xhc3ModGhpcy5iYXJEb20sICdub3R5X2hhc190aW1lb3V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3QgPSB0aGlzO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyB1Z2x5IGZpeCBmb3IgcHJvZ3Jlc3NiYXIgZGlzcGxheSBidWdcbiAgICAgICAgICBfdC5yZXN1bWUoKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSlcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zT3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJuIHtOb3R5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRUZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGV4dChodG1sKSB7XG4gICAgICB2YXIgb3B0aW9uc092ZXJyaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuYmFyRG9tKSB7XG4gICAgICAgIHRoaXMuYmFyRG9tLnF1ZXJ5U2VsZWN0b3IoJy5ub3R5X2JvZHknKS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9uc092ZXJyaWRlKSB0aGlzLm9wdGlvbnMudGV4dCA9IGh0bWw7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zT3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJuIHtOb3R5fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRUeXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VHlwZSh0eXBlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnNPdmVycmlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmJhckRvbSkge1xuICAgICAgICB2YXIgY2xhc3NMaXN0ID0gVXRpbHMuY2xhc3NMaXN0KHRoaXMuYmFyRG9tKS5zcGxpdCgnICcpO1xuXG4gICAgICAgIGNsYXNzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgaWYgKGMuc3Vic3RyaW5nKDAsIDExKSA9PT0gJ25vdHlfdHlwZV9fJykge1xuICAgICAgICAgICAgVXRpbHMucmVtb3ZlQ2xhc3MoX3RoaXMyLmJhckRvbSwgYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBVdGlscy5hZGRDbGFzcyh0aGlzLmJhckRvbSwgJ25vdHlfdHlwZV9fJyArIHR5cGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9uc092ZXJyaWRlKSB0aGlzLm9wdGlvbnMudHlwZSA9IHR5cGU7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aGVtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9uc092ZXJyaWRlXG4gICAgICogQHJldHVybiB7Tm90eX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0VGhlbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUaGVtZSh0aGVtZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBvcHRpb25zT3ZlcnJpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5iYXJEb20pIHtcbiAgICAgICAgdmFyIGNsYXNzTGlzdCA9IFV0aWxzLmNsYXNzTGlzdCh0aGlzLmJhckRvbSkuc3BsaXQoJyAnKTtcblxuICAgICAgICBjbGFzc0xpc3QuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGlmIChjLnN1YnN0cmluZygwLCAxMikgPT09ICdub3R5X3RoZW1lX18nKSB7XG4gICAgICAgICAgICBVdGlscy5yZW1vdmVDbGFzcyhfdGhpczMuYmFyRG9tLCBjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIFV0aWxzLmFkZENsYXNzKHRoaXMuYmFyRG9tLCAnbm90eV90aGVtZV9fJyArIHRoZW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnNPdmVycmlkZSkgdGhpcy5vcHRpb25zLnRoZW1lID0gdGhlbWU7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge05vdHl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Nsb3NlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuY2xvc2VkKSByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLnNob3duKSB7XG4gICAgICAgIC8vIGl0J3MgaW4gdGhlIHF1ZXVlXG4gICAgICAgIEFQSS5yZW1vdmVGcm9tUXVldWUodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBBUEkuZmlyZSh0aGlzLCAnb25DbG9zZScpO1xuXG4gICAgICB0aGlzLmNsb3NpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbi5jbG9zZSA9PT0gbnVsbCB8fCB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uLmNsb3NlID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnByb21pc2VzLmNsb3NlID0gbmV3IF9lczZQcm9taXNlMi5kZWZhdWx0KGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hbmltYXRpb24uY2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlcy5jbG9zZSA9IG5ldyBfZXM2UHJvbWlzZTIuZGVmYXVsdCh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uLmNsb3NlLmJpbmQodGhpcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVXRpbHMuYWRkQ2xhc3ModGhpcy5iYXJEb20sIHRoaXMub3B0aW9ucy5hbmltYXRpb24uY2xvc2UpO1xuICAgICAgICB0aGlzLnByb21pc2VzLmNsb3NlID0gbmV3IF9lczZQcm9taXNlMi5kZWZhdWx0KGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgVXRpbHMuYWRkTGlzdGVuZXIoX3RoaXM0LmJhckRvbSwgVXRpbHMuYW5pbWF0aW9uRW5kRXZlbnRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXM0Lm9wdGlvbnMuZm9yY2UpIHtcbiAgICAgICAgICAgICAgVXRpbHMucmVtb3ZlKF90aGlzNC5iYXJEb20pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgQVBJLmdob3N0Rml4KF90aGlzNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb21pc2VzLmNsb3NlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBBUEkuY2xvc2VGbG93KF90aGlzNCk7XG4gICAgICAgIEFQSS5oYW5kbGVNb2RhbENsb3NlKF90aGlzNCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBUEkgZnVuY3Rpb25zXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58c3RyaW5nfSBxdWV1ZU5hbWVcbiAgICAgKiBAcmV0dXJuIHtOb3R5fVxuICAgICAqL1xuXG4gIH1dLCBbe1xuICAgIGtleTogJ2Nsb3NlQWxsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VBbGwoKSB7XG4gICAgICB2YXIgcXVldWVOYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgICAgT2JqZWN0LmtleXMoQVBJLlN0b3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAocXVldWVOYW1lKSB7XG4gICAgICAgICAgaWYgKEFQSS5TdG9yZVtpZF0ub3B0aW9ucy5xdWV1ZSA9PT0gcXVldWVOYW1lICYmIEFQSS5TdG9yZVtpZF0ua2lsbGFibGUpIHtcbiAgICAgICAgICAgIEFQSS5TdG9yZVtpZF0uY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQVBJLlN0b3JlW2lkXS5raWxsYWJsZSkge1xuICAgICAgICAgIEFQSS5TdG9yZVtpZF0uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcXVldWVOYW1lXG4gICAgICogQHJldHVybiB7Tm90eX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2xlYXJRdWV1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyUXVldWUoKSB7XG4gICAgICB2YXIgcXVldWVOYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnZ2xvYmFsJztcblxuICAgICAgaWYgKEFQSS5RdWV1ZXMuaGFzT3duUHJvcGVydHkocXVldWVOYW1lKSkge1xuICAgICAgICBBUEkuUXVldWVzW3F1ZXVlTmFtZV0ucXVldWUgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0FQSS5RdWV1ZXN9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ292ZXJyaWRlRGVmYXVsdHMnLFxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICogQHJldHVybiB7Tm90eX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gb3ZlcnJpZGVEZWZhdWx0cyhvYmopIHtcbiAgICAgIEFQSS5EZWZhdWx0cyA9IFV0aWxzLmRlZXBFeHRlbmQoe30sIEFQSS5EZWZhdWx0cywgb2JqKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW50fSBhbW91bnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcXVldWVOYW1lXG4gICAgICogQHJldHVybiB7Tm90eX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0TWF4VmlzaWJsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1heFZpc2libGUoKSB7XG4gICAgICB2YXIgYW1vdW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBBUEkuRGVmYXVsdE1heFZpc2libGU7XG4gICAgICB2YXIgcXVldWVOYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnZ2xvYmFsJztcblxuICAgICAgaWYgKCFBUEkuUXVldWVzLmhhc093blByb3BlcnR5KHF1ZXVlTmFtZSkpIHtcbiAgICAgICAgQVBJLlF1ZXVlc1txdWV1ZU5hbWVdID0geyBtYXhWaXNpYmxlOiBhbW91bnQsIHF1ZXVlOiBbXSB9O1xuICAgICAgfVxuXG4gICAgICBBUEkuUXVldWVzW3F1ZXVlTmFtZV0ubWF4VmlzaWJsZSA9IGFtb3VudDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbm5lckh0bWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3Nlc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAgICAgKiBAcmV0dXJuIHtOb3R5QnV0dG9ufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdidXR0b24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidXR0b24oaW5uZXJIdG1sKSB7XG4gICAgICB2YXIgY2xhc3NlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgIHZhciBjYiA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgcmV0dXJuIG5ldyBfYnV0dG9uLk5vdHlCdXR0b24oaW5uZXJIdG1sLCBjbGFzc2VzLCBjYiwgYXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd2ZXJzaW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmVyc2lvbigpIHtcbiAgICAgIHJldHVybiBcIjMuMi4wLWJldGFcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd29ya2VyUGF0aFxuICAgICAqIEByZXR1cm4ge1B1c2h9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ1B1c2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBQdXNoKHdvcmtlclBhdGgpIHtcbiAgICAgIHJldHVybiBuZXcgX3B1c2guUHVzaCh3b3JrZXJQYXRoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdRdWV1ZXMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIEFQSS5RdWV1ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7QVBJLlBhZ2VIaWRkZW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ1BhZ2VIaWRkZW4nLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIEFQSS5QYWdlSGlkZGVuO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb3R5O1xufSgpO1xuXG4vLyBEb2N1bWVudCB2aXNpYmlsaXR5IGNoYW5nZSBjb250cm9sbGVyXG5cblxuZXhwb3J0cy5kZWZhdWx0ID0gTm90eTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBVdGlscy52aXNpYmlsaXR5Q2hhbmdlRmxvdygpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qIChpZ25vcmVkKSAqL1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdHkuanMubWFwIiwiLyohXG4gKiBzbHkgMS42LjEgLSA4dGggQXVnIDIwMTVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJzYWluL3NseVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG47KGZ1bmN0aW9uICgkLCB3LCB1bmRlZmluZWQpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBwbHVnaW5OYW1lID0gJ3NseSc7XG5cdHZhciBjbGFzc05hbWUgID0gJ1NseSc7XG5cdHZhciBuYW1lc3BhY2UgID0gcGx1Z2luTmFtZTtcblxuXHQvLyBMb2NhbCBXaW5kb3dBbmltYXRpb25UaW1pbmcgaW50ZXJmYWNlXG5cdHZhciBjQUYgPSB3LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHcuY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHR2YXIgckFGID0gdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cblx0Ly8gU3VwcG9ydCBpbmRpY2F0b3JzXG5cdHZhciB0cmFuc2Zvcm0sIGdwdUFjY2VsZXJhdGlvbjtcblxuXHQvLyBPdGhlciBnbG9iYWwgdmFsdWVzXG5cdHZhciAkZG9jID0gJChkb2N1bWVudCk7XG5cdHZhciBkcmFnSW5pdEV2ZW50cyA9ICd0b3VjaHN0YXJ0LicgKyBuYW1lc3BhY2UgKyAnIG1vdXNlZG93bi4nICsgbmFtZXNwYWNlO1xuXHR2YXIgZHJhZ01vdXNlRXZlbnRzID0gJ21vdXNlbW92ZS4nICsgbmFtZXNwYWNlICsgJyBtb3VzZXVwLicgKyBuYW1lc3BhY2U7XG5cdHZhciBkcmFnVG91Y2hFdmVudHMgPSAndG91Y2htb3ZlLicgKyBuYW1lc3BhY2UgKyAnIHRvdWNoZW5kLicgKyBuYW1lc3BhY2U7XG5cdHZhciB3aGVlbEV2ZW50ID0gKGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ0V2ZW50LndoZWVsJywgJzMuMCcpID8gJ3doZWVsLicgOiAnbW91c2V3aGVlbC4nKSArIG5hbWVzcGFjZTtcblx0dmFyIGNsaWNrRXZlbnQgPSAnY2xpY2suJyArIG5hbWVzcGFjZTtcblx0dmFyIG1vdXNlRG93bkV2ZW50ID0gJ21vdXNlZG93bi4nICsgbmFtZXNwYWNlO1xuXHR2YXIgaW50ZXJhY3RpdmVFbGVtZW50cyA9IFsnSU5QVVQnLCAnU0VMRUNUJywgJ0JVVFRPTicsICdURVhUQVJFQSddO1xuXHR2YXIgdG1wQXJyYXkgPSBbXTtcblx0dmFyIHRpbWU7XG5cblx0Ly8gTWF0aCBzaG9ydGhhbmRzXG5cdHZhciBhYnMgPSBNYXRoLmFicztcblx0dmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG5cdHZhciBwb3cgPSBNYXRoLnBvdztcblx0dmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcblx0dmFyIG1heCA9IE1hdGgubWF4O1xuXHR2YXIgbWluID0gTWF0aC5taW47XG5cblx0Ly8gS2VlcCB0cmFjayBvZiBsYXN0IGZpcmVkIGdsb2JhbCB3aGVlbCBldmVudFxuXHR2YXIgbGFzdEdsb2JhbFdoZWVsID0gMDtcblx0JGRvYy5vbih3aGVlbEV2ZW50LCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgc2x5ID0gZXZlbnQub3JpZ2luYWxFdmVudFtuYW1lc3BhY2VdO1xuXHRcdHZhciB0aW1lID0gK25ldyBEYXRlKCk7XG5cdFx0Ly8gVXBkYXRlIGxhc3QgZ2xvYmFsIHdoZWVsIHRpbWUsIGJ1dCBvbmx5IHdoZW4gZXZlbnQgZGlkbid0IG9yaWdpbmF0ZVxuXHRcdC8vIGluIFNseSBmcmFtZSwgb3IgdGhlIG9yaWdpbiB3YXMgbGVzcyB0aGFuIHNjcm9sbEhpamFjayB0aW1lIGFnb1xuXHRcdGlmICghc2x5IHx8IHNseS5vcHRpb25zLnNjcm9sbEhpamFjayA8IHRpbWUgLSBsYXN0R2xvYmFsV2hlZWwpIGxhc3RHbG9iYWxXaGVlbCA9IHRpbWU7XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBTbHkuXG5cdCAqXG5cdCAqIEBjbGFzc1xuXHQgKlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGZyYW1lICAgICAgIERPTSBlbGVtZW50IG9mIHNseSBjb250YWluZXIuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSAgb3B0aW9ucyAgICAgT2JqZWN0IHdpdGggb3B0aW9ucy5cblx0ICogQHBhcmFtIHtPYmplY3R9ICBjYWxsYmFja01hcCBDYWxsYmFja3MgbWFwLlxuXHQgKi9cblx0ZnVuY3Rpb24gU2x5KGZyYW1lLCBvcHRpb25zLCBjYWxsYmFja01hcCkge1xuXHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBTbHkpKSByZXR1cm4gbmV3IFNseShmcmFtZSwgb3B0aW9ucywgY2FsbGJhY2tNYXApO1xuXG5cdFx0Ly8gRXh0ZW5kIG9wdGlvbnNcblx0XHR2YXIgbyA9ICQuZXh0ZW5kKHt9LCBTbHkuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG5cdFx0Ly8gUHJpdmF0ZSB2YXJpYWJsZXNcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIHBhcmFsbGF4ID0gaXNOdW1iZXIoZnJhbWUpO1xuXG5cdFx0Ly8gRnJhbWVcblx0XHR2YXIgJGZyYW1lID0gJChmcmFtZSk7XG5cdFx0dmFyICRzbGlkZWUgPSBvLnNsaWRlZSA/ICQoby5zbGlkZWUpLmVxKDApIDogJGZyYW1lLmNoaWxkcmVuKCkuZXEoMCk7XG5cdFx0dmFyIGZyYW1lU2l6ZSA9IDA7XG5cdFx0dmFyIHNsaWRlZVNpemUgPSAwO1xuXHRcdHZhciBwb3MgPSB7XG5cdFx0XHRzdGFydDogMCxcblx0XHRcdGNlbnRlcjogMCxcblx0XHRcdGVuZDogMCxcblx0XHRcdGN1cjogMCxcblx0XHRcdGRlc3Q6IDBcblx0XHR9O1xuXG5cdFx0Ly8gU2Nyb2xsYmFyXG5cdFx0dmFyICRzYiA9ICQoby5zY3JvbGxCYXIpLmVxKDApO1xuXHRcdHZhciAkaGFuZGxlID0gJHNiLmNoaWxkcmVuKCkuZXEoMCk7XG5cdFx0dmFyIHNiU2l6ZSA9IDA7XG5cdFx0dmFyIGhhbmRsZVNpemUgPSAwO1xuXHRcdHZhciBoUG9zID0ge1xuXHRcdFx0c3RhcnQ6IDAsXG5cdFx0XHRlbmQ6IDAsXG5cdFx0XHRjdXI6IDBcblx0XHR9O1xuXG5cdFx0Ly8gUGFnZXNiYXJcblx0XHR2YXIgJHBiID0gJChvLnBhZ2VzQmFyKTtcblx0XHR2YXIgJHBhZ2VzID0gMDtcblx0XHR2YXIgcGFnZXMgPSBbXTtcblxuXHRcdC8vIEl0ZW1zXG5cdFx0dmFyICRpdGVtcyA9IDA7XG5cdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0dmFyIHJlbCA9IHtcblx0XHRcdGZpcnN0SXRlbTogMCxcblx0XHRcdGxhc3RJdGVtOiAwLFxuXHRcdFx0Y2VudGVySXRlbTogMCxcblx0XHRcdGFjdGl2ZUl0ZW06IG51bGwsXG5cdFx0XHRhY3RpdmVQYWdlOiAwXG5cdFx0fTtcblxuXHRcdC8vIFN0eWxlc1xuXHRcdHZhciBmcmFtZVN0eWxlcyA9IG5ldyBTdHlsZVJlc3RvcmVyKCRmcmFtZVswXSk7XG5cdFx0dmFyIHNsaWRlZVN0eWxlcyA9IG5ldyBTdHlsZVJlc3RvcmVyKCRzbGlkZWVbMF0pO1xuXHRcdHZhciBzYlN0eWxlcyA9IG5ldyBTdHlsZVJlc3RvcmVyKCRzYlswXSk7XG5cdFx0dmFyIGhhbmRsZVN0eWxlcyA9IG5ldyBTdHlsZVJlc3RvcmVyKCRoYW5kbGVbMF0pO1xuXG5cdFx0Ly8gTmF2aWdhdGlvbiB0eXBlIGJvb2xlYW5zXG5cdFx0dmFyIGJhc2ljTmF2ID0gby5pdGVtTmF2ID09PSAnYmFzaWMnO1xuXHRcdHZhciBmb3JjZUNlbnRlcmVkTmF2ID0gby5pdGVtTmF2ID09PSAnZm9yY2VDZW50ZXJlZCc7XG5cdFx0dmFyIGNlbnRlcmVkTmF2ID0gby5pdGVtTmF2ID09PSAnY2VudGVyZWQnIHx8IGZvcmNlQ2VudGVyZWROYXY7XG5cdFx0dmFyIGl0ZW1OYXYgPSAhcGFyYWxsYXggJiYgKGJhc2ljTmF2IHx8IGNlbnRlcmVkTmF2IHx8IGZvcmNlQ2VudGVyZWROYXYpO1xuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdHZhciAkc2Nyb2xsU291cmNlID0gby5zY3JvbGxTb3VyY2UgPyAkKG8uc2Nyb2xsU291cmNlKSA6ICRmcmFtZTtcblx0XHR2YXIgJGRyYWdTb3VyY2UgPSBvLmRyYWdTb3VyY2UgPyAkKG8uZHJhZ1NvdXJjZSkgOiAkZnJhbWU7XG5cdFx0dmFyICRmb3J3YXJkQnV0dG9uID0gJChvLmZvcndhcmQpO1xuXHRcdHZhciAkYmFja3dhcmRCdXR0b24gPSAkKG8uYmFja3dhcmQpO1xuXHRcdHZhciAkcHJldkJ1dHRvbiA9ICQoby5wcmV2KTtcblx0XHR2YXIgJG5leHRCdXR0b24gPSAkKG8ubmV4dCk7XG5cdFx0dmFyICRwcmV2UGFnZUJ1dHRvbiA9ICQoby5wcmV2UGFnZSk7XG5cdFx0dmFyICRuZXh0UGFnZUJ1dHRvbiA9ICQoby5uZXh0UGFnZSk7XG5cdFx0dmFyIGNhbGxiYWNrcyA9IHt9O1xuXHRcdHZhciBsYXN0ID0ge307XG5cdFx0dmFyIGFuaW1hdGlvbiA9IHt9O1xuXHRcdHZhciBtb3ZlID0ge307XG5cdFx0dmFyIGRyYWdnaW5nID0ge1xuXHRcdFx0cmVsZWFzZWQ6IDFcblx0XHR9O1xuXHRcdHZhciBzY3JvbGxpbmcgPSB7XG5cdFx0XHRsYXN0OiAwLFxuXHRcdFx0ZGVsdGE6IDAsXG5cdFx0XHRyZXNldFRpbWU6IDIwMFxuXHRcdH07XG5cdFx0dmFyIHJlbmRlcklEID0gMDtcblx0XHR2YXIgaGlzdG9yeUlEID0gMDtcblx0XHR2YXIgY3ljbGVJRCA9IDA7XG5cdFx0dmFyIGNvbnRpbnVvdXNJRCA9IDA7XG5cdFx0dmFyIGksIGw7XG5cblx0XHQvLyBOb3JtYWxpemluZyBmcmFtZVxuXHRcdGlmICghcGFyYWxsYXgpIHtcblx0XHRcdGZyYW1lID0gJGZyYW1lWzBdO1xuXHRcdH1cblxuXHRcdC8vIEV4cG9zZSBwcm9wZXJ0aWVzXG5cdFx0c2VsZi5pbml0aWFsaXplZCA9IDA7XG5cdFx0c2VsZi5mcmFtZSA9IGZyYW1lO1xuXHRcdHNlbGYuc2xpZGVlID0gJHNsaWRlZVswXTtcblx0XHRzZWxmLnBvcyA9IHBvcztcblx0XHRzZWxmLnJlbCA9IHJlbDtcblx0XHRzZWxmLml0ZW1zID0gaXRlbXM7XG5cdFx0c2VsZi5wYWdlcyA9IHBhZ2VzO1xuXHRcdHNlbGYuaXNQYXVzZWQgPSAwO1xuXHRcdHNlbGYub3B0aW9ucyA9IG87XG5cdFx0c2VsZi5kcmFnZ2luZyA9IGRyYWdnaW5nO1xuXG5cdFx0LyoqXG5cdFx0ICogTG9hZGluZyBmdW5jdGlvbi5cblx0XHQgKlxuXHRcdCAqIFBvcHVsYXRlIGFycmF5cywgc2V0IHNpemVzLCBiaW5kIGV2ZW50cywgLi4uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc0luaXRdIFdoZXRoZXIgbG9hZCBpcyBjYWxsZWQgZnJvbSB3aXRoaW4gc2VsZi5pbml0KCkuXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBsb2FkKGlzSW5pdCkge1xuXHRcdFx0Ly8gTG9jYWwgdmFyaWFibGVzXG5cdFx0XHR2YXIgbGFzdEl0ZW1zQ291bnQgPSAwO1xuXHRcdFx0dmFyIGxhc3RQYWdlc0NvdW50ID0gcGFnZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBTYXZlIG9sZCBwb3NpdGlvblxuXHRcdFx0cG9zLm9sZCA9ICQuZXh0ZW5kKHt9LCBwb3MpO1xuXG5cdFx0XHQvLyBSZXNldCBnbG9iYWwgdmFyaWFibGVzXG5cdFx0XHRmcmFtZVNpemUgPSBwYXJhbGxheCA/IDAgOiAkZnJhbWVbby5ob3Jpem9udGFsID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSgpO1xuXHRcdFx0c2JTaXplID0gJHNiW28uaG9yaXpvbnRhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0J10oKTtcblx0XHRcdHNsaWRlZVNpemUgPSBwYXJhbGxheCA/IGZyYW1lIDogJHNsaWRlZVtvLmhvcml6b250YWwgPyAnb3V0ZXJXaWR0aCcgOiAnb3V0ZXJIZWlnaHQnXSgpO1xuXHRcdFx0cGFnZXMubGVuZ3RoID0gMDtcblxuXHRcdFx0Ly8gU2V0IHBvc2l0aW9uIGxpbWl0cyAmIHJlbGF0aXZlc1xuXHRcdFx0cG9zLnN0YXJ0ID0gMDtcblx0XHRcdHBvcy5lbmQgPSBtYXgoc2xpZGVlU2l6ZSAtIGZyYW1lU2l6ZSwgMCk7XG5cblx0XHRcdC8vIFNpemVzICYgb2Zmc2V0cyBmb3IgaXRlbSBiYXNlZCBuYXZpZ2F0aW9uc1xuXHRcdFx0aWYgKGl0ZW1OYXYpIHtcblx0XHRcdFx0Ly8gU2F2ZSB0aGUgbnVtYmVyIG9mIGN1cnJlbnQgaXRlbXNcblx0XHRcdFx0bGFzdEl0ZW1zQ291bnQgPSBpdGVtcy5sZW5ndGg7XG5cblx0XHRcdFx0Ly8gUmVzZXQgaXRlbU5hdiByZWxhdGVkIHZhcmlhYmxlc1xuXHRcdFx0XHQkaXRlbXMgPSAkc2xpZGVlLmNoaWxkcmVuKG8uaXRlbVNlbGVjdG9yKTtcblx0XHRcdFx0aXRlbXMubGVuZ3RoID0gMDtcblxuXHRcdFx0XHQvLyBOZWVkZWQgdmFyaWFibGVzXG5cdFx0XHRcdHZhciBwYWRkaW5nU3RhcnQgPSBnZXRQeCgkc2xpZGVlLCBvLmhvcml6b250YWwgPyAncGFkZGluZ0xlZnQnIDogJ3BhZGRpbmdUb3AnKTtcblx0XHRcdFx0dmFyIHBhZGRpbmdFbmQgPSBnZXRQeCgkc2xpZGVlLCBvLmhvcml6b250YWwgPyAncGFkZGluZ1JpZ2h0JyA6ICdwYWRkaW5nQm90dG9tJyk7XG5cdFx0XHRcdHZhciBib3JkZXJCb3ggPSAkKCRpdGVtcykuY3NzKCdib3hTaXppbmcnKSA9PT0gJ2JvcmRlci1ib3gnO1xuXHRcdFx0XHR2YXIgYXJlRmxvYXRlZCA9ICRpdGVtcy5jc3MoJ2Zsb2F0JykgIT09ICdub25lJztcblx0XHRcdFx0dmFyIGlnbm9yZWRNYXJnaW4gPSAwO1xuXHRcdFx0XHR2YXIgbGFzdEl0ZW1JbmRleCA9ICRpdGVtcy5sZW5ndGggLSAxO1xuXHRcdFx0XHR2YXIgbGFzdEl0ZW07XG5cblx0XHRcdFx0Ly8gUmVzZXQgc2xpZGVlU2l6ZVxuXHRcdFx0XHRzbGlkZWVTaXplID0gMDtcblxuXHRcdFx0XHQvLyBJdGVyYXRlIHRocm91Z2ggaXRlbXNcblx0XHRcdFx0JGl0ZW1zLmVhY2goZnVuY3Rpb24gKGksIGVsZW1lbnQpIHtcblx0XHRcdFx0XHQvLyBJdGVtXG5cdFx0XHRcdFx0dmFyICRpdGVtID0gJChlbGVtZW50KTtcblx0XHRcdFx0XHR2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRcdFx0dmFyIGl0ZW1TaXplID0gcm91bmQoby5ob3Jpem9udGFsID8gcmVjdC53aWR0aCB8fCByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0IDogcmVjdC5oZWlnaHQgfHwgcmVjdC5ib3R0b20gLSByZWN0LnRvcCk7XG5cdFx0XHRcdFx0dmFyIGl0ZW1NYXJnaW5TdGFydCA9IGdldFB4KCRpdGVtLCBvLmhvcml6b250YWwgPyAnbWFyZ2luTGVmdCcgOiAnbWFyZ2luVG9wJyk7XG5cdFx0XHRcdFx0dmFyIGl0ZW1NYXJnaW5FbmQgPSBnZXRQeCgkaXRlbSwgby5ob3Jpem9udGFsID8gJ21hcmdpblJpZ2h0JyA6ICdtYXJnaW5Cb3R0b20nKTtcblx0XHRcdFx0XHR2YXIgaXRlbVNpemVGdWxsID0gaXRlbVNpemUgKyBpdGVtTWFyZ2luU3RhcnQgKyBpdGVtTWFyZ2luRW5kO1xuXHRcdFx0XHRcdHZhciBzaW5nbGVTcGFjZWQgPSAhaXRlbU1hcmdpblN0YXJ0IHx8ICFpdGVtTWFyZ2luRW5kO1xuXHRcdFx0XHRcdHZhciBpdGVtID0ge307XG5cdFx0XHRcdFx0aXRlbS5lbCA9IGVsZW1lbnQ7XG5cdFx0XHRcdFx0aXRlbS5zaXplID0gc2luZ2xlU3BhY2VkID8gaXRlbVNpemUgOiBpdGVtU2l6ZUZ1bGw7XG5cdFx0XHRcdFx0aXRlbS5oYWxmID0gaXRlbS5zaXplIC8gMjtcblx0XHRcdFx0XHRpdGVtLnN0YXJ0ID0gc2xpZGVlU2l6ZSArIChzaW5nbGVTcGFjZWQgPyBpdGVtTWFyZ2luU3RhcnQgOiAwKTtcblx0XHRcdFx0XHRpdGVtLmNlbnRlciA9IGl0ZW0uc3RhcnQgLSByb3VuZChmcmFtZVNpemUgLyAyIC0gaXRlbS5zaXplIC8gMik7XG5cdFx0XHRcdFx0aXRlbS5lbmQgPSBpdGVtLnN0YXJ0IC0gZnJhbWVTaXplICsgaXRlbS5zaXplO1xuXG5cdFx0XHRcdFx0Ly8gQWNjb3VudCBmb3Igc2xpZGVlIHBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIWkpIHtcblx0XHRcdFx0XHRcdHNsaWRlZVNpemUgKz0gcGFkZGluZ1N0YXJ0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEluY3JlbWVudCBzbGlkZWUgc2l6ZSBmb3Igc2l6ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnRcblx0XHRcdFx0XHRzbGlkZWVTaXplICs9IGl0ZW1TaXplRnVsbDtcblxuXHRcdFx0XHRcdC8vIFRyeSB0byBhY2NvdW50IGZvciB2ZXJ0aWNhbCBtYXJnaW4gY29sbGFwc2luZyBpbiB2ZXJ0aWNhbCBtb2RlXG5cdFx0XHRcdFx0Ly8gSXQncyBub3QgYnVsbGV0cHJvb2YsIGJ1dCBzaG91bGQgd29yayBpbiA5OSUgb2YgY2FzZXNcblx0XHRcdFx0XHRpZiAoIW8uaG9yaXpvbnRhbCAmJiAhYXJlRmxvYXRlZCkge1xuXHRcdFx0XHRcdFx0Ly8gU3VidHJhY3Qgc21hbGxlciBtYXJnaW4sIGJ1dCBvbmx5IHdoZW4gdG9wIG1hcmdpbiBpcyBub3QgMCwgYW5kIHRoaXMgaXMgbm90IHRoZSBmaXJzdCBlbGVtZW50XG5cdFx0XHRcdFx0XHRpZiAoaXRlbU1hcmdpbkVuZCAmJiBpdGVtTWFyZ2luU3RhcnQgJiYgaSA+IDApIHtcblx0XHRcdFx0XHRcdFx0c2xpZGVlU2l6ZSAtPSBtaW4oaXRlbU1hcmdpblN0YXJ0LCBpdGVtTWFyZ2luRW5kKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBUaGluZ3MgdG8gYmUgZG9uZSBvbiBsYXN0IGl0ZW1cblx0XHRcdFx0XHRpZiAoaSA9PT0gbGFzdEl0ZW1JbmRleCkge1xuXHRcdFx0XHRcdFx0aXRlbS5lbmQgKz0gcGFkZGluZ0VuZDtcblx0XHRcdFx0XHRcdHNsaWRlZVNpemUgKz0gcGFkZGluZ0VuZDtcblx0XHRcdFx0XHRcdGlnbm9yZWRNYXJnaW4gPSBzaW5nbGVTcGFjZWQgPyBpdGVtTWFyZ2luRW5kIDogMDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBBZGQgaXRlbSBvYmplY3QgdG8gaXRlbXMgYXJyYXlcblx0XHRcdFx0XHRpdGVtcy5wdXNoKGl0ZW0pO1xuXHRcdFx0XHRcdGxhc3RJdGVtID0gaXRlbTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gUmVzaXplIFNMSURFRSB0byBmaXQgYWxsIGl0ZW1zXG5cdFx0XHRcdCRzbGlkZWVbMF0uc3R5bGVbby5ob3Jpem9udGFsID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSA9IChib3JkZXJCb3ggPyBzbGlkZWVTaXplOiBzbGlkZWVTaXplIC0gcGFkZGluZ1N0YXJ0IC0gcGFkZGluZ0VuZCkgKyAncHgnO1xuXG5cdFx0XHRcdC8vIEFkanVzdCBpbnRlcm5hbCBTTElERUUgc2l6ZSBmb3IgbGFzdCBtYXJnaW5cblx0XHRcdFx0c2xpZGVlU2l6ZSAtPSBpZ25vcmVkTWFyZ2luO1xuXG5cdFx0XHRcdC8vIFNldCBsaW1pdHNcblx0XHRcdFx0aWYgKGl0ZW1zLmxlbmd0aCkge1xuXHRcdFx0XHRcdHBvcy5zdGFydCA9ICBpdGVtc1swXVtmb3JjZUNlbnRlcmVkTmF2ID8gJ2NlbnRlcicgOiAnc3RhcnQnXTtcblx0XHRcdFx0XHRwb3MuZW5kID0gZm9yY2VDZW50ZXJlZE5hdiA/IGxhc3RJdGVtLmNlbnRlciA6IGZyYW1lU2l6ZSA8IHNsaWRlZVNpemUgPyBsYXN0SXRlbS5lbmQgOiBwb3Muc3RhcnQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cG9zLnN0YXJ0ID0gcG9zLmVuZCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIFNMSURFRSBjZW50ZXIgcG9zaXRpb25cblx0XHRcdHBvcy5jZW50ZXIgPSByb3VuZChwb3MuZW5kIC8gMiArIHBvcy5zdGFydCAvIDIpO1xuXG5cdFx0XHQvLyBVcGRhdGUgcmVsYXRpdmUgcG9zaXRpb25zXG5cdFx0XHR1cGRhdGVSZWxhdGl2ZXMoKTtcblxuXHRcdFx0Ly8gU2Nyb2xsYmFyXG5cdFx0XHRpZiAoJGhhbmRsZS5sZW5ndGggJiYgc2JTaXplID4gMCkge1xuXHRcdFx0XHQvLyBTdHJldGNoIHNjcm9sbGJhciBoYW5kbGUgdG8gcmVwcmVzZW50IHRoZSB2aXNpYmxlIGFyZWFcblx0XHRcdFx0aWYgKG8uZHluYW1pY0hhbmRsZSkge1xuXHRcdFx0XHRcdGhhbmRsZVNpemUgPSBwb3Muc3RhcnQgPT09IHBvcy5lbmQgPyBzYlNpemUgOiByb3VuZChzYlNpemUgKiBmcmFtZVNpemUgLyBzbGlkZWVTaXplKTtcblx0XHRcdFx0XHRoYW5kbGVTaXplID0gd2l0aGluKGhhbmRsZVNpemUsIG8ubWluSGFuZGxlU2l6ZSwgc2JTaXplKTtcblx0XHRcdFx0XHQkaGFuZGxlWzBdLnN0eWxlW28uaG9yaXpvbnRhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gPSBoYW5kbGVTaXplICsgJ3B4Jztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoYW5kbGVTaXplID0gJGhhbmRsZVtvLmhvcml6b250YWwgPyAnb3V0ZXJXaWR0aCcgOiAnb3V0ZXJIZWlnaHQnXSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aFBvcy5lbmQgPSBzYlNpemUgLSBoYW5kbGVTaXplO1xuXG5cdFx0XHRcdGlmICghcmVuZGVySUQpIHtcblx0XHRcdFx0XHRzeW5jU2Nyb2xsYmFyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFnZXNcblx0XHRcdGlmICghcGFyYWxsYXggJiYgZnJhbWVTaXplID4gMCkge1xuXHRcdFx0XHR2YXIgdGVtcFBhZ2VQb3MgPSBwb3Muc3RhcnQ7XG5cdFx0XHRcdHZhciBwYWdlc0h0bWwgPSAnJztcblxuXHRcdFx0XHQvLyBQb3B1bGF0ZSBwYWdlcyBhcnJheVxuXHRcdFx0XHRpZiAoaXRlbU5hdikge1xuXHRcdFx0XHRcdCQuZWFjaChpdGVtcywgZnVuY3Rpb24gKGksIGl0ZW0pIHtcblx0XHRcdFx0XHRcdGlmIChmb3JjZUNlbnRlcmVkTmF2KSB7XG5cdFx0XHRcdFx0XHRcdHBhZ2VzLnB1c2goaXRlbS5jZW50ZXIpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChpdGVtLnN0YXJ0ICsgaXRlbS5zaXplID4gdGVtcFBhZ2VQb3MgJiYgdGVtcFBhZ2VQb3MgPD0gcG9zLmVuZCkge1xuXHRcdFx0XHRcdFx0XHR0ZW1wUGFnZVBvcyA9IGl0ZW0uc3RhcnQ7XG5cdFx0XHRcdFx0XHRcdHBhZ2VzLnB1c2godGVtcFBhZ2VQb3MpO1xuXHRcdFx0XHRcdFx0XHR0ZW1wUGFnZVBvcyArPSBmcmFtZVNpemU7XG5cdFx0XHRcdFx0XHRcdGlmICh0ZW1wUGFnZVBvcyA+IHBvcy5lbmQgJiYgdGVtcFBhZ2VQb3MgPCBwb3MuZW5kICsgZnJhbWVTaXplKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGFnZXMucHVzaChwb3MuZW5kKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHdoaWxlICh0ZW1wUGFnZVBvcyAtIGZyYW1lU2l6ZSA8IHBvcy5lbmQpIHtcblx0XHRcdFx0XHRcdHBhZ2VzLnB1c2godGVtcFBhZ2VQb3MpO1xuXHRcdFx0XHRcdFx0dGVtcFBhZ2VQb3MgKz0gZnJhbWVTaXplO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFBhZ2VzIGJhclxuXHRcdFx0XHRpZiAoJHBiWzBdICYmIGxhc3RQYWdlc0NvdW50ICE9PSBwYWdlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRwYWdlc0h0bWwgKz0gby5wYWdlQnVpbGRlci5jYWxsKHNlbGYsIGkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQkcGFnZXMgPSAkcGIuaHRtbChwYWdlc0h0bWwpLmNoaWxkcmVuKCk7XG5cdFx0XHRcdFx0JHBhZ2VzLmVxKHJlbC5hY3RpdmVQYWdlKS5hZGRDbGFzcyhvLmFjdGl2ZUNsYXNzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBFeHRlbmQgcmVsYXRpdmUgdmFyaWFibGVzIG9iamVjdCB3aXRoIHNvbWUgdXNlZnVsIGluZm9cblx0XHRcdHJlbC5zbGlkZWVTaXplID0gc2xpZGVlU2l6ZTtcblx0XHRcdHJlbC5mcmFtZVNpemUgPSBmcmFtZVNpemU7XG5cdFx0XHRyZWwuc2JTaXplID0gc2JTaXplO1xuXHRcdFx0cmVsLmhhbmRsZVNpemUgPSBoYW5kbGVTaXplO1xuXG5cdFx0XHQvLyBBY3RpdmF0ZSByZXF1ZXN0ZWQgcG9zaXRpb25cblx0XHRcdGlmIChpdGVtTmF2KSB7XG5cdFx0XHRcdGlmIChpc0luaXQgJiYgby5zdGFydEF0ICE9IG51bGwpIHtcblx0XHRcdFx0XHRhY3RpdmF0ZShvLnN0YXJ0QXQpO1xuXHRcdFx0XHRcdHNlbGZbY2VudGVyZWROYXYgPyAndG9DZW50ZXInIDogJ3RvU3RhcnQnXShvLnN0YXJ0QXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIEZpeCBwb3NzaWJsZSBvdmVyZmxvd2luZ1xuXHRcdFx0XHR2YXIgYWN0aXZlSXRlbSA9IGl0ZW1zW3JlbC5hY3RpdmVJdGVtXTtcblx0XHRcdFx0c2xpZGVUbyhjZW50ZXJlZE5hdiAmJiBhY3RpdmVJdGVtID8gYWN0aXZlSXRlbS5jZW50ZXIgOiB3aXRoaW4ocG9zLmRlc3QsIHBvcy5zdGFydCwgcG9zLmVuZCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGlzSW5pdCkge1xuXHRcdFx0XHRcdGlmIChvLnN0YXJ0QXQgIT0gbnVsbCkgc2xpZGVUbyhvLnN0YXJ0QXQsIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEZpeCBwb3NzaWJsZSBvdmVyZmxvd2luZ1xuXHRcdFx0XHRcdHNsaWRlVG8od2l0aGluKHBvcy5kZXN0LCBwb3Muc3RhcnQsIHBvcy5lbmQpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmlnZ2VyIGxvYWQgZXZlbnRcblx0XHRcdHRyaWdnZXIoJ2xvYWQnKTtcblx0XHR9XG5cdFx0c2VsZi5yZWxvYWQgPSBmdW5jdGlvbiAoKSB7IGxvYWQoKTsgfTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuaW1hdGUgdG8gYSBwb3NpdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7SW50fSAgbmV3UG9zICAgIE5ldyBwb3NpdGlvbi5cblx0XHQgKiBAcGFyYW0ge0Jvb2x9IGltbWVkaWF0ZSBSZXBvc2l0aW9uIGltbWVkaWF0ZWx5IHdpdGhvdXQgYW4gYW5pbWF0aW9uLlxuXHRcdCAqIEBwYXJhbSB7Qm9vbH0gZG9udEFsaWduIERvIG5vdCBhbGlnbiBpdGVtcywgdXNlIHRoZSByYXcgcG9zaXRpb24gcGFzc2VkIGluIGZpcnN0IGFyZ3VtZW50LlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBzbGlkZVRvKG5ld1BvcywgaW1tZWRpYXRlLCBkb250QWxpZ24pIHtcblx0XHRcdC8vIEFsaWduIGl0ZW1zXG5cdFx0XHRpZiAoaXRlbU5hdiAmJiBkcmFnZ2luZy5yZWxlYXNlZCAmJiAhZG9udEFsaWduKSB7XG5cdFx0XHRcdHZhciB0ZW1wUmVsID0gZ2V0UmVsYXRpdmVzKG5ld1Bvcyk7XG5cdFx0XHRcdHZhciBpc05vdEJvcmRlcmluZyA9IG5ld1BvcyA+IHBvcy5zdGFydCAmJiBuZXdQb3MgPCBwb3MuZW5kO1xuXG5cdFx0XHRcdGlmIChjZW50ZXJlZE5hdikge1xuXHRcdFx0XHRcdGlmIChpc05vdEJvcmRlcmluZykge1xuXHRcdFx0XHRcdFx0bmV3UG9zID0gaXRlbXNbdGVtcFJlbC5jZW50ZXJJdGVtXS5jZW50ZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChmb3JjZUNlbnRlcmVkTmF2ICYmIG8uYWN0aXZhdGVNaWRkbGUpIHtcblx0XHRcdFx0XHRcdGFjdGl2YXRlKHRlbXBSZWwuY2VudGVySXRlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGlzTm90Qm9yZGVyaW5nKSB7XG5cdFx0XHRcdFx0bmV3UG9zID0gaXRlbXNbdGVtcFJlbC5maXJzdEl0ZW1dLnN0YXJ0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSBvdmVyZmxvd2luZyBwb3NpdGlvbiBsaW1pdHNcblx0XHRcdGlmIChkcmFnZ2luZy5pbml0ICYmIGRyYWdnaW5nLnNsaWRlZSAmJiBvLmVsYXN0aWNCb3VuZHMpIHtcblx0XHRcdFx0aWYgKG5ld1BvcyA+IHBvcy5lbmQpIHtcblx0XHRcdFx0XHRuZXdQb3MgPSBwb3MuZW5kICsgKG5ld1BvcyAtIHBvcy5lbmQpIC8gNjtcblx0XHRcdFx0fSBlbHNlIGlmIChuZXdQb3MgPCBwb3Muc3RhcnQpIHtcblx0XHRcdFx0XHRuZXdQb3MgPSBwb3Muc3RhcnQgKyAobmV3UG9zIC0gcG9zLnN0YXJ0KSAvIDY7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld1BvcyA9IHdpdGhpbihuZXdQb3MsIHBvcy5zdGFydCwgcG9zLmVuZCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSB0aGUgYW5pbWF0aW9uIG9iamVjdFxuXHRcdFx0YW5pbWF0aW9uLnN0YXJ0ID0gK25ldyBEYXRlKCk7XG5cdFx0XHRhbmltYXRpb24udGltZSA9IDA7XG5cdFx0XHRhbmltYXRpb24uZnJvbSA9IHBvcy5jdXI7XG5cdFx0XHRhbmltYXRpb24udG8gPSBuZXdQb3M7XG5cdFx0XHRhbmltYXRpb24uZGVsdGEgPSBuZXdQb3MgLSBwb3MuY3VyO1xuXHRcdFx0YW5pbWF0aW9uLnR3ZWVzaW5nID0gZHJhZ2dpbmcudHdlZXNlIHx8IGRyYWdnaW5nLmluaXQgJiYgIWRyYWdnaW5nLnNsaWRlZTtcblx0XHRcdGFuaW1hdGlvbi5pbW1lZGlhdGUgPSAhYW5pbWF0aW9uLnR3ZWVzaW5nICYmIChpbW1lZGlhdGUgfHwgZHJhZ2dpbmcuaW5pdCAmJiBkcmFnZ2luZy5zbGlkZWUgfHwgIW8uc3BlZWQpO1xuXG5cdFx0XHQvLyBSZXNldCBkcmFnZ2luZyB0d2Vlc2luZyByZXF1ZXN0XG5cdFx0XHRkcmFnZ2luZy50d2Vlc2UgPSAwO1xuXG5cdFx0XHQvLyBTdGFydCBhbmltYXRpb24gcmVuZGVyaW5nXG5cdFx0XHRpZiAobmV3UG9zICE9PSBwb3MuZGVzdCkge1xuXHRcdFx0XHRwb3MuZGVzdCA9IG5ld1Bvcztcblx0XHRcdFx0dHJpZ2dlcignY2hhbmdlJyk7XG5cdFx0XHRcdGlmICghcmVuZGVySUQpIHtcblx0XHRcdFx0XHRyZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNldCBuZXh0IGN5Y2xlIHRpbWVvdXRcblx0XHRcdHJlc2V0Q3ljbGUoKTtcblxuXHRcdFx0Ly8gU3luY2hyb25pemUgc3RhdGVzXG5cdFx0XHR1cGRhdGVSZWxhdGl2ZXMoKTtcblx0XHRcdHVwZGF0ZUJ1dHRvbnNTdGF0ZSgpO1xuXHRcdFx0c3luY1BhZ2VzYmFyKCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmVuZGVyIGFuaW1hdGlvbiBmcmFtZS5cblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge1ZvaWR9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcmVuZGVyKCkge1xuXHRcdFx0aWYgKCFzZWxmLmluaXRpYWxpemVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZmlyc3QgcmVuZGVyIGNhbGwsIHdhaXQgZm9yIG5leHQgYW5pbWF0aW9uRnJhbWVcblx0XHRcdGlmICghcmVuZGVySUQpIHtcblx0XHRcdFx0cmVuZGVySUQgPSByQUYocmVuZGVyKTtcblx0XHRcdFx0aWYgKGRyYWdnaW5nLnJlbGVhc2VkKSB7XG5cdFx0XHRcdFx0dHJpZ2dlcignbW92ZVN0YXJ0Jyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBpbW1lZGlhdGUgcmVwb3NpdGlvbmluZyBpcyByZXF1ZXN0ZWQsIGRvbid0IGFuaW1hdGUuXG5cdFx0XHRpZiAoYW5pbWF0aW9uLmltbWVkaWF0ZSkge1xuXHRcdFx0XHRwb3MuY3VyID0gYW5pbWF0aW9uLnRvO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVXNlIHR3ZWVzaW5nIGZvciBhbmltYXRpb25zIHdpdGhvdXQga25vd24gZW5kIHBvaW50XG5cdFx0XHRlbHNlIGlmIChhbmltYXRpb24udHdlZXNpbmcpIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVzZURlbHRhID0gYW5pbWF0aW9uLnRvIC0gcG9zLmN1cjtcblx0XHRcdFx0Ly8gRnVjayBaZW5vJ3MgcGFyYWRveFxuXHRcdFx0XHRpZiAoYWJzKGFuaW1hdGlvbi50d2Vlc2VEZWx0YSkgPCAwLjEpIHtcblx0XHRcdFx0XHRwb3MuY3VyID0gYW5pbWF0aW9uLnRvO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBvcy5jdXIgKz0gYW5pbWF0aW9uLnR3ZWVzZURlbHRhICogKGRyYWdnaW5nLnJlbGVhc2VkID8gby5zd2luZ1NwZWVkIDogby5zeW5jU3BlZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBVc2UgdHdlZW5pbmcgZm9yIGJhc2ljIGFuaW1hdGlvbnMgd2l0aCBrbm93biBlbmQgcG9pbnRcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRhbmltYXRpb24udGltZSA9IG1pbigrbmV3IERhdGUoKSAtIGFuaW1hdGlvbi5zdGFydCwgby5zcGVlZCk7XG5cdFx0XHRcdHBvcy5jdXIgPSBhbmltYXRpb24uZnJvbSArIGFuaW1hdGlvbi5kZWx0YSAqICQuZWFzaW5nW28uZWFzaW5nXShhbmltYXRpb24udGltZS9vLnNwZWVkLCBhbmltYXRpb24udGltZSwgMCwgMSwgby5zcGVlZCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZXJlIGlzIG5vdGhpbmcgbW9yZSB0byByZW5kZXIgYnJlYWsgdGhlIHJlbmRlcmluZyBsb29wLCBvdGhlcndpc2UgcmVxdWVzdCBuZXcgYW5pbWF0aW9uIGZyYW1lLlxuXHRcdFx0aWYgKGFuaW1hdGlvbi50byA9PT0gcG9zLmN1cikge1xuXHRcdFx0XHRwb3MuY3VyID0gYW5pbWF0aW9uLnRvO1xuXHRcdFx0XHRkcmFnZ2luZy50d2Vlc2UgPSByZW5kZXJJRCA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZW5kZXJJRCA9IHJBRihyZW5kZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHR0cmlnZ2VyKCdtb3ZlJyk7XG5cblx0XHRcdC8vIFVwZGF0ZSBTTElERUUgcG9zaXRpb25cblx0XHRcdGlmICghcGFyYWxsYXgpIHtcblx0XHRcdFx0aWYgKHRyYW5zZm9ybSkge1xuXHRcdFx0XHRcdCRzbGlkZWVbMF0uc3R5bGVbdHJhbnNmb3JtXSA9IGdwdUFjY2VsZXJhdGlvbiArIChvLmhvcml6b250YWwgPyAndHJhbnNsYXRlWCcgOiAndHJhbnNsYXRlWScpICsgJygnICsgKC1wb3MuY3VyKSArICdweCknO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCRzbGlkZWVbMF0uc3R5bGVbby5ob3Jpem9udGFsID8gJ2xlZnQnIDogJ3RvcCddID0gLXJvdW5kKHBvcy5jdXIpICsgJ3B4Jztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBXaGVuIGFuaW1hdGlvbiByZWFjaGVkIHRoZSBlbmQsIGFuZCBkcmFnZ2luZyBpcyBub3QgYWN0aXZlLCB0cmlnZ2VyIG1vdmVFbmRcblx0XHRcdGlmICghcmVuZGVySUQgJiYgZHJhZ2dpbmcucmVsZWFzZWQpIHtcblx0XHRcdFx0dHJpZ2dlcignbW92ZUVuZCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRzeW5jU2Nyb2xsYmFyKCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogU3luY2hyb25pemVzIHNjcm9sbGJhciB3aXRoIHRoZSBTTElERUUuXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHN5bmNTY3JvbGxiYXIoKSB7XG5cdFx0XHRpZiAoJGhhbmRsZS5sZW5ndGgpIHtcblx0XHRcdFx0aFBvcy5jdXIgPSBwb3Muc3RhcnQgPT09IHBvcy5lbmQgPyAwIDogKCgoZHJhZ2dpbmcuaW5pdCAmJiAhZHJhZ2dpbmcuc2xpZGVlKSA/IHBvcy5kZXN0IDogcG9zLmN1cikgLSBwb3Muc3RhcnQpIC8gKHBvcy5lbmQgLSBwb3Muc3RhcnQpICogaFBvcy5lbmQ7XG5cdFx0XHRcdGhQb3MuY3VyID0gd2l0aGluKHJvdW5kKGhQb3MuY3VyKSwgaFBvcy5zdGFydCwgaFBvcy5lbmQpO1xuXHRcdFx0XHRpZiAobGFzdC5oUG9zICE9PSBoUG9zLmN1cikge1xuXHRcdFx0XHRcdGxhc3QuaFBvcyA9IGhQb3MuY3VyO1xuXHRcdFx0XHRcdGlmICh0cmFuc2Zvcm0pIHtcblx0XHRcdFx0XHRcdCRoYW5kbGVbMF0uc3R5bGVbdHJhbnNmb3JtXSA9IGdwdUFjY2VsZXJhdGlvbiArIChvLmhvcml6b250YWwgPyAndHJhbnNsYXRlWCcgOiAndHJhbnNsYXRlWScpICsgJygnICsgaFBvcy5jdXIgKyAncHgpJztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0JGhhbmRsZVswXS5zdHlsZVtvLmhvcml6b250YWwgPyAnbGVmdCcgOiAndG9wJ10gPSBoUG9zLmN1ciArICdweCc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogU3luY2hyb25pemVzIHBhZ2VzYmFyIHdpdGggU0xJREVFLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBzeW5jUGFnZXNiYXIoKSB7XG5cdFx0XHRpZiAoJHBhZ2VzWzBdICYmIGxhc3QucGFnZSAhPT0gcmVsLmFjdGl2ZVBhZ2UpIHtcblx0XHRcdFx0bGFzdC5wYWdlID0gcmVsLmFjdGl2ZVBhZ2U7XG5cdFx0XHRcdCRwYWdlcy5yZW1vdmVDbGFzcyhvLmFjdGl2ZUNsYXNzKS5lcShyZWwuYWN0aXZlUGFnZSkuYWRkQ2xhc3Moby5hY3RpdmVDbGFzcyk7XG5cdFx0XHRcdHRyaWdnZXIoJ2FjdGl2ZVBhZ2UnLCBsYXN0LnBhZ2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9iamVjdC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7TWl4ZWR9IGl0ZW1cblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge09iamVjdH1cblx0XHQgKi9cblx0XHRzZWxmLmdldFBvcyA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRpZiAoaXRlbU5hdikge1xuXHRcdFx0XHR2YXIgaW5kZXggPSBnZXRJbmRleChpdGVtKTtcblx0XHRcdFx0cmV0dXJuIGluZGV4ICE9PSAtMSA/IGl0ZW1zW2luZGV4XSA6IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyICRpdGVtID0gJHNsaWRlZS5maW5kKGl0ZW0pLmVxKDApO1xuXG5cdFx0XHRcdGlmICgkaXRlbVswXSkge1xuXHRcdFx0XHRcdHZhciBvZmZzZXQgPSBvLmhvcml6b250YWwgPyAkaXRlbS5vZmZzZXQoKS5sZWZ0IC0gJHNsaWRlZS5vZmZzZXQoKS5sZWZ0IDogJGl0ZW0ub2Zmc2V0KCkudG9wIC0gJHNsaWRlZS5vZmZzZXQoKS50b3A7XG5cdFx0XHRcdFx0dmFyIHNpemUgPSAkaXRlbVtvLmhvcml6b250YWwgPyAnb3V0ZXJXaWR0aCcgOiAnb3V0ZXJIZWlnaHQnXSgpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHN0YXJ0OiBvZmZzZXQsXG5cdFx0XHRcdFx0XHRjZW50ZXI6IG9mZnNldCAtIGZyYW1lU2l6ZSAvIDIgKyBzaXplIC8gMixcblx0XHRcdFx0XHRcdGVuZDogb2Zmc2V0IC0gZnJhbWVTaXplICsgc2l6ZSxcblx0XHRcdFx0XHRcdHNpemU6IHNpemVcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBDb250aW51b3VzIG1vdmUgaW4gYSBzcGVjaWZpZWQgZGlyZWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtICB7Qm9vbH0gZm9yd2FyZCBUcnVlIGZvciBmb3J3YXJkIG1vdmVtZW50LCBvdGhlcndpc2UgaXQnbGwgZ28gYmFja3dhcmRzLlxuXHRcdCAqIEBwYXJhbSAge0ludH0gIHNwZWVkICAgTW92ZW1lbnQgc3BlZWQgaW4gcGl4ZWxzIHBlciBmcmFtZS4gT3ZlcnJpZGVzIG9wdGlvbnMubW92ZUJ5IHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRzZWxmLm1vdmVCeSA9IGZ1bmN0aW9uIChzcGVlZCkge1xuXHRcdFx0bW92ZS5zcGVlZCA9IHNwZWVkO1xuXHRcdFx0Ly8gSWYgYWxyZWFkeSBpbml0aWF0ZWQsIG9yIHRoZXJlIGlzIG5vd2hlcmUgdG8gbW92ZSwgYWJvcnRcblx0XHRcdGlmIChkcmFnZ2luZy5pbml0IHx8ICFtb3ZlLnNwZWVkIHx8IHBvcy5jdXIgPT09IChtb3ZlLnNwZWVkID4gMCA/IHBvcy5lbmQgOiBwb3Muc3RhcnQpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIEluaXRpYXRlIG1vdmUgb2JqZWN0XG5cdFx0XHRtb3ZlLmxhc3RUaW1lID0gK25ldyBEYXRlKCk7XG5cdFx0XHRtb3ZlLnN0YXJ0UG9zID0gcG9zLmN1cjtcblx0XHRcdC8vIFNldCBkcmFnZ2luZyBhcyBpbml0aWF0ZWRcblx0XHRcdGNvbnRpbnVvdXNJbml0KCdidXR0b24nKTtcblx0XHRcdGRyYWdnaW5nLmluaXQgPSAxO1xuXHRcdFx0Ly8gU3RhcnQgbW92ZW1lbnRcblx0XHRcdHRyaWdnZXIoJ21vdmVTdGFydCcpO1xuXHRcdFx0Y0FGKGNvbnRpbnVvdXNJRCk7XG5cdFx0XHRtb3ZlTG9vcCgpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBDb250aW51b3VzIG1vdmVtZW50IGxvb3AuXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIG1vdmVMb29wKCkge1xuXHRcdFx0Ly8gSWYgdGhlcmUgaXMgbm93aGVyZSB0byBtb3ZlIGFueW1vcmUsIHN0b3Bcblx0XHRcdGlmICghbW92ZS5zcGVlZCB8fCBwb3MuY3VyID09PSAobW92ZS5zcGVlZCA+IDAgPyBwb3MuZW5kIDogcG9zLnN0YXJ0KSkge1xuXHRcdFx0XHRzZWxmLnN0b3AoKTtcblx0XHRcdH1cblx0XHRcdC8vIFJlcXVlc3QgbmV3IG1vdmUgbG9vcCBpZiBpdCBoYXNuJ3QgYmVlbiBzdG9wcGVkXG5cdFx0XHRjb250aW51b3VzSUQgPSBkcmFnZ2luZy5pbml0ID8gckFGKG1vdmVMb29wKSA6IDA7XG5cdFx0XHQvLyBVcGRhdGUgbW92ZSBvYmplY3Rcblx0XHRcdG1vdmUubm93ID0gK25ldyBEYXRlKCk7XG5cdFx0XHRtb3ZlLnBvcyA9IHBvcy5jdXIgKyAobW92ZS5ub3cgLSBtb3ZlLmxhc3RUaW1lKSAvIDEwMDAgKiBtb3ZlLnNwZWVkO1xuXHRcdFx0Ly8gU2xpZGVcblx0XHRcdHNsaWRlVG8oZHJhZ2dpbmcuaW5pdCA/IG1vdmUucG9zIDogcm91bmQobW92ZS5wb3MpKTtcblx0XHRcdC8vIE5vcm1hbGx5LCB0aGlzIGlzIHRyaWdnZXJlZCBpbiByZW5kZXIoKSwgYnV0IGlmIHRoZXJlXG5cdFx0XHQvLyBpcyBub3RoaW5nIHRvIHJlbmRlciwgd2UgaGF2ZSB0byBkbyBpdCBtYW51YWxseSBoZXJlLlxuXHRcdFx0aWYgKCFkcmFnZ2luZy5pbml0ICYmIHBvcy5jdXIgPT09IHBvcy5kZXN0KSB7XG5cdFx0XHRcdHRyaWdnZXIoJ21vdmVFbmQnKTtcblx0XHRcdH1cblx0XHRcdC8vIFVwZGF0ZSB0aW1lcyBmb3IgZnV0dXJlIGl0ZXJhdGlvblxuXHRcdFx0bW92ZS5sYXN0VGltZSA9IG1vdmUubm93O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFN0b3BzIGNvbnRpbnVvdXMgbW92ZW1lbnQuXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdHNlbGYuc3RvcCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChkcmFnZ2luZy5zb3VyY2UgPT09ICdidXR0b24nKSB7XG5cdFx0XHRcdGRyYWdnaW5nLmluaXQgPSAwO1xuXHRcdFx0XHRkcmFnZ2luZy5yZWxlYXNlZCA9IDE7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFjdGl2YXRlIHByZXZpb3VzIGl0ZW0uXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdHNlbGYucHJldiA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHNlbGYuYWN0aXZhdGUocmVsLmFjdGl2ZUl0ZW0gPT0gbnVsbCA/IDAgOiByZWwuYWN0aXZlSXRlbSAtIDEpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBBY3RpdmF0ZSBuZXh0IGl0ZW0uXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdHNlbGYubmV4dCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHNlbGYuYWN0aXZhdGUocmVsLmFjdGl2ZUl0ZW0gPT0gbnVsbCA/IDAgOiByZWwuYWN0aXZlSXRlbSArIDEpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBBY3RpdmF0ZSBwcmV2aW91cyBwYWdlLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRzZWxmLnByZXZQYWdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0c2VsZi5hY3RpdmF0ZVBhZ2UocmVsLmFjdGl2ZVBhZ2UgLSAxKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQWN0aXZhdGUgbmV4dCBwYWdlLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRzZWxmLm5leHRQYWdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0c2VsZi5hY3RpdmF0ZVBhZ2UocmVsLmFjdGl2ZVBhZ2UgKyAxKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogU2xpZGUgU0xJREVFIGJ5IGFtb3VudCBvZiBwaXhlbHMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0ludH0gIGRlbHRhICAgICBQaXhlbHMvSXRlbXMuIFBvc2l0aXZlIG1lYW5zIGZvcndhcmQsIG5lZ2F0aXZlIG1lYW5zIGJhY2t3YXJkLlxuXHRcdCAqIEBwYXJhbSB7Qm9vbH0gaW1tZWRpYXRlIFJlcG9zaXRpb24gaW1tZWRpYXRlbHkgd2l0aG91dCBhbiBhbmltYXRpb24uXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdHNlbGYuc2xpZGVCeSA9IGZ1bmN0aW9uIChkZWx0YSwgaW1tZWRpYXRlKSB7XG5cdFx0XHRpZiAoIWRlbHRhKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmIChpdGVtTmF2KSB7XG5cdFx0XHRcdHNlbGZbY2VudGVyZWROYXYgPyAndG9DZW50ZXInIDogJ3RvU3RhcnQnXShcblx0XHRcdFx0XHR3aXRoaW4oKGNlbnRlcmVkTmF2ID8gcmVsLmNlbnRlckl0ZW0gOiByZWwuZmlyc3RJdGVtKSArIG8uc2Nyb2xsQnkgKiBkZWx0YSwgMCwgaXRlbXMubGVuZ3RoKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2xpZGVUbyhwb3MuZGVzdCArIGRlbHRhLCBpbW1lZGlhdGUpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBBbmltYXRlIFNMSURFRSB0byBhIHNwZWNpZmljIHBvc2l0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtJbnR9ICBwb3MgICAgICAgTmV3IHBvc2l0aW9uLlxuXHRcdCAqIEBwYXJhbSB7Qm9vbH0gaW1tZWRpYXRlIFJlcG9zaXRpb24gaW1tZWRpYXRlbHkgd2l0aG91dCBhbiBhbmltYXRpb24uXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdHNlbGYuc2xpZGVUbyA9IGZ1bmN0aW9uIChwb3MsIGltbWVkaWF0ZSkge1xuXHRcdFx0c2xpZGVUbyhwb3MsIGltbWVkaWF0ZSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIENvcmUgbWV0aG9kIGZvciBoYW5kbGluZyBgdG9Mb2NhdGlvbmAgbWV0aG9kcy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gbG9jYXRpb25cblx0XHQgKiBAcGFyYW0gIHtNaXhlZH0gIGl0ZW1cblx0XHQgKiBAcGFyYW0gIHtCb29sfSAgIGltbWVkaWF0ZVxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiB0byhsb2NhdGlvbiwgaXRlbSwgaW1tZWRpYXRlKSB7XG5cdFx0XHQvLyBPcHRpb25hbCBhcmd1bWVudHMgbG9naWNcblx0XHRcdGlmICh0eXBlKGl0ZW0pID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0aW1tZWRpYXRlID0gaXRlbTtcblx0XHRcdFx0aXRlbSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRzbGlkZVRvKHBvc1tsb2NhdGlvbl0sIGltbWVkaWF0ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBZb3UgY2FuJ3QgYWxpZ24gaXRlbXMgdG8gc2lkZXMgb2YgdGhlIGZyYW1lXG5cdFx0XHRcdC8vIHdoZW4gY2VudGVyZWQgbmF2aWdhdGlvbiB0eXBlIGlzIGVuYWJsZWRcblx0XHRcdFx0aWYgKGNlbnRlcmVkTmF2ICYmIGxvY2F0aW9uICE9PSAnY2VudGVyJykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBpdGVtUG9zID0gc2VsZi5nZXRQb3MoaXRlbSk7XG5cdFx0XHRcdGlmIChpdGVtUG9zKSB7XG5cdFx0XHRcdFx0c2xpZGVUbyhpdGVtUG9zW2xvY2F0aW9uXSwgaW1tZWRpYXRlLCAhY2VudGVyZWROYXYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQW5pbWF0ZSBlbGVtZW50IG9yIHRoZSB3aG9sZSBTTElERUUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBmcmFtZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7TWl4ZWR9IGl0ZW0gICAgICBJdGVtIERPTSBlbGVtZW50LCBvciBpbmRleCBzdGFydGluZyBhdCAwLiBPbWl0dGluZyB3aWxsIGFuaW1hdGUgU0xJREVFLlxuXHRcdCAqIEBwYXJhbSB7Qm9vbH0gIGltbWVkaWF0ZSBSZXBvc2l0aW9uIGltbWVkaWF0ZWx5IHdpdGhvdXQgYW4gYW5pbWF0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRzZWxmLnRvU3RhcnQgPSBmdW5jdGlvbiAoaXRlbSwgaW1tZWRpYXRlKSB7XG5cdFx0XHR0bygnc3RhcnQnLCBpdGVtLCBpbW1lZGlhdGUpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBBbmltYXRlIGVsZW1lbnQgb3IgdGhlIHdob2xlIFNMSURFRSB0byB0aGUgZW5kIG9mIHRoZSBmcmFtZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7TWl4ZWR9IGl0ZW0gICAgICBJdGVtIERPTSBlbGVtZW50LCBvciBpbmRleCBzdGFydGluZyBhdCAwLiBPbWl0dGluZyB3aWxsIGFuaW1hdGUgU0xJREVFLlxuXHRcdCAqIEBwYXJhbSB7Qm9vbH0gIGltbWVkaWF0ZSBSZXBvc2l0aW9uIGltbWVkaWF0ZWx5IHdpdGhvdXQgYW4gYW5pbWF0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRzZWxmLnRvRW5kID0gZnVuY3Rpb24gKGl0ZW0sIGltbWVkaWF0ZSkge1xuXHRcdFx0dG8oJ2VuZCcsIGl0ZW0sIGltbWVkaWF0ZSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuaW1hdGUgZWxlbWVudCBvciB0aGUgd2hvbGUgU0xJREVFIHRvIHRoZSBjZW50ZXIgb2YgdGhlIGZyYW1lLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtNaXhlZH0gaXRlbSAgICAgIEl0ZW0gRE9NIGVsZW1lbnQsIG9yIGluZGV4IHN0YXJ0aW5nIGF0IDAuIE9taXR0aW5nIHdpbGwgYW5pbWF0ZSBTTElERUUuXG5cdFx0ICogQHBhcmFtIHtCb29sfSAgaW1tZWRpYXRlIFJlcG9zaXRpb24gaW1tZWRpYXRlbHkgd2l0aG91dCBhbiBhbmltYXRpb24uXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdHNlbGYudG9DZW50ZXIgPSBmdW5jdGlvbiAoaXRlbSwgaW1tZWRpYXRlKSB7XG5cdFx0XHR0bygnY2VudGVyJywgaXRlbSwgaW1tZWRpYXRlKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBpbmRleCBvZiBhbiBpdGVtIGluIFNMSURFRS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7TWl4ZWR9IGl0ZW0gICAgIEl0ZW0gRE9NIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtJbnR9ICBJdGVtIGluZGV4LCBvciAtMSBpZiBub3QgZm91bmQuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZ2V0SW5kZXgoaXRlbSkge1xuXHRcdFx0cmV0dXJuIGl0ZW0gIT0gbnVsbCA/XG5cdFx0XHRcdFx0aXNOdW1iZXIoaXRlbSkgP1xuXHRcdFx0XHRcdFx0aXRlbSA+PSAwICYmIGl0ZW0gPCBpdGVtcy5sZW5ndGggPyBpdGVtIDogLTEgOlxuXHRcdFx0XHRcdFx0JGl0ZW1zLmluZGV4KGl0ZW0pIDpcblx0XHRcdFx0XHQtMTtcblx0XHR9XG5cdFx0Ly8gRXhwb3NlIGdldEluZGV4IHdpdGhvdXQgbG93ZXJpbmcgdGhlIGNvbXByZXNzaWJpbGl0eSBvZiBpdCxcblx0XHQvLyBhcyBpdCBpcyB1c2VkIHF1aXRlIG9mdGVuIHRocm91Z2hvdXQgU2x5LlxuXHRcdHNlbGYuZ2V0SW5kZXggPSBnZXRJbmRleDtcblxuXHRcdC8qKlxuXHRcdCAqIEdldCBpbmRleCBvZiBhbiBpdGVtIGluIFNMSURFRSBiYXNlZCBvbiBhIHZhcmlldHkgb2YgaW5wdXQgdHlwZXMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0gIHtNaXhlZH0gaXRlbSBET00gZWxlbWVudCwgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW50ZWdlci5cblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge0ludH0gICBJdGVtIGluZGV4LCBvciAtMSBpZiBub3QgZm91bmQuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZ2V0UmVsYXRpdmVJbmRleChpdGVtKSB7XG5cdFx0XHRyZXR1cm4gZ2V0SW5kZXgoaXNOdW1iZXIoaXRlbSkgJiYgaXRlbSA8IDAgPyBpdGVtICsgaXRlbXMubGVuZ3RoIDogaXRlbSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQWN0aXZhdGVzIGFuIGl0ZW0uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0gIHtNaXhlZH0gaXRlbSBJdGVtIERPTSBlbGVtZW50LCBvciBpbmRleCBzdGFydGluZyBhdCAwLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7TWl4ZWR9IEFjdGl2YXRlZCBpdGVtIGluZGV4IG9yIGZhbHNlIG9uIGZhaWwuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gYWN0aXZhdGUoaXRlbSwgZm9yY2UpIHtcblx0XHRcdHZhciBpbmRleCA9IGdldEluZGV4KGl0ZW0pO1xuXG5cdFx0XHRpZiAoIWl0ZW1OYXYgfHwgaW5kZXggPCAwKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIGNsYXNzZXMsIGxhc3QgYWN0aXZlIGluZGV4LCBhbmQgdHJpZ2dlciBhY3RpdmUgZXZlbnQgb25seSB3aGVuIHRoZXJlXG5cdFx0XHQvLyBoYXMgYmVlbiBhIGNoYW5nZS4gT3RoZXJ3aXNlIGp1c3QgcmV0dXJuIHRoZSBjdXJyZW50IGFjdGl2ZSBpbmRleC5cblx0XHRcdGlmIChsYXN0LmFjdGl2ZSAhPT0gaW5kZXggfHwgZm9yY2UpIHtcblx0XHRcdFx0Ly8gVXBkYXRlIGNsYXNzZXNcblx0XHRcdFx0JGl0ZW1zLmVxKHJlbC5hY3RpdmVJdGVtKS5yZW1vdmVDbGFzcyhvLmFjdGl2ZUNsYXNzKTtcblx0XHRcdFx0JGl0ZW1zLmVxKGluZGV4KS5hZGRDbGFzcyhvLmFjdGl2ZUNsYXNzKTtcblxuXHRcdFx0XHRsYXN0LmFjdGl2ZSA9IHJlbC5hY3RpdmVJdGVtID0gaW5kZXg7XG5cblx0XHRcdFx0dXBkYXRlQnV0dG9uc1N0YXRlKCk7XG5cdFx0XHRcdHRyaWdnZXIoJ2FjdGl2ZScsIGluZGV4KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGluZGV4O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEFjdGl2YXRlcyBhbiBpdGVtIGFuZCBoZWxwcyB3aXRoIGZ1cnRoZXIgbmF2aWdhdGlvbiB3aGVuIG8uc21hcnQgaXMgZW5hYmxlZC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7TWl4ZWR9IGl0ZW0gICAgICBJdGVtIERPTSBlbGVtZW50LCBvciBpbmRleCBzdGFydGluZyBhdCAwLlxuXHRcdCAqIEBwYXJhbSB7Qm9vbH0gIGltbWVkaWF0ZSBXaGV0aGVyIHRvIHJlcG9zaXRpb24gaW1tZWRpYXRlbHkgaW4gc21hcnQgbmF2aWdhdGlvbi5cblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge1ZvaWR9XG5cdFx0ICovXG5cdFx0c2VsZi5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtLCBpbW1lZGlhdGUpIHtcblx0XHRcdHZhciBpbmRleCA9IGFjdGl2YXRlKGl0ZW0pO1xuXG5cdFx0XHQvLyBTbWFydCBuYXZpZ2F0aW9uXG5cdFx0XHRpZiAoby5zbWFydCAmJiBpbmRleCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0Ly8gV2hlbiBjZW50ZXJlZE5hdiBpcyBlbmFibGVkLCBjZW50ZXIgdGhlIGVsZW1lbnQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgZGV0ZXJtaW5lIHdoZXJlIHRvIHBvc2l0aW9uIHRoZSBlbGVtZW50IGJhc2VkIG9uIGl0cyBjdXJyZW50IHBvc2l0aW9uLlxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBpcyBjdXJyZW50bHkgb24gdGhlIGZhciBlbmQgc2lkZSBvZiB0aGUgZnJhbWUsIGFzc3VtZSB0aGF0IHVzZXIgaXNcblx0XHRcdFx0Ly8gbW92aW5nIGZvcndhcmQgYW5kIGFuaW1hdGUgaXQgdG8gdGhlIHN0YXJ0IG9mIHRoZSB2aXNpYmxlIGZyYW1lLCBhbmQgdmljZSB2ZXJzYS5cblx0XHRcdFx0aWYgKGNlbnRlcmVkTmF2KSB7XG5cdFx0XHRcdFx0c2VsZi50b0NlbnRlcihpbmRleCwgaW1tZWRpYXRlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpbmRleCA+PSByZWwubGFzdEl0ZW0pIHtcblx0XHRcdFx0XHRzZWxmLnRvU3RhcnQoaW5kZXgsIGltbWVkaWF0ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggPD0gcmVsLmZpcnN0SXRlbSkge1xuXHRcdFx0XHRcdHNlbGYudG9FbmQoaW5kZXgsIGltbWVkaWF0ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzZXRDeWNsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFjdGl2YXRlcyBhIHBhZ2UuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0ludH0gIGluZGV4ICAgICBQYWdlIGluZGV4LCBzdGFydGluZyBmcm9tIDAuXG5cdFx0ICogQHBhcmFtIHtCb29sfSBpbW1lZGlhdGUgV2hldGhlciB0byByZXBvc2l0aW9uIGltbWVkaWF0ZWx5IHdpdGhvdXQgYW5pbWF0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRzZWxmLmFjdGl2YXRlUGFnZSA9IGZ1bmN0aW9uIChpbmRleCwgaW1tZWRpYXRlKSB7XG5cdFx0XHRpZiAoaXNOdW1iZXIoaW5kZXgpKSB7XG5cdFx0XHRcdHNsaWRlVG8ocGFnZXNbd2l0aGluKGluZGV4LCAwLCBwYWdlcy5sZW5ndGggLSAxKV0sIGltbWVkaWF0ZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiByZWxhdGl2ZSBwb3NpdGlvbnMgb2YgaXRlbXMgYmFzZWQgb24gdGhlaXIgdmlzaWJpbGl0eSB3aXRoaW4gRlJBTUUuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0ludH0gc2xpZGVlUG9zIFBvc2l0aW9uIG9mIFNMSURFRS5cblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge1ZvaWR9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZ2V0UmVsYXRpdmVzKHNsaWRlZVBvcykge1xuXHRcdFx0c2xpZGVlUG9zID0gd2l0aGluKGlzTnVtYmVyKHNsaWRlZVBvcykgPyBzbGlkZWVQb3MgOiBwb3MuZGVzdCwgcG9zLnN0YXJ0LCBwb3MuZW5kKTtcblxuXHRcdFx0dmFyIHJlbGF0aXZlcyA9IHt9O1xuXHRcdFx0dmFyIGNlbnRlck9mZnNldCA9IGZvcmNlQ2VudGVyZWROYXYgPyAwIDogZnJhbWVTaXplIC8gMjtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGFjdGl2ZSBwYWdlXG5cdFx0XHRpZiAoIXBhcmFsbGF4KSB7XG5cdFx0XHRcdGZvciAodmFyIHAgPSAwLCBwbCA9IHBhZ2VzLmxlbmd0aDsgcCA8IHBsOyBwKyspIHtcblx0XHRcdFx0XHRpZiAoc2xpZGVlUG9zID49IHBvcy5lbmQgfHwgcCA9PT0gcGFnZXMubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdFx0cmVsYXRpdmVzLmFjdGl2ZVBhZ2UgPSBwYWdlcy5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHNsaWRlZVBvcyA8PSBwYWdlc1twXSArIGNlbnRlck9mZnNldCkge1xuXHRcdFx0XHRcdFx0cmVsYXRpdmVzLmFjdGl2ZVBhZ2UgPSBwO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbGF0aXZlIGl0ZW0gaW5kZXhlc1xuXHRcdFx0aWYgKGl0ZW1OYXYpIHtcblx0XHRcdFx0dmFyIGZpcnN0ID0gZmFsc2U7XG5cdFx0XHRcdHZhciBsYXN0ID0gZmFsc2U7XG5cdFx0XHRcdHZhciBjZW50ZXIgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyBGcm9tIHN0YXJ0XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBpbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcblx0XHRcdFx0XHQvLyBGaXJzdCBpdGVtXG5cdFx0XHRcdFx0aWYgKGZpcnN0ID09PSBmYWxzZSAmJiBzbGlkZWVQb3MgPD0gaXRlbXNbaV0uc3RhcnQgKyBpdGVtc1tpXS5oYWxmKSB7XG5cdFx0XHRcdFx0XHRmaXJzdCA9IGk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQ2VudGVyIGl0ZW1cblx0XHRcdFx0XHRpZiAoY2VudGVyID09PSBmYWxzZSAmJiBzbGlkZWVQb3MgPD0gaXRlbXNbaV0uY2VudGVyICsgaXRlbXNbaV0uaGFsZikge1xuXHRcdFx0XHRcdFx0Y2VudGVyID0gaTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMYXN0IGl0ZW1cblx0XHRcdFx0XHRpZiAoaSA9PT0gaWwgLSAxIHx8IHNsaWRlZVBvcyA8PSBpdGVtc1tpXS5lbmQgKyBpdGVtc1tpXS5oYWxmKSB7XG5cdFx0XHRcdFx0XHRsYXN0ID0gaTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNhZmUgYXNzaWdubWVudCwganVzdCB0byBiZSBzdXJlIHRoZSBmYWxzZSB3b24ndCBiZSByZXR1cm5lZFxuXHRcdFx0XHRyZWxhdGl2ZXMuZmlyc3RJdGVtID0gaXNOdW1iZXIoZmlyc3QpID8gZmlyc3QgOiAwO1xuXHRcdFx0XHRyZWxhdGl2ZXMuY2VudGVySXRlbSA9IGlzTnVtYmVyKGNlbnRlcikgPyBjZW50ZXIgOiByZWxhdGl2ZXMuZmlyc3RJdGVtO1xuXHRcdFx0XHRyZWxhdGl2ZXMubGFzdEl0ZW0gPSBpc051bWJlcihsYXN0KSA/IGxhc3QgOiByZWxhdGl2ZXMuY2VudGVySXRlbTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlbGF0aXZlcztcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGUgb2JqZWN0IHdpdGggcmVsYXRpdmUgcG9zaXRpb25zLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtJbnR9IG5ld1Bvc1xuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiB1cGRhdGVSZWxhdGl2ZXMobmV3UG9zKSB7XG5cdFx0XHQkLmV4dGVuZChyZWwsIGdldFJlbGF0aXZlcyhuZXdQb3MpKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBEaXNhYmxlIG5hdmlnYXRpb24gYnV0dG9ucyB3aGVuIG5lZWRlZC5cblx0XHQgKlxuXHRcdCAqIEFkZHMgZGlzYWJsZWRDbGFzcywgYW5kIHdoZW4gdGhlIGJ1dHRvbiBpcyA8YnV0dG9uPiBvciA8aW5wdXQ+LCBhY3RpdmF0ZXMgOmRpc2FibGVkIHN0YXRlLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiB1cGRhdGVCdXR0b25zU3RhdGUoKSB7XG5cdFx0XHR2YXIgaXNTdGFydCA9IHBvcy5kZXN0IDw9IHBvcy5zdGFydDtcblx0XHRcdHZhciBpc0VuZCA9IHBvcy5kZXN0ID49IHBvcy5lbmQ7XG5cdFx0XHR2YXIgc2xpZGVlUG9zU3RhdGUgPSAoaXNTdGFydCA/IDEgOiAwKSB8IChpc0VuZCA/IDIgOiAwKTtcblxuXHRcdFx0Ly8gVXBkYXRlIHBhZ2luZyBidXR0b25zIG9ubHkgaWYgdGhlcmUgaGFzIGJlZW4gYSBjaGFuZ2UgaW4gU0xJREVFIHBvc2l0aW9uXG5cdFx0XHRpZiAobGFzdC5zbGlkZWVQb3NTdGF0ZSAhPT0gc2xpZGVlUG9zU3RhdGUpIHtcblx0XHRcdFx0bGFzdC5zbGlkZWVQb3NTdGF0ZSA9IHNsaWRlZVBvc1N0YXRlO1xuXG5cdFx0XHRcdGlmICgkcHJldlBhZ2VCdXR0b24uaXMoJ2J1dHRvbixpbnB1dCcpKSB7XG5cdFx0XHRcdFx0JHByZXZQYWdlQnV0dG9uLnByb3AoJ2Rpc2FibGVkJywgaXNTdGFydCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoJG5leHRQYWdlQnV0dG9uLmlzKCdidXR0b24saW5wdXQnKSkge1xuXHRcdFx0XHRcdCRuZXh0UGFnZUJ1dHRvbi5wcm9wKCdkaXNhYmxlZCcsIGlzRW5kKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdCRwcmV2UGFnZUJ1dHRvbi5hZGQoJGJhY2t3YXJkQnV0dG9uKVtpc1N0YXJ0ID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKG8uZGlzYWJsZWRDbGFzcyk7XG5cdFx0XHRcdCRuZXh0UGFnZUJ1dHRvbi5hZGQoJGZvcndhcmRCdXR0b24pW2lzRW5kID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKG8uZGlzYWJsZWRDbGFzcyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcndhcmQgJiBCYWNrd2FyZCBidXR0b25zIG5lZWQgYSBzZXBhcmF0ZSBzdGF0ZSBjYWNoaW5nIGJlY2F1c2Ugd2UgY2Fubm90IFwicHJvcGVydHkgZGlzYWJsZVwiXG5cdFx0XHQvLyB0aGVtIHdoaWxlIHRoZXkgYXJlIGJlaW5nIHVzZWQsIGFzIGRpc2FibGVkIGJ1dHRvbnMgc3RvcCBlbWl0dGluZyBtb3VzZSBldmVudHMuXG5cdFx0XHRpZiAobGFzdC5md2Rid2RTdGF0ZSAhPT0gc2xpZGVlUG9zU3RhdGUgJiYgZHJhZ2dpbmcucmVsZWFzZWQpIHtcblx0XHRcdFx0bGFzdC5md2Rid2RTdGF0ZSA9IHNsaWRlZVBvc1N0YXRlO1xuXG5cdFx0XHRcdGlmICgkYmFja3dhcmRCdXR0b24uaXMoJ2J1dHRvbixpbnB1dCcpKSB7XG5cdFx0XHRcdFx0JGJhY2t3YXJkQnV0dG9uLnByb3AoJ2Rpc2FibGVkJywgaXNTdGFydCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoJGZvcndhcmRCdXR0b24uaXMoJ2J1dHRvbixpbnB1dCcpKSB7XG5cdFx0XHRcdFx0JGZvcndhcmRCdXR0b24ucHJvcCgnZGlzYWJsZWQnLCBpc0VuZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSXRlbSBuYXZpZ2F0aW9uXG5cdFx0XHRpZiAoaXRlbU5hdiAmJiByZWwuYWN0aXZlSXRlbSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBpc0ZpcnN0ID0gcmVsLmFjdGl2ZUl0ZW0gPT09IDA7XG5cdFx0XHRcdHZhciBpc0xhc3QgPSByZWwuYWN0aXZlSXRlbSA+PSBpdGVtcy5sZW5ndGggLSAxO1xuXHRcdFx0XHR2YXIgaXRlbXNCdXR0b25TdGF0ZSA9IChpc0ZpcnN0ID8gMSA6IDApIHwgKGlzTGFzdCA/IDIgOiAwKTtcblxuXHRcdFx0XHRpZiAobGFzdC5pdGVtc0J1dHRvblN0YXRlICE9PSBpdGVtc0J1dHRvblN0YXRlKSB7XG5cdFx0XHRcdFx0bGFzdC5pdGVtc0J1dHRvblN0YXRlID0gaXRlbXNCdXR0b25TdGF0ZTtcblxuXHRcdFx0XHRcdGlmICgkcHJldkJ1dHRvbi5pcygnYnV0dG9uLGlucHV0JykpIHtcblx0XHRcdFx0XHRcdCRwcmV2QnV0dG9uLnByb3AoJ2Rpc2FibGVkJywgaXNGaXJzdCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCRuZXh0QnV0dG9uLmlzKCdidXR0b24saW5wdXQnKSkge1xuXHRcdFx0XHRcdFx0JG5leHRCdXR0b24ucHJvcCgnZGlzYWJsZWQnLCBpc0xhc3QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCRwcmV2QnV0dG9uW2lzRmlyc3QgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oby5kaXNhYmxlZENsYXNzKTtcblx0XHRcdFx0XHQkbmV4dEJ1dHRvbltpc0xhc3QgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oby5kaXNhYmxlZENsYXNzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJlc3VtZSBjeWNsaW5nLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtJbnR9IHByaW9yaXR5IFJlc3VtZSBwYXVzZSB3aXRoIHByaW9yaXR5IGxvd2VyIG9yIGVxdWFsIHRoYW4gdGhpcy4gVXNlZCBpbnRlcm5hbGx5IGZvciBwYXVzZU9uSG92ZXIuXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdHNlbGYucmVzdW1lID0gZnVuY3Rpb24gKHByaW9yaXR5KSB7XG5cdFx0XHRpZiAoIW8uY3ljbGVCeSB8fCAhby5jeWNsZUludGVydmFsIHx8IG8uY3ljbGVCeSA9PT0gJ2l0ZW1zJyAmJiAoIWl0ZW1zWzBdIHx8IHJlbC5hY3RpdmVJdGVtID09IG51bGwpIHx8IHByaW9yaXR5IDwgc2VsZi5pc1BhdXNlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHNlbGYuaXNQYXVzZWQgPSAwO1xuXG5cdFx0XHRpZiAoY3ljbGVJRCkge1xuXHRcdFx0XHRjeWNsZUlEID0gY2xlYXJUaW1lb3V0KGN5Y2xlSUQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHJpZ2dlcigncmVzdW1lJyk7XG5cdFx0XHR9XG5cblx0XHRcdGN5Y2xlSUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dHJpZ2dlcignY3ljbGUnKTtcblx0XHRcdFx0c3dpdGNoIChvLmN5Y2xlQnkpIHtcblx0XHRcdFx0XHRjYXNlICdpdGVtcyc6XG5cdFx0XHRcdFx0XHRzZWxmLmFjdGl2YXRlKHJlbC5hY3RpdmVJdGVtID49IGl0ZW1zLmxlbmd0aCAtIDEgPyAwIDogcmVsLmFjdGl2ZUl0ZW0gKyAxKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncGFnZXMnOlxuXHRcdFx0XHRcdFx0c2VsZi5hY3RpdmF0ZVBhZ2UocmVsLmFjdGl2ZVBhZ2UgPj0gcGFnZXMubGVuZ3RoIC0gMSA/IDAgOiByZWwuYWN0aXZlUGFnZSArIDEpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH0sIG8uY3ljbGVJbnRlcnZhbCk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFBhdXNlIGN5Y2xpbmcuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0ludH0gcHJpb3JpdHkgUGF1c2UgcHJpb3JpdHkuIDEwMCBpcyBkZWZhdWx0LiBVc2VkIGludGVybmFsbHkgZm9yIHBhdXNlT25Ib3Zlci5cblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge1ZvaWR9XG5cdFx0ICovXG5cdFx0c2VsZi5wYXVzZSA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xuXHRcdFx0aWYgKHByaW9yaXR5IDwgc2VsZi5pc1BhdXNlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHNlbGYuaXNQYXVzZWQgPSBwcmlvcml0eSB8fCAxMDA7XG5cblx0XHRcdGlmIChjeWNsZUlEKSB7XG5cdFx0XHRcdGN5Y2xlSUQgPSBjbGVhclRpbWVvdXQoY3ljbGVJRCk7XG5cdFx0XHRcdHRyaWdnZXIoJ3BhdXNlJyk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFRvZ2dsZSBjeWNsaW5nLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRzZWxmLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHNlbGZbY3ljbGVJRCA/ICdwYXVzZScgOiAncmVzdW1lJ10oKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyBhIHNpZ25sZSBvciBtdWx0aXBsZSBvcHRpb24gdmFsdWVzLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtNaXhlZH0gbmFtZSAgTmFtZSBvZiB0aGUgb3B0aW9uIHRoYXQgc2hvdWxkIGJlIHVwZGF0ZWQsIG9yIG9iamVjdCB0aGF0IHdpbGwgZXh0ZW5kIHRoZSBvcHRpb25zLlxuXHRcdCAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIE5ldyBvcHRpb24gdmFsdWUuXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdHNlbGYuc2V0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRpZiAoJC5pc1BsYWluT2JqZWN0KG5hbWUpKSB7XG5cdFx0XHRcdCQuZXh0ZW5kKG8sIG5hbWUpO1xuXHRcdFx0fSBlbHNlIGlmIChvLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRcdG9bbmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQWRkIG9uZSBvciBtdWx0aXBsZSBpdGVtcyB0byB0aGUgU0xJREVFIGVuZCwgb3IgYSBzcGVjaWZpZWQgcG9zaXRpb24gaW5kZXguXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge01peGVkfSBlbGVtZW50IE5vZGUgZWxlbWVudCwgb3IgSFRNTCBzdHJpbmcuXG5cdFx0ICogQHBhcmFtIHtJbnR9ICAgaW5kZXggICBJbmRleCBvZiBhIG5ldyBpdGVtIHBvc2l0aW9uLiBCeSBkZWZhdWx0IGl0ZW0gaXMgYXBwZW5kZWQgYXQgdGhlIGVuZC5cblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge1ZvaWR9XG5cdFx0ICovXG5cdFx0c2VsZi5hZGQgPSBmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcblx0XHRcdHZhciAkZWxlbWVudCA9ICQoZWxlbWVudCk7XG5cblx0XHRcdGlmIChpdGVtTmF2KSB7XG5cdFx0XHRcdC8vIEluc2VydCB0aGUgZWxlbWVudChzKVxuXHRcdFx0XHRpZiAoaW5kZXggPT0gbnVsbCB8fCAhaXRlbXNbMF0gfHwgaW5kZXggPj0gaXRlbXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0JGVsZW1lbnQuYXBwZW5kVG8oJHNsaWRlZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXRlbXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0JGVsZW1lbnQuaW5zZXJ0QmVmb3JlKGl0ZW1zW2luZGV4XS5lbCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGp1c3QgdGhlIGFjdGl2ZUl0ZW0gaW5kZXhcblx0XHRcdFx0aWYgKHJlbC5hY3RpdmVJdGVtICE9IG51bGwgJiYgaW5kZXggPD0gcmVsLmFjdGl2ZUl0ZW0pIHtcblx0XHRcdFx0XHRsYXN0LmFjdGl2ZSA9IHJlbC5hY3RpdmVJdGVtICs9ICRlbGVtZW50Lmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JHNsaWRlZS5hcHBlbmQoJGVsZW1lbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZWxvYWRcblx0XHRcdGxvYWQoKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBTTElERUUuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge01peGVkfSBlbGVtZW50IEl0ZW0gaW5kZXgsIG9yIERPTSBlbGVtZW50LlxuXHRcdCAqIEBwYXJhbSB7SW50fSAgIGluZGV4ICAgSW5kZXggb2YgYSBuZXcgaXRlbSBwb3NpdGlvbi4gQnkgZGVmYXVsdCBpdGVtIGlzIGFwcGVuZGVkIGF0IHRoZSBlbmQuXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdHNlbGYucmVtb3ZlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdGlmIChpdGVtTmF2KSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IGdldFJlbGF0aXZlSW5kZXgoZWxlbWVudCk7XG5cblx0XHRcdFx0aWYgKGluZGV4ID4gLTEpIHtcblx0XHRcdFx0XHQvLyBSZW1vdmUgdGhlIGVsZW1lbnRcblx0XHRcdFx0XHQkaXRlbXMuZXEoaW5kZXgpLnJlbW92ZSgpO1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGN1cnJlbnQgaXRlbSBpcyBiZWluZyByZW1vdmVkLCBhY3RpdmF0ZSBuZXcgb25lIGFmdGVyIHJlbG9hZFxuXHRcdFx0XHRcdHZhciByZWFjdGl2YXRlID0gaW5kZXggPT09IHJlbC5hY3RpdmVJdGVtO1xuXG5cdFx0XHRcdFx0Ly8gQWRqdXN0IHRoZSBhY3RpdmVJdGVtIGluZGV4XG5cdFx0XHRcdFx0aWYgKHJlbC5hY3RpdmVJdGVtICE9IG51bGwgJiYgaW5kZXggPCByZWwuYWN0aXZlSXRlbSkge1xuXHRcdFx0XHRcdFx0bGFzdC5hY3RpdmUgPSAtLXJlbC5hY3RpdmVJdGVtO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlbG9hZFxuXHRcdFx0XHRcdGxvYWQoKTtcblxuXHRcdFx0XHRcdC8vIEFjdGl2YXRlIG5ldyBpdGVtIGF0IHRoZSByZW1vdmVkIHBvc2l0aW9uXG5cdFx0XHRcdFx0aWYgKHJlYWN0aXZhdGUpIHtcblx0XHRcdFx0XHRcdGxhc3QuYWN0aXZlID0gbnVsbDtcblx0XHRcdFx0XHRcdHNlbGYuYWN0aXZhdGUocmVsLmFjdGl2ZUl0ZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JChlbGVtZW50KS5yZW1vdmUoKTtcblx0XHRcdFx0bG9hZCgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIZWxwcyByZS1hcnJhbmdpbmcgaXRlbXMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0gIHtNaXhlZH0gaXRlbSAgICAgSXRlbSBET00gZWxlbWVudCwgb3IgaW5kZXggc3RhcnRpbmcgYXQgMC4gVXNlIG5lZ2F0aXZlIG51bWJlcnMgdG8gc2VsZWN0IGl0ZW1zIGZyb20gdGhlIGVuZC5cblx0XHQgKiBAcGFyYW0gIHtNaXhlZH0gcG9zaXRpb24gSXRlbSBpbnNlcnRpb24gYW5jaG9yLiBBY2NlcHRzIHNhbWUgaW5wdXQgdHlwZXMgYXMgaXRlbSBhcmd1bWVudC5cblx0XHQgKiBAcGFyYW0gIHtCb29sfSAgYWZ0ZXIgICAgSW5zZXJ0IGFmdGVyIGluc3RlYWQgb2YgYmVmb3JlIHRoZSBhbmNob3IuXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIG1vdmVJdGVtKGl0ZW0sIHBvc2l0aW9uLCBhZnRlcikge1xuXHRcdFx0aXRlbSA9IGdldFJlbGF0aXZlSW5kZXgoaXRlbSk7XG5cdFx0XHRwb3NpdGlvbiA9IGdldFJlbGF0aXZlSW5kZXgocG9zaXRpb24pO1xuXG5cdFx0XHQvLyBNb3ZlIG9ubHkgaWYgdGhlcmUgaXMgYW4gYWN0dWFsIGNoYW5nZSByZXF1ZXN0ZWRcblx0XHRcdGlmIChpdGVtID4gLTEgJiYgcG9zaXRpb24gPiAtMSAmJiBpdGVtICE9PSBwb3NpdGlvbiAmJiAoIWFmdGVyIHx8IHBvc2l0aW9uICE9PSBpdGVtIC0gMSkgJiYgKGFmdGVyIHx8IHBvc2l0aW9uICE9PSBpdGVtICsgMSkpIHtcblx0XHRcdFx0JGl0ZW1zLmVxKGl0ZW0pW2FmdGVyID8gJ2luc2VydEFmdGVyJyA6ICdpbnNlcnRCZWZvcmUnXShpdGVtc1twb3NpdGlvbl0uZWwpO1xuXG5cdFx0XHRcdHZhciBzaGlmdFN0YXJ0ID0gaXRlbSA8IHBvc2l0aW9uID8gaXRlbSA6IChhZnRlciA/IHBvc2l0aW9uIDogcG9zaXRpb24gLSAxKTtcblx0XHRcdFx0dmFyIHNoaWZ0RW5kID0gaXRlbSA+IHBvc2l0aW9uID8gaXRlbSA6IChhZnRlciA/IHBvc2l0aW9uICsgMSA6IHBvc2l0aW9uKTtcblx0XHRcdFx0dmFyIHNoaWZ0c1VwID0gaXRlbSA+IHBvc2l0aW9uO1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSBhY3RpdmVJdGVtIGluZGV4XG5cdFx0XHRcdGlmIChyZWwuYWN0aXZlSXRlbSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKGl0ZW0gPT09IHJlbC5hY3RpdmVJdGVtKSB7XG5cdFx0XHRcdFx0XHRsYXN0LmFjdGl2ZSA9IHJlbC5hY3RpdmVJdGVtID0gYWZ0ZXIgPyAoc2hpZnRzVXAgPyBwb3NpdGlvbiArIDEgOiBwb3NpdGlvbikgOiAoc2hpZnRzVXAgPyBwb3NpdGlvbiA6IHBvc2l0aW9uIC0gMSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChyZWwuYWN0aXZlSXRlbSA+IHNoaWZ0U3RhcnQgJiYgcmVsLmFjdGl2ZUl0ZW0gPCBzaGlmdEVuZCkge1xuXHRcdFx0XHRcdFx0bGFzdC5hY3RpdmUgPSByZWwuYWN0aXZlSXRlbSArPSBzaGlmdHNVcCA/IDEgOiAtMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWxvYWRcblx0XHRcdFx0bG9hZCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIE1vdmUgaXRlbSBhZnRlciB0aGUgdGFyZ2V0IGFuY2hvci5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSAge01peGVkfSBpdGVtICAgICBJdGVtIHRvIGJlIG1vdmVkLiBDYW4gYmUgRE9NIGVsZW1lbnQgb3IgaXRlbSBpbmRleC5cblx0XHQgKiBAcGFyYW0gIHtNaXhlZH0gcG9zaXRpb24gVGFyZ2V0IHBvc2l0aW9uIGFuY2hvci4gQ2FuIGJlIERPTSBlbGVtZW50IG9yIGl0ZW0gaW5kZXguXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdHNlbGYubW92ZUFmdGVyID0gZnVuY3Rpb24gKGl0ZW0sIHBvc2l0aW9uKSB7XG5cdFx0XHRtb3ZlSXRlbShpdGVtLCBwb3NpdGlvbiwgMSk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIE1vdmUgaXRlbSBiZWZvcmUgdGhlIHRhcmdldCBhbmNob3IuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0gIHtNaXhlZH0gaXRlbSAgICAgSXRlbSB0byBiZSBtb3ZlZC4gQ2FuIGJlIERPTSBlbGVtZW50IG9yIGl0ZW0gaW5kZXguXG5cdFx0ICogQHBhcmFtICB7TWl4ZWR9IHBvc2l0aW9uIFRhcmdldCBwb3NpdGlvbiBhbmNob3IuIENhbiBiZSBET00gZWxlbWVudCBvciBpdGVtIGluZGV4LlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRzZWxmLm1vdmVCZWZvcmUgPSBmdW5jdGlvbiAoaXRlbSwgcG9zaXRpb24pIHtcblx0XHRcdG1vdmVJdGVtKGl0ZW0sIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXJzIGNhbGxiYWNrcy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSAge01peGVkfSBuYW1lICBFdmVudCBuYW1lLCBvciBjYWxsYmFja3MgbWFwLlxuXHRcdCAqIEBwYXJhbSAge01peGVkfSBmbiAgICBDYWxsYmFjaywgb3IgYW4gYXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRzZWxmLm9uID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG5cdFx0XHQvLyBDYWxsYmFja3MgbWFwXG5cdFx0XHRpZiAodHlwZShuYW1lKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG5hbWUpIHtcblx0XHRcdFx0XHRpZiAobmFtZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0XHRzZWxmLm9uKGtleSwgbmFtZVtrZXldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUoZm4pID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHZhciBuYW1lcyA9IG5hbWUuc3BsaXQoJyAnKTtcblx0XHRcdFx0Zm9yICh2YXIgbiA9IDAsIG5sID0gbmFtZXMubGVuZ3RoOyBuIDwgbmw7IG4rKykge1xuXHRcdFx0XHRcdGNhbGxiYWNrc1tuYW1lc1tuXV0gPSBjYWxsYmFja3NbbmFtZXNbbl1dIHx8IFtdO1xuXHRcdFx0XHRcdGlmIChjYWxsYmFja0luZGV4KG5hbWVzW25dLCBmbikgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFja3NbbmFtZXNbbl1dLnB1c2goZm4pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGFycmF5XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUoZm4pID09PSAnYXJyYXknKSB7XG5cdFx0XHRcdGZvciAodmFyIGYgPSAwLCBmbCA9IGZuLmxlbmd0aDsgZiA8IGZsOyBmKyspIHtcblx0XHRcdFx0XHRzZWxmLm9uKG5hbWUsIGZuW2ZdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIHRvIGJlIGV4ZWN1dGVkIG9ubHkgb25jZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSAge01peGVkfSBuYW1lICBFdmVudCBuYW1lLCBvciBjYWxsYmFja3MgbWFwLlxuXHRcdCAqIEBwYXJhbSAge01peGVkfSBmbiAgICBDYWxsYmFjaywgb3IgYW4gYXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRzZWxmLm9uZSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuXHRcdFx0ZnVuY3Rpb24gcHJveHkoKSB7XG5cdFx0XHRcdGZuLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdHNlbGYub2ZmKG5hbWUsIHByb3h5KTtcblx0XHRcdH1cblx0XHRcdHNlbGYub24obmFtZSwgcHJveHkpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmUgb25lIG9yIGFsbCBjYWxsYmFja3MuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgRXZlbnQgbmFtZS5cblx0XHQgKiBAcGFyYW0gIHtNaXhlZH0gIGZuICAgQ2FsbGJhY2ssIG9yIGFuIGFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucy4gT21pdCB0byByZW1vdmUgYWxsIGNhbGxiYWNrcy5cblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge1ZvaWR9XG5cdFx0ICovXG5cdFx0c2VsZi5vZmYgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcblx0XHRcdGlmIChmbiBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdGZvciAodmFyIGYgPSAwLCBmbCA9IGZuLmxlbmd0aDsgZiA8IGZsOyBmKyspIHtcblx0XHRcdFx0XHRzZWxmLm9mZihuYW1lLCBmbltmXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBuYW1lcyA9IG5hbWUuc3BsaXQoJyAnKTtcblx0XHRcdFx0Zm9yICh2YXIgbiA9IDAsIG5sID0gbmFtZXMubGVuZ3RoOyBuIDwgbmw7IG4rKykge1xuXHRcdFx0XHRcdGNhbGxiYWNrc1tuYW1lc1tuXV0gPSBjYWxsYmFja3NbbmFtZXNbbl1dIHx8IFtdO1xuXHRcdFx0XHRcdGlmIChmbiA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFja3NbbmFtZXNbbl1dLmxlbmd0aCA9IDA7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBpbmRleCA9IGNhbGxiYWNrSW5kZXgobmFtZXNbbl0sIGZuKTtcblx0XHRcdFx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2tzW25hbWVzW25dXS5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGNhbGxiYWNrIGFycmF5IGluZGV4LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSAgIG5hbWUgRXZlbnQgbmFtZS5cblx0XHQgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICBGdW5jdGlvblxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7SW50fSBDYWxsYmFjayBhcnJheSBpbmRleCwgb3IgLTEgaWYgaXNuJ3QgcmVnaXN0ZXJlZC5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBjYWxsYmFja0luZGV4KG5hbWUsIGZuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrc1tuYW1lXS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aWYgKGNhbGxiYWNrc1tuYW1lXVtpXSA9PT0gZm4pIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJlc2V0IG5leHQgY3ljbGUgdGltZW91dC5cblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge1ZvaWR9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcmVzZXRDeWNsZSgpIHtcblx0XHRcdGlmIChkcmFnZ2luZy5yZWxlYXNlZCAmJiAhc2VsZi5pc1BhdXNlZCkge1xuXHRcdFx0XHRzZWxmLnJlc3VtZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIENhbGN1bGF0ZSBTTElERUUgcmVwcmVzZW50YXRpb24gb2YgaGFuZGxlIHBvc2l0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtICB7SW50fSBoYW5kbGVQb3Ncblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge0ludH1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBoYW5kbGVUb1NsaWRlZShoYW5kbGVQb3MpIHtcblx0XHRcdHJldHVybiByb3VuZCh3aXRoaW4oaGFuZGxlUG9zLCBoUG9zLnN0YXJ0LCBoUG9zLmVuZCkgLyBoUG9zLmVuZCAqIChwb3MuZW5kIC0gcG9zLnN0YXJ0KSkgKyBwb3Muc3RhcnQ7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogS2VlcHMgdHJhY2sgb2YgYSBkcmFnZ2luZyBkZWx0YSBoaXN0b3J5LlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBkcmFnZ2luZ0hpc3RvcnlUaWNrKCkge1xuXHRcdFx0Ly8gTG9va2luZyBhdCB0aGlzLCBJIGtub3cgd2hhdCB5b3UncmUgdGhpbmtpbmcgOikgQnV0IGFzIHdlIG5lZWQgb25seSA0IGhpc3Rvcnkgc3RhdGVzLCBkb2luZyBpdCB0aGlzIHdheVxuXHRcdFx0Ly8gYXMgb3Bwb3NlZCB0byBhIHByb3BlciBsb29wIGlzIH4yNSBieXRlcyBzbWFsbGVyICh3aGVuIG1pbmlmaWVkIHdpdGggR0NDKSwgYSBsb3QgZmFzdGVyLCBhbmQgZG9lc24ndFxuXHRcdFx0Ly8gZ2VuZXJhdGUgZ2FyYmFnZS4gVGhlIGxvb3AgdmVyc2lvbiB3b3VsZCBjcmVhdGUgMiBuZXcgdmFyaWFibGVzIG9uIGV2ZXJ5IHRpY2suIFVuZXhhcHRhYmxlIVxuXHRcdFx0ZHJhZ2dpbmcuaGlzdG9yeVswXSA9IGRyYWdnaW5nLmhpc3RvcnlbMV07XG5cdFx0XHRkcmFnZ2luZy5oaXN0b3J5WzFdID0gZHJhZ2dpbmcuaGlzdG9yeVsyXTtcblx0XHRcdGRyYWdnaW5nLmhpc3RvcnlbMl0gPSBkcmFnZ2luZy5oaXN0b3J5WzNdO1xuXHRcdFx0ZHJhZ2dpbmcuaGlzdG9yeVszXSA9IGRyYWdnaW5nLmRlbHRhO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemUgY29udGludW91cyBtb3ZlbWVudC5cblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge1ZvaWR9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gY29udGludW91c0luaXQoc291cmNlKSB7XG5cdFx0XHRkcmFnZ2luZy5yZWxlYXNlZCA9IDA7XG5cdFx0XHRkcmFnZ2luZy5zb3VyY2UgPSBzb3VyY2U7XG5cdFx0XHRkcmFnZ2luZy5zbGlkZWUgPSBzb3VyY2UgPT09ICdzbGlkZWUnO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIERyYWdnaW5nIGluaXRpYXRvci5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSAge0V2ZW50fSBldmVudFxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBkcmFnSW5pdChldmVudCkge1xuXHRcdFx0dmFyIGlzVG91Y2ggPSBldmVudC50eXBlID09PSAndG91Y2hzdGFydCc7XG5cdFx0XHR2YXIgc291cmNlID0gZXZlbnQuZGF0YS5zb3VyY2U7XG5cdFx0XHR2YXIgaXNTbGlkZWUgPSBzb3VyY2UgPT09ICdzbGlkZWUnO1xuXG5cdFx0XHQvLyBJZ25vcmUgd2hlbiBhbHJlYWR5IGluIHByb2dyZXNzLCBvciBpbnRlcmFjdGl2ZSBlbGVtZW50IGluIG5vbi10b3VjaCBuYXZpdmFnaW9uXG5cdFx0XHRpZiAoZHJhZ2dpbmcuaW5pdCB8fCAhaXNUb3VjaCAmJiBpc0ludGVyYWN0aXZlKGV2ZW50LnRhcmdldCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYW5kbGUgZHJhZ2dpbmcgY29uZGl0aW9uc1xuXHRcdFx0aWYgKHNvdXJjZSA9PT0gJ2hhbmRsZScgJiYgKCFvLmRyYWdIYW5kbGUgfHwgaFBvcy5zdGFydCA9PT0gaFBvcy5lbmQpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU0xJREVFIGRyYWdnaW5nIGNvbmRpdGlvbnNcblx0XHRcdGlmIChpc1NsaWRlZSAmJiAhKGlzVG91Y2ggPyBvLnRvdWNoRHJhZ2dpbmcgOiBvLm1vdXNlRHJhZ2dpbmcgJiYgZXZlbnQud2hpY2ggPCAyKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaXNUb3VjaCkge1xuXHRcdFx0XHQvLyBwcmV2ZW50cyBuYXRpdmUgaW1hZ2UgZHJhZ2dpbmcgaW4gRmlyZWZveFxuXHRcdFx0XHRzdG9wRGVmYXVsdChldmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc2V0IGRyYWdnaW5nIG9iamVjdFxuXHRcdFx0Y29udGludW91c0luaXQoc291cmNlKTtcblxuXHRcdFx0Ly8gUHJvcGVydGllcyB1c2VkIGluIGRyYWdIYW5kbGVyXG5cdFx0XHRkcmFnZ2luZy5pbml0ID0gMDtcblx0XHRcdGRyYWdnaW5nLiRzb3VyY2UgPSAkKGV2ZW50LnRhcmdldCk7XG5cdFx0XHRkcmFnZ2luZy50b3VjaCA9IGlzVG91Y2g7XG5cdFx0XHRkcmFnZ2luZy5wb2ludGVyID0gaXNUb3VjaCA/IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXSA6IGV2ZW50O1xuXHRcdFx0ZHJhZ2dpbmcuaW5pdFggPSBkcmFnZ2luZy5wb2ludGVyLnBhZ2VYO1xuXHRcdFx0ZHJhZ2dpbmcuaW5pdFkgPSBkcmFnZ2luZy5wb2ludGVyLnBhZ2VZO1xuXHRcdFx0ZHJhZ2dpbmcuaW5pdFBvcyA9IGlzU2xpZGVlID8gcG9zLmN1ciA6IGhQb3MuY3VyO1xuXHRcdFx0ZHJhZ2dpbmcuc3RhcnQgPSArbmV3IERhdGUoKTtcblx0XHRcdGRyYWdnaW5nLnRpbWUgPSAwO1xuXHRcdFx0ZHJhZ2dpbmcucGF0aCA9IDA7XG5cdFx0XHRkcmFnZ2luZy5kZWx0YSA9IDA7XG5cdFx0XHRkcmFnZ2luZy5sb2NrZWQgPSAwO1xuXHRcdFx0ZHJhZ2dpbmcuaGlzdG9yeSA9IFswLCAwLCAwLCAwXTtcblx0XHRcdGRyYWdnaW5nLnBhdGhUb0xvY2sgPSBpc1NsaWRlZSA/IGlzVG91Y2ggPyAzMCA6IDEwIDogMDtcblxuXHRcdFx0Ly8gQmluZCBkcmFnZ2luZyBldmVudHNcblx0XHRcdCRkb2Mub24oaXNUb3VjaCA/IGRyYWdUb3VjaEV2ZW50cyA6IGRyYWdNb3VzZUV2ZW50cywgZHJhZ0hhbmRsZXIpO1xuXG5cdFx0XHQvLyBQYXVzZSBvbmdvaW5nIGN5Y2xlXG5cdFx0XHRzZWxmLnBhdXNlKDEpO1xuXG5cdFx0XHQvLyBBZGQgZHJhZ2dpbmcgY2xhc3Ncblx0XHRcdChpc1NsaWRlZSA/ICRzbGlkZWUgOiAkaGFuZGxlKS5hZGRDbGFzcyhvLmRyYWdnZWRDbGFzcyk7XG5cblx0XHRcdC8vIFRyaWdnZXIgbW92ZVN0YXJ0IGV2ZW50XG5cdFx0XHR0cmlnZ2VyKCdtb3ZlU3RhcnQnKTtcblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiBhIGRyYWdnaW5nIHBhdGggaGlzdG9yeS4gVGhpcyBpcyBsYXRlciB1c2VkIGluIHRoZVxuXHRcdFx0Ly8gZHJhZ2dpbmcgcmVsZWFzZSBzd2luZyBjYWxjdWxhdGlvbiB3aGVuIGRyYWdnaW5nIFNMSURFRS5cblx0XHRcdGlmIChpc1NsaWRlZSkge1xuXHRcdFx0XHRoaXN0b3J5SUQgPSBzZXRJbnRlcnZhbChkcmFnZ2luZ0hpc3RvcnlUaWNrLCAxMCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciBmb3IgZHJhZ2dpbmcgc2Nyb2xsYmFyIGhhbmRsZSBvciBTTElERUUuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0gIHtFdmVudH0gZXZlbnRcblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge1ZvaWR9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZHJhZ0hhbmRsZXIoZXZlbnQpIHtcblx0XHRcdGRyYWdnaW5nLnJlbGVhc2VkID0gZXZlbnQudHlwZSA9PT0gJ21vdXNldXAnIHx8IGV2ZW50LnR5cGUgPT09ICd0b3VjaGVuZCc7XG5cdFx0XHRkcmFnZ2luZy5wb2ludGVyID0gZHJhZ2dpbmcudG91Y2ggPyBldmVudC5vcmlnaW5hbEV2ZW50W2RyYWdnaW5nLnJlbGVhc2VkID8gJ2NoYW5nZWRUb3VjaGVzJyA6ICd0b3VjaGVzJ11bMF0gOiBldmVudDtcblx0XHRcdGRyYWdnaW5nLnBhdGhYID0gZHJhZ2dpbmcucG9pbnRlci5wYWdlWCAtIGRyYWdnaW5nLmluaXRYO1xuXHRcdFx0ZHJhZ2dpbmcucGF0aFkgPSBkcmFnZ2luZy5wb2ludGVyLnBhZ2VZIC0gZHJhZ2dpbmcuaW5pdFk7XG5cdFx0XHRkcmFnZ2luZy5wYXRoID0gc3FydChwb3coZHJhZ2dpbmcucGF0aFgsIDIpICsgcG93KGRyYWdnaW5nLnBhdGhZLCAyKSk7XG5cdFx0XHRkcmFnZ2luZy5kZWx0YSA9IG8uaG9yaXpvbnRhbCA/IGRyYWdnaW5nLnBhdGhYIDogZHJhZ2dpbmcucGF0aFk7XG5cblx0XHRcdGlmICghZHJhZ2dpbmcucmVsZWFzZWQgJiYgZHJhZ2dpbmcucGF0aCA8IDEpIHJldHVybjtcblxuXHRcdFx0Ly8gV2UgaGF2ZW4ndCBkZWNpZGVkIHdoZXRoZXIgdGhpcyBpcyBhIGRyYWcgb3Igbm90Li4uXG5cdFx0XHRpZiAoIWRyYWdnaW5nLmluaXQpIHtcblx0XHRcdFx0Ly8gSWYgdGhlIGRyYWcgcGF0aCB3YXMgdmVyeSBzaG9ydCwgbWF5YmUgaXQncyBub3QgYSBkcmFnP1xuXHRcdFx0XHRpZiAoZHJhZ2dpbmcucGF0aCA8IG8uZHJhZ1RocmVzaG9sZCkge1xuXHRcdFx0XHRcdC8vIElmIHRoZSBwb2ludGVyIHdhcyByZWxlYXNlZCwgdGhlIHBhdGggd2lsbCBub3QgYmVjb21lIGxvbmdlciBhbmQgaXQnc1xuXHRcdFx0XHRcdC8vIGRlZmluaXRlbHkgbm90IGEgZHJhZy4gSWYgbm90IHJlbGVhc2VkIHlldCwgZGVjaWRlIG9uIG5leHQgaXRlcmF0aW9uXG5cdFx0XHRcdFx0cmV0dXJuIGRyYWdnaW5nLnJlbGVhc2VkID8gZHJhZ0VuZCgpIDogdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIElmIGRyYWdnaW5nIHBhdGggaXMgc3VmZmljaWVudGx5IGxvbmcgd2UgY2FuIGNvbmZpZGVudGx5IHN0YXJ0IGEgZHJhZ1xuXHRcdFx0XHRcdC8vIGlmIGRyYWcgaXMgaW4gZGlmZmVyZW50IGRpcmVjdGlvbiB0aGFuIHNjcm9sbCwgaWdub3JlIGl0XG5cdFx0XHRcdFx0aWYgKG8uaG9yaXpvbnRhbCA/IGFicyhkcmFnZ2luZy5wYXRoWCkgPiBhYnMoZHJhZ2dpbmcucGF0aFkpIDogYWJzKGRyYWdnaW5nLnBhdGhYKSA8IGFicyhkcmFnZ2luZy5wYXRoWSkpIHtcblx0XHRcdFx0XHRcdGRyYWdnaW5nLmluaXQgPSAxO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZHJhZ0VuZCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRzdG9wRGVmYXVsdChldmVudCk7XG5cblx0XHRcdC8vIERpc2FibGUgY2xpY2sgb24gYSBzb3VyY2UgZWxlbWVudCwgYXMgaXQgaXMgdW53ZWxjb21lIHdoZW4gZHJhZ2dpbmdcblx0XHRcdGlmICghZHJhZ2dpbmcubG9ja2VkICYmIGRyYWdnaW5nLnBhdGggPiBkcmFnZ2luZy5wYXRoVG9Mb2NrICYmIGRyYWdnaW5nLnNsaWRlZSkge1xuXHRcdFx0XHRkcmFnZ2luZy5sb2NrZWQgPSAxO1xuXHRcdFx0XHRkcmFnZ2luZy4kc291cmNlLm9uKGNsaWNrRXZlbnQsIGRpc2FibGVPbmVFdmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbmNlbCBkcmFnZ2luZyBvbiByZWxlYXNlXG5cdFx0XHRpZiAoZHJhZ2dpbmcucmVsZWFzZWQpIHtcblx0XHRcdFx0ZHJhZ0VuZCgpO1xuXG5cdFx0XHRcdC8vIEFkanVzdCBwYXRoIHdpdGggYSBzd2luZyBvbiBtb3VzZSByZWxlYXNlXG5cdFx0XHRcdGlmIChvLnJlbGVhc2VTd2luZyAmJiBkcmFnZ2luZy5zbGlkZWUpIHtcblx0XHRcdFx0XHRkcmFnZ2luZy5zd2luZyA9IChkcmFnZ2luZy5kZWx0YSAtIGRyYWdnaW5nLmhpc3RvcnlbMF0pIC8gNDAgKiAzMDA7XG5cdFx0XHRcdFx0ZHJhZ2dpbmcuZGVsdGEgKz0gZHJhZ2dpbmcuc3dpbmc7XG5cdFx0XHRcdFx0ZHJhZ2dpbmcudHdlZXNlID0gYWJzKGRyYWdnaW5nLnN3aW5nKSA+IDEwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHNsaWRlVG8oZHJhZ2dpbmcuc2xpZGVlID8gcm91bmQoZHJhZ2dpbmcuaW5pdFBvcyAtIGRyYWdnaW5nLmRlbHRhKSA6IGhhbmRsZVRvU2xpZGVlKGRyYWdnaW5nLmluaXRQb3MgKyBkcmFnZ2luZy5kZWx0YSkpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFN0b3BzIGRyYWdnaW5nIGFuZCBjbGVhbnMgdXAgYWZ0ZXIgaXQuXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGRyYWdFbmQoKSB7XG5cdFx0XHRjbGVhckludGVydmFsKGhpc3RvcnlJRCk7XG5cdFx0XHRkcmFnZ2luZy5yZWxlYXNlZCA9IHRydWU7XG5cdFx0XHQkZG9jLm9mZihkcmFnZ2luZy50b3VjaCA/IGRyYWdUb3VjaEV2ZW50cyA6IGRyYWdNb3VzZUV2ZW50cywgZHJhZ0hhbmRsZXIpO1xuXHRcdFx0KGRyYWdnaW5nLnNsaWRlZSA/ICRzbGlkZWUgOiAkaGFuZGxlKS5yZW1vdmVDbGFzcyhvLmRyYWdnZWRDbGFzcyk7XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGRpc2FibGVPbmVFdmVudCBpcyBub3QgYWN0aXZlIGluIG5leHQgdGljay5cblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRkcmFnZ2luZy4kc291cmNlLm9mZihjbGlja0V2ZW50LCBkaXNhYmxlT25lRXZlbnQpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIE5vcm1hbGx5LCB0aGlzIGlzIHRyaWdnZXJlZCBpbiByZW5kZXIoKSwgYnV0IGlmIHRoZXJlXG5cdFx0XHQvLyBpcyBub3RoaW5nIHRvIHJlbmRlciwgd2UgaGF2ZSB0byBkbyBpdCBtYW51YWxseSBoZXJlLlxuXHRcdFx0aWYgKHBvcy5jdXIgPT09IHBvcy5kZXN0ICYmIGRyYWdnaW5nLmluaXQpIHtcblx0XHRcdFx0dHJpZ2dlcignbW92ZUVuZCcpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXN1bWUgb25nb2luZyBjeWNsZVxuXHRcdFx0c2VsZi5yZXN1bWUoMSk7XG5cblx0XHRcdGRyYWdnaW5nLmluaXQgPSAwO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIHdoZXRoZXIgZWxlbWVudCBpcyBpbnRlcmFjdGl2ZS5cblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZShlbGVtZW50KSB7XG5cdFx0XHRyZXR1cm4gfiQuaW5BcnJheShlbGVtZW50Lm5vZGVOYW1lLCBpbnRlcmFjdGl2ZUVsZW1lbnRzKSB8fCAkKGVsZW1lbnQpLmlzKG8uaW50ZXJhY3RpdmUpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIENvbnRpbnVvdXMgbW92ZW1lbnQgY2xlYW51cCBvbiBtb3VzZXVwLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBtb3ZlbWVudFJlbGVhc2VIYW5kbGVyKCkge1xuXHRcdFx0c2VsZi5zdG9wKCk7XG5cdFx0XHQkZG9jLm9mZignbW91c2V1cCcsIG1vdmVtZW50UmVsZWFzZUhhbmRsZXIpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEJ1dHRvbnMgbmF2aWdhdGlvbiBoYW5kbGVyLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtICB7RXZlbnR9IGV2ZW50XG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGJ1dHRvbnNIYW5kbGVyKGV2ZW50KSB7XG5cdFx0XHQvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuXHRcdFx0c3RvcERlZmF1bHQoZXZlbnQpO1xuXHRcdFx0c3dpdGNoICh0aGlzKSB7XG5cdFx0XHRcdGNhc2UgJGZvcndhcmRCdXR0b25bMF06XG5cdFx0XHRcdGNhc2UgJGJhY2t3YXJkQnV0dG9uWzBdOlxuXHRcdFx0XHRcdHNlbGYubW92ZUJ5KCRmb3J3YXJkQnV0dG9uLmlzKHRoaXMpID8gby5tb3ZlQnkgOiAtby5tb3ZlQnkpO1xuXHRcdFx0XHRcdCRkb2Mub24oJ21vdXNldXAnLCBtb3ZlbWVudFJlbGVhc2VIYW5kbGVyKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICRwcmV2QnV0dG9uWzBdOlxuXHRcdFx0XHRcdHNlbGYucHJldigpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJG5leHRCdXR0b25bMF06XG5cdFx0XHRcdFx0c2VsZi5uZXh0KCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAkcHJldlBhZ2VCdXR0b25bMF06XG5cdFx0XHRcdFx0c2VsZi5wcmV2UGFnZSgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJG5leHRQYWdlQnV0dG9uWzBdOlxuXHRcdFx0XHRcdHNlbGYubmV4dFBhZ2UoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBNb3VzZSB3aGVlbCBkZWx0YSBub3JtYWxpemF0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtICB7RXZlbnR9IGV2ZW50XG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtJbnR9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gbm9ybWFsaXplV2hlZWxEZWx0YShldmVudCkge1xuXHRcdFx0Ly8gd2hlZWxEZWx0YSBuZWVkZWQgb25seSBmb3IgSUU4LVxuXHRcdFx0c2Nyb2xsaW5nLmN1ckRlbHRhID0gKChvLmhvcml6b250YWwgPyBldmVudC5kZWx0YVkgfHwgZXZlbnQuZGVsdGFYIDogZXZlbnQuZGVsdGFZKSB8fCAtZXZlbnQud2hlZWxEZWx0YSk7XG5cdFx0XHRzY3JvbGxpbmcuY3VyRGVsdGEgLz0gZXZlbnQuZGVsdGFNb2RlID09PSAxID8gMyA6IDEwMDtcblx0XHRcdGlmICghaXRlbU5hdikge1xuXHRcdFx0XHRyZXR1cm4gc2Nyb2xsaW5nLmN1ckRlbHRhO1xuXHRcdFx0fVxuXHRcdFx0dGltZSA9ICtuZXcgRGF0ZSgpO1xuXHRcdFx0aWYgKHNjcm9sbGluZy5sYXN0IDwgdGltZSAtIHNjcm9sbGluZy5yZXNldFRpbWUpIHtcblx0XHRcdFx0c2Nyb2xsaW5nLmRlbHRhID0gMDtcblx0XHRcdH1cblx0XHRcdHNjcm9sbGluZy5sYXN0ID0gdGltZTtcblx0XHRcdHNjcm9sbGluZy5kZWx0YSArPSBzY3JvbGxpbmcuY3VyRGVsdGE7XG5cdFx0XHRpZiAoYWJzKHNjcm9sbGluZy5kZWx0YSkgPCAxKSB7XG5cdFx0XHRcdHNjcm9sbGluZy5maW5hbERlbHRhID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNjcm9sbGluZy5maW5hbERlbHRhID0gcm91bmQoc2Nyb2xsaW5nLmRlbHRhIC8gMSk7XG5cdFx0XHRcdHNjcm9sbGluZy5kZWx0YSAlPSAxO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNjcm9sbGluZy5maW5hbERlbHRhO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIE1vdXNlIHNjcm9sbGluZyBoYW5kbGVyLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtICB7RXZlbnR9IGV2ZW50XG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHNjcm9sbEhhbmRsZXIoZXZlbnQpIHtcblx0XHRcdC8vIE1hcmsgZXZlbnQgYXMgb3JpZ2luYXRpbmcgaW4gYSBTbHkgaW5zdGFuY2Vcblx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnRbbmFtZXNwYWNlXSA9IHNlbGY7XG5cdFx0XHQvLyBEb24ndCBoaWphY2sgZ2xvYmFsIHNjcm9sbGluZ1xuXHRcdFx0dmFyIHRpbWUgPSArbmV3IERhdGUoKTtcblx0XHRcdGlmIChsYXN0R2xvYmFsV2hlZWwgKyBvLnNjcm9sbEhpamFjayA+IHRpbWUgJiYgJHNjcm9sbFNvdXJjZVswXSAhPT0gZG9jdW1lbnQgJiYgJHNjcm9sbFNvdXJjZVswXSAhPT0gd2luZG93KSB7XG5cdFx0XHRcdGxhc3RHbG9iYWxXaGVlbCA9IHRpbWU7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIElnbm9yZSBpZiB0aGVyZSBpcyBubyBzY3JvbGxpbmcgdG8gYmUgZG9uZVxuXHRcdFx0aWYgKCFvLnNjcm9sbEJ5IHx8IHBvcy5zdGFydCA9PT0gcG9zLmVuZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgZGVsdGEgPSBub3JtYWxpemVXaGVlbERlbHRhKGV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xuXHRcdFx0Ly8gVHJhcCBzY3JvbGxpbmcgb25seSB3aGVuIG5lY2Vzc2FyeSBhbmQvb3IgcmVxdWVzdGVkXG5cdFx0XHRpZiAoby5zY3JvbGxUcmFwIHx8IGRlbHRhID4gMCAmJiBwb3MuZGVzdCA8IHBvcy5lbmQgfHwgZGVsdGEgPCAwICYmIHBvcy5kZXN0ID4gcG9zLnN0YXJ0KSB7XG5cdFx0XHRcdHN0b3BEZWZhdWx0KGV2ZW50LCAxKTtcblx0XHRcdH1cblx0XHRcdHNlbGYuc2xpZGVCeShvLnNjcm9sbEJ5ICogZGVsdGEpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFNjcm9sbGJhciBjbGljayBoYW5kbGVyLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtICB7RXZlbnR9IGV2ZW50XG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHNjcm9sbGJhckhhbmRsZXIoZXZlbnQpIHtcblx0XHRcdC8vIE9ubHkgY2xpY2tzIG9uIHNjcm9sbCBiYXIuIElnbm9yZSB0aGUgaGFuZGxlLlxuXHRcdFx0aWYgKG8uY2xpY2tCYXIgJiYgZXZlbnQudGFyZ2V0ID09PSAkc2JbMF0pIHtcblx0XHRcdFx0c3RvcERlZmF1bHQoZXZlbnQpO1xuXHRcdFx0XHQvLyBDYWxjdWxhdGUgbmV3IGhhbmRsZSBwb3NpdGlvbiBhbmQgc3luYyBTTElERUUgdG8gaXRcblx0XHRcdFx0c2xpZGVUbyhoYW5kbGVUb1NsaWRlZSgoby5ob3Jpem9udGFsID8gZXZlbnQucGFnZVggLSAkc2Iub2Zmc2V0KCkubGVmdCA6IGV2ZW50LnBhZ2VZIC0gJHNiLm9mZnNldCgpLnRvcCkgLSBoYW5kbGVTaXplIC8gMikpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEtleWJvYXJkIGlucHV0IGhhbmRsZXIuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0gIHtFdmVudH0gZXZlbnRcblx0XHQgKlxuXHRcdCAqIEByZXR1cm4ge1ZvaWR9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24ga2V5Ym9hcmRIYW5kbGVyKGV2ZW50KSB7XG5cdFx0XHRpZiAoIW8ua2V5Ym9hcmROYXZCeSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHN3aXRjaCAoZXZlbnQud2hpY2gpIHtcblx0XHRcdFx0Ly8gTGVmdCBvciBVcFxuXHRcdFx0XHRjYXNlIG8uaG9yaXpvbnRhbCA/IDM3IDogMzg6XG5cdFx0XHRcdFx0c3RvcERlZmF1bHQoZXZlbnQpO1xuXHRcdFx0XHRcdHNlbGZbby5rZXlib2FyZE5hdkJ5ID09PSAncGFnZXMnID8gJ3ByZXZQYWdlJyA6ICdwcmV2J10oKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHQvLyBSaWdodCBvciBEb3duXG5cdFx0XHRcdGNhc2Ugby5ob3Jpem9udGFsID8gMzkgOiA0MDpcblx0XHRcdFx0XHRzdG9wRGVmYXVsdChldmVudCk7XG5cdFx0XHRcdFx0c2VsZltvLmtleWJvYXJkTmF2QnkgPT09ICdwYWdlcycgPyAnbmV4dFBhZ2UnIDogJ25leHQnXSgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIENsaWNrIG9uIGl0ZW0gYWN0aXZhdGlvbiBoYW5kbGVyLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtICB7RXZlbnR9IGV2ZW50XG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGFjdGl2YXRlSGFuZGxlcihldmVudCkge1xuXHRcdFx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cblxuXHRcdFx0Ly8gSWdub3JlIGNsaWNrcyBvbiBpbnRlcmFjdGl2ZSBlbGVtZW50cy5cblx0XHRcdGlmIChpc0ludGVyYWN0aXZlKHRoaXMpKSB7XG5cdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnRbbmFtZXNwYWNlICsgJ2lnbm9yZSddID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZ25vcmUgZXZlbnRzIHRoYXQ6XG5cdFx0XHQvLyAtIGFyZSBub3Qgb3JpZ2luYXRpbmcgZnJvbSBkaXJlY3QgU0xJREVFIGNoaWxkcmVuXG5cdFx0XHQvLyAtIG9yaWdpbmF0ZWQgZnJvbSBpbnRlcmFjdGl2ZSBlbGVtZW50c1xuXHRcdFx0aWYgKHRoaXMucGFyZW50Tm9kZSAhPT0gJHNsaWRlZVswXSB8fCBldmVudC5vcmlnaW5hbEV2ZW50W25hbWVzcGFjZSArICdpZ25vcmUnXSkgcmV0dXJuO1xuXG5cdFx0XHRzZWxmLmFjdGl2YXRlKHRoaXMpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIENsaWNrIG9uIHBhZ2UgYnV0dG9uIGhhbmRsZXIuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBhY3RpdmF0ZVBhZ2VIYW5kbGVyKCkge1xuXHRcdFx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cblx0XHRcdC8vIEFjY2VwdCBvbmx5IGV2ZW50cyBmcm9tIGRpcmVjdCBwYWdlcyBiYXIgY2hpbGRyZW4uXG5cdFx0XHRpZiAodGhpcy5wYXJlbnROb2RlID09PSAkcGJbMF0pIHtcblx0XHRcdFx0c2VsZi5hY3RpdmF0ZVBhZ2UoJHBhZ2VzLmluZGV4KHRoaXMpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBQYXVzZSBvbiBob3ZlciBoYW5kbGVyLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtICB7RXZlbnR9IGV2ZW50XG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHBhdXNlT25Ib3ZlckhhbmRsZXIoZXZlbnQpIHtcblx0XHRcdGlmIChvLnBhdXNlT25Ib3Zlcikge1xuXHRcdFx0XHRzZWxmW2V2ZW50LnR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdwYXVzZScgOiAncmVzdW1lJ10oMik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlciBjYWxsYmFja3MgZm9yIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIEV2ZW50IG5hbWUuXG5cdFx0ICogQHBhcmFtICB7TWl4ZWR9ICBhcmdYIEFyZ3VtZW50cyBwYXNzZWQgdG8gY2FsbGJhY2tzLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7Vm9pZH1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiB0cmlnZ2VyKG5hbWUsIGFyZzEpIHtcblx0XHRcdGlmIChjYWxsYmFja3NbbmFtZV0pIHtcblx0XHRcdFx0bCA9IGNhbGxiYWNrc1tuYW1lXS5sZW5ndGg7XG5cdFx0XHRcdC8vIENhbGxiYWNrcyB3aWxsIGJlIHN0b3JlZCBhbmQgZXhlY3V0ZWQgZnJvbSBhIHRlbXBvcmFyeSBhcnJheSB0byBub3Rcblx0XHRcdFx0Ly8gYnJlYWsgdGhlIGV4ZWN1dGlvbiBxdWV1ZSB3aGVuIG9uZSBvZiB0aGUgY2FsbGJhY2tzIHVuYmluZHMgaXRzZWxmLlxuXHRcdFx0XHR0bXBBcnJheS5sZW5ndGggPSAwO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dG1wQXJyYXkucHVzaChjYWxsYmFja3NbbmFtZV1baV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGNhbGxiYWNrc1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dG1wQXJyYXlbaV0uY2FsbChzZWxmLCBuYW1lLCBhcmcxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIERlc3Ryb3lzIGluc3RhbmNlIGFuZCBldmVyeXRoaW5nIGl0IGNyZWF0ZWQuXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtWb2lkfVxuXHRcdCAqL1xuXHRcdHNlbGYuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFJlbW92ZSB0aGUgcmVmZXJlbmNlIHRvIGl0c2VsZlxuXHRcdFx0U2x5LnJlbW92ZUluc3RhbmNlKGZyYW1lKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHNcblx0XHRcdCRzY3JvbGxTb3VyY2Vcblx0XHRcdFx0LmFkZCgkaGFuZGxlKVxuXHRcdFx0XHQuYWRkKCRzYilcblx0XHRcdFx0LmFkZCgkcGIpXG5cdFx0XHRcdC5hZGQoJGZvcndhcmRCdXR0b24pXG5cdFx0XHRcdC5hZGQoJGJhY2t3YXJkQnV0dG9uKVxuXHRcdFx0XHQuYWRkKCRwcmV2QnV0dG9uKVxuXHRcdFx0XHQuYWRkKCRuZXh0QnV0dG9uKVxuXHRcdFx0XHQuYWRkKCRwcmV2UGFnZUJ1dHRvbilcblx0XHRcdFx0LmFkZCgkbmV4dFBhZ2VCdXR0b24pXG5cdFx0XHRcdC5vZmYoJy4nICsgbmFtZXNwYWNlKTtcblxuXHRcdFx0Ly8gVW5iaW5kaW5nIHNwZWNpZmljYWxseSBhcyB0byBub3QgbnVrZSBvdXQgb3RoZXIgaW5zdGFuY2VzXG5cdFx0XHQkZG9jLm9mZigna2V5ZG93bicsIGtleWJvYXJkSGFuZGxlcik7XG5cblx0XHRcdC8vIFJlbW92ZSBjbGFzc2VzXG5cdFx0XHQkcHJldkJ1dHRvblxuXHRcdFx0XHQuYWRkKCRuZXh0QnV0dG9uKVxuXHRcdFx0XHQuYWRkKCRwcmV2UGFnZUJ1dHRvbilcblx0XHRcdFx0LmFkZCgkbmV4dFBhZ2VCdXR0b24pXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyhvLmRpc2FibGVkQ2xhc3MpO1xuXG5cdFx0XHRpZiAoJGl0ZW1zICYmIHJlbC5hY3RpdmVJdGVtICE9IG51bGwpIHtcblx0XHRcdFx0JGl0ZW1zLmVxKHJlbC5hY3RpdmVJdGVtKS5yZW1vdmVDbGFzcyhvLmFjdGl2ZUNsYXNzKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIHBhZ2UgaXRlbXNcblx0XHRcdCRwYi5lbXB0eSgpO1xuXG5cdFx0XHRpZiAoIXBhcmFsbGF4KSB7XG5cdFx0XHRcdC8vIFVuYmluZCBldmVudHMgZnJvbSBmcmFtZVxuXHRcdFx0XHQkZnJhbWUub2ZmKCcuJyArIG5hbWVzcGFjZSk7XG5cdFx0XHRcdC8vIFJlc3RvcmUgb3JpZ2luYWwgc3R5bGVzXG5cdFx0XHRcdGZyYW1lU3R5bGVzLnJlc3RvcmUoKTtcblx0XHRcdFx0c2xpZGVlU3R5bGVzLnJlc3RvcmUoKTtcblx0XHRcdFx0c2JTdHlsZXMucmVzdG9yZSgpO1xuXHRcdFx0XHRoYW5kbGVTdHlsZXMucmVzdG9yZSgpO1xuXHRcdFx0XHQvLyBSZW1vdmUgdGhlIGluc3RhbmNlIGZyb20gZWxlbWVudCBkYXRhIHN0b3JhZ2Vcblx0XHRcdFx0JC5yZW1vdmVEYXRhKGZyYW1lLCBuYW1lc3BhY2UpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhbiB1cCBjb2xsZWN0aW9uc1xuXHRcdFx0aXRlbXMubGVuZ3RoID0gcGFnZXMubGVuZ3RoID0gMDtcblx0XHRcdGxhc3QgPSB7fTtcblxuXHRcdFx0Ly8gUmVzZXQgaW5pdGlhbGl6ZWQgc3RhdHVzIGFuZCByZXR1cm4gdGhlIGluc3RhbmNlXG5cdFx0XHRzZWxmLmluaXRpYWxpemVkID0gMDtcblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHNlbGYuaW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChzZWxmLmluaXRpYWxpemVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGlzYWxsb3cgbXVsdGlwbGUgaW5zdGFuY2VzIG9uIHRoZSBzYW1lIGVsZW1lbnRcblx0XHRcdGlmIChTbHkuZ2V0SW5zdGFuY2UoZnJhbWUpKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIGFscmVhZHkgYSBTbHkgaW5zdGFuY2Ugb24gdGhpcyBlbGVtZW50Jyk7XG5cblx0XHRcdC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgdG8gaXRzZWxmXG5cdFx0XHRTbHkuc3RvcmVJbnN0YW5jZShmcmFtZSwgc2VsZik7XG5cblx0XHRcdC8vIFJlZ2lzdGVyIGNhbGxiYWNrcyBtYXBcblx0XHRcdHNlbGYub24oY2FsbGJhY2tNYXApO1xuXG5cdFx0XHQvLyBTYXZlIHN0eWxlc1xuXHRcdFx0dmFyIGhvbGRlclByb3BzID0gWydvdmVyZmxvdycsICdwb3NpdGlvbiddO1xuXHRcdFx0dmFyIG1vdmFibGVQcm9wcyA9IFsncG9zaXRpb24nLCAnd2Via2l0VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJywgJ3RyYW5zZm9ybScsICdsZWZ0JywgJ3RvcCcsICd3aWR0aCcsICdoZWlnaHQnXTtcblx0XHRcdGZyYW1lU3R5bGVzLnNhdmUuYXBwbHkoZnJhbWVTdHlsZXMsIGhvbGRlclByb3BzKTtcblx0XHRcdHNiU3R5bGVzLnNhdmUuYXBwbHkoc2JTdHlsZXMsIGhvbGRlclByb3BzKTtcblx0XHRcdHNsaWRlZVN0eWxlcy5zYXZlLmFwcGx5KHNsaWRlZVN0eWxlcywgbW92YWJsZVByb3BzKTtcblx0XHRcdGhhbmRsZVN0eWxlcy5zYXZlLmFwcGx5KGhhbmRsZVN0eWxlcywgbW92YWJsZVByb3BzKTtcblxuXHRcdFx0Ly8gU2V0IHJlcXVpcmVkIHN0eWxlc1xuXHRcdFx0dmFyICRtb3ZhYmxlcyA9ICRoYW5kbGU7XG5cdFx0XHRpZiAoIXBhcmFsbGF4KSB7XG5cdFx0XHRcdCRtb3ZhYmxlcyA9ICRtb3ZhYmxlcy5hZGQoJHNsaWRlZSk7XG5cdFx0XHRcdCRmcmFtZS5jc3MoJ292ZXJmbG93JywgJ2hpZGRlbicpO1xuXHRcdFx0XHRpZiAoIXRyYW5zZm9ybSAmJiAkZnJhbWUuY3NzKCdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuXHRcdFx0XHRcdCRmcmFtZS5jc3MoJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0cmFuc2Zvcm0pIHtcblx0XHRcdFx0aWYgKGdwdUFjY2VsZXJhdGlvbikge1xuXHRcdFx0XHRcdCRtb3ZhYmxlcy5jc3ModHJhbnNmb3JtLCBncHVBY2NlbGVyYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoJHNiLmNzcygncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcblx0XHRcdFx0XHQkc2IuY3NzKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCRtb3ZhYmxlcy5jc3MoeyBwb3NpdGlvbjogJ2Fic29sdXRlJyB9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF2aWdhdGlvbiBidXR0b25zXG5cdFx0XHRpZiAoby5mb3J3YXJkKSB7XG5cdFx0XHRcdCRmb3J3YXJkQnV0dG9uLm9uKG1vdXNlRG93bkV2ZW50LCBidXR0b25zSGFuZGxlcik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoby5iYWNrd2FyZCkge1xuXHRcdFx0XHQkYmFja3dhcmRCdXR0b24ub24obW91c2VEb3duRXZlbnQsIGJ1dHRvbnNIYW5kbGVyKTtcblx0XHRcdH1cblx0XHRcdGlmIChvLnByZXYpIHtcblx0XHRcdFx0JHByZXZCdXR0b24ub24oY2xpY2tFdmVudCwgYnV0dG9uc0hhbmRsZXIpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG8ubmV4dCkge1xuXHRcdFx0XHQkbmV4dEJ1dHRvbi5vbihjbGlja0V2ZW50LCBidXR0b25zSGFuZGxlcik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoby5wcmV2UGFnZSkge1xuXHRcdFx0XHQkcHJldlBhZ2VCdXR0b24ub24oY2xpY2tFdmVudCwgYnV0dG9uc0hhbmRsZXIpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG8ubmV4dFBhZ2UpIHtcblx0XHRcdFx0JG5leHRQYWdlQnV0dG9uLm9uKGNsaWNrRXZlbnQsIGJ1dHRvbnNIYW5kbGVyKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2Nyb2xsaW5nIG5hdmlnYXRpb25cblx0XHRcdCRzY3JvbGxTb3VyY2Uub24od2hlZWxFdmVudCwgc2Nyb2xsSGFuZGxlcik7XG5cblx0XHRcdC8vIENsaWNraW5nIG9uIHNjcm9sbGJhciBuYXZpZ2F0aW9uXG5cdFx0XHRpZiAoJHNiWzBdKSB7XG5cdFx0XHRcdCRzYi5vbihjbGlja0V2ZW50LCBzY3JvbGxiYXJIYW5kbGVyKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xpY2sgb24gaXRlbXMgbmF2aWdhdGlvblxuXHRcdFx0aWYgKGl0ZW1OYXYgJiYgby5hY3RpdmF0ZU9uKSB7XG5cdFx0XHRcdCRmcmFtZS5vbihvLmFjdGl2YXRlT24gKyAnLicgKyBuYW1lc3BhY2UsICcqJywgYWN0aXZhdGVIYW5kbGVyKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFnZXMgbmF2aWdhdGlvblxuXHRcdFx0aWYgKCRwYlswXSAmJiBvLmFjdGl2YXRlUGFnZU9uKSB7XG5cdFx0XHRcdCRwYi5vbihvLmFjdGl2YXRlUGFnZU9uICsgJy4nICsgbmFtZXNwYWNlLCAnKicsIGFjdGl2YXRlUGFnZUhhbmRsZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEcmFnZ2luZyBuYXZpZ2F0aW9uXG5cdFx0XHQkZHJhZ1NvdXJjZS5vbihkcmFnSW5pdEV2ZW50cywgeyBzb3VyY2U6ICdzbGlkZWUnIH0sIGRyYWdJbml0KTtcblxuXHRcdFx0Ly8gU2Nyb2xsYmFyIGRyYWdnaW5nIG5hdmlnYXRpb25cblx0XHRcdGlmICgkaGFuZGxlKSB7XG5cdFx0XHRcdCRoYW5kbGUub24oZHJhZ0luaXRFdmVudHMsIHsgc291cmNlOiAnaGFuZGxlJyB9LCBkcmFnSW5pdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtleWJvYXJkIG5hdmlnYXRpb25cblx0XHRcdCRkb2Mub24oJ2tleWRvd24nLCBrZXlib2FyZEhhbmRsZXIpO1xuXG5cdFx0XHRpZiAoIXBhcmFsbGF4KSB7XG5cdFx0XHRcdC8vIFBhdXNlIG9uIGhvdmVyXG5cdFx0XHRcdCRmcmFtZS5vbignbW91c2VlbnRlci4nICsgbmFtZXNwYWNlICsgJyBtb3VzZWxlYXZlLicgKyBuYW1lc3BhY2UsIHBhdXNlT25Ib3ZlckhhbmRsZXIpO1xuXHRcdFx0XHQvLyBSZXNldCBuYXRpdmUgRlJBTUUgZWxlbWVudCBzY3JvbGxcblx0XHRcdFx0JGZyYW1lLm9uKCdzY3JvbGwuJyArIG5hbWVzcGFjZSwgcmVzZXRTY3JvbGwpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXJrIGluc3RhbmNlIGFzIGluaXRpYWxpemVkXG5cdFx0XHRzZWxmLmluaXRpYWxpemVkID0gMTtcblxuXHRcdFx0Ly8gTG9hZFxuXHRcdFx0bG9hZCh0cnVlKTtcblxuXHRcdFx0Ly8gSW5pdGlhdGUgYXV0b21hdGljIGN5Y2xpbmdcblx0XHRcdGlmIChvLmN5Y2xlQnkgJiYgIXBhcmFsbGF4KSB7XG5cdFx0XHRcdHNlbGZbby5zdGFydFBhdXNlZCA/ICdwYXVzZScgOiAncmVzdW1lJ10oKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIGluc3RhbmNlXG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9O1xuXHR9XG5cblx0U2x5LmdldEluc3RhbmNlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gJC5kYXRhKGVsZW1lbnQsIG5hbWVzcGFjZSk7XG5cdH07XG5cblx0U2x5LnN0b3JlSW5zdGFuY2UgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2x5KSB7XG5cdFx0cmV0dXJuICQuZGF0YShlbGVtZW50LCBuYW1lc3BhY2UsIHNseSk7XG5cdH07XG5cblx0U2x5LnJlbW92ZUluc3RhbmNlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gJC5yZW1vdmVEYXRhKGVsZW1lbnQsIG5hbWVzcGFjZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiB0eXBlIG9mIHRoZSB2YWx1ZS5cblx0ICpcblx0ICogQHBhcmFtICB7TWl4ZWR9IHZhbHVlXG5cdCAqXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIHR5cGUodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKSB8fCAnb2JqZWN0Jztcblx0XHR9XG5cblx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV2ZW50IHByZXZlbnREZWZhdWx0ICYgc3RvcFByb3BhZ2F0aW9uIGhlbHBlci5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgICAgIEV2ZW50IG9iamVjdC5cblx0ICogQHBhcmFtIHtCb29sfSAgbm9CdWJibGVzIENhbmNlbCBldmVudCBidWJibGluZy5cblx0ICpcblx0ICogQHJldHVybiB7Vm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIHN0b3BEZWZhdWx0KGV2ZW50LCBub0J1YmJsZXMpIHtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGlmIChub0J1YmJsZXMpIHtcblx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlcyBhbiBldmVudCBpdCB3YXMgdHJpZ2dlcmVkIG9uIGFuZCB1bmJpbmRzIGl0c2VsZi5cblx0ICpcblx0ICogQHBhcmFtICB7RXZlbnR9IGV2ZW50XG5cdCAqXG5cdCAqIEByZXR1cm4ge1ZvaWR9XG5cdCAqL1xuXHRmdW5jdGlvbiBkaXNhYmxlT25lRXZlbnQoZXZlbnQpIHtcblx0XHQvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuXHRcdHN0b3BEZWZhdWx0KGV2ZW50LCAxKTtcblx0XHQkKHRoaXMpLm9mZihldmVudC50eXBlLCBkaXNhYmxlT25lRXZlbnQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlc2V0cyBuYXRpdmUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIHRvIDAuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1ZvaWR9XG5cdCAqL1xuXHRmdW5jdGlvbiByZXNldFNjcm9sbCgpIHtcblx0XHQvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuXHRcdHRoaXMuc2Nyb2xsTGVmdCA9IDA7XG5cdFx0dGhpcy5zY3JvbGxUb3AgPSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHZhcmlhYmxlIGlzIGEgbnVtYmVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuXHQgKlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcblx0XHRyZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKSAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUGFyc2Ugc3R5bGUgdG8gcGl4ZWxzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gICAkaXRlbSAgICBqUXVlcnkgb2JqZWN0IHdpdGggZWxlbWVudC5cblx0ICogQHBhcmFtIHtQcm9wZXJ0eX0gcHJvcGVydHkgQ1NTIHByb3BlcnR5IHRvIGdldCB0aGUgcGl4ZWxzIGZyb20uXG5cdCAqXG5cdCAqIEByZXR1cm4ge0ludH1cblx0ICovXG5cdGZ1bmN0aW9uIGdldFB4KCRpdGVtLCBwcm9wZXJ0eSkge1xuXHRcdHJldHVybiAwIHwgcm91bmQoU3RyaW5nKCRpdGVtLmNzcyhwcm9wZXJ0eSkpLnJlcGxhY2UoL1teXFwtMC05Ll0vZywgJycpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYWtlIHN1cmUgdGhhdCBudW1iZXIgaXMgd2l0aGluIHRoZSBsaW1pdHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1pblxuXHQgKiBAcGFyYW0ge051bWJlcn0gbWF4XG5cdCAqXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICovXG5cdGZ1bmN0aW9uIHdpdGhpbihudW1iZXIsIG1pbiwgbWF4KSB7XG5cdFx0cmV0dXJuIG51bWJlciA8IG1pbiA/IG1pbiA6IG51bWJlciA+IG1heCA/IG1heCA6IG51bWJlcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBTYXZlcyBlbGVtZW50IHN0eWxlcyBmb3IgbGF0ZXIgcmVzdG9yYXRpb24uXG5cdCAqXG5cdCAqIEV4YW1wbGU6XG5cdCAqICAgdmFyIHN0eWxlcyA9IG5ldyBTdHlsZVJlc3RvcmVyKGZyYW1lKTtcblx0ICogICBzdHlsZXMuc2F2ZSgncG9zaXRpb24nKTtcblx0ICogICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0ICogICBzdHlsZXMucmVzdG9yZSgpOyAvLyByZXN0b3JlcyB0byBzdGF0ZSBiZWZvcmUgdGhlIGFzc2lnbm1lbnQgYWJvdmVcblx0ICpcblx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBTdHlsZVJlc3RvcmVyKGVsZW1lbnQpIHtcblx0XHR2YXIgc2VsZiA9IHt9O1xuXHRcdHNlbGYuc3R5bGUgPSB7fTtcblx0XHRzZWxmLnNhdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQubm9kZVR5cGUpIHJldHVybjtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNlbGYuc3R5bGVbYXJndW1lbnRzW2ldXSA9IGVsZW1lbnQuc3R5bGVbYXJndW1lbnRzW2ldXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH07XG5cdFx0c2VsZi5yZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCFlbGVtZW50IHx8ICFlbGVtZW50Lm5vZGVUeXBlKSByZXR1cm47XG5cdFx0XHRmb3IgKHZhciBwcm9wIGluIHNlbGYuc3R5bGUpIHtcblx0XHRcdFx0aWYgKHNlbGYuc3R5bGUuaGFzT3duUHJvcGVydHkocHJvcCkpIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBzZWxmLnN0eWxlW3Byb3BdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fTtcblx0XHRyZXR1cm4gc2VsZjtcblx0fVxuXG5cdC8vIExvY2FsIFdpbmRvd0FuaW1hdGlvblRpbWluZyBpbnRlcmZhY2UgcG9seWZpbGxcblx0KGZ1bmN0aW9uICh3KSB7XG5cdFx0ckFGID0gdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcblx0XHRcdHx8IHcud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdFx0XHR8fCBmYWxsYmFjaztcblxuXHRcdC8qKlxuXHRcdCogRmFsbGJhY2sgaW1wbGVtZW50YXRpb24uXG5cdFx0Ki9cblx0XHR2YXIgcHJldiA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdGZ1bmN0aW9uIGZhbGxiYWNrKGZuKSB7XG5cdFx0XHR2YXIgY3VyciA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdFx0dmFyIG1zID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyciAtIHByZXYpKTtcblx0XHRcdHZhciByZXEgPSBzZXRUaW1lb3V0KGZuLCBtcyk7XG5cdFx0XHRwcmV2ID0gY3Vycjtcblx0XHRcdHJldHVybiByZXE7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0KiBDYW5jZWwuXG5cdFx0Ki9cblx0XHR2YXIgY2FuY2VsID0gdy5jYW5jZWxBbmltYXRpb25GcmFtZVxuXHRcdFx0fHwgdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZVxuXHRcdFx0fHwgdy5jbGVhclRpbWVvdXQ7XG5cblx0XHRjQUYgPSBmdW5jdGlvbihpZCl7XG5cdFx0XHRjYW5jZWwuY2FsbCh3LCBpZCk7XG5cdFx0fTtcblx0fSh3aW5kb3cpKTtcblxuXHQvLyBGZWF0dXJlIGRldGVjdHNcblx0KGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHJlZml4ZXMgPSBbJycsICdXZWJraXQnLCAnTW96JywgJ21zJywgJ08nXTtcblx0XHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuXHRcdGZ1bmN0aW9uIHRlc3RQcm9wKHByb3ApIHtcblx0XHRcdGZvciAodmFyIHAgPSAwLCBwbCA9IHByZWZpeGVzLmxlbmd0aDsgcCA8IHBsOyBwKyspIHtcblx0XHRcdFx0dmFyIHByZWZpeGVkUHJvcCA9IHByZWZpeGVzW3BdID8gcHJlZml4ZXNbcF0gKyBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKSA6IHByb3A7XG5cdFx0XHRcdGlmIChlbC5zdHlsZVtwcmVmaXhlZFByb3BdICE9IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJlZml4ZWRQcm9wO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gR2xvYmFsIHN1cHBvcnQgaW5kaWNhdG9yc1xuXHRcdHRyYW5zZm9ybSA9IHRlc3RQcm9wKCd0cmFuc2Zvcm0nKTtcblx0XHRncHVBY2NlbGVyYXRpb24gPSB0ZXN0UHJvcCgncGVyc3BlY3RpdmUnKSA/ICd0cmFuc2xhdGVaKDApICcgOiAnJztcblx0fSgpKTtcblxuXHQvLyBFeHBvc2UgY2xhc3MgZ2xvYmFsbHlcblx0d1tjbGFzc05hbWVdID0gU2x5O1xuXG5cdC8vIGpRdWVyeSBwcm94eVxuXHQkLmZuW3BsdWdpbk5hbWVdID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrTWFwKSB7XG5cdFx0dmFyIG1ldGhvZCwgbWV0aG9kQXJncztcblxuXHRcdC8vIEF0dHJpYnV0ZXMgbG9naWNcblx0XHRpZiAoISQuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuXHRcdFx0aWYgKHR5cGUob3B0aW9ucykgPT09ICdzdHJpbmcnIHx8IG9wdGlvbnMgPT09IGZhbHNlKSB7XG5cdFx0XHRcdG1ldGhvZCA9IG9wdGlvbnMgPT09IGZhbHNlID8gJ2Rlc3Ryb3knIDogb3B0aW9ucztcblx0XHRcdFx0bWV0aG9kQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdG8gYWxsIGVsZW1lbnRzXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSwgZWxlbWVudCkge1xuXHRcdFx0Ly8gQ2FsbCB3aXRoIHByZXZlbnRpb24gYWdhaW5zdCBtdWx0aXBsZSBpbnN0YW50aWF0aW9uc1xuXHRcdFx0dmFyIHBsdWdpbiA9IFNseS5nZXRJbnN0YW5jZShlbGVtZW50KTtcblxuXHRcdFx0aWYgKCFwbHVnaW4gJiYgIW1ldGhvZCkge1xuXHRcdFx0XHQvLyBDcmVhdGUgYSBuZXcgb2JqZWN0IGlmIGl0IGRvZXNuJ3QgZXhpc3QgeWV0XG5cdFx0XHRcdHBsdWdpbiA9IG5ldyBTbHkoZWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2tNYXApLmluaXQoKTtcblx0XHRcdH0gZWxzZSBpZiAocGx1Z2luICYmIG1ldGhvZCkge1xuXHRcdFx0XHQvLyBDYWxsIG1ldGhvZFxuXHRcdFx0XHRpZiAocGx1Z2luW21ldGhvZF0pIHtcblx0XHRcdFx0XHRwbHVnaW5bbWV0aG9kXS5hcHBseShwbHVnaW4sIG1ldGhvZEFyZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0Ly8gRGVmYXVsdCBvcHRpb25zXG5cdFNseS5kZWZhdWx0cyA9IHtcblx0XHRzbGlkZWU6ICAgICBudWxsLCAgLy8gU2VsZWN0b3IsIERPTSBlbGVtZW50LCBvciBqUXVlcnkgb2JqZWN0IHdpdGggRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIFNMSURFRS5cblx0XHRob3Jpem9udGFsOiBmYWxzZSwgLy8gU3dpdGNoIHRvIGhvcml6b250YWwgbW9kZS5cblxuXHRcdC8vIEl0ZW0gYmFzZWQgbmF2aWdhdGlvblxuXHRcdGl0ZW1OYXY6ICAgICAgICBudWxsLCAgLy8gSXRlbSBuYXZpZ2F0aW9uIHR5cGUuIENhbiBiZTogJ2Jhc2ljJywgJ2NlbnRlcmVkJywgJ2ZvcmNlQ2VudGVyZWQnLlxuXHRcdGl0ZW1TZWxlY3RvcjogICBudWxsLCAgLy8gU2VsZWN0IG9ubHkgaXRlbXMgdGhhdCBtYXRjaCB0aGlzIHNlbGVjdG9yLlxuXHRcdHNtYXJ0OiAgICAgICAgICBmYWxzZSwgLy8gUmVwb3NpdGlvbnMgdGhlIGFjdGl2YXRlZCBpdGVtIHRvIGhlbHAgd2l0aCBmdXJ0aGVyIG5hdmlnYXRpb24uXG5cdFx0YWN0aXZhdGVPbjogICAgIG51bGwsICAvLyBBY3RpdmF0ZSBhbiBpdGVtIG9uIHRoaXMgZXZlbnQuIENhbiBiZTogJ2NsaWNrJywgJ21vdXNlZW50ZXInLCAuLi5cblx0XHRhY3RpdmF0ZU1pZGRsZTogZmFsc2UsIC8vIEFsd2F5cyBhY3RpdmF0ZSB0aGUgaXRlbSBpbiB0aGUgbWlkZGxlIG9mIHRoZSBGUkFNRS4gZm9yY2VDZW50ZXJlZCBvbmx5LlxuXG5cdFx0Ly8gU2Nyb2xsaW5nXG5cdFx0c2Nyb2xsU291cmNlOiBudWxsLCAgLy8gRWxlbWVudCBmb3IgY2F0Y2hpbmcgdGhlIG1vdXNlIHdoZWVsIHNjcm9sbGluZy4gRGVmYXVsdCBpcyBGUkFNRS5cblx0XHRzY3JvbGxCeTogICAgIDAsICAgICAvLyBQaXhlbHMgb3IgaXRlbXMgdG8gbW92ZSBwZXIgb25lIG1vdXNlIHNjcm9sbC4gMCB0byBkaXNhYmxlIHNjcm9sbGluZy5cblx0XHRzY3JvbGxIaWphY2s6IDMwMCwgICAvLyBNaWxsaXNlY29uZHMgc2luY2UgbGFzdCB3aGVlbCBldmVudCBhZnRlciB3aGljaCBpdCBpcyBhY2NlcHRhYmxlIHRvIGhpamFjayBnbG9iYWwgc2Nyb2xsLlxuXHRcdHNjcm9sbFRyYXA6ICAgZmFsc2UsIC8vIERvbid0IGJ1YmJsZSBzY3JvbGxpbmcgd2hlbiBoaXR0aW5nIHNjcm9sbGluZyBsaW1pdHMuXG5cblx0XHQvLyBEcmFnZ2luZ1xuXHRcdGRyYWdTb3VyY2U6ICAgIG51bGwsICAvLyBTZWxlY3RvciBvciBET00gZWxlbWVudCBmb3IgY2F0Y2hpbmcgZHJhZ2dpbmcgZXZlbnRzLiBEZWZhdWx0IGlzIEZSQU1FLlxuXHRcdG1vdXNlRHJhZ2dpbmc6IGZhbHNlLCAvLyBFbmFibGUgbmF2aWdhdGlvbiBieSBkcmFnZ2luZyB0aGUgU0xJREVFIHdpdGggbW91c2UgY3Vyc29yLlxuXHRcdHRvdWNoRHJhZ2dpbmc6IGZhbHNlLCAvLyBFbmFibGUgbmF2aWdhdGlvbiBieSBkcmFnZ2luZyB0aGUgU0xJREVFIHdpdGggdG91Y2ggZXZlbnRzLlxuXHRcdHJlbGVhc2VTd2luZzogIGZhbHNlLCAvLyBFYXNlIG91dCBvbiBkcmFnZ2luZyBzd2luZyByZWxlYXNlLlxuXHRcdHN3aW5nU3BlZWQ6ICAgIDAuMiwgICAvLyBTd2luZyBzeW5jaHJvbml6YXRpb24gc3BlZWQsIHdoZXJlOiAxID0gaW5zdGFudCwgMCA9IGluZmluaXRlLlxuXHRcdGVsYXN0aWNCb3VuZHM6IGZhbHNlLCAvLyBTdHJldGNoIFNMSURFRSBwb3NpdGlvbiBsaW1pdHMgd2hlbiBkcmFnZ2luZyBwYXN0IEZSQU1FIGJvdW5kYXJpZXMuXG5cdFx0ZHJhZ1RocmVzaG9sZDogMywgICAgIC8vIERpc3RhbmNlIGluIHBpeGVscyBiZWZvcmUgU2x5IHJlY29nbml6ZXMgZHJhZ2dpbmcuXG5cdFx0aW50ZXJhY3RpdmU6ICAgbnVsbCwgIC8vIFNlbGVjdG9yIGZvciBzcGVjaWFsIGludGVyYWN0aXZlIGVsZW1lbnRzLlxuXG5cdFx0Ly8gU2Nyb2xsYmFyXG5cdFx0c2Nyb2xsQmFyOiAgICAgbnVsbCwgIC8vIFNlbGVjdG9yIG9yIERPTSBlbGVtZW50IGZvciBzY3JvbGxiYXIgY29udGFpbmVyLlxuXHRcdGRyYWdIYW5kbGU6ICAgIGZhbHNlLCAvLyBXaGV0aGVyIHRoZSBzY3JvbGxiYXIgaGFuZGxlIHNob3VsZCBiZSBkcmFnZ2FibGUuXG5cdFx0ZHluYW1pY0hhbmRsZTogZmFsc2UsIC8vIFNjcm9sbGJhciBoYW5kbGUgcmVwcmVzZW50cyB0aGUgcmF0aW8gYmV0d2VlbiBoaWRkZW4gYW5kIHZpc2libGUgY29udGVudC5cblx0XHRtaW5IYW5kbGVTaXplOiA1MCwgICAgLy8gTWluaW1hbCBoZWlnaHQgb3Igd2lkdGggKGRlcGVuZHMgb24gc2x5IGRpcmVjdGlvbikgb2YgYSBoYW5kbGUgaW4gcGl4ZWxzLlxuXHRcdGNsaWNrQmFyOiAgICAgIGZhbHNlLCAvLyBFbmFibGUgbmF2aWdhdGlvbiBieSBjbGlja2luZyBvbiBzY3JvbGxiYXIuXG5cdFx0c3luY1NwZWVkOiAgICAgMC41LCAgIC8vIEhhbmRsZSA9PiBTTElERUUgc3luY2hyb25pemF0aW9uIHNwZWVkLCB3aGVyZTogMSA9IGluc3RhbnQsIDAgPSBpbmZpbml0ZS5cblxuXHRcdC8vIFBhZ2VzYmFyXG5cdFx0cGFnZXNCYXI6ICAgICAgIG51bGwsIC8vIFNlbGVjdG9yIG9yIERPTSBlbGVtZW50IGZvciBwYWdlcyBiYXIgY29udGFpbmVyLlxuXHRcdGFjdGl2YXRlUGFnZU9uOiBudWxsLCAvLyBFdmVudCB1c2VkIHRvIGFjdGl2YXRlIHBhZ2UuIENhbiBiZTogY2xpY2ssIG1vdXNlZW50ZXIsIC4uLlxuXHRcdHBhZ2VCdWlsZGVyOiAgICAgICAgICAvLyBQYWdlIGl0ZW0gZ2VuZXJhdG9yLlxuXHRcdFx0ZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0XHRcdHJldHVybiAnPGxpPicgKyAoaW5kZXggKyAxKSArICc8L2xpPic7XG5cdFx0XHR9LFxuXG5cdFx0Ly8gTmF2aWdhdGlvbiBidXR0b25zXG5cdFx0Zm9yd2FyZDogIG51bGwsIC8vIFNlbGVjdG9yIG9yIERPTSBlbGVtZW50IGZvciBcImZvcndhcmQgbW92ZW1lbnRcIiBidXR0b24uXG5cdFx0YmFja3dhcmQ6IG51bGwsIC8vIFNlbGVjdG9yIG9yIERPTSBlbGVtZW50IGZvciBcImJhY2t3YXJkIG1vdmVtZW50XCIgYnV0dG9uLlxuXHRcdHByZXY6ICAgICBudWxsLCAvLyBTZWxlY3RvciBvciBET00gZWxlbWVudCBmb3IgXCJwcmV2aW91cyBpdGVtXCIgYnV0dG9uLlxuXHRcdG5leHQ6ICAgICBudWxsLCAvLyBTZWxlY3RvciBvciBET00gZWxlbWVudCBmb3IgXCJuZXh0IGl0ZW1cIiBidXR0b24uXG5cdFx0cHJldlBhZ2U6IG51bGwsIC8vIFNlbGVjdG9yIG9yIERPTSBlbGVtZW50IGZvciBcInByZXZpb3VzIHBhZ2VcIiBidXR0b24uXG5cdFx0bmV4dFBhZ2U6IG51bGwsIC8vIFNlbGVjdG9yIG9yIERPTSBlbGVtZW50IGZvciBcIm5leHQgcGFnZVwiIGJ1dHRvbi5cblxuXHRcdC8vIEF1dG9tYXRlZCBjeWNsaW5nXG5cdFx0Y3ljbGVCeTogICAgICAgbnVsbCwgIC8vIEVuYWJsZSBhdXRvbWF0aWMgY3ljbGluZyBieSAnaXRlbXMnIG9yICdwYWdlcycuXG5cdFx0Y3ljbGVJbnRlcnZhbDogNTAwMCwgIC8vIERlbGF5IGJldHdlZW4gY3ljbGVzIGluIG1pbGxpc2Vjb25kcy5cblx0XHRwYXVzZU9uSG92ZXI6ICBmYWxzZSwgLy8gUGF1c2UgY3ljbGluZyB3aGVuIG1vdXNlIGhvdmVycyBvdmVyIHRoZSBGUkFNRS5cblx0XHRzdGFydFBhdXNlZDogICBmYWxzZSwgLy8gV2hldGhlciB0byBzdGFydCBpbiBwYXVzZWQgc2F0ZS5cblxuXHRcdC8vIE1peGVkIG9wdGlvbnNcblx0XHRtb3ZlQnk6ICAgICAgICAzMDAsICAgICAvLyBTcGVlZCBpbiBwaXhlbHMgcGVyIHNlY29uZCB1c2VkIGJ5IGZvcndhcmQgYW5kIGJhY2t3YXJkIGJ1dHRvbnMuXG5cdFx0c3BlZWQ6ICAgICAgICAgMCwgICAgICAgLy8gQW5pbWF0aW9ucyBzcGVlZCBpbiBtaWxsaXNlY29uZHMuIDAgdG8gZGlzYWJsZSBhbmltYXRpb25zLlxuXHRcdGVhc2luZzogICAgICAgICdzd2luZycsIC8vIEVhc2luZyBmb3IgZHVyYXRpb24gYmFzZWQgKHR3ZWVuaW5nKSBhbmltYXRpb25zLlxuXHRcdHN0YXJ0QXQ6ICAgICAgIG51bGwsICAgIC8vIFN0YXJ0aW5nIG9mZnNldCBpbiBwaXhlbHMgb3IgaXRlbXMuXG5cdFx0a2V5Ym9hcmROYXZCeTogbnVsbCwgICAgLy8gRW5hYmxlIGtleWJvYXJkIG5hdmlnYXRpb24gYnkgJ2l0ZW1zJyBvciAncGFnZXMnLlxuXG5cdFx0Ly8gQ2xhc3Nlc1xuXHRcdGRyYWdnZWRDbGFzczogICdkcmFnZ2VkJywgLy8gQ2xhc3MgZm9yIGRyYWdnZWQgZWxlbWVudHMgKGxpa2UgU0xJREVFIG9yIHNjcm9sbGJhciBoYW5kbGUpLlxuXHRcdGFjdGl2ZUNsYXNzOiAgICdhY3RpdmUnLCAgLy8gQ2xhc3MgZm9yIGFjdGl2ZSBpdGVtcyBhbmQgcGFnZXMuXG5cdFx0ZGlzYWJsZWRDbGFzczogJ2Rpc2FibGVkJyAvLyBDbGFzcyBmb3IgZGlzYWJsZWQgbmF2aWdhdGlvbiBlbGVtZW50cy5cblx0fTtcbn0oalF1ZXJ5LCB3aW5kb3cpKTtcbiIsIiQoZnVuY3Rpb24oKSB7XG4gICAgJCgndWwuYTJsaXhfdHJhbnNsYXRpb25zTG9jYWxlcycpLm9uKCdjbGljaycsICdhJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciB0YXJnZXQgPSAkKHRoaXMpLmF0dHIoJ2RhdGEtdGFyZ2V0Jyk7XG4gICAgICAgICQoJ2xpOmhhcyhhW2RhdGEtdGFyZ2V0PVwiJyArIHRhcmdldCArICdcIl0pLCBkaXYnICsgdGFyZ2V0LCAnZGl2LmEybGl4X3RyYW5zbGF0aW9ucycpLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgICAgICAgLnNpYmxpbmdzKCkucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgIH0pO1xuXG4gICAgJCgnZGl2LmEybGl4X3RyYW5zbGF0aW9uc0xvY2FsZXNTZWxlY3RvcicpLm9uKCdjaGFuZ2UnLCAnaW5wdXQnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdmFyICR0YWJzID0gJCgndWwuYTJsaXhfdHJhbnNsYXRpb25zTG9jYWxlcycpO1xuXG4gICAgICAgICQoJ2Rpdi5hMmxpeF90cmFuc2xhdGlvbnNMb2NhbGVzU2VsZWN0b3InKS5maW5kKCdpbnB1dCcpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkdGFicy5maW5kKCdsaTpoYXMoYVtkYXRhLXRhcmdldD1cIi5hMmxpeF90cmFuc2xhdGlvbnNGaWVsZHMtJyArIHRoaXMudmFsdWUgKyAnXCJdKScpLnRvZ2dsZSh0aGlzLmNoZWNrZWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAkKCd1bC5hMmxpeF90cmFuc2xhdGlvbnNMb2NhbGVzIGxpOnZpc2libGU6Zmlyc3QnKS5maW5kKCdhJykudHJpZ2dlcignY2xpY2snKTtcbiAgICB9KS50cmlnZ2VyKCdjaGFuZ2UnKTtcbn0pO1xuIiwiLyoqXG4gKiBAYXV0aG9yIFdpbGxpYW0gRFVSQU5EIDx3aWxsaWFtLmR1cmFuZDFAZ21haWwuY29tPlxuICogQGxpY2Vuc2UgTUlUIExpY2Vuc2VkXG4gKi9cbiFmdW5jdGlvbihlLGEpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoXCJUcmFuc2xhdG9yXCIsYSk6XCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9YSgpOmUuVHJhbnNsYXRvcj1hKCl9KHRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBlKGUsYSl7dmFyIHMsbj1wLnBsYWNlSG9sZGVyUHJlZml4LGM9cC5wbGFjZUhvbGRlclN1ZmZpeDtmb3IocyBpbiBhKXt2YXIgcj1uZXcgUmVnRXhwKG4rcytjLFwiZ1wiKTtpZihyLnRlc3QoZSkpe3ZhciB0PVN0cmluZyhhW3NdKS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxcJFwiLFwiZ1wiKSxcIiQkJCRcIik7ZT1lLnJlcGxhY2Uocix0KX19cmV0dXJuIGV9ZnVuY3Rpb24gYShlLGEsbixjLHIpe3ZhciB0PW58fGN8fHIsaT1hLHU9dC5zcGxpdChcIl9cIilbMF07aWYoISh0IGluIGwpKWlmKHUgaW4gbCl0PXU7ZWxzZXtpZighKHIgaW4gbCkpcmV0dXJuIGU7dD1yfWlmKHZvaWQgMD09PWl8fG51bGw9PT1pKWZvcih2YXIgbz0wO288Zi5sZW5ndGg7bysrKWlmKHModCxmW29dLGUpfHxzKHUsZltvXSxlKXx8cyhyLGZbb10sZSkpe2k9ZltvXTticmVha31pZihzKHQsaSxlKSlyZXR1cm4gbFt0XVtpXVtlXTtmb3IodmFyIGgsZCxwLG07dC5sZW5ndGg+MiYmKGg9dC5sZW5ndGgsZD10LnNwbGl0KC9bXFxzX10rLykscD1kW2QubGVuZ3RoLTFdLG09cC5sZW5ndGgsMSE9PWQubGVuZ3RoKTspaWYodD10LnN1YnN0cmluZygwLGgtKG0rMSkpLHModCxpLGUpKXJldHVybiBsW3RdW2ldW2VdO3JldHVybiBzKHIsaSxlKT9sW3JdW2ldW2VdOmV9ZnVuY3Rpb24gcyhlLGEscyl7cmV0dXJuIGUgaW4gbCYmKGEgaW4gbFtlXSYmcyBpbiBsW2VdW2FdKX1mdW5jdGlvbiBuKGUsYSxzKXt2YXIgbix0LGk9W10sbD1bXSx1PWUuc3BsaXQocC5wbHVyYWxTZXBhcmF0b3IpLGY9W107Zm9yKG49MDtuPHUubGVuZ3RoO24rKyl7dmFyIG09dVtuXTtoLnRlc3QobSk/KGY9bS5tYXRjaChoKSxpW2ZbMF1dPWZbZi5sZW5ndGgtMV0pOm8udGVzdChtKT8oZj1tLm1hdGNoKG8pLGwucHVzaChmWzFdKSk6bC5wdXNoKG0pfWZvcih0IGluIGkpaWYoZC50ZXN0KHQpKWlmKGY9dC5tYXRjaChkKSxmWzFdKXt2YXIgZyx2PWZbMl0uc3BsaXQoXCIsXCIpO2ZvcihnIGluIHYpaWYoYT09dltnXSlyZXR1cm4gaVt0XX1lbHNle3ZhciBiPWMoZls0XSksaz1jKGZbNV0pO2lmKChcIltcIj09PWZbM10/YT49YjphPmIpJiYoXCJdXCI9PT1mWzZdP2E8PWs6YTxrKSlyZXR1cm4gaVt0XX1yZXR1cm4gbFtyKGEscyldfHxsWzBdfHx2b2lkIDB9ZnVuY3Rpb24gYyhlKXtyZXR1cm5cIi1JbmZcIj09PWU/TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZOlwiK0luZlwiPT09ZXx8XCJJbmZcIj09PWU/TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOnBhcnNlSW50KGUsMTApfWZ1bmN0aW9uIHIoZSxhKXt2YXIgcz1hO3N3aXRjaChcInB0X0JSXCI9PT1zJiYocz1cInhiclwiKSxzLmxlbmd0aD4zJiYocz1zLnNwbGl0KFwiX1wiKVswXSkscyl7Y2FzZVwiYm9cIjpjYXNlXCJkelwiOmNhc2VcImlkXCI6Y2FzZVwiamFcIjpjYXNlXCJqdlwiOmNhc2VcImthXCI6Y2FzZVwia21cIjpjYXNlXCJrblwiOmNhc2VcImtvXCI6Y2FzZVwibXNcIjpjYXNlXCJ0aFwiOmNhc2VcInRyXCI6Y2FzZVwidmlcIjpjYXNlXCJ6aFwiOnJldHVybiAwO2Nhc2VcImFmXCI6Y2FzZVwiYXpcIjpjYXNlXCJiblwiOmNhc2VcImJnXCI6Y2FzZVwiY2FcIjpjYXNlXCJkYVwiOmNhc2VcImRlXCI6Y2FzZVwiZWxcIjpjYXNlXCJlblwiOmNhc2VcImVvXCI6Y2FzZVwiZXNcIjpjYXNlXCJldFwiOmNhc2VcImV1XCI6Y2FzZVwiZmFcIjpjYXNlXCJmaVwiOmNhc2VcImZvXCI6Y2FzZVwiZnVyXCI6Y2FzZVwiZnlcIjpjYXNlXCJnbFwiOmNhc2VcImd1XCI6Y2FzZVwiaGFcIjpjYXNlXCJoZVwiOmNhc2VcImh1XCI6Y2FzZVwiaXNcIjpjYXNlXCJpdFwiOmNhc2VcImt1XCI6Y2FzZVwibGJcIjpjYXNlXCJtbFwiOmNhc2VcIm1uXCI6Y2FzZVwibXJcIjpjYXNlXCJuYWhcIjpjYXNlXCJuYlwiOmNhc2VcIm5lXCI6Y2FzZVwibmxcIjpjYXNlXCJublwiOmNhc2VcIm5vXCI6Y2FzZVwib21cIjpjYXNlXCJvclwiOmNhc2VcInBhXCI6Y2FzZVwicGFwXCI6Y2FzZVwicHNcIjpjYXNlXCJwdFwiOmNhc2VcInNvXCI6Y2FzZVwic3FcIjpjYXNlXCJzdlwiOmNhc2VcInN3XCI6Y2FzZVwidGFcIjpjYXNlXCJ0ZVwiOmNhc2VcInRrXCI6Y2FzZVwidXJcIjpjYXNlXCJ6dVwiOnJldHVybiAxPT1lPzA6MTtjYXNlXCJhbVwiOmNhc2VcImJoXCI6Y2FzZVwiZmlsXCI6Y2FzZVwiZnJcIjpjYXNlXCJndW5cIjpjYXNlXCJoaVwiOmNhc2VcImxuXCI6Y2FzZVwibWdcIjpjYXNlXCJuc29cIjpjYXNlXCJ4YnJcIjpjYXNlXCJ0aVwiOmNhc2VcIndhXCI6cmV0dXJuIDA9PT1lfHwxPT1lPzA6MTtjYXNlXCJiZVwiOmNhc2VcImJzXCI6Y2FzZVwiaHJcIjpjYXNlXCJydVwiOmNhc2VcInNyXCI6Y2FzZVwidWtcIjpyZXR1cm4gZSUxMD09MSYmZSUxMDAhPTExPzA6ZSUxMD49MiYmZSUxMDw9NCYmKGUlMTAwPDEwfHxlJTEwMD49MjApPzE6MjtjYXNlXCJjc1wiOmNhc2VcInNrXCI6cmV0dXJuIDE9PWU/MDplPj0yJiZlPD00PzE6MjtjYXNlXCJnYVwiOnJldHVybiAxPT1lPzA6Mj09ZT8xOjI7Y2FzZVwibHRcIjpyZXR1cm4gZSUxMD09MSYmZSUxMDAhPTExPzA6ZSUxMD49MiYmKGUlMTAwPDEwfHxlJTEwMD49MjApPzE6MjtjYXNlXCJzbFwiOnJldHVybiBlJTEwMD09MT8wOmUlMTAwPT0yPzE6ZSUxMDA9PTN8fGUlMTAwPT00PzI6MztjYXNlXCJta1wiOnJldHVybiBlJTEwPT0xPzA6MTtjYXNlXCJtdFwiOnJldHVybiAxPT1lPzA6MD09PWV8fGUlMTAwPjEmJmUlMTAwPDExPzE6ZSUxMDA+MTAmJmUlMTAwPDIwPzI6MztjYXNlXCJsdlwiOnJldHVybiAwPT09ZT8wOmUlMTA9PTEmJmUlMTAwIT0xMT8xOjI7Y2FzZVwicGxcIjpyZXR1cm4gMT09ZT8wOmUlMTA+PTImJmUlMTA8PTQmJihlJTEwMDwxMnx8ZSUxMDA+MTQpPzE6MjtjYXNlXCJjeVwiOnJldHVybiAxPT1lPzA6Mj09ZT8xOjg9PWV8fDExPT1lPzI6MztjYXNlXCJyb1wiOnJldHVybiAxPT1lPzA6MD09PWV8fGUlMTAwPjAmJmUlMTAwPDIwPzE6MjtjYXNlXCJhclwiOnJldHVybiAwPT09ZT8wOjE9PWU/MToyPT1lPzI6ZT49MyYmZTw9MTA/MzplPj0xMSYmZTw9OTk/NDo1O2RlZmF1bHQ6cmV0dXJuIDB9fWZ1bmN0aW9uIHQoZSxhKXtmb3IodmFyIHM9MDtzPGUubGVuZ3RoO3MrKylpZihhPT09ZVtzXSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBpKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50P2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nLnJlcGxhY2UoXCItXCIsXCJfXCIpOnV9dmFyIGw9e30sdT1cImVuXCIsZj1bXSxvPW5ldyBSZWdFeHAoL15cXHcrXFw6ICsoLispJC8pLGg9bmV3IFJlZ0V4cCgvXlxccyooKFxce1xccyooXFwtP1xcZCtbXFxzKixcXHMqXFwtP1xcZCtdKilcXHMqXFx9KXwoW1xcW1xcXV0pXFxzKigtSW5mfFxcLT9cXGQrKVxccyosXFxzKihcXCs/SW5mfFxcLT9cXGQrKVxccyooW1xcW1xcXV0pKVxccz8oLis/KSQvKSxkPW5ldyBSZWdFeHAoL15cXHMqKFxce1xccyooXFwtP1xcZCtbXFxzKixcXHMqXFwtP1xcZCtdKilcXHMqXFx9KXwoW1xcW1xcXV0pXFxzKigtSW5mfFxcLT9cXGQrKVxccyosXFxzKihcXCs/SW5mfFxcLT9cXGQrKVxccyooW1xcW1xcXV0pLykscD17bG9jYWxlOmkoKSxmYWxsYmFjazp1LHBsYWNlSG9sZGVyUHJlZml4OlwiJVwiLHBsYWNlSG9sZGVyU3VmZml4OlwiJVwiLGRlZmF1bHREb21haW46XCJtZXNzYWdlc1wiLHBsdXJhbFNlcGFyYXRvcjpcInxcIixhZGQ6ZnVuY3Rpb24oZSxhLHMsbil7dmFyIGM9bnx8dGhpcy5sb2NhbGV8fHRoaXMuZmFsbGJhY2sscj1zfHx0aGlzLmRlZmF1bHREb21haW47cmV0dXJuIGxbY118fChsW2NdPXt9KSxsW2NdW3JdfHwobFtjXVtyXT17fSksbFtjXVtyXVtlXT1hLCExPT09dChmLHIpJiZmLnB1c2gociksdGhpc30sdHJhbnM6ZnVuY3Rpb24ocyxuLGMscil7cmV0dXJuIGUoYShzLGMscix0aGlzLmxvY2FsZSx0aGlzLmZhbGxiYWNrKSxufHx7fSl9LHRyYW5zQ2hvaWNlOmZ1bmN0aW9uKHMsYyxyLHQsaSl7dmFyIGw9YShzLHQsaSx0aGlzLmxvY2FsZSx0aGlzLmZhbGxiYWNrKSx1PXBhcnNlSW50KGMsMTApO3JldHVybiByPXJ8fHt9LHZvaWQgMD09PXIuY291bnQmJihyLmNvdW50PWMpLHZvaWQgMD09PWx8fGlzTmFOKHUpfHwobD1uKGwsdSxpfHx0aGlzLmxvY2FsZXx8dGhpcy5mYWxsYmFjaykpLGUobCxyKX0sZnJvbUpTT046ZnVuY3Rpb24oZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPUpTT04ucGFyc2UoZSkpLGUubG9jYWxlJiYodGhpcy5sb2NhbGU9ZS5sb2NhbGUpLGUuZmFsbGJhY2smJih0aGlzLmZhbGxiYWNrPWUuZmFsbGJhY2spLGUuZGVmYXVsdERvbWFpbiYmKHRoaXMuZGVmYXVsdERvbWFpbj1lLmRlZmF1bHREb21haW4pLGUudHJhbnNsYXRpb25zKWZvcih2YXIgYSBpbiBlLnRyYW5zbGF0aW9ucylmb3IodmFyIHMgaW4gZS50cmFuc2xhdGlvbnNbYV0pZm9yKHZhciBuIGluIGUudHJhbnNsYXRpb25zW2FdW3NdKXRoaXMuYWRkKG4sZS50cmFuc2xhdGlvbnNbYV1bc11bbl0scyxhKTtyZXR1cm4gdGhpc30scmVzZXQ6ZnVuY3Rpb24oKXtsPXt9LGY9W10sdGhpcy5sb2NhbGU9aSgpfX07cmV0dXJuIHB9KTsiLCJ2YXIgQUpBWF9MT0FERVIgID0gJzxzcGFuIGNsYXNzPVwiYWpheF9sb2FkZXJcIj48L3NwYW4+JztcbnZhciBOT1RZX1RJTUVPVVQgPSAxNTAwO1xuXG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHRleHQsIHR5cGUpIHtcbiAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5ldyBOb3R5KHtcbiAgICAgICAgdGV4dDogICAgVHJhbnNsYXRvci50cmFucyh0ZXh0KSxcbiAgICAgICAgdHlwZTogICAgdHlwZSB8fCAnc3VjY2VzcycsXG4gICAgICAgIHRoZW1lOiAgICdib290c3RyYXAtdjMnLFxuICAgICAgICB0aW1lb3V0OiBOT1RZX1RJTUVPVVRcbiAgICB9KS5zaG93KCk7XG59O1xuXG52YXIgb25BamF4RmFpbCA9IGZ1bmN0aW9uIChqcVhIUikge1xuICAgIHZhciBtZXNzYWdlID0gJ2V4Y2VwdGlvbi4nICsganFYSFIuc3RhdHVzO1xuICAgIHZhciB0cmFuc2xhdGVkID0gVHJhbnNsYXRvci50cmFucyhtZXNzYWdlKTtcblxuICAgIGlmICh0cmFuc2xhdGVkID09PSBtZXNzYWdlKSB7XG4gICAgICAgIHRyYW5zbGF0ZWQgPSBUcmFuc2xhdG9yLnRyYW5zKCdleGNlcHRpb24uNTAwJyk7XG4gICAgfVxuXG4gICAgbm90aWZ5KHRyYW5zbGF0ZWQsICdlcnJvcicpO1xufTtcblxuJChkb2N1bWVudCkuYmluZCgnYWpheENvbXBsZXRlJywgZnVuY3Rpb24gKCkge1xuICAgICQoJy5hamF4X2xvYWRlcicpLnJlbW92ZSgpO1xuXG4gICAgJCgnYSwgZm9ybScpLnJlbW92ZURhdGEoJ3N1Ym1pdHRlZCcpO1xufSk7XG4iLCJ2YXIgWWFuZGV4VHJhbnNsYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAodGV4dCwgZnJvbSwgdG8sIHN1Y2Nlc3NDYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgWUFOREVYX1RSQU5TTEFURV9BUElfS0VZIHx8ICcnID09PSBZQU5ERVhfVFJBTlNMQVRFX0FQSV9LRVkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTm9uIGVtcHR5IFwiWUFOREVYX1RSQU5TTEFURV9BUElfS0VZXCIgdmFyaWFibGUgbXVzdCBiZSBkZWZpbmVkLCBza2lwIHRyYW5zbGF0aW5nLicpO1xuXG4gICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHRleHQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGFuZyA9IGZyb20gKyAnLScgKyB0bztcbiAgICAgICAgICAgIHZhciB1cmwgPSAnaHR0cHM6Ly90cmFuc2xhdGUueWFuZGV4Lm5ldC9hcGkvdjEuNS90ci5qc29uL3RyYW5zbGF0ZT9rZXk9JyArIFlBTkRFWF9UUkFOU0xBVEVfQVBJX0tFWSArICcmdGV4dD0nICsgdGV4dCArICcmbGFuZz0nICsgbGFuZztcblxuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgfSkuZG9uZShmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoMjAwICE9PSByZXNwb25zZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHJlc3BvbnNlLnRleHRbMF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcbiIsIiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAkKCdib2R5Jykub24oJ3N1Ym1pdCcsICdmb3JtLmFqYXhbYWN0aW9uXVttZXRob2RdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciAkZm9ybSA9ICQodGhpcyk7XG5cbiAgICAgICAgaWYgKCRmb3JtLmRhdGEoJ3N1Ym1pdHRlZCcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAkZm9ybVxuICAgICAgICAgICAgLmRhdGEoJ3N1Ym1pdHRlZCcsIHRydWUpXG4gICAgICAgICAgICAuZmluZCgnW3R5cGU9XCJzdWJtaXRcIl0nKS5hcHBlbmQoQUpBWF9MT0FERVIpO1xuXG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6ICAgICAgICAgJGZvcm0uYXR0cignYWN0aW9uJyksXG4gICAgICAgICAgICB0eXBlOiAgICAgICAgJGZvcm0uYXR0cignbWV0aG9kJyksXG4gICAgICAgICAgICBkYXRhOiAgICAgICAgbmV3IEZvcm1EYXRhKCRmb3JtWzBdKSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBmYWxzZSxcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZVxuICAgICAgICB9KS5kb25lKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBub3RpZnkoZGF0YS5tZXNzYWdlLCBkYXRhLnN1Y2Nlc3MgPyAnc3VjY2VzcycgOiAnZXJyb3InKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuaHRtbCkge1xuICAgICAgICAgICAgICAgICRmb3JtLnJlcGxhY2VXaXRoKGRhdGEuaHRtbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gZGF0YS5yZWRpcmVjdFVybCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5sb2NhdGlvbi5ocmVmID0gZGF0YS5yZWRpcmVjdFVybDtcbiAgICAgICAgICAgICAgICB9LCBOT1RZX1RJTUVPVVQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5mYWlsKG9uQWpheEZhaWwpO1xuICAgIH0pO1xufSk7XG4iLCIkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgJCgnYm9keScpXG4gICAgICAgIC5vbignY2hhbmdlJywgJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXS5iYXRjaF9kZWxldGVfY2hlY2tbZGF0YS1pZF0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJGNoZWNrID0gJCh0aGlzKTtcbiAgICAgICAgICAgIHZhciAkY29udGV4dCA9ICRjaGVjay5jbG9zZXN0KCcucHJvcGVydHlfZm9ybXMnKTtcbiAgICAgICAgICAgIHZhciAkY2hlY2tBbGwgPSAkY29udGV4dC5maW5kKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0uYmF0Y2hfZGVsZXRlX2NoZWNrX2FsbCcpO1xuICAgICAgICAgICAgdmFyICRmb3JtID0gJGNvbnRleHQuZmluZCgnZm9ybS5iYXRjaF9kZWxldGVfZm9ybScpO1xuICAgICAgICAgICAgdmFyICRzdWJtaXQgPSAkZm9ybS5maW5kKCdbdHlwZT1cInN1Ym1pdFwiXTpmaXJzdCcpO1xuXG4gICAgICAgICAgICAkZm9ybS5maW5kKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl1bdmFsdWU9XCInICsgJGNoZWNrLmRhdGEoJ2lkJykgKyAnXCJdJylbMF0uY2hlY2tlZCA9IHRoaXMuY2hlY2tlZDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAkY2hlY2tBbGxbMF0uY2hlY2tlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCRzdWJtaXQuaXMoJzp2aXNpYmxlJykgJiYgMCA9PT0gJCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdLmJhdGNoX2RlbGV0ZV9jaGVja1tkYXRhLWlkXTpjaGVja2VkJykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICRzdWJtaXQuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyICRjaGVja3MgPSAkY29udGV4dC5maW5kKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0uYmF0Y2hfZGVsZXRlX2NoZWNrW2RhdGEtaWRdJyk7XG5cbiAgICAgICAgICAgICRjaGVja0FsbFswXS5jaGVja2VkID0gJGNoZWNrcy5sZW5ndGggPT09ICRjaGVja3MuZmlsdGVyKCc6Y2hlY2tlZCcpLmxlbmd0aDtcbiAgICAgICAgICAgICRzdWJtaXQuc2hvdygpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2NoYW5nZScsICdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0uYmF0Y2hfZGVsZXRlX2NoZWNrX2FsbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGVja2VkID0gdGhpcy5jaGVja2VkO1xuXG4gICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJy5wcm9wZXJ0eV9mb3JtcycpLmZpbmQoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXS5iYXRjaF9kZWxldGVfY2hlY2snKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrZWQgPSBjaGVja2VkO1xuXG4gICAgICAgICAgICAgICAgJCh0aGlzKS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbn0pO1xuIiwiJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgIHZhciBTQ1JPTExfU1BFRUQgPSAtMSAhPT0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPyAxMCA6IDE7XG5cbiAgICB2YXIgc2VhcmNoUmVzdWx0c01vdXNld2hlZWwgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZGVsdGE7XG5cbiAgICAgICAgaWYgKGUub3JpZ2luYWxFdmVudCkge1xuICAgICAgICAgICAgZGVsdGEgPSBlLm9yaWdpbmFsRXZlbnQuZGVsdGFZIHx8IC1lLm9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YSB8fCBlLm9yaWdpbmFsRXZlbnQuZGV0YWlsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWx0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfcmVzdWx0cy5zY3JvbGxUb3AoZGVsdGEgKiAoZS50eXBlID09PSAnRE9NTW91c2VTY3JvbGwnID8gNDAgOiBTQ1JPTExfU1BFRUQpICsgdGhpcy5zZWFyY2hfcmVzdWx0cy5zY3JvbGxUb3AoKSk7XG4gICAgfTtcblxuICAgIHZhciBpbml0O1xuICAgIChpbml0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgJChjb250ZXh0IHx8ICdib2R5JykuZmluZCgnc2VsZWN0OnZpc2libGUnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQodGhpcylcbiAgICAgICAgICAgICAgICAuY2hvc2VuKHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dfc2luZ2xlX2Rlc2VsZWN0OiAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbm9fcmVzdWx0c190ZXh0OiAgICAgICAgICAgVHJhbnNsYXRvci50cmFucygnY2hvc2VuLm5vX3Jlc3VsdHNfdGV4dCcpLFxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcl90ZXh0X211bHRpcGxlOiBUcmFuc2xhdG9yLnRyYW5zKCdjaG9zZW4ucGxhY2Vob2xkZXJfdGV4dF9tdWx0aXBsZScpLFxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcl90ZXh0X3NpbmdsZTogICBUcmFuc2xhdG9yLnRyYW5zKCdjaG9zZW4ucGxhY2Vob2xkZXJfdGV4dF9zaW5nbGUnKSxcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoX2NvbnRhaW5zOiAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNoYW5nZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykudHJpZ2dlcignY2hvc2VuOnVwZGF0ZWQnKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5kYXRhKCdjaG9zZW4nKS5zZWFyY2hfcmVzdWx0c19tb3VzZXdoZWVsID0gc2VhcmNoUmVzdWx0c01vdXNld2hlZWw7XG4gICAgICAgIH0pO1xuICAgIH0pKCk7XG5cbiAgICAkKGRvY3VtZW50KVxuICAgICAgICAub24oJ2Zvcm1Db2xsZWN0aW9uQWRkJywgZnVuY3Rpb24gKGUsIGZvcm0pIHtcbiAgICAgICAgICAgIGluaXQoZm9ybSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbigncHJvcGVydHlGb3JtU3VibWl0JywgZnVuY3Rpb24gKGUsIGZvcm0pIHtcbiAgICAgICAgICAgIGluaXQoZm9ybSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignc2VhcmNoQ29tcGxldGUnLCBmdW5jdGlvbiAoZSwgcmVzdWx0cykge1xuICAgICAgICAgICAgaW5pdChyZXN1bHRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdzcG9pbGVyT3BlbicsIGZ1bmN0aW9uIChlLCBzcG9pbGVyKSB7XG4gICAgICAgICAgICBpbml0KHNwb2lsZXIpO1xuICAgICAgICB9KTtcbn0pO1xuIiwiJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICQuZXh0ZW5kKCQuY29sb3Jib3guc2V0dGluZ3MsIHtcbiAgICAgICAgbWF4V2lkdGg6ICAnOTAlJyxcbiAgICAgICAgb3BhY2l0eTogICAwLjcsXG4gICAgICAgIHNjcm9sbGluZzogZmFsc2UsXG4gICAgICAgIHRyYXBGb2N1czogZmFsc2VcbiAgICB9KTtcblxuICAgIHZhciB0cmFuc2xhdGFibGUgPSBbXG4gICAgICAgICdjdXJyZW50JyxcbiAgICAgICAgJ3ByZXZpb3VzJyxcbiAgICAgICAgJ25leHQnLFxuICAgICAgICAnY2xvc2UnLFxuICAgICAgICAneGhyRXJyb3InLFxuICAgICAgICAnaW1nRXJyb3InLFxuICAgICAgICAnc2xpZGVzaG93U3RhcnQnLFxuICAgICAgICAnc2xpZGVzaG93U3RvcCdcbiAgICBdO1xuICAgIHZhciBsb2NhbGUgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNsYXRhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxvY2FsZVt0cmFuc2xhdGFibGVbaV1dID0gVHJhbnNsYXRvci50cmFucygnY29sb3Jib3guJyArIHRyYW5zbGF0YWJsZVtpXSk7XG4gICAgfVxuXG4gICAgdmFyIGluaXQ7XG4gICAgKGluaXQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAkKGNvbnRleHQpXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgJ2EuY29sb3Jib3hfYWpheFtocmVmXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgdmFyICRsaW5rID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciB1cmwgPSAkbGluay5hdHRyKCdocmVmJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXVybCB8fCAnIycgPT09IHVybCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJC5jb2xvcmJveCgkLmV4dGVuZCh7fSwgbG9jYWxlLCB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6ICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAkbGluay5hdHRyKCd0aXRsZScpIHx8ICRsaW5rLmRhdGEoJ3RpdGxlJylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbmQoJy5jb2xvcmJveCcpLmNvbG9yYm94KGxvY2FsZSk7XG4gICAgfSkoJ2JvZHknKTtcblxuICAgICQoZG9jdW1lbnQpLm9uKCdzZWFyY2hDb21wbGV0ZScsIGZ1bmN0aW9uIChlLCByZXN1bHRzKSB7XG4gICAgICAgIGluaXQocmVzdWx0cyk7XG4gICAgfSk7XG59KTtcbiIsIiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAkKCcubWFpbl9vcHRpb25zX2NvbnRhaW5lciAucGVybWlzc2lvbnMgaW5wdXQnKS5oaWRlKCk7XG5cbiAgICAkKCdib2R5Jykub24oJ2NsaWNrJywgJy5tYWluX29wdGlvbnNfY29udGFpbmVyIC5wZXJtaXNzaW9uW2RhdGEtY2hlY2tib3hdW2RhdGEtY2xhc3MtY2hlY2tlZF1bZGF0YS1jbGFzcy11bmNoZWNrZWRdJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciAkYnV0dG9uID0gJCh0aGlzKTtcbiAgICAgICAgdmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJGJ1dHRvbi5kYXRhKCdjaGVja2JveCcpKTtcblxuICAgICAgICBpZiAoJGJ1dHRvbi5oYXNDbGFzcygkYnV0dG9uLmRhdGEoJ2NsYXNzLWNoZWNrZWQnKSkpIHtcbiAgICAgICAgICAgICRidXR0b25cbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJGJ1dHRvbi5kYXRhKCdjbGFzcy1jaGVja2VkJykpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCRidXR0b24uZGF0YSgnY2xhc3MtdW5jaGVja2VkJykpO1xuICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAkYnV0dG9uXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJGJ1dHRvbi5kYXRhKCdjbGFzcy11bmNoZWNrZWQnKSlcbiAgICAgICAgICAgIC5hZGRDbGFzcygkYnV0dG9uLmRhdGEoJ2NsYXNzLWNoZWNrZWQnKSk7XG4gICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xuICAgIH0pO1xufSk7XG4iLCIkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxvY2FsZSA9ICdlbicgIT09IExPQ0FMRSA/IExPQ0FMRSA6ICcnO1xuICAgIHZhciB0cmFuc2xhdGlvbnMgPSB7XG4gICAgICAgIGRhdGVwaWNrZXI6ICQuZGF0ZXBpY2tlci5yZWdpb25hbFsndW5kZWZpbmVkJyAhPT0gdHlwZW9mICQuZGF0ZXBpY2tlci5yZWdpb25hbFtsb2NhbGVdID8gbG9jYWxlIDogJyddLFxuICAgICAgICB0aW1lcGlja2VyOiAkLnRpbWVwaWNrZXIucmVnaW9uYWxbJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiAkLnRpbWVwaWNrZXIucmVnaW9uYWxbbG9jYWxlXSA/IGxvY2FsZSA6ICcnXVxuICAgIH07XG5cbiAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB0cmFuc2xhdGlvbnMuZGF0ZXBpY2tlciwgdHJhbnNsYXRpb25zLnRpbWVwaWNrZXIsIHtcbiAgICAgICAgZGF0ZUZvcm1hdDogJ2RkLm1tLnl5J1xuICAgIH0pO1xuXG4gICAgdmFyIGluaXQ7XG4gICAgKGluaXQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBbJ2RhdGUnLCAnZGF0ZXRpbWUnLCAndGltZSddLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgJChjb250ZXh0IHx8ICdib2R5JykuZmluZCgnaW5wdXQuJyArIHR5cGUpW3R5cGUgKyAncGlja2VyJ10ob3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH0pKCk7XG5cbiAgICAkKGRvY3VtZW50KVxuICAgICAgICAub24oJ2FqYXhTdWNjZXNzJywgaW5pdClcbiAgICAgICAgLm9uKCdmb3JtQ29sbGVjdGlvbkFkZCcsIGZ1bmN0aW9uIChlLCAkbmV3RWxlbWVudCkge1xuICAgICAgICAgICAgaW5pdCgkbmV3RWxlbWVudCk7XG4gICAgICAgIH0pO1xufSk7XG4iLCIkKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSAnLnR5cGVfYm9vbGVhbi5uYW1lX2VuYWJsZWQgaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOmZpcnN0JztcblxuICAgIHZhciBpbml0O1xuICAgIChpbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAkKCcucHJvcGVydHlfZm9ybXMgLnNlY3Rpb25fdGFibGUgdGFibGUnKS5maW5kKCd0cltkYXRhLWxldmVsXScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICRyb3cgPSAkKHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgJGNoZWNrYm94ID0gJHJvdy5maW5kKHNlbGVjdG9yKSxcbiAgICAgICAgICAgICAgICBsZXZlbCAgICAgPSAkcm93LmRhdGEoJ2xldmVsJyk7XG5cbiAgICAgICAgICAgIGlmICghJGNoZWNrYm94Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkcm93Lm5leHQoJ3RyW2RhdGEtbGV2ZWw9XCInICsgKGxldmVsICsgMSkgKyAnXCJdJykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgJGNoZWNrYm94LmRhdGEoJ3JlbG9hZC1wYWdlJywgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGV2ZWwgPCAyIHx8ICRjaGVja2JveC5pcygnOmNoZWNrZWQnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyICRwYXJlbnQgPSAkcm93LnByZXZBbGwoJ3RyW2RhdGEtbGV2ZWw9XCInICsgKGxldmVsIC0gMSkgKyAnXCJdOmZpcnN0JykuZmluZChzZWxlY3Rvcik7XG5cbiAgICAgICAgICAgICRjaGVja2JveC5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuXG4gICAgICAgICAgICBpZiAoISRwYXJlbnQuaXMoJzpjaGVja2VkJykgfHwgJHBhcmVudC5pcygnOmRpc2FibGVkJykpIHtcbiAgICAgICAgICAgICAgICAkY2hlY2tib3guYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSkoKTtcbiAgICAkKGRvY3VtZW50KS5vbignYWpheFN1Y2Nlc3MnLCBpbml0KTtcbn0pO1xuIiwiJChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJ1dHRvbnMgPSB7XG4gICAgICAgICdhZGQnOiAgICAnPGJ1dHRvbiBjbGFzcz1cImNvbGxlY3Rpb25fYWRkXCIgdHlwZT1cImJ1dHRvblwiPicgKyBUcmFuc2xhdG9yLnRyYW5zKCdmb3JtX2NvbGxlY3Rpb25zLmFkZCcpICsgJzwvYnV0dG9uPicsXG4gICAgICAgICdkZWxldGUnOiAnPGJ1dHRvbiBjbGFzcz1cImNvbGxlY3Rpb25fZGVsZXRlXCIgdHlwZT1cImJ1dHRvblwiPicgKyBUcmFuc2xhdG9yLnRyYW5zKCdmb3JtX2NvbGxlY3Rpb25zLmRlbGV0ZScpICsgJzwvYnV0dG9uPidcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUxhYmVscyA9IGZ1bmN0aW9uICgkY29sbGVjdGlvbikge1xuICAgICAgICBpZiAoJGNvbGxlY3Rpb24uZGF0YSgnYWxsb3ctYWRkJykpIHtcbiAgICAgICAgICAgICRjb2xsZWN0aW9uLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmNoaWxkcmVuKCdsYWJlbDpmaXJzdCcpLnRleHQoaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBpbml0O1xuICAgIChpbml0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgJChjb250ZXh0IHx8ICdib2R5JykuZmluZCgnLmNvbGxlY3Rpb25bZGF0YS1wcm90b3R5cGVdOm5vdChbZGF0YS1hdXRvaW5pdD1cIjBcIl0pJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJGNvbGxlY3Rpb24gPSAkKHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAoJGNvbGxlY3Rpb24uZGF0YSgnYWxsb3ctZGVsZXRlJykpIHtcbiAgICAgICAgICAgICAgICAkY29sbGVjdGlvbi5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmFwcGVuZChidXR0b25zLmRlbGV0ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJGNvbGxlY3Rpb24uZGF0YSgnYWxsb3ctYWRkJykpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVMYWJlbHMoJGNvbGxlY3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgJGNvbGxlY3Rpb24uYXBwZW5kKGJ1dHRvbnMuYWRkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSkoKTtcbiAgICAkKGRvY3VtZW50KS5vbignZm9ybUNvbGxlY3Rpb25BZGQnLCBmdW5jdGlvbiAoZSwgaXRlbSkge1xuICAgICAgICBpbml0KGl0ZW0pO1xuICAgIH0pO1xuXG4gICAgJCgnYm9keScpXG4gICAgICAgIC5vbignY2xpY2snLCAnZm9ybSAuY29sbGVjdGlvbiAuY29sbGVjdGlvbl9kZWxldGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJGJ1dHRvbiA9ICQodGhpcyk7XG5cbiAgICAgICAgICAgIC8vIEZldGNoIGNvbGxlY3Rpb24gbm9kZSBiZWZvcmUgKCEpIGl0ZW0gcmVtb3ZhbFxuICAgICAgICAgICAgdmFyICRjb2xsZWN0aW9uID0gJGJ1dHRvbi5jbG9zZXN0KCcuY29sbGVjdGlvbltkYXRhLXByb3RvdHlwZV0nKTtcblxuICAgICAgICAgICAgJGJ1dHRvbi5jbG9zZXN0KCdkaXYnKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgdXBkYXRlTGFiZWxzKCRjb2xsZWN0aW9uKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdjbGljaycsICdmb3JtIC5jb2xsZWN0aW9uW2RhdGEtcHJvdG90eXBlXSAuY29sbGVjdGlvbl9hZGQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJGJ1dHRvbiA9ICQodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciAkY29sbGVjdGlvbiA9ICRidXR0b24uY2xvc2VzdCgnLmNvbGxlY3Rpb25bZGF0YS1wcm90b3R5cGVdJyk7XG5cbiAgICAgICAgICAgIHZhciBpbmRleCA9ICRjb2xsZWN0aW9uLmRhdGEoJ2luZGV4JyksXG4gICAgICAgICAgICAgICAgbmFtZSAgPSAkY29sbGVjdGlvbi5kYXRhKCduYW1lJykgfHwgJyc7XG5cbiAgICAgICAgICAgIHZhciBpdGVtID0gJGNvbGxlY3Rpb24uZGF0YSgncHJvdG90eXBlJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKG5hbWUgKyAnX19fbmFtZV9fJywgJ2cnKSwgbmFtZSArICdfJyArIGluZGV4KVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxbJyArIG5hbWUgKyAnXFxcXF1cXFxcW19fbmFtZV9fXFxcXF0nLCAnZycpLCAnWycgKyBuYW1lICsgJ11bJyArIGluZGV4ICsgJ10nKTtcblxuICAgICAgICAgICAgdmFyICRpdGVtID0gJChpdGVtKTtcblxuICAgICAgICAgICAgaWYgKCRjb2xsZWN0aW9uLmRhdGEoJ2FsbG93LWRlbGV0ZScpKSB7XG4gICAgICAgICAgICAgICAgJGl0ZW0uYXBwZW5kKGJ1dHRvbnMuZGVsZXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJGJ1dHRvbi5iZWZvcmUoJGl0ZW0pO1xuXG4gICAgICAgICAgICB1cGRhdGVMYWJlbHMoJGNvbGxlY3Rpb24pO1xuXG4gICAgICAgICAgICAkKGRvY3VtZW50KS50cmlnZ2VyKCdmb3JtQ29sbGVjdGlvbkFkZCcsICRpdGVtKTtcblxuICAgICAgICAgICAgJGNvbGxlY3Rpb24uZGF0YSgnaW5kZXgnLCBpbmRleCArIDEpO1xuICAgICAgICB9KTtcbn0pO1xuIiwiJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICQoJ2JvZHknKVxuICAgICAgICAub24oJ2NsaWNrJywgJy5pbWFnZV9kZWxldGVbZGF0YS11cmxdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgdmFyICRsaW5rID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgaWYgKCRsaW5rLmRhdGEoJ3N1Ym1pdHRlZCcpIHx8ICFjb25maXJtKFRyYW5zbGF0b3IudHJhbnMoJ2ltYWdlLmFjdGlvbi5kZWxldGUuY29uZmlybScpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJGxpbmsuZGF0YSgnc3VibWl0dGVkJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciAkaW1hZ2UgPSAkbGluay5jbG9zZXN0KCcuaW1hZ2UnKTtcblxuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6ICAkbGluay5kYXRhKCd1cmwnKSxcbiAgICAgICAgICAgICAgICB0eXBlOiAncG9zdCdcbiAgICAgICAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICRpbWFnZS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgIG5vdGlmeSgnaW1hZ2UuYWN0aW9uLmRlbGV0ZS5zdWNjZXNzJyk7XG4gICAgICAgICAgICB9KS5mYWlsKG9uQWpheEZhaWwpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2NsaWNrJywgJy5pbWFnZV90b2dnbGVfZW5hYmxlZFtkYXRhLWRpc2FibGUtdGl0bGVdW2RhdGEtZGlzYWJsZS11cmxdW2RhdGEtZW5hYmxlLXRpdGxlXVtkYXRhLWVuYWJsZS11cmxdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgdmFyICRsaW5rID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgaWYgKCRsaW5rLmhhc0NsYXNzKCdpbWFnZV9kaXNhYmxlJykpIHtcbiAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6ICAkbGluay5kYXRhKCdkaXNhYmxlLXVybCcpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zdCdcbiAgICAgICAgICAgICAgICB9KS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgJGxpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnaW1hZ2VfZGlzYWJsZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2ltYWdlX2VuYWJsZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGl0bGUnLCAkbGluay5kYXRhKCdlbmFibGUtdGl0bGUnKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbm90aWZ5KCdpbWFnZS5hY3Rpb24uZGlzYWJsZS5zdWNjZXNzJyk7XG4gICAgICAgICAgICAgICAgfSkuZmFpbChvbkFqYXhGYWlsKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6ICAkbGluay5kYXRhKCdlbmFibGUtdXJsJyksXG4gICAgICAgICAgICAgICAgdHlwZTogJ3Bvc3QnXG4gICAgICAgICAgICB9KS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkbGlua1xuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ2ltYWdlX2VuYWJsZScpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnaW1hZ2VfZGlzYWJsZScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0aXRsZScsICRsaW5rLmRhdGEoJ2Rpc2FibGUtdGl0bGUnKSk7XG5cbiAgICAgICAgICAgICAgICBub3RpZnkoJ2ltYWdlLmFjdGlvbi5lbmFibGUuc3VjY2VzcycpO1xuICAgICAgICAgICAgfSkuZmFpbChvbkFqYXhGYWlsKTtcbiAgICAgICAgfSk7XG5cbiAgICB2YXIgJHNvcnRhYmxlID0gJCgnLnRhYmxlX3JvdyAuaW1hZ2VzW2RhdGEtc29ydC11cmxdJyk7XG5cbiAgICBpZiAoJHNvcnRhYmxlLmxlbmd0aCkge1xuICAgICAgICAkc29ydGFibGUuc29ydGFibGUoe1xuICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICd1aS1zdGF0ZS1oaWdobGlnaHQnLFxuICAgICAgICAgICAgdXBkYXRlOiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6ICAkc29ydGFibGUuZGF0YSgnc29ydC11cmwnKSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc3QnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHM6ICRzb3J0YWJsZS5maW5kKCcuaW1hZ2VbZGF0YS1pZF0nKS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmRhdGEoJ2lkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5nZXQoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuZmFpbChvbkFqYXhGYWlsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRzb3J0YWJsZS5kaXNhYmxlU2VsZWN0aW9uKCk7XG4gICAgfVxufSk7XG4iLCIkKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSAnW2RhdGEtbWFzdGVyXVtkYXRhLXNob3ctb25dJztcblxuICAgIHZhciBpc1NsYXZlVmlzaWJsZSA9IGZ1bmN0aW9uICgkbWFzdGVyLCBzaG93T24pIHtcbiAgICAgICAgaWYgKCRtYXN0ZXIuaXMoJzpjaGVja2JveCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gKCskbWFzdGVyLmlzKCc6Y2hlY2tlZCcpKS50b1N0cmluZygpID09PSBzaG93T247XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSAkbWFzdGVyLnZhbCgpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKCRtYXN0ZXIuaXMoJ3NlbGVjdCcpICYmICRtYXN0ZXIucHJvcCgnbXVsdGlwbGUnKSkge1xuICAgICAgICAgICAgaWYgKCEkLmlzQXJyYXkoc2hvd09uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5pbmRleE9mKHNob3dPbikgPj0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hvd09uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluZGV4T2Yoc2hvd09uW2ldKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICQuaXNBcnJheShzaG93T24pID8gc2hvd09uLmluZGV4T2YodmFsdWUpID49IDAgOiB2YWx1ZSA9PT0gc2hvd09uO1xuICAgIH07XG4gICAgdmFyIHRvZ2dsZVNsYXZlID0gZnVuY3Rpb24gKCRzbGF2ZUNvbnRhaW5lciwgJG1hc3Rlciwgc2hvd09uKSB7XG4gICAgICAgICRtYXN0ZXIudmFsKCkgJiYgaXNTbGF2ZVZpc2libGUoJG1hc3Rlciwgc2hvd09uKSA/ICRzbGF2ZUNvbnRhaW5lci5zaG93KCkgOiAkc2xhdmVDb250YWluZXIuaGlkZSgpO1xuXG4gICAgICAgIGlmICgkc2xhdmVDb250YWluZXIuaXMoJ29wdGlvbicpKSB7XG4gICAgICAgICAgICB2YXIgJG9wdGlvbnMgPSAkc2xhdmVDb250YWluZXIuY2xvc2VzdCgnc2VsZWN0JykuZmluZCgnb3B0aW9uJyArIHNlbGVjdG9yKTtcblxuICAgICAgICAgICAgaWYgKCRvcHRpb25zLmluZGV4KCRzbGF2ZUNvbnRhaW5lcikgKyAxID09PSAkb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAkc2xhdmVDb250YWluZXIuY2xvc2VzdCgnc2VsZWN0JykudHJpZ2dlcignY2hvc2VuOnVwZGF0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkKHNlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRzbGF2ZSA9ICQodGhpcyk7XG5cbiAgICAgICAgdmFyIG1hc3RlclNlbGVjdG9yICA9ICRzbGF2ZS5kYXRhKCdtYXN0ZXInKSArICc6Zmlyc3QnLFxuICAgICAgICAgICAgc2hvd09uICAgICAgICAgID0gJHNsYXZlLmRhdGEoJ3Nob3ctb24nKSxcbiAgICAgICAgICAgICRzbGF2ZUNvbnRhaW5lciA9ICRzbGF2ZS5pcygnb3B0aW9uJykgPyAkc2xhdmUgOiAkc2xhdmUuY2xvc2VzdCgnLnRhYmxlX3JvdycpO1xuXG4gICAgICAgIHNob3dPbiA9ICQuaXNBcnJheShzaG93T24pXG4gICAgICAgICAgICA/IHNob3dPbi5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS50b1N0cmluZygpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogc2hvd09uLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgdmFyICRjb250ZXh0ID0gJHNsYXZlLmNsb3Nlc3QoJ1tjbGFzcyo9XCJfYTJsaXhfdHJhbnNsYXRpb25zRmllbGRzLVwiXScpO1xuICAgICAgICB2YXIgJG1hc3RlciA9ICRjb250ZXh0LmZpbmQobWFzdGVyU2VsZWN0b3IpO1xuXG4gICAgICAgIGlmICghJG1hc3Rlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICRjb250ZXh0ID0gJHNsYXZlLmNsb3Nlc3QoJ2Zvcm0nKTtcbiAgICAgICAgICAgICRtYXN0ZXIgPSAkY29udGV4dC5maW5kKG1hc3RlclNlbGVjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvZ2dsZVNsYXZlKCRzbGF2ZUNvbnRhaW5lciwgJG1hc3Rlciwgc2hvd09uKTtcblxuICAgICAgICAkY29udGV4dC5vbignY2hhbmdlJywgbWFzdGVyU2VsZWN0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRvZ2dsZVNsYXZlKCRzbGF2ZUNvbnRhaW5lciwgJCh0aGlzKSwgc2hvd09uKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcbiIsIiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3VibWl0Rm9ybSA9IGZ1bmN0aW9uICgkZm9ybSwgcmVsb2FkUGFnZSkge1xuICAgICAgICBpZiAoJGZvcm0uZGF0YSgnc3VibWl0dGVkJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgICRmb3JtXG4gICAgICAgICAgICAuZGF0YSgnc3VibWl0dGVkJywgdHJ1ZSlcbiAgICAgICAgICAgIC5hcHBlbmQoQUpBWF9MT0FERVIpO1xuXG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgICAgICBkYXRhOiAgJGZvcm0uc2VyaWFsaXplKCksXG4gICAgICAgICAgICB0eXBlOiAgJ3Bvc3QnLFxuICAgICAgICAgICAgdXJsOiAgICRmb3JtLmF0dHIoJ2FjdGlvbicpXG4gICAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciAkZm9ybVJlcGxhY2VtZW50ID0gJChkYXRhLmZvcm0pO1xuICAgICAgICAgICAgJGZvcm0ucmVwbGFjZVdpdGgoJGZvcm1SZXBsYWNlbWVudCk7XG5cbiAgICAgICAgICAgIHRvZ2dsZUJ1dHRvbnMoJGZvcm1SZXBsYWNlbWVudC5maW5kKCcuZmllbGQnKSk7XG5cbiAgICAgICAgICAgICQoZG9jdW1lbnQpLnRyaWdnZXIoJ3Byb3BlcnR5Rm9ybVN1Ym1pdCcsICRmb3JtUmVwbGFjZW1lbnQpO1xuXG4gICAgICAgICAgICBub3RpZnkoZGF0YS5tZXNzYWdlLCBkYXRhLnN1Y2Nlc3MgPyAnc3VjY2VzcycgOiAnZXJyb3InKTtcblxuICAgICAgICAgICAgaWYgKHJlbG9hZFBhZ2UgJiYgISRmb3JtUmVwbGFjZW1lbnQuY2xvc2VzdCgnLnByb3BlcnR5X2Zvcm1zJykucGFyZW50KCcuc2VhcmNoYWJsZV9yZXN1bHRzJykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgJC5hamF4KCkuZG9uZShmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgICAgICAgICAgICAkZm9ybVJlcGxhY2VtZW50LmNsb3Nlc3QoJy5zZWN0aW9uX3RhYmxlJykucmVwbGFjZVdpdGgoJChodG1sKS5maW5kKCcuc2VjdGlvbl90YWJsZTpmaXJzdCcpKTtcbiAgICAgICAgICAgICAgICB9KS5mYWlsKG9uQWpheEZhaWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5mYWlsKG9uQWpheEZhaWwpO1xuICAgIH07XG5cbiAgICB2YXIgdG9nZ2xlQnV0dG9ucyA9IGZ1bmN0aW9uICgkZmllbGQpIHtcbiAgICAgICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2YgJGZpZWxkLmRhdGEoJ29yaWdpbmFsLXZhbHVlJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciAkZm9ybSA9ICRmaWVsZC5jbG9zZXN0KCcucHJvcGVydHlfZm9ybScpO1xuICAgICAgICAkZm9ybS5hdHRyKCdkYXRhLW1vZGlmaWVkJywgJGZpZWxkLnZhbCgpLnRvU3RyaW5nKCkgIT09ICRmaWVsZC5kYXRhKCdvcmlnaW5hbC12YWx1ZScpLnRvU3RyaW5nKCkgPyAxIDogMCk7XG5cbiAgICAgICAgdmFyICRmb3JtcyA9ICRmb3JtLmNsb3Nlc3QoJy5wcm9wZXJ0eV9mb3JtcycpO1xuXG4gICAgICAgIGlmICgxICE9ICRmb3JtLmF0dHIoJ2RhdGEtbW9kaWZpZWQnKSAmJiAhJGZvcm1zLmZpbmQoJ2Zvcm0ucHJvcGVydHlfZm9ybVtkYXRhLW1vZGlmaWVkPVwiMVwiXScpLmxlbmd0aCkge1xuICAgICAgICAgICAgJGZvcm1zLmZpbmQoJy5wcm9wZXJ0eV9mb3Jtc19zdWJtaXQnKS5oaWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkZm9ybXMuZmluZCgnLnByb3BlcnR5X2Zvcm1zX3N1Ym1pdCcpLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoMSAhPSAkZm9ybS5hdHRyKCdkYXRhLW1vZGlmaWVkJykpIHtcbiAgICAgICAgICAgICRmb3JtLmZpbmQoJ1t0eXBlPVwic3VibWl0XCJdLCBbdHlwZT1cInJlc2V0XCJdJykucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISRmb3JtLmZpbmQoJ1t0eXBlPVwic3VibWl0XCJdJykubGVuZ3RoKSB7XG4gICAgICAgICAgICAkZm9ybS5hcHBlbmQoJzxidXR0b24gdHlwZT1cInN1Ym1pdFwiPm88L2J1dHRvbj4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISRmb3JtLmZpbmQoJ1t0eXBlPVwicmVzZXRcIl0nKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICRmb3JtLmFwcGVuZCgnPGJ1dHRvbiB0eXBlPVwicmVzZXRcIj54PC9idXR0b24+Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGluaXQ7XG4gICAgKGluaXQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB2YXIgJGNvbnRleHQgPSAkKGNvbnRleHQgfHwgJ2JvZHknKTtcblxuICAgICAgICAkY29udGV4dC5maW5kKCcucHJvcGVydHlfZm9ybSAuZmllbGRbdHlwZSE9XCJjaGVja2JveFwiXScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdG9nZ2xlQnV0dG9ucygkKHRoaXMpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJGNvbnRleHRcbiAgICAgICAgICAgIC5vbignY2hhbmdlJywgJy5wcm9wZXJ0eV9mb3JtIC5maWVsZFt0eXBlIT1cImNoZWNrYm94XCJdJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRvZ2dsZUJ1dHRvbnMoJCh0aGlzKSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdrZXl1cCcsICcucHJvcGVydHlfZm9ybSBpbnB1dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0b2dnbGVCdXR0b25zKCQodGhpcykpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2hhbmdlJywgJy5wcm9wZXJ0eV9mb3JtIGlucHV0W3R5cGU9XCJjaGVja2JveFwiXScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgJGNoZWNrYm94ID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHN1Ym1pdEZvcm0oJGNoZWNrYm94LmNsb3Nlc3QoJ2Zvcm0ucHJvcGVydHlfZm9ybScpLCAkY2hlY2tib3guZGF0YSgncmVsb2FkLXBhZ2UnKSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsICcucHJvcGVydHlfZm9ybSBbdHlwZT1cInJlc2V0XCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgJGZpZWxkID0gJCh0aGlzKS5zaWJsaW5ncygnLmZpZWxkJyk7XG5cbiAgICAgICAgICAgICAgICAkZmllbGRcbiAgICAgICAgICAgICAgICAgICAgLnZhbCgkZmllbGQuZGF0YSgnb3JpZ2luYWwtdmFsdWUnKSlcbiAgICAgICAgICAgICAgICAgICAgLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCAnLnByb3BlcnR5X2Zvcm1zIC5wcm9wZXJ0eV9mb3Jtc19zdWJtaXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyICRmb3JtcyAgICAgPSAkKHRoaXMpLmNsb3Nlc3QoJy5wcm9wZXJ0eV9mb3JtcycpLmZpbmQoJ2Zvcm0ucHJvcGVydHlfZm9ybVtkYXRhLW1vZGlmaWVkPVwiMVwiXScpLFxuICAgICAgICAgICAgICAgICAgICByZWxvYWRQYWdlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAkZm9ybXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgJGZvcm0gPSAkKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVsb2FkUGFnZSAmJiAkZm9ybS5maW5kKCdpbnB1dCwgc2VsZWN0JykuZGF0YSgncmVsb2FkLXBhZ2UnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsb2FkUGFnZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzdWJtaXRGb3JtKCRmb3JtLCBpID09PSAkZm9ybXMubGVuZ3RoIC0gMSA/IHJlbG9hZFBhZ2UgOiBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdzdWJtaXQnLCAnZm9ybS5wcm9wZXJ0eV9mb3JtJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgJGZvcm0gPSAkKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgc3VibWl0Rm9ybSgkZm9ybSwgJGZvcm0uZmluZCgnaW5wdXQsIHNlbGVjdCcpLmRhdGEoJ3JlbG9hZC1wYWdlJykpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSkoKTtcblxuICAgICQoZG9jdW1lbnQpLm9uKCdzZWFyY2hDb21wbGV0ZScsIGZ1bmN0aW9uIChlLCByZXN1bHRzKSB7XG4gICAgICAgIGluaXQocmVzdWx0cyk7XG4gICAgfSk7XG59KTtcbiIsIiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHNlYXJjaGFibGVzID0gJCgnLnNlYXJjaGFibGVbZGF0YS1zb3VyY2VdJyk7XG5cbiAgICBpZiAoISRzZWFyY2hhYmxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwZW5kaW5nID0gZmFsc2U7XG5cbiAgICAkc2VhcmNoYWJsZXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkc2VhcmNoYWJsZSA9ICQodGhpcyk7XG4gICAgICAgIHZhciAkcmVzdWx0cyA9ICRzZWFyY2hhYmxlLmZpbmQoJy5zZWFyY2hhYmxlX3Jlc3VsdHMnKTtcblxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICAkc2VhcmNoYWJsZS5zaG93KCkuZmluZCgnLnNlYXJjaGFibGVfdGl0bGUnKS5hcHBlbmQoQUpBWF9MT0FERVIpO1xuXG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIHVybDogJHNlYXJjaGFibGUuZGF0YSgnc291cmNlJylcbiAgICAgICAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgJGh0bWwgPSAkKGh0bWwpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEkaHRtbC5maW5kKCd0cicpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAkc2VhcmNoYWJsZS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJHJlc3VsdHMuaHRtbChodG1sKTtcbiAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS50cmlnZ2VyKCdzZWFyY2hDb21wbGV0ZScsICRyZXN1bHRzKTtcbiAgICAgICAgICAgIH0pLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSkuZmFpbChvbkFqYXhGYWlsKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9KTtcbn0pO1xuIiwiJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZXRXaWRnZXQgPSBmdW5jdGlvbiAoJGNoaWxkKSB7XG4gICAgICAgIHJldHVybiAkY2hpbGQuY2xvc2VzdCgnLnNsdWdfc3VmZml4Jyk7XG4gICAgfTtcblxuICAgIHZhciBidWlsZFVybFByZWZpeCA9IGZ1bmN0aW9uICgkd2lkZ2V0KSB7XG4gICAgICAgIHZhciBwYXJlbnRTbHVnID0gJHdpZGdldC5jbG9zZXN0KCdmb3JtJykuZmluZCgkd2lkZ2V0LmRhdGEoJ3BhcmVudC1zZWxlY3QnKSkuY2hpbGRyZW4oJ29wdGlvbjpzZWxlY3RlZCcpXG4gICAgICAgICAgICAuZGF0YSgkd2lkZ2V0LmRhdGEoJ3BhcmVudC1vcHRpb24tZGF0YS1zbHVnJykpO1xuXG4gICAgICAgIHJldHVybiAkd2lkZ2V0LmRhdGEoJ2Jhc2UtdXJsJykgKyAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBwYXJlbnRTbHVnID8gcGFyZW50U2x1ZyArICcvJyA6ICcnKTtcbiAgICB9O1xuXG4gICAgdmFyIGJ1aWxkVXJsID0gZnVuY3Rpb24gKCR3aWRnZXQpIHtcbiAgICAgICAgdmFyIHNsdWdTdWZmaXggPSAkd2lkZ2V0LmZpbmQoJy5mb3JtX3dpZGdldCBpbnB1dCcpLnZhbCgpO1xuXG4gICAgICAgIHJldHVybiBidWlsZFVybFByZWZpeCgkd2lkZ2V0KSArIChzbHVnU3VmZml4ID8gc2x1Z1N1ZmZpeCA6ICdfX18nKSArICR3aWRnZXQuZGF0YSgndXJsLXN1ZmZpeCcpO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlV2lkZ2V0ID0gZnVuY3Rpb24gKCR3aWRnZXQpIHtcbiAgICAgICAgdmFyICRpbnB1dCA9ICR3aWRnZXQuZmluZCgnLmZvcm1fd2lkZ2V0IGlucHV0Jyk7XG4gICAgICAgIHZhciAkcmVzZXQgPSAkd2lkZ2V0LmZpbmQoJy5yZXNldCcpO1xuICAgICAgICB2YXIgc2x1Z1N1ZmZpeCA9ICRpbnB1dC52YWwoKTtcbiAgICAgICAgJGlucHV0LmRhdGEoJ2RlZmF1bHQnKS50b1N0cmluZygpICE9PSBzbHVnU3VmZml4ID8gJHJlc2V0LnNob3coKSA6ICRyZXNldC5oaWRlKCk7XG5cbiAgICAgICAgJHdpZGdldC5maW5kKCcudXJsX3ByZWZpeCcpLnRleHQoYnVpbGRVcmxQcmVmaXgoJHdpZGdldCkpO1xuXG4gICAgICAgIHZhciB1cmwgPSBidWlsZFVybCgkd2lkZ2V0KTtcbiAgICAgICAgJHdpZGdldC5maW5kKCcubGlua193aWRnZXQgYScpLmF0dHIoJ2hyZWYnLCB1cmwpLnRleHQodXJsKTtcblxuICAgICAgICBpZiAoJHdpZGdldC5kYXRhKCdkZWZhdWx0LXVybCcpLnRvU3RyaW5nKCkgIT09IHVybCkge1xuICAgICAgICAgICAgJHdpZGdldC5hZGRDbGFzcygnY2hhbmdlZCcpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNsdWdTdWZmaXgpIHtcbiAgICAgICAgICAgICR3aWRnZXQucmVtb3ZlQ2xhc3MoJ2NoYW5nZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkKCcuc2x1Z19zdWZmaXgnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICR3aWRnZXQgPSAkKHRoaXMpO1xuICAgICAgICAkd2lkZ2V0LmRhdGEoJ2Jhc2UtdXJsJywgJHdpZGdldC5kYXRhKCd1cmwtcHJlZml4JykpO1xuXG4gICAgICAgIHZhciAkZm9ybSA9ICR3aWRnZXQuY2xvc2VzdCgnZm9ybScpO1xuXG4gICAgICAgIGlmICgkd2lkZ2V0LmRhdGEoJ3BhcmVudC1zZWxlY3QnKSkge1xuICAgICAgICAgICAgdmFyICRwYXJlbnQgPSAkZm9ybS5maW5kKCR3aWRnZXQuZGF0YSgncGFyZW50LXNlbGVjdCcpKTtcblxuICAgICAgICAgICAgaWYgKCRwYXJlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFNsdWcgPSAkcGFyZW50LmZpbmQoJ29wdGlvbjpzZWxlY3RlZCcpLmRhdGEoJHdpZGdldC5kYXRhKCdwYXJlbnQtb3B0aW9uLWRhdGEtc2x1ZycpKTtcblxuICAgICAgICAgICAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHBhcmVudFNsdWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmwgPSAkd2lkZ2V0LmRhdGEoJ3VybC1wcmVmaXgnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYmFzZVVybC5pbmRleE9mKHBhcmVudFNsdWcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBiYXNlVXJsLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICR3aWRnZXQuZGF0YSgnYmFzZS11cmwnLCBiYXNlVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZVdpZGdldCgkd2lkZ2V0KTtcblxuICAgICAgICAvLyAkd2lkZ2V0LmZpbmQoJy5mb3JtX3dpZGdldCBpbnB1dCcpLmNvdW50ZXIoe1xuICAgICAgICAvLyAgICAgY291bnQ6ICAndXAnLFxuICAgICAgICAvLyAgICAgZ29hbDogICAnc2t5JyxcbiAgICAgICAgLy8gICAgIHRhcmdldDogJHdpZGdldC5maW5kKCcuZm9ybV93aWRnZXQgLmlucHV0X3ZhbHVlJylcbiAgICAgICAgLy8gfSk7XG4gICAgICAgICR3aWRnZXQuZmluZCgnLmZvcm1fd2lkZ2V0IGlucHV0JykudGV4dGNvdW50ZXIoe1xuICAgICAgICAgICAgY291bnRTcGFjZXM6IHRydWUsXG4gICAgICAgICAgICBjb3VudGVyVGV4dDogJyVkJyxcbiAgICAgICAgICAgIG1heDogICAgICAgICAtMVxuICAgICAgICB9KTtcbiAgICAgICAgJGZvcm0ub24oJ2NoYW5nZScsICR3aWRnZXQuZGF0YSgncGFyZW50LXNlbGVjdCcpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB1cGRhdGVXaWRnZXQoJHdpZGdldCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgJCgnYm9keScpXG4gICAgICAgIC5vbignY2xpY2snLCAnLnNsdWdfc3VmZml4IC5lZGl0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICR3aWRnZXQgPSBnZXRXaWRnZXQoJCh0aGlzKSk7XG5cbiAgICAgICAgICAgICR3aWRnZXQuZmluZCgnLmZvcm1fd2lkZ2V0Jykuc2hvdygpO1xuICAgICAgICAgICAgJHdpZGdldC5maW5kKCcubGlua193aWRnZXQnKS5oaWRlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignY2xpY2snLCAnLnNsdWdfc3VmZml4IC5yZXNldCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAkd2lkZ2V0ID0gZ2V0V2lkZ2V0KCQodGhpcykpO1xuXG4gICAgICAgICAgICB2YXIgJGlucHV0ID0gJHdpZGdldC5maW5kKCcuZm9ybV93aWRnZXQgaW5wdXQnKTtcbiAgICAgICAgICAgICRpbnB1dC52YWwoJGlucHV0LmRhdGEoJ2RlZmF1bHQnKSkudHJpZ2dlcignY2hhbmdlJyk7XG5cbiAgICAgICAgICAgICR3aWRnZXQuZmluZCgnLnVwZGF0ZScpLnRyaWdnZXIoJ2NsaWNrJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignY2xpY2snLCAnLnNsdWdfc3VmZml4IC51cGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJHdpZGdldCA9IGdldFdpZGdldCgkKHRoaXMpKTtcblxuICAgICAgICAgICAgdXBkYXRlV2lkZ2V0KCR3aWRnZXQpO1xuXG4gICAgICAgICAgICAkd2lkZ2V0LmZpbmQoJy5mb3JtX3dpZGdldCcpLmhpZGUoKTtcbiAgICAgICAgICAgICR3aWRnZXQuZmluZCgnLmxpbmtfd2lkZ2V0Jykuc2hvdygpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2NsaWNrJywgJy5zbHVnX3N1ZmZpeC5jaGFuZ2VkIC5saW5rX3dpZGdldCBhJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSk7XG59KTtcbiIsIiQoJy5zZWN0aW9uX3RhYmxlJykuZWFjaChmdW5jdGlvbigpe1xuXHR2YXIgc2VsZiA9ICQodGhpcyk7XG5cdHZhciBzY3JlZW5IZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cdHZhciB0YWJsZUhlaWdodCA9ICQodGhpcykuaGVpZ2h0KCk7XG5cdHZhciBoZWFkID0gJCh0aGlzKS5maW5kKCd0aGVhZCB0cicpLmVxKDApLmNsb25lKCk7XG5cdFxuXHRpZih0YWJsZUhlaWdodCA+IHNjcmVlbkhlaWdodCoxLjgpe1xuXHRcdHZhciBjb3VudGVySGVpZ2h0ID0gMDtcblx0XHR2YXIgY291bnRIZWFkID0gdGFibGVIZWlnaHQvKCBzY3JlZW5IZWlnaHQqMC45KTtcblx0XHR2YXIgaW50ZXJ2YWwgPSB0YWJsZUhlaWdodCAvIGNvdW50SGVhZDtcblx0XHR2YXIgaW50ZXJ2YWxDdXJyID0gMDtcblx0XHR2YXIgcm93cyA9IHNlbGYuZmluZCgndGJvZHkgdHInKTtcblx0XHRcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRpbnRlcnZhbEN1cnIgKz0gcm93cy5lcShpKS5oZWlnaHQoKTtcblx0XHRcdFxuXHRcdFx0aWYoaW50ZXJ2YWxDdXJyID49IGludGVydmFsKXtcblx0XHRcdFx0JChoZWFkKS5jbG9uZSgpLmluc2VydEFmdGVyKHJvd3MuZXEoaSkpO1xuXHRcdFx0XHRpbnRlcnZhbEN1cnIgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBcblx0XG5cdHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRpZih0YWJsZUhlaWdodCA+IHNjcmVlbkhlaWdodCoxLjIpe1xuXHRcdFx0aWYoc2VsZi5maW5kKCd0cjpsYXN0IHRoJykpe1xuXHRcdFx0XHQkKHRoaXMpLmZpbmQoJ3RhYmxlIHRib2R5JykuYXBwZW5kKCBoZWFkLmNsb25lKCkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sIDEwKVxuXHRcbn0pOyIsIiQoZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZXRMb2NhbGUgPSBmdW5jdGlvbiAoJHRhYikge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9ICR0YWIuYXR0cignY2xhc3MnKS5tYXRjaCgvYTJsaXhfdHJhbnNsYXRpb25zZmllbGRzLShbYS16XSspXFxzKi9pKTtcblxuICAgICAgICByZXR1cm4gbWF0Y2hlc1sxXTtcbiAgICB9O1xuXG4gICAgJCgnYm9keScpXG4gICAgICAgIC5vbignY2xpY2snLCAnZm9ybSAuYTJsaXhfdHJhbnNsYXRpb25zTG9jYWxlcy5uYXYubmF2LXRhYnMgYScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQodGhpcykucGFyZW50cygnLmEybGl4X3RyYW5zbGF0aW9ucycpLmZpcnN0KCkuZmluZCgnaW5wdXRbdHlwZT1cInRleHRcIl0nKS5yZW1vdmVEYXRhKCdzeW5jZWQnKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdjaGFuZ2UnLCAnZm9ybSAuYTJsaXhfdHJhbnNsYXRpb25zRmllbGRzIC50YWItcGFuZS5hY3RpdmUgaW5wdXRbdHlwZT1cInRleHRcIl0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJHNvdXJjZUlucHV0ID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgJHNvdXJjZUlucHV0LnJlbW92ZURhdGEoJ3N5bmNlZCcpO1xuXG4gICAgICAgICAgICB2YXIgJHJvdyA9ICRzb3VyY2VJbnB1dC5wYXJlbnRzKCcudGFibGVfcm93JykuZmlyc3QoKTtcblxuICAgICAgICAgICAgdmFyICRzb3VyY2VUYWIgPSAkcm93LnBhcmVudHMoJy50YWItcGFuZScpLmZpcnN0KCksXG4gICAgICAgICAgICAgICAgcm93SW5kZXggICA9ICRyb3cuaW5kZXgoKSxcbiAgICAgICAgICAgICAgICBzb3VyY2VUZXh0ID0gJHNvdXJjZUlucHV0LnZhbCgpO1xuXG4gICAgICAgICAgICB2YXIgc291cmNlTG9jYWxlID0gZ2V0TG9jYWxlKCRzb3VyY2VUYWIpO1xuXG4gICAgICAgICAgICAkc291cmNlVGFiLnNpYmxpbmdzKCcudGFiLXBhbmUnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgJHRhcmdldFRhYiA9ICQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgJHRhcmdldElucHV0ID0gJHRhcmdldFRhYi5maW5kKCcudGFibGVfcm93JykuZXEocm93SW5kZXgpLmZpbmQoJ2lucHV0W3R5cGU9XCJ0ZXh0XCJdJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoJycgIT09ICR0YXJnZXRJbnB1dC52YWwoKSAmJiAhJHRhcmdldElucHV0LmRhdGEoJ3N5bmNlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCcnID09PSBzb3VyY2VUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICR0YXJnZXRJbnB1dC52YWwoc291cmNlVGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFlhbmRleFRyYW5zbGF0b3IudHJhbnNsYXRlKHNvdXJjZVRleHQsIHNvdXJjZUxvY2FsZSwgZ2V0TG9jYWxlKCR0YXJnZXRUYWIpLCBmdW5jdGlvbiAodHJhbnNsYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAkdGFyZ2V0SW5wdXQudmFsKHRyYW5zbGF0ZWQpLmRhdGEoJ3N5bmNlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xufSk7XG4iLCIkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIENMQVNTRVMgPSBbXG4gICAgICAgICcnLFxuICAgICAgICAnY2hlY2tlZCcsXG4gICAgICAgICd1bmNoZWNrZWQnXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGNoZWNrSW5wdXQoJGNoZWNrYm94LCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gMikge1xuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgJGNoZWNrYm94XG4gICAgICAgICAgICAuZGF0YSgnaW5kZXgnLCBpbmRleCkuYWRkQ2xhc3MoQ0xBU1NFU1tpbmRleF0pXG4gICAgICAgICAgICAuZmluZCgnaW5wdXQnKVtpbmRleF0uY2hlY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5jaGVja0lucHV0KCRjaGVja2JveCwgaW5kZXgpIHtcbiAgICAgICAgJGNoZWNrYm94LnJlbW92ZUNsYXNzKENMQVNTRVNbaW5kZXhdKVxuICAgICAgICAgICAgLmZpbmQoJ2lucHV0JylbaW5kZXhdLmNoZWNrZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAoZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgJCgnLnRyaV9zdGF0ZV9jaGVja2JveCcpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICRjaGVja2JveCA9ICQodGhpcyk7XG4gICAgICAgICAgICAkY2hlY2tib3guYWRkQ2xhc3MoJ3JlYWR5JykuZmluZCgnOm5vdChpbnB1dCknKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgY2hlY2tJbnB1dCgkY2hlY2tib3gsICRjaGVja2JveC5maW5kKCdpbnB1dDpjaGVja2VkJykuaW5kZXgoKSk7XG4gICAgICAgIH0pO1xuICAgIH0pKCk7XG5cbiAgICAkKCdib2R5Jykub24oJ2NsaWNrJywgJy50cmlfc3RhdGVfY2hlY2tib3gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkY2hlY2tib3ggPSAkKHRoaXMpO1xuICAgICAgICB2YXIgaW5kZXggPSAkY2hlY2tib3guZGF0YSgnaW5kZXgnKTtcblxuICAgICAgICB1bmNoZWNrSW5wdXQoJGNoZWNrYm94LCBpbmRleCk7XG5cbiAgICAgICAgaW5kZXgrKztcblxuICAgICAgICBjaGVja0lucHV0KCRjaGVja2JveCwgaW5kZXgpO1xuICAgIH0pO1xufSk7XG4iLCIvKiDQv9C+0LrQsNC30LDRgtGML9GB0LrRgNGL0YLRjCDRgdCw0LnQtNCx0LDRgCAqL1xuJCgnI3NpZGViYXJfc3dpdGNoZXInKS5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oKXtcblx0dmFyIHN3aXRjaF9idG4gPSAkKCcjc2lkZWJhcl9zd2l0Y2hlcicpO1xuXHR2YXIgc2lkZWJhcl93cmFwID0gJCgnLnNpZGViYXJfd3JhcCcpO1xuXHR2YXIgY29udGVudF93cmFwID0gJCgnLmNvbnRlbnRfd3JhcCcpO1xuXHR2YXIgbWFpbl93cmFwID0gJCgnLm1haW5fd3JhcCcpO1xuXHRzaWRlYmFyX3dyYXAudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpO1xuXHRjb250ZW50X3dyYXAudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpO1xuXHRtYWluX3dyYXAudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpO1xuXHRzd2l0Y2hfYnRuLnRvZ2dsZUNsYXNzKCdhY3RpdmUnKTtcblx0aWYoc3dpdGNoX2J0bi5oYXNDbGFzcygnYWN0aXZlJykpe1xuXHRcdHN3aXRjaF9idG4udGV4dChUcmFuc2xhdG9yLnRyYW5zKCdsYXlvdXQubWVudS5jb2xsYXBzZScpKTtcblx0XHRzaWRlYmFyX3dyYXAucmVtb3ZlQ2xhc3MoJ25vYWN0aXZlJyk7XG4gICAgICAgICQuY29va2llKENPT0tJRV9TSURFQkFSLCAxLCB7XG4gICAgICAgICAgICBwYXRoOiAnLydcbiAgICAgICAgfSk7XG5cdH0gZWxzZSB7XG5cdFx0c3dpdGNoX2J0bi50ZXh0KFRyYW5zbGF0b3IudHJhbnMoJ2xheW91dC5tZW51LmV4cGFuZCcpKTtcblx0XHRzaWRlYmFyX3dyYXAuYWRkQ2xhc3MoJ25vYWN0aXZlJyk7XG4gICAgICAgICQuY29va2llKENPT0tJRV9TSURFQkFSLCAwLCB7XG4gICAgICAgICAgICBwYXRoOiAnLydcbiAgICAgICAgfSk7XG5cdH1cblx0c2V0VGltZW91dCggZnVuY3Rpb24oKXsgJCh3aW5kb3cpLnJlc2l6ZSgpO30sIDMwMCk7XG59KTtcblxuLyog0YHQv9C+0LnQu9C10YAgKi9cbiQoJy5zcG9pbGVyX2xpbmtzJykub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKCl7XG5cdHZhciBzcG9pbGVyX2NvbnRhaW5lciA9ICQodGhpcykucGFyZW50cygnLnNwb2lsZXJfY29udGFpbmVyJyk7XG4gICAgdmFyIGJvZHkgPSBzcG9pbGVyX2NvbnRhaW5lci5maW5kKCcuc3BvaWxlcl9ib2R5Jyk7XG4gICAgaWYgKGJvZHkuY3NzKFwiZGlzcGxheVwiKT09XCJub25lXCIpXG5cdHtcblx0XHRib2R5LmhpZGUoJ25vcm1hbCcpO1xuXHRcdGJvZHkudG9nZ2xlKCdub3JtYWwnKTtcbiAgICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgYm9keS5kYXRhKCdjb29raWUnKSkge1xuICAgICAgICAgICAgJC5jb29raWUoYm9keS5kYXRhKCdjb29raWUnKSwgMSwge1xuICAgICAgICAgICAgICAgIHBhdGg6ICcvJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAkKGRvY3VtZW50KS50cmlnZ2VyKCdzcG9pbGVyT3BlbicsIGJvZHkpO1xuXHR9IGVsc2Uge1xuICAgICAgICBib2R5LmhpZGUoJ25vcm1hbCcpO1xuICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBib2R5LmRhdGEoJ2Nvb2tpZScpKSB7XG4gICAgICAgICAgICAkLmNvb2tpZShib2R5LmRhdGEoJ2Nvb2tpZScpLCAwLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogJy8nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblx0c3BvaWxlcl9jb250YWluZXIudG9nZ2xlQ2xhc3MoJ25vYWN0aXZlJyk7XG5cdHJldHVybiBmYWxzZTtcbiB9KTtcbiBcbiAvKiDQutC70LjQuiDQvdCwINC/0YPQvdC60YLQtSDQvNC10L3RjiDQs9C70LDQstC90L7QuSAqL1xuICQoJy5tYWluX21lbnUgLml0ZW0ucGFyZW50ID4gLm5hbWUgYSwgLm1haW5fbWVudSAuaXRlbS5wYXJlbnQgPiAuaW1nIGEnKS5vbignY2xpY2snLCBmdW5jdGlvbigpe1xuXHR2YXIgaXRlbSA9ICQodGhpcykucGFyZW50cygnLnBhcmVudCcpO1xuXHRpZihpdGVtLmhhc0NsYXNzKCdhY3RpdmUnKSl7XG5cdFx0aXRlbS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cdH0gZWxzZSB7XG5cdFx0JCgnLm1haW5fbWVudSAuaXRlbS5wYXJlbnQuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdHJlc2l6ZSgpO1xuXHRcdGl0ZW0uYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdGl0ZW0uZmluZCgnLm1haW5fZHJvcGRvd25fbWVudScpLmNzcyh7J21heEhlaWdodCcgOiBpdGVtLmZpbmQoJy5tYWluX2Ryb3Bkb3duX21lbnVfaW5uZXInKS5oZWlnaHQoKSs1MH0pO1xuXHR9XG5cdHJlc2l6ZSgpO1xuXHRzZXRUaW1lb3V0KCByZXNpemUoKSwgNTAwKTtcblx0cmV0dXJuIGZhbHNlO1xufSk7XG5cbi8qINGE0LjQutGBINGH0LXQutCx0L7QutGB0L7QsiDQsdC10Lcg0L3Rg9C20L3QvtC5INCy0ZHRgNGC0YHQutC4Ki9cbnZhciBjaGVja2JveGVzSW5pdDtcbihjaGVja2JveGVzSW5pdCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gJChjb250ZXh0IHx8ICdib2R5JykuZmluZCgnLmlucHV0X3ZhbHVlIGlucHV0W3R5cGU9XCJjaGVja2JveFwiXScpLmVhY2goZnVuY3Rpb24oKXtcblx0JCh0aGlzKS53cmFwKFwiPGxhYmVsPjwvbGFiZWw+XCIpLndyYXAoXCI8c3BhbiBjbGFzcz0nY2hlY2tib3gnPjwvc3Bhbj5cIik7XG5cdCQodGhpcykuYWZ0ZXIoXCI8c3Bhbj48L3NwYW4+XCIpXG4gfSk7XG59KSgpO1xuJChkb2N1bWVudCkub24oJ2Zvcm1Db2xsZWN0aW9uQWRkJywgZnVuY3Rpb24gKGUsIGZvcm0pIHtcbiAgICBjaGVja2JveGVzSW5pdChmb3JtKTtcbn0pO1xuXG4gXG4galF1ZXJ5KGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe1xuXHRyZXNpemUoKTtcblx0XG5cdHNob3dfbWVudV9mdW5jdGlvbigpO1xuXHRcblx0JCgnLmNvbnRlbnRfd3JhcCcpLmNzcyh7J21pbkhlaWdodCc6ICQoJy5sZWZ0X21lbnUnKS5oZWlnaHQoKSB9KTtcbiB9KTtcblxuIGZ1bmN0aW9uIHNob3dfbWVudV9mdW5jdGlvbigpe1xuXHQvKnZhciBjb3VudCA9ICQoJy5tYWluX21lbnUgLml0ZW0nKS5sZW5ndGg7XG5cdGNvbnNvbGUubG9nKGNvdW50KTtcblx0Zm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcdFxuXHRcdGNvbnNvbGUubG9nKGkpO1xuXHRcdHNldFRpbWVvdXQoICQoJy5tYWluX21lbnUgLml0ZW06ZXEoJytpKycpJykuYWRkQ2xhc3MoJ2FuaW1hdGVfc3RhcnQnKSwgNzAwKTtcblx0fSovXG59XG5cbiB3aW5kb3cub25yZXNpemUgPSByZXNpemU7XG4gXG4gZnVuY3Rpb24gcmVzaXplKCl7XG5cdC8qINC80LXQvdGOINC90LAg0LPQu9Cw0LLQvdC+0LkgKi9cblx0JCgnLm1haW5fbWVudSAuaXRlbScpLmhlaWdodCgnYXV0bycpO1xuXHQkKCcubWFpbl9tZW51IC5pdGVtIC5kZXNjcmlwdGlvbicpLmhlaWdodCgnYXV0bycpO1xuXHRcblx0dmFyIG1heEhlaWdodEl0ZW0gPSAwO1xuXHR2YXIgbWF4SGVpZ2h0SXRlbVRleHQgPSAwO1xuXHR2YXIgbWF4SGVpZ2h0RG93bkRyb3AgPSAwO1xuXHQkKCcubWFpbl9tZW51IC5pdGVtJykuZWFjaChmdW5jdGlvbigpe1xuXHRcdGlmKCQodGhpcykuaGVpZ2h0KCkgPiBtYXhIZWlnaHRJdGVtKXsgbWF4SGVpZ2h0SXRlbSA9ICQodGhpcykuaGVpZ2h0KCk7fVxuXHR9KTtcblx0JCgnLm1haW5fbWVudSAuaXRlbSAuZGVzY3JpcHRpb24nKS5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0aWYoJCh0aGlzKS5oZWlnaHQoKSA+IG1heEhlaWdodEl0ZW1UZXh0KXsgbWF4SGVpZ2h0SXRlbVRleHQgPSAkKHRoaXMpLmhlaWdodCgpO31cblx0fSk7XG5cdCQoJy5tYWluX21lbnUgLm1haW5fZHJvcGRvd25fbWVudScpLmVhY2goZnVuY3Rpb24oKXtcblx0XHRpZigkKHRoaXMpLmhlaWdodCgpID4gbWF4SGVpZ2h0RG93bkRyb3ApeyBtYXhIZWlnaHREb3duRHJvcCA9ICQodGhpcykuaGVpZ2h0KCk7fVxuXHR9KTtcblx0JCgnLm1haW5fbWVudSAuaXRlbScpLmhlaWdodChtYXhIZWlnaHRJdGVtKTtcblx0JCgnLm1haW5fbWVudSAuaXRlbSAuZGVzY3JpcHRpb24nKS5oZWlnaHQobWF4SGVpZ2h0SXRlbVRleHQpO1xuXHRpZiggJCgnLm1haW5fbWVudSAuaXRlbS5wYXJlbnQuYWN0aXZlJykubGVuZ3RoID4gMCApe1xuXHRcdCQoJy5tYWluX21lbnUgLml0ZW0ucGFyZW50LmFjdGl2ZScpLmNzcyh7J21hcmdpbkJvdHRvbSc6IG1heEhlaWdodERvd25Ecm9wICsgNX0pO1xuXHR9IGVsc2Uge1xuXHRcdCQoJy5tYWluX21lbnUgLml0ZW0ucGFyZW50JykuY3NzKHsnbWFyZ2luQm90dG9tJzogJzEwcHgnfSk7XG5cdFx0JCgnLm1haW5fbWVudSAuaXRlbScpLmhlaWdodCgnYXV0bycpO1xuXHRcdCQoJy5tYWluX21lbnUgLml0ZW0gLmRlc2NyaXB0aW9uJykuaGVpZ2h0KCdhdXRvJyk7XG5cdH1cbi8vXHRjb25zb2xlLmxvZygncmVzaXplJylcbn1cblxuXG4vKiDRgdC60YDQvtC70LHQsNGAICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vLyDQvdCw0YHRgtGA0L7QudC60Lgg0YHQutGA0L7Qu9Cx0LDRgNCwXG52YXIgc2x5T3B0aW9ucyA9IHtcbiAgICBob3Jpem9udGFsOiAxLFxuICAgIHNtYXJ0OiAxLFxuICAgIG1vdXNlRHJhZ2dpbmc6IDEsXG4gICAgdG91Y2hEcmFnZ2luZzogMSxcbiAgICByZWxlYXNlU3dpbmc6IDEsXG4gICAgc2Nyb2xsQmFyOiAkKCcuc2Nyb2xsYmFyJyksXG4gICAgc3BlZWQ6IDMwMCxcbiAgICBhY3RpdmF0ZVBhZ2VPbjogJ2NsaWNrJyxcbiAgICBzY3JvbGxCeTogMTAwLFxuICAgIGRyYWdIYW5kbGU6IDEsXG4gICAgZHluYW1pY0hhbmRsZTogMSxcbiAgICBjbGlja0JhcjogMSxcbiAgICBzY3JvbGxTb3VyY2U6ICcgJ1xufTtcblxuLy8g0YHQutGA0YvQstCw0LXRgi/Qv9C+0LrQsNC30YvQstCw0LXRgiDRgdC60YDQvtC7INCx0LDRgCwg0LXRgdC70Lgg0L7QvSDQvdC1INC90YPQttC10L1cbmZ1bmN0aW9uIHN3aXRjaFNjcm9sbEJhcigpIHtcblx0dmFyIHNjcm9sbGJhciA9ICQoJy5qcy1zY3JvbGxiYXInKTtcblx0dmFyIGhhbmRsZSA9IHNjcm9sbGJhci5maW5kKCcuaGFuZGxlJyk7XG4gICAgdmFyIHNjcm9sbGJhcl93aWR0aCA9IHNjcm9sbGJhci5lcSgwKS53aWR0aCgpO1xuICAgIHZhciBoYW5kbGVfd2lkdGggPSBzY3JvbGxiYXIuZXEoMCkuZmluZCgnLmhhbmRsZScpLndpZHRoKCk7XG4gICAgdmFyIGNvbnRlbnRfd2lkdGggPSAkKCcuc2x5LWNvbnRhaW5lciAuc2VjdGlvbl90YWJsZSA+IHRhYmxlJykud2lkdGgoKTtcblxuICAgIGlmKGNvbnRlbnRfd2lkdGggPiBzY3JvbGxiYXJfd2lkdGgpe1xuICAgICAgICBpZihzY3JvbGxiYXJfd2lkdGggPD0gaGFuZGxlX3dpZHRoICsgNSApeyAvLyA1IC0g0LzQsNCz0LjRh9C10YHQutC+0LUg0YfQuNGB0LvQviwg0YfRgtC+0LHRiyDQvdC40LLQtdC70LjRgNC+0LLQsNGC0Ywg0YDQsNC30L3QuNGG0YMg0YjQuNGA0LjQvSDQv9GA0Lgg0YDQtdGB0LDQudC30LVcbiAgICAgICAgICAgIHNjcm9sbGJhci5jc3MoeydvcGFjaXR5JzowfSk7XG4gICAgICAgICAgICBoYW5kbGUuY3NzKHsnZGlzcGxheSc6ICdub25lJ30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsYmFyLmNzcyh7J29wYWNpdHknOjF9KTtcbiAgICAgICAgICAgIGhhbmRsZS5jc3MoeydkaXNwbGF5JzogJ2Jsb2NrJ30pO1xuICAgICAgICB9XG5cdH0gZWxzZSB7XG4gICAgICAgIHNjcm9sbGJhci5jc3MoeydvcGFjaXR5JzowfSk7XG4gICAgICAgIGhhbmRsZS5jc3MoeydkaXNwbGF5JzogJ25vbmUnfSk7XG5cdH1cbn1cbi8vINC40L3QuNGG0LjQsNC70LjQt9Cw0YbQuNGPINGB0LrRgNC+0LvQsdCw0YDQsFxuZnVuY3Rpb24gaW5pdFNseSggY29udGFpbmVyLCBvcHRpb25zICkge1xuICAgIC8vINC00LvRjyDQutCw0LbQtNC+0LPQviDQutC+0L3RgtC10L3QtdGA0LBcbiAgICAkKGNvbnRhaW5lcikuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICB2YXIgJHNlbGYgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgJGZyYW1lID0gJHNlbGYuZmluZCgnLnNseS1mcmFtZScpO1xuXG4gICAgICAgIHZhciBzbHkgPSBuZXcgU2x5KCAkZnJhbWUsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIG1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxTeW5jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNseS5pbml0KCk7XG4gICAgICAgICQoJy5zbHktY29udGFpbmVyIC5zY3JvbGxiYXInKS5jbG9uZSh0cnVlKS5hcHBlbmRUbygnLnNseS1jb250YWluZXInKTtcblxuICAgICAgICBzY3JvbGxTeW5jKCk7XG4gICAgICAgIHN3aXRjaFNjcm9sbEJhcigpO1xuICAgICAgICAkKHdpbmRvdykucmVzaXplKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2Nyb2xsU3luYygpO1xuICAgICAgICAgICAgc3dpdGNoU2Nyb2xsQmFyKCk7XG4gICAgICAgICAgICBzbHkucmVsb2FkKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNjcm9sbFN5bmMoKSB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsYmFyMV9oYW5kbGUgPSAkc2VsZi5maW5kKCcuc2Nyb2xsYmFyJykuZXEoMCkuZmluZCgnLmhhbmRsZScpO1xuICAgICAgICAgICAgdmFyIHNjcm9sbGJhcjJfaGFuZGxlID0gJHNlbGYuZmluZCgnLnNjcm9sbGJhcicpLmVxKDEpLmZpbmQoJy5oYW5kbGUnKTtcbiAgICAgICAgICAgIHNjcm9sbGJhcjJfaGFuZGxlLmF0dHIoJ3N0eWxlJywgc2Nyb2xsYmFyMV9oYW5kbGUuYXR0cignc3R5bGUnKSlcbiAgICAgICAgfVxuICAgIH0pO1xufVxuc2V0VGltZW91dChpbml0U2x5LCAxLCAkKCcuc2x5LWNvbnRhaW5lcicpLCBzbHlPcHRpb25zKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSAnLmJ0bl90b2dnbGVbZGF0YS1jb29raWVdW2RhdGEtaWRdW2RhdGEtdGV4dC1vcGVuXVtkYXRhLXRleHQtY2xvc2VdJztcblxuICAgIHZhciB0b2dnbGUgPSBmdW5jdGlvbiAoJHRvZ2dsZSwgJGl0ZW0pIHtcbiAgICAgICAgJHRvZ2dsZS5wYXJlbnQoKS5uZXh0KCkuc2xpZGVUb2dnbGUoMTAwKTtcbiAgICAgICAgJHRvZ2dsZS50b2dnbGVDbGFzcygnaXMtb3BlbicpO1xuICAgICAgICAkaXRlbS50b2dnbGVDbGFzcygnaXMtb3BlbicpO1xuXG4gICAgICAgIGlmICgkaXRlbS5oYXNDbGFzcygnaXMtb3BlbicpKSB7XG4gICAgICAgICAgICAkdG9nZ2xlLnRleHQoJHRvZ2dsZS5hdHRyKCdkYXRhLXRleHQtb3BlbicpKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgJHRvZ2dsZS50ZXh0KCR0b2dnbGUuYXR0cignZGF0YS10ZXh0LWNsb3NlJykpO1xuICAgIH07XG5cbiAgICAkKCcubWFpbl9vcHRpb25zX2l0ZW1fY29udGFpbmVyICcgKyBzZWxlY3RvcikuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJHRvZ2dsZSA9ICQodGhpcyk7XG4gICAgICAgIHZhciAkaXRlbSA9ICR0b2dnbGUuY2xvc2VzdCgnLm1haW5fb3B0aW9uc19pdGVtJyk7XG5cbiAgICAgICAgdG9nZ2xlKCR0b2dnbGUsICRpdGVtKTtcblxuICAgICAgICB2YXIgY29va2llID0gJC5jb29raWUoJHRvZ2dsZS5kYXRhKCdjb29raWUnKSk7XG4gICAgICAgIHZhciBleHBhbmRlZCA9ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgY29va2llID8gY29va2llLnNwbGl0KCcsJykgOiBbXTtcblxuICAgICAgICBpZiAoJGl0ZW0uaGFzQ2xhc3MoJ2lzLW9wZW4nKSkge1xuICAgICAgICAgICAgaWYgKC0xID09PSBleHBhbmRlZC5pbmRleE9mKCR0b2dnbGUuZGF0YSgnaWQnKSkpIHtcbiAgICAgICAgICAgICAgICBleHBhbmRlZC5wdXNoKCR0b2dnbGUuZGF0YSgnaWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHBhbmRlZC5zcGxpY2UoZXhwYW5kZWQuaW5kZXhPZigkdG9nZ2xlLmRhdGEoJ2lkJykpLCAxKTtcblxuICAgICAgICAgICAgJGl0ZW0uZmluZChzZWxlY3RvciArICdbZGF0YS1pZCE9XCInICsgJHRvZ2dsZS5kYXRhKCdpZCcpICsgJ1wiXS5pcy1vcGVuJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyICR0b2dnbGUgPSAkKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdG9nZ2xlKCR0b2dnbGUsICR0b2dnbGUuY2xvc2VzdCgnLm1haW5fb3B0aW9uc19pdGVtJykpO1xuXG4gICAgICAgICAgICAgICAgZXhwYW5kZWQuc3BsaWNlKGV4cGFuZGVkLmluZGV4T2YoJHRvZ2dsZS5kYXRhKCdpZCcpKSwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgICQuY29va2llKCR0b2dnbGUuZGF0YSgnY29va2llJyksIGV4cGFuZGVkLmpvaW4oJywnKSwge1xuICAgICAgICAgICAgcGF0aDogJy8nXG4gICAgICAgIH0pO1xuICAgIH0pXG59KSgpO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuIl19
